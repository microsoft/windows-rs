#[cfg(feature = "implement_exclusive")]
pub trait IAnchorRequestedEventArgsImpl: Sized {
    fn Anchor(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetAnchor(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn AnchorCandidates(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::UIElement>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAnchorRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAnchorRequestedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IAnchorRequestedEventArgsVtbl {
    pub const fn new<Impl: IAnchorRequestedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAnchorRequestedEventArgsVtbl {
        unsafe extern "system" fn Anchor<Impl: IAnchorRequestedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Anchor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAnchor<Impl: IAnchorRequestedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAnchor(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AnchorCandidates<Impl: IAnchorRequestedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AnchorCandidates() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAnchorRequestedEventArgs>, base.5, Anchor::<Impl, OFFSET>, SetAnchor::<Impl, OFFSET>, AnchorCandidates::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarImpl: Sized {
    fn IsOpen(&self) -> ::windows::core::Result<bool>;
    fn SetIsOpen(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsSticky(&self) -> ::windows::core::Result<bool>;
    fn SetIsSticky(&self, value: bool) -> ::windows::core::Result<()>;
    fn Opened(&self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpened(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Closed(&self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosed(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBar {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBar";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarVtbl {
    pub const fn new<Impl: IAppBarImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarVtbl {
        unsafe extern "system" fn IsOpen<Impl: IAppBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsOpen<Impl: IAppBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsOpen(value).into()
        }
        unsafe extern "system" fn IsSticky<Impl: IAppBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSticky() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSticky<Impl: IAppBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsSticky(value).into()
        }
        unsafe extern "system" fn Opened<Impl: IAppBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Opened(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpened<Impl: IAppBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Closed<Impl: IAppBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Closed(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosed<Impl: IAppBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBar>, base.5, IsOpen::<Impl, OFFSET>, SetIsOpen::<Impl, OFFSET>, IsSticky::<Impl, OFFSET>, SetIsSticky::<Impl, OFFSET>, Opened::<Impl, OFFSET>, RemoveOpened::<Impl, OFFSET>, Closed::<Impl, OFFSET>, RemoveClosed::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBar2Impl: Sized {
    fn ClosedDisplayMode(&self) -> ::windows::core::Result<AppBarClosedDisplayMode>;
    fn SetClosedDisplayMode(&self, value: AppBarClosedDisplayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBar2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBar2";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBar2Vtbl {
    pub const fn new<Impl: IAppBar2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBar2Vtbl {
        unsafe extern "system" fn ClosedDisplayMode<Impl: IAppBar2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut AppBarClosedDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ClosedDisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClosedDisplayMode<Impl: IAppBar2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: AppBarClosedDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetClosedDisplayMode(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBar2>, base.5, ClosedDisplayMode::<Impl, OFFSET>, SetClosedDisplayMode::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBar3Impl: Sized {
    fn TemplateSettings(&self) -> ::windows::core::Result<Primitives::AppBarTemplateSettings>;
    fn Opening(&self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpening(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Closing(&self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosing(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBar3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBar3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBar3Vtbl {
    pub const fn new<Impl: IAppBar3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBar3Vtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IAppBar3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Opening<Impl: IAppBar3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Opening(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpening<Impl: IAppBar3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Closing<Impl: IAppBar3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Closing(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosing<Impl: IAppBar3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveClosing(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBar3>, base.5, TemplateSettings::<Impl, OFFSET>, Opening::<Impl, OFFSET>, RemoveOpening::<Impl, OFFSET>, Closing::<Impl, OFFSET>, RemoveClosing::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBar4Impl: Sized {
    fn LightDismissOverlayMode(&self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBar4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBar4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBar4Vtbl {
    pub const fn new<Impl: IAppBar4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBar4Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: IAppBar4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: IAppBar4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBar4>, base.5, LightDismissOverlayMode::<Impl, OFFSET>, SetLightDismissOverlayMode::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButtonImpl: Sized {
    fn Label(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetLabel(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Icon(&self) -> ::windows::core::Result<IconElement>;
    fn SetIcon(&self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButton";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButtonVtbl {
    pub const fn new<Impl: IAppBarButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarButtonVtbl {
        unsafe extern "system" fn Label<Impl: IAppBarButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Label() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLabel<Impl: IAppBarButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLabel(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Icon<Impl: IAppBarButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Icon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIcon<Impl: IAppBarButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarButton>, base.5, Label::<Impl, OFFSET>, SetLabel::<Impl, OFFSET>, Icon::<Impl, OFFSET>, SetIcon::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButton3Impl: Sized {
    fn LabelPosition(&self) -> ::windows::core::Result<CommandBarLabelPosition>;
    fn SetLabelPosition(&self, value: CommandBarLabelPosition) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButton3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButton3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButton3Vtbl {
    pub const fn new<Impl: IAppBarButton3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarButton3Vtbl {
        unsafe extern "system" fn LabelPosition<Impl: IAppBarButton3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut CommandBarLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LabelPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLabelPosition<Impl: IAppBarButton3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: CommandBarLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLabelPosition(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarButton3>, base.5, LabelPosition::<Impl, OFFSET>, SetLabelPosition::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButton4Impl: Sized {
    fn KeyboardAcceleratorTextOverride(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetKeyboardAcceleratorTextOverride(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButton4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButton4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButton4Vtbl {
    pub const fn new<Impl: IAppBarButton4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarButton4Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverride<Impl: IAppBarButton4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverride() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetKeyboardAcceleratorTextOverride<Impl: IAppBarButton4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetKeyboardAcceleratorTextOverride(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarButton4>, base.5, KeyboardAcceleratorTextOverride::<Impl, OFFSET>, SetKeyboardAcceleratorTextOverride::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButton5Impl: Sized {
    fn TemplateSettings(&self) -> ::windows::core::Result<Primitives::AppBarButtonTemplateSettings>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButton5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButton5";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButton5Vtbl {
    pub const fn new<Impl: IAppBarButton5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarButton5Vtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IAppBarButton5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarButton5>, base.5, TemplateSettings::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButtonFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<AppBarButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButtonFactoryVtbl {
    pub const fn new<Impl: IAppBarButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IAppBarButtonFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarButtonFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButtonStaticsImpl: Sized {
    fn LabelProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IconProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCompactProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButtonStaticsVtbl {
    pub const fn new<Impl: IAppBarButtonStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarButtonStaticsVtbl {
        unsafe extern "system" fn LabelProperty<Impl: IAppBarButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LabelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IconProperty<Impl: IAppBarButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCompactProperty<Impl: IAppBarButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCompactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarButtonStatics>, base.5, LabelProperty::<Impl, OFFSET>, IconProperty::<Impl, OFFSET>, IsCompactProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButtonStatics3Impl: Sized {
    fn LabelPositionProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsInOverflowProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DynamicOverflowOrderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButtonStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButtonStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButtonStatics3Vtbl {
    pub const fn new<Impl: IAppBarButtonStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarButtonStatics3Vtbl {
        unsafe extern "system" fn LabelPositionProperty<Impl: IAppBarButtonStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LabelPositionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsInOverflowProperty<Impl: IAppBarButtonStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsInOverflowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DynamicOverflowOrderProperty<Impl: IAppBarButtonStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarButtonStatics3>, base.5, LabelPositionProperty::<Impl, OFFSET>, IsInOverflowProperty::<Impl, OFFSET>, DynamicOverflowOrderProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarButtonStatics4Impl: Sized {
    fn KeyboardAcceleratorTextOverrideProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarButtonStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarButtonStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarButtonStatics4Vtbl {
    pub const fn new<Impl: IAppBarButtonStatics4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarButtonStatics4Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverrideProperty<Impl: IAppBarButtonStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverrideProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarButtonStatics4>, base.5, KeyboardAcceleratorTextOverrideProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarElementContainerImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarElementContainer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarElementContainer";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarElementContainerVtbl {
    pub const fn new<Impl: IAppBarElementContainerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarElementContainerVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarElementContainer>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarElementContainerFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<AppBarElementContainer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarElementContainerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarElementContainerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarElementContainerFactoryVtbl {
    pub const fn new<Impl: IAppBarElementContainerFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarElementContainerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IAppBarElementContainerFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarElementContainerFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarElementContainerStaticsImpl: Sized {
    fn IsCompactProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsInOverflowProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DynamicOverflowOrderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarElementContainerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarElementContainerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarElementContainerStaticsVtbl {
    pub const fn new<Impl: IAppBarElementContainerStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarElementContainerStaticsVtbl {
        unsafe extern "system" fn IsCompactProperty<Impl: IAppBarElementContainerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCompactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsInOverflowProperty<Impl: IAppBarElementContainerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsInOverflowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DynamicOverflowOrderProperty<Impl: IAppBarElementContainerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarElementContainerStatics>, base.5, IsCompactProperty::<Impl, OFFSET>, IsInOverflowProperty::<Impl, OFFSET>, DynamicOverflowOrderProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<AppBar>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarFactoryVtbl {
    pub const fn new<Impl: IAppBarFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IAppBarFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarOverridesImpl: Sized {
    fn OnClosed(&self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnOpened(&self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarOverridesVtbl {
    pub const fn new<Impl: IAppBarOverridesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarOverridesVtbl {
        unsafe extern "system" fn OnClosed<Impl: IAppBarOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnClosed(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnOpened<Impl: IAppBarOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnOpened(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarOverrides>, base.5, OnClosed::<Impl, OFFSET>, OnOpened::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarOverrides3Impl: Sized {
    fn OnClosing(&self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnOpening(&self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarOverrides3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarOverrides3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarOverrides3Vtbl {
    pub const fn new<Impl: IAppBarOverrides3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarOverrides3Vtbl {
        unsafe extern "system" fn OnClosing<Impl: IAppBarOverrides3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnClosing(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnOpening<Impl: IAppBarOverrides3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnOpening(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarOverrides3>, base.5, OnClosing::<Impl, OFFSET>, OnOpening::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarSeparatorImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarSeparator {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarSeparator";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarSeparatorVtbl {
    pub const fn new<Impl: IAppBarSeparatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarSeparatorVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarSeparator>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarSeparatorFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<AppBarSeparator>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarSeparatorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarSeparatorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarSeparatorFactoryVtbl {
    pub const fn new<Impl: IAppBarSeparatorFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarSeparatorFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IAppBarSeparatorFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarSeparatorFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarSeparatorStaticsImpl: Sized {
    fn IsCompactProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarSeparatorStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarSeparatorStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarSeparatorStaticsVtbl {
    pub const fn new<Impl: IAppBarSeparatorStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarSeparatorStaticsVtbl {
        unsafe extern "system" fn IsCompactProperty<Impl: IAppBarSeparatorStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCompactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarSeparatorStatics>, base.5, IsCompactProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarSeparatorStatics3Impl: Sized {
    fn IsInOverflowProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DynamicOverflowOrderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarSeparatorStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarSeparatorStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarSeparatorStatics3Vtbl {
    pub const fn new<Impl: IAppBarSeparatorStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarSeparatorStatics3Vtbl {
        unsafe extern "system" fn IsInOverflowProperty<Impl: IAppBarSeparatorStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsInOverflowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DynamicOverflowOrderProperty<Impl: IAppBarSeparatorStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarSeparatorStatics3>, base.5, IsInOverflowProperty::<Impl, OFFSET>, DynamicOverflowOrderProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarStaticsImpl: Sized {
    fn IsOpenProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsStickyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarStaticsVtbl {
    pub const fn new<Impl: IAppBarStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarStaticsVtbl {
        unsafe extern "system" fn IsOpenProperty<Impl: IAppBarStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsStickyProperty<Impl: IAppBarStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsStickyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarStatics>, base.5, IsOpenProperty::<Impl, OFFSET>, IsStickyProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarStatics2Impl: Sized {
    fn ClosedDisplayModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarStatics2Vtbl {
    pub const fn new<Impl: IAppBarStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarStatics2Vtbl {
        unsafe extern "system" fn ClosedDisplayModeProperty<Impl: IAppBarStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ClosedDisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarStatics2>, base.5, ClosedDisplayModeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarStatics4Impl: Sized {
    fn LightDismissOverlayModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarStatics4Vtbl {
    pub const fn new<Impl: IAppBarStatics4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarStatics4Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: IAppBarStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarStatics4>, base.5, LightDismissOverlayModeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButtonImpl: Sized {
    fn Label(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetLabel(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Icon(&self) -> ::windows::core::Result<IconElement>;
    fn SetIcon(&self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButton";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButtonVtbl {
    pub const fn new<Impl: IAppBarToggleButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarToggleButtonVtbl {
        unsafe extern "system" fn Label<Impl: IAppBarToggleButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Label() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLabel<Impl: IAppBarToggleButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLabel(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Icon<Impl: IAppBarToggleButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Icon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIcon<Impl: IAppBarToggleButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarToggleButton>, base.5, Label::<Impl, OFFSET>, SetLabel::<Impl, OFFSET>, Icon::<Impl, OFFSET>, SetIcon::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButton3Impl: Sized {
    fn LabelPosition(&self) -> ::windows::core::Result<CommandBarLabelPosition>;
    fn SetLabelPosition(&self, value: CommandBarLabelPosition) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButton3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButton3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButton3Vtbl {
    pub const fn new<Impl: IAppBarToggleButton3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarToggleButton3Vtbl {
        unsafe extern "system" fn LabelPosition<Impl: IAppBarToggleButton3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut CommandBarLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LabelPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLabelPosition<Impl: IAppBarToggleButton3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: CommandBarLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLabelPosition(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarToggleButton3>, base.5, LabelPosition::<Impl, OFFSET>, SetLabelPosition::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButton4Impl: Sized {
    fn KeyboardAcceleratorTextOverride(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetKeyboardAcceleratorTextOverride(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButton4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButton4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButton4Vtbl {
    pub const fn new<Impl: IAppBarToggleButton4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarToggleButton4Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverride<Impl: IAppBarToggleButton4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverride() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetKeyboardAcceleratorTextOverride<Impl: IAppBarToggleButton4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetKeyboardAcceleratorTextOverride(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarToggleButton4>, base.5, KeyboardAcceleratorTextOverride::<Impl, OFFSET>, SetKeyboardAcceleratorTextOverride::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButton5Impl: Sized {
    fn TemplateSettings(&self) -> ::windows::core::Result<Primitives::AppBarToggleButtonTemplateSettings>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButton5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButton5";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButton5Vtbl {
    pub const fn new<Impl: IAppBarToggleButton5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarToggleButton5Vtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IAppBarToggleButton5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarToggleButton5>, base.5, TemplateSettings::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButtonFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<AppBarToggleButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButtonFactoryVtbl {
    pub const fn new<Impl: IAppBarToggleButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarToggleButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IAppBarToggleButtonFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarToggleButtonFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButtonStaticsImpl: Sized {
    fn LabelProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IconProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCompactProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButtonStaticsVtbl {
    pub const fn new<Impl: IAppBarToggleButtonStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarToggleButtonStaticsVtbl {
        unsafe extern "system" fn LabelProperty<Impl: IAppBarToggleButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LabelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IconProperty<Impl: IAppBarToggleButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCompactProperty<Impl: IAppBarToggleButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCompactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarToggleButtonStatics>, base.5, LabelProperty::<Impl, OFFSET>, IconProperty::<Impl, OFFSET>, IsCompactProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButtonStatics3Impl: Sized {
    fn LabelPositionProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsInOverflowProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DynamicOverflowOrderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButtonStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButtonStatics3Vtbl {
    pub const fn new<Impl: IAppBarToggleButtonStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarToggleButtonStatics3Vtbl {
        unsafe extern "system" fn LabelPositionProperty<Impl: IAppBarToggleButtonStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LabelPositionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsInOverflowProperty<Impl: IAppBarToggleButtonStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsInOverflowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DynamicOverflowOrderProperty<Impl: IAppBarToggleButtonStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarToggleButtonStatics3>, base.5, LabelPositionProperty::<Impl, OFFSET>, IsInOverflowProperty::<Impl, OFFSET>, DynamicOverflowOrderProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAppBarToggleButtonStatics4Impl: Sized {
    fn KeyboardAcceleratorTextOverrideProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAppBarToggleButtonStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IAppBarToggleButtonStatics4Vtbl {
    pub const fn new<Impl: IAppBarToggleButtonStatics4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAppBarToggleButtonStatics4Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverrideProperty<Impl: IAppBarToggleButtonStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverrideProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAppBarToggleButtonStatics4>, base.5, KeyboardAcceleratorTextOverrideProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxImpl: Sized {
    fn MaxSuggestionListHeight(&self) -> ::windows::core::Result<f64>;
    fn SetMaxSuggestionListHeight(&self, value: f64) -> ::windows::core::Result<()>;
    fn IsSuggestionListOpen(&self) -> ::windows::core::Result<bool>;
    fn SetIsSuggestionListOpen(&self, value: bool) -> ::windows::core::Result<()>;
    fn TextMemberPath(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetTextMemberPath(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Text(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn UpdateTextOnSelect(&self) -> ::windows::core::Result<bool>;
    fn SetUpdateTextOnSelect(&self, value: bool) -> ::windows::core::Result<()>;
    fn PlaceholderText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Header(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AutoMaximizeSuggestionArea(&self) -> ::windows::core::Result<bool>;
    fn SetAutoMaximizeSuggestionArea(&self, value: bool) -> ::windows::core::Result<()>;
    fn TextBoxStyle(&self) -> ::windows::core::Result<super::Style>;
    fn SetTextBoxStyle(&self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn SuggestionChosen(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxSuggestionChosenEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSuggestionChosen(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxTextChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBox";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxVtbl {
    pub const fn new<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAutoSuggestBoxVtbl {
        unsafe extern "system" fn MaxSuggestionListHeight<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxSuggestionListHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxSuggestionListHeight<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxSuggestionListHeight(value).into()
        }
        unsafe extern "system" fn IsSuggestionListOpen<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSuggestionListOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSuggestionListOpen<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsSuggestionListOpen(value).into()
        }
        unsafe extern "system" fn TextMemberPath<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextMemberPath() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextMemberPath<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextMemberPath(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Text<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UpdateTextOnSelect<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UpdateTextOnSelect() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUpdateTextOnSelect<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetUpdateTextOnSelect(value).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Header<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AutoMaximizeSuggestionArea<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AutoMaximizeSuggestionArea() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAutoMaximizeSuggestionArea<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAutoMaximizeSuggestionArea(value).into()
        }
        unsafe extern "system" fn TextBoxStyle<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextBoxStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextBoxStyle<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextBoxStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SuggestionChosen<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SuggestionChosen(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxSuggestionChosenEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxSuggestionChosenEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSuggestionChosen<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSuggestionChosen(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextChanged<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxTextChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxTextChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextChanged<Impl: IAutoSuggestBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveTextChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IAutoSuggestBox>,
            base.5,
            MaxSuggestionListHeight::<Impl, OFFSET>,
            SetMaxSuggestionListHeight::<Impl, OFFSET>,
            IsSuggestionListOpen::<Impl, OFFSET>,
            SetIsSuggestionListOpen::<Impl, OFFSET>,
            TextMemberPath::<Impl, OFFSET>,
            SetTextMemberPath::<Impl, OFFSET>,
            Text::<Impl, OFFSET>,
            SetText::<Impl, OFFSET>,
            UpdateTextOnSelect::<Impl, OFFSET>,
            SetUpdateTextOnSelect::<Impl, OFFSET>,
            PlaceholderText::<Impl, OFFSET>,
            SetPlaceholderText::<Impl, OFFSET>,
            Header::<Impl, OFFSET>,
            SetHeader::<Impl, OFFSET>,
            AutoMaximizeSuggestionArea::<Impl, OFFSET>,
            SetAutoMaximizeSuggestionArea::<Impl, OFFSET>,
            TextBoxStyle::<Impl, OFFSET>,
            SetTextBoxStyle::<Impl, OFFSET>,
            SuggestionChosen::<Impl, OFFSET>,
            RemoveSuggestionChosen::<Impl, OFFSET>,
            TextChanged::<Impl, OFFSET>,
            RemoveTextChanged::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBox2Impl: Sized {
    fn QueryIcon(&self) -> ::windows::core::Result<IconElement>;
    fn SetQueryIcon(&self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
    fn QuerySubmitted(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxQuerySubmittedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveQuerySubmitted(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBox2";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBox2Vtbl {
    pub const fn new<Impl: IAutoSuggestBox2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAutoSuggestBox2Vtbl {
        unsafe extern "system" fn QueryIcon<Impl: IAutoSuggestBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryIcon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetQueryIcon<Impl: IAutoSuggestBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetQueryIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn QuerySubmitted<Impl: IAutoSuggestBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QuerySubmitted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxQuerySubmittedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<AutoSuggestBox, AutoSuggestBoxQuerySubmittedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveQuerySubmitted<Impl: IAutoSuggestBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveQuerySubmitted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAutoSuggestBox2>, base.5, QueryIcon::<Impl, OFFSET>, SetQueryIcon::<Impl, OFFSET>, QuerySubmitted::<Impl, OFFSET>, RemoveQuerySubmitted::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBox3Impl: Sized {
    fn LightDismissOverlayMode(&self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBox3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBox3";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBox3Vtbl {
    pub const fn new<Impl: IAutoSuggestBox3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAutoSuggestBox3Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: IAutoSuggestBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: IAutoSuggestBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAutoSuggestBox3>, base.5, LightDismissOverlayMode::<Impl, OFFSET>, SetLightDismissOverlayMode::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBox4Impl: Sized {
    fn Description(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBox4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBox4";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBox4Vtbl {
    pub const fn new<Impl: IAutoSuggestBox4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAutoSuggestBox4Vtbl {
        unsafe extern "system" fn Description<Impl: IAutoSuggestBox4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: IAutoSuggestBox4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAutoSuggestBox4>, base.5, Description::<Impl, OFFSET>, SetDescription::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxQuerySubmittedEventArgsImpl: Sized {
    fn QueryText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn ChosenSuggestion(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxQuerySubmittedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxQuerySubmittedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxQuerySubmittedEventArgsVtbl {
    pub const fn new<Impl: IAutoSuggestBoxQuerySubmittedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAutoSuggestBoxQuerySubmittedEventArgsVtbl {
        unsafe extern "system" fn QueryText<Impl: IAutoSuggestBoxQuerySubmittedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChosenSuggestion<Impl: IAutoSuggestBoxQuerySubmittedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChosenSuggestion() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAutoSuggestBoxQuerySubmittedEventArgs>, base.5, QueryText::<Impl, OFFSET>, ChosenSuggestion::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxStaticsImpl: Sized {
    fn MaxSuggestionListHeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSuggestionListOpenProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextMemberPathProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn UpdateTextOnSelectProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AutoMaximizeSuggestionAreaProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextBoxStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxStaticsVtbl {
    pub const fn new<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAutoSuggestBoxStaticsVtbl {
        unsafe extern "system" fn MaxSuggestionListHeightProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxSuggestionListHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSuggestionListOpenProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSuggestionListOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextMemberPathProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextMemberPathProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UpdateTextOnSelectProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UpdateTextOnSelectProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoMaximizeSuggestionAreaProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AutoMaximizeSuggestionAreaProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextBoxStyleProperty<Impl: IAutoSuggestBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextBoxStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAutoSuggestBoxStatics>, base.5, MaxSuggestionListHeightProperty::<Impl, OFFSET>, IsSuggestionListOpenProperty::<Impl, OFFSET>, TextMemberPathProperty::<Impl, OFFSET>, TextProperty::<Impl, OFFSET>, UpdateTextOnSelectProperty::<Impl, OFFSET>, PlaceholderTextProperty::<Impl, OFFSET>, HeaderProperty::<Impl, OFFSET>, AutoMaximizeSuggestionAreaProperty::<Impl, OFFSET>, TextBoxStyleProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxStatics2Impl: Sized {
    fn QueryIconProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxStatics2Vtbl {
    pub const fn new<Impl: IAutoSuggestBoxStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAutoSuggestBoxStatics2Vtbl {
        unsafe extern "system" fn QueryIconProperty<Impl: IAutoSuggestBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryIconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAutoSuggestBoxStatics2>, base.5, QueryIconProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxStatics3Impl: Sized {
    fn LightDismissOverlayModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxStatics3Vtbl {
    pub const fn new<Impl: IAutoSuggestBoxStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAutoSuggestBoxStatics3Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: IAutoSuggestBoxStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAutoSuggestBoxStatics3>, base.5, LightDismissOverlayModeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxStatics4Impl: Sized {
    fn DescriptionProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxStatics4Vtbl {
    pub const fn new<Impl: IAutoSuggestBoxStatics4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAutoSuggestBoxStatics4Vtbl {
        unsafe extern "system" fn DescriptionProperty<Impl: IAutoSuggestBoxStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAutoSuggestBoxStatics4>, base.5, DescriptionProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxSuggestionChosenEventArgsImpl: Sized {
    fn SelectedItem(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxSuggestionChosenEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxSuggestionChosenEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxSuggestionChosenEventArgsVtbl {
    pub const fn new<Impl: IAutoSuggestBoxSuggestionChosenEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAutoSuggestBoxSuggestionChosenEventArgsVtbl {
        unsafe extern "system" fn SelectedItem<Impl: IAutoSuggestBoxSuggestionChosenEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAutoSuggestBoxSuggestionChosenEventArgs>, base.5, SelectedItem::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxTextChangedEventArgsImpl: Sized {
    fn Reason(&self) -> ::windows::core::Result<AutoSuggestionBoxTextChangeReason>;
    fn SetReason(&self, value: AutoSuggestionBoxTextChangeReason) -> ::windows::core::Result<()>;
    fn CheckCurrent(&self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxTextChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxTextChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxTextChangedEventArgsVtbl {
    pub const fn new<Impl: IAutoSuggestBoxTextChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAutoSuggestBoxTextChangedEventArgsVtbl {
        unsafe extern "system" fn Reason<Impl: IAutoSuggestBoxTextChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut AutoSuggestionBoxTextChangeReason) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reason() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetReason<Impl: IAutoSuggestBoxTextChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: AutoSuggestionBoxTextChangeReason) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetReason(value).into()
        }
        unsafe extern "system" fn CheckCurrent<Impl: IAutoSuggestBoxTextChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CheckCurrent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAutoSuggestBoxTextChangedEventArgs>, base.5, Reason::<Impl, OFFSET>, SetReason::<Impl, OFFSET>, CheckCurrent::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IAutoSuggestBoxTextChangedEventArgsStaticsImpl: Sized {
    fn ReasonProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IAutoSuggestBoxTextChangedEventArgsStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IAutoSuggestBoxTextChangedEventArgsStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IAutoSuggestBoxTextChangedEventArgsStaticsVtbl {
    pub const fn new<Impl: IAutoSuggestBoxTextChangedEventArgsStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAutoSuggestBoxTextChangedEventArgsStaticsVtbl {
        unsafe extern "system" fn ReasonProperty<Impl: IAutoSuggestBoxTextChangedEventArgsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReasonProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAutoSuggestBoxTextChangedEventArgsStatics>, base.5, ReasonProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBackClickEventArgsImpl: Sized {
    fn Handled(&self) -> ::windows::core::Result<bool>;
    fn SetHandled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBackClickEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBackClickEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IBackClickEventArgsVtbl {
    pub const fn new<Impl: IBackClickEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBackClickEventArgsVtbl {
        unsafe extern "system" fn Handled<Impl: IBackClickEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IBackClickEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBackClickEventArgs>, base.5, Handled::<Impl, OFFSET>, SetHandled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIconImpl: Sized {
    fn UriSource(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetUriSource(&self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIcon {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIcon";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIconVtbl {
    pub const fn new<Impl: IBitmapIconImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBitmapIconVtbl {
        unsafe extern "system" fn UriSource<Impl: IBitmapIconImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UriSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUriSource<Impl: IBitmapIconImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetUriSource(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBitmapIcon>, base.5, UriSource::<Impl, OFFSET>, SetUriSource::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIcon2Impl: Sized {
    fn ShowAsMonochrome(&self) -> ::windows::core::Result<bool>;
    fn SetShowAsMonochrome(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIcon2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIcon2";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIcon2Vtbl {
    pub const fn new<Impl: IBitmapIcon2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBitmapIcon2Vtbl {
        unsafe extern "system" fn ShowAsMonochrome<Impl: IBitmapIcon2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowAsMonochrome() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowAsMonochrome<Impl: IBitmapIcon2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetShowAsMonochrome(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBitmapIcon2>, base.5, ShowAsMonochrome::<Impl, OFFSET>, SetShowAsMonochrome::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIconFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<BitmapIcon>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIconFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIconFactoryVtbl {
    pub const fn new<Impl: IBitmapIconFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBitmapIconFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IBitmapIconFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBitmapIconFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIconSourceImpl: Sized {
    fn UriSource(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetUriSource(&self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
    fn ShowAsMonochrome(&self) -> ::windows::core::Result<bool>;
    fn SetShowAsMonochrome(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIconSource {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconSource";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIconSourceVtbl {
    pub const fn new<Impl: IBitmapIconSourceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBitmapIconSourceVtbl {
        unsafe extern "system" fn UriSource<Impl: IBitmapIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UriSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUriSource<Impl: IBitmapIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetUriSource(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ShowAsMonochrome<Impl: IBitmapIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowAsMonochrome() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowAsMonochrome<Impl: IBitmapIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetShowAsMonochrome(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBitmapIconSource>, base.5, UriSource::<Impl, OFFSET>, SetUriSource::<Impl, OFFSET>, ShowAsMonochrome::<Impl, OFFSET>, SetShowAsMonochrome::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIconSourceFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<BitmapIconSource>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIconSourceFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconSourceFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIconSourceFactoryVtbl {
    pub const fn new<Impl: IBitmapIconSourceFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBitmapIconSourceFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IBitmapIconSourceFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBitmapIconSourceFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIconSourceStaticsImpl: Sized {
    fn UriSourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ShowAsMonochromeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIconSourceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconSourceStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIconSourceStaticsVtbl {
    pub const fn new<Impl: IBitmapIconSourceStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBitmapIconSourceStaticsVtbl {
        unsafe extern "system" fn UriSourceProperty<Impl: IBitmapIconSourceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UriSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShowAsMonochromeProperty<Impl: IBitmapIconSourceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowAsMonochromeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBitmapIconSourceStatics>, base.5, UriSourceProperty::<Impl, OFFSET>, ShowAsMonochromeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIconStaticsImpl: Sized {
    fn UriSourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIconStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIconStaticsVtbl {
    pub const fn new<Impl: IBitmapIconStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBitmapIconStaticsVtbl {
        unsafe extern "system" fn UriSourceProperty<Impl: IBitmapIconStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UriSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBitmapIconStatics>, base.5, UriSourceProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBitmapIconStatics2Impl: Sized {
    fn ShowAsMonochromeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBitmapIconStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBitmapIconStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IBitmapIconStatics2Vtbl {
    pub const fn new<Impl: IBitmapIconStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBitmapIconStatics2Vtbl {
        unsafe extern "system" fn ShowAsMonochromeProperty<Impl: IBitmapIconStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowAsMonochromeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBitmapIconStatics2>, base.5, ShowAsMonochromeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBorderImpl: Sized {
    fn BorderBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn Background(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CornerRadius(&self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
    fn Padding(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn Child(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetChild(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn ChildTransitions(&self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetChildTransitions(&self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBorder {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBorder";
}
#[cfg(feature = "implement_exclusive")]
impl IBorderVtbl {
    pub const fn new<Impl: IBorderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBorderVtbl {
        unsafe extern "system" fn BorderBrush<Impl: IBorderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IBorderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IBorderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IBorderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Background<Impl: IBorderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Background() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackground<Impl: IBorderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IBorderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IBorderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IBorderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IBorderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Child<Impl: IBorderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Child() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChild<Impl: IBorderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetChild(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ChildTransitions<Impl: IBorderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChildTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChildTransitions<Impl: IBorderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetChildTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IBorder>,
            base.5,
            BorderBrush::<Impl, OFFSET>,
            SetBorderBrush::<Impl, OFFSET>,
            BorderThickness::<Impl, OFFSET>,
            SetBorderThickness::<Impl, OFFSET>,
            Background::<Impl, OFFSET>,
            SetBackground::<Impl, OFFSET>,
            CornerRadius::<Impl, OFFSET>,
            SetCornerRadius::<Impl, OFFSET>,
            Padding::<Impl, OFFSET>,
            SetPadding::<Impl, OFFSET>,
            Child::<Impl, OFFSET>,
            SetChild::<Impl, OFFSET>,
            ChildTransitions::<Impl, OFFSET>,
            SetChildTransitions::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBorder2Impl: Sized {
    fn BackgroundSizing(&self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&self, value: BackgroundSizing) -> ::windows::core::Result<()>;
    fn BackgroundTransition(&self) -> ::windows::core::Result<super::BrushTransition>;
    fn SetBackgroundTransition(&self, value: &::core::option::Option<super::BrushTransition>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBorder2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBorder2";
}
#[cfg(feature = "implement_exclusive")]
impl IBorder2Vtbl {
    pub const fn new<Impl: IBorder2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBorder2Vtbl {
        unsafe extern "system" fn BackgroundSizing<Impl: IBorder2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IBorder2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        unsafe extern "system" fn BackgroundTransition<Impl: IBorder2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundTransition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundTransition<Impl: IBorder2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBackgroundTransition(&*(&value as *const <super::BrushTransition as ::windows::core::Abi>::Abi as *const <super::BrushTransition as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBorder2>, base.5, BackgroundSizing::<Impl, OFFSET>, SetBackgroundSizing::<Impl, OFFSET>, BackgroundTransition::<Impl, OFFSET>, SetBackgroundTransition::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBorderStaticsImpl: Sized {
    fn BorderBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ChildTransitionsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBorderStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBorderStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IBorderStaticsVtbl {
    pub const fn new<Impl: IBorderStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBorderStaticsVtbl {
        unsafe extern "system" fn BorderBrushProperty<Impl: IBorderStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IBorderStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackgroundProperty<Impl: IBorderStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IBorderStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IBorderStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChildTransitionsProperty<Impl: IBorderStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChildTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBorderStatics>, base.5, BorderBrushProperty::<Impl, OFFSET>, BorderThicknessProperty::<Impl, OFFSET>, BackgroundProperty::<Impl, OFFSET>, CornerRadiusProperty::<Impl, OFFSET>, PaddingProperty::<Impl, OFFSET>, ChildTransitionsProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IBorderStatics2Impl: Sized {
    fn BackgroundSizingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IBorderStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IBorderStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IBorderStatics2Vtbl {
    pub const fn new<Impl: IBorderStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IBorderStatics2Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IBorderStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IBorderStatics2>, base.5, BackgroundSizingProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IButtonImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IButton";
}
#[cfg(feature = "implement_exclusive")]
impl IButtonVtbl {
    pub const fn new<Impl: IButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IButtonVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IButton>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IButtonFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Button>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IButtonFactoryVtbl {
    pub const fn new<Impl: IButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IButtonFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IButtonFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IButtonStaticsWithFlyoutImpl: Sized {
    fn FlyoutProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IButtonStaticsWithFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IButtonStaticsWithFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl IButtonStaticsWithFlyoutVtbl {
    pub const fn new<Impl: IButtonStaticsWithFlyoutImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IButtonStaticsWithFlyoutVtbl {
        unsafe extern "system" fn FlyoutProperty<Impl: IButtonStaticsWithFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IButtonStaticsWithFlyout>, base.5, FlyoutProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IButtonWithFlyoutImpl: Sized {
    fn Flyout(&self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetFlyout(&self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IButtonWithFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IButtonWithFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl IButtonWithFlyoutVtbl {
    pub const fn new<Impl: IButtonWithFlyoutImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IButtonWithFlyoutVtbl {
        unsafe extern "system" fn Flyout<Impl: IButtonWithFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Flyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFlyout<Impl: IButtonWithFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IButtonWithFlyout>, base.5, Flyout::<Impl, OFFSET>, SetFlyout::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePickerImpl: Sized {
    fn Date(&self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
    fn SetDate(&self, value: &::core::option::Option<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>) -> ::windows::core::Result<()>;
    fn IsCalendarOpen(&self) -> ::windows::core::Result<bool>;
    fn SetIsCalendarOpen(&self, value: bool) -> ::windows::core::Result<()>;
    fn DateFormat(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDateFormat(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PlaceholderText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Header(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn CalendarViewStyle(&self) -> ::windows::core::Result<super::Style>;
    fn SetCalendarViewStyle(&self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn MinDate(&self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMinDate(&self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn MaxDate(&self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMaxDate(&self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn IsTodayHighlighted(&self) -> ::windows::core::Result<bool>;
    fn SetIsTodayHighlighted(&self, value: bool) -> ::windows::core::Result<()>;
    fn DisplayMode(&self) -> ::windows::core::Result<CalendarViewDisplayMode>;
    fn SetDisplayMode(&self, value: CalendarViewDisplayMode) -> ::windows::core::Result<()>;
    fn FirstDayOfWeek(&self) -> ::windows::core::Result<super::super::super::Globalization::DayOfWeek>;
    fn SetFirstDayOfWeek(&self, value: super::super::super::Globalization::DayOfWeek) -> ::windows::core::Result<()>;
    fn DayOfWeekFormat(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDayOfWeekFormat(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn CalendarIdentifier(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCalendarIdentifier(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn IsOutOfScopeEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsOutOfScopeEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsGroupLabelVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsGroupLabelVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn CalendarViewDayItemChanging(&self, handler: &::core::option::Option<CalendarViewDayItemChangingEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCalendarViewDayItemChanging(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DateChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CalendarDatePicker, CalendarDatePickerDateChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDateChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Opened(&self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpened(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Closed(&self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosed(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SetDisplayDate(&self, date: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn SetYearDecadeDisplayDimensions(&self, columns: i32, rows: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePicker {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePicker";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePickerVtbl {
    pub const fn new<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarDatePickerVtbl {
        unsafe extern "system" fn Date<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Date() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDate<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDate(&*(&value as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsCalendarOpen<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCalendarOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCalendarOpen<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsCalendarOpen(value).into()
        }
        unsafe extern "system" fn DateFormat<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DateFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDateFormat<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDateFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Header<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarViewStyle<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarViewStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarViewStyle<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCalendarViewStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinDate<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinDate<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMinDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxDate<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxDate<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsTodayHighlighted<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTodayHighlighted() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTodayHighlighted<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsTodayHighlighted(value).into()
        }
        unsafe extern "system" fn DisplayMode<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut CalendarViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayMode<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: CalendarViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDisplayMode(value).into()
        }
        unsafe extern "system" fn FirstDayOfWeek<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Globalization::DayOfWeek) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstDayOfWeek() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstDayOfWeek<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::super::Globalization::DayOfWeek) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFirstDayOfWeek(value).into()
        }
        unsafe extern "system" fn DayOfWeekFormat<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayOfWeekFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayOfWeekFormat<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDayOfWeekFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarIdentifier<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarIdentifier<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCalendarIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsOutOfScopeEnabled<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsOutOfScopeEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsOutOfScopeEnabled<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsOutOfScopeEnabled(value).into()
        }
        unsafe extern "system" fn IsGroupLabelVisible<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsGroupLabelVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsGroupLabelVisible<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsGroupLabelVisible(value).into()
        }
        unsafe extern "system" fn CalendarViewDayItemChanging<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarViewDayItemChanging(&*(&handler as *const <CalendarViewDayItemChangingEventHandler as ::windows::core::Abi>::Abi as *const <CalendarViewDayItemChangingEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCalendarViewDayItemChanging<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveCalendarViewDayItemChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DateChanged<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DateChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<CalendarDatePicker, CalendarDatePickerDateChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CalendarDatePicker, CalendarDatePickerDateChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDateChanged<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveDateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Opened<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Opened(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpened<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Closed<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Closed(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosed<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetDisplayDate<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, date: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDisplayDate(&*(&date as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetYearDecadeDisplayDimensions<Impl: ICalendarDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, columns: i32, rows: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetYearDecadeDisplayDimensions(columns, rows).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ICalendarDatePicker>,
            base.5,
            Date::<Impl, OFFSET>,
            SetDate::<Impl, OFFSET>,
            IsCalendarOpen::<Impl, OFFSET>,
            SetIsCalendarOpen::<Impl, OFFSET>,
            DateFormat::<Impl, OFFSET>,
            SetDateFormat::<Impl, OFFSET>,
            PlaceholderText::<Impl, OFFSET>,
            SetPlaceholderText::<Impl, OFFSET>,
            Header::<Impl, OFFSET>,
            SetHeader::<Impl, OFFSET>,
            HeaderTemplate::<Impl, OFFSET>,
            SetHeaderTemplate::<Impl, OFFSET>,
            CalendarViewStyle::<Impl, OFFSET>,
            SetCalendarViewStyle::<Impl, OFFSET>,
            MinDate::<Impl, OFFSET>,
            SetMinDate::<Impl, OFFSET>,
            MaxDate::<Impl, OFFSET>,
            SetMaxDate::<Impl, OFFSET>,
            IsTodayHighlighted::<Impl, OFFSET>,
            SetIsTodayHighlighted::<Impl, OFFSET>,
            DisplayMode::<Impl, OFFSET>,
            SetDisplayMode::<Impl, OFFSET>,
            FirstDayOfWeek::<Impl, OFFSET>,
            SetFirstDayOfWeek::<Impl, OFFSET>,
            DayOfWeekFormat::<Impl, OFFSET>,
            SetDayOfWeekFormat::<Impl, OFFSET>,
            CalendarIdentifier::<Impl, OFFSET>,
            SetCalendarIdentifier::<Impl, OFFSET>,
            IsOutOfScopeEnabled::<Impl, OFFSET>,
            SetIsOutOfScopeEnabled::<Impl, OFFSET>,
            IsGroupLabelVisible::<Impl, OFFSET>,
            SetIsGroupLabelVisible::<Impl, OFFSET>,
            CalendarViewDayItemChanging::<Impl, OFFSET>,
            RemoveCalendarViewDayItemChanging::<Impl, OFFSET>,
            DateChanged::<Impl, OFFSET>,
            RemoveDateChanged::<Impl, OFFSET>,
            Opened::<Impl, OFFSET>,
            RemoveOpened::<Impl, OFFSET>,
            Closed::<Impl, OFFSET>,
            RemoveClosed::<Impl, OFFSET>,
            SetDisplayDate::<Impl, OFFSET>,
            SetYearDecadeDisplayDimensions::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePicker2Impl: Sized {
    fn LightDismissOverlayMode(&self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePicker2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePicker2";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePicker2Vtbl {
    pub const fn new<Impl: ICalendarDatePicker2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarDatePicker2Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: ICalendarDatePicker2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: ICalendarDatePicker2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICalendarDatePicker2>, base.5, LightDismissOverlayMode::<Impl, OFFSET>, SetLightDismissOverlayMode::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePicker3Impl: Sized {
    fn Description(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePicker3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePicker3";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePicker3Vtbl {
    pub const fn new<Impl: ICalendarDatePicker3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarDatePicker3Vtbl {
        unsafe extern "system" fn Description<Impl: ICalendarDatePicker3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: ICalendarDatePicker3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICalendarDatePicker3>, base.5, Description::<Impl, OFFSET>, SetDescription::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePickerDateChangedEventArgsImpl: Sized {
    fn NewDate(&self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
    fn OldDate(&self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePickerDateChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePickerDateChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePickerDateChangedEventArgsVtbl {
    pub const fn new<Impl: ICalendarDatePickerDateChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarDatePickerDateChangedEventArgsVtbl {
        unsafe extern "system" fn NewDate<Impl: ICalendarDatePickerDateChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NewDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OldDate<Impl: ICalendarDatePickerDateChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OldDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICalendarDatePickerDateChangedEventArgs>, base.5, NewDate::<Impl, OFFSET>, OldDate::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePickerFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CalendarDatePicker>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePickerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePickerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePickerFactoryVtbl {
    pub const fn new<Impl: ICalendarDatePickerFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarDatePickerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICalendarDatePickerFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICalendarDatePickerFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePickerStaticsImpl: Sized {
    fn DateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCalendarOpenProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DateFormatProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarViewStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinDateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxDateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTodayHighlightedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstDayOfWeekProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayOfWeekFormatProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarIdentifierProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsOutOfScopeEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsGroupLabelVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePickerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePickerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePickerStaticsVtbl {
    pub const fn new<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarDatePickerStaticsVtbl {
        unsafe extern "system" fn DateProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCalendarOpenProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCalendarOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DateFormatProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DateFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarViewStyleProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarViewStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinDateProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinDateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxDateProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxDateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTodayHighlightedProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTodayHighlightedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayModeProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstDayOfWeekProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstDayOfWeekProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayOfWeekFormatProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayOfWeekFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarIdentifierProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsOutOfScopeEnabledProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsOutOfScopeEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsGroupLabelVisibleProperty<Impl: ICalendarDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsGroupLabelVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ICalendarDatePickerStatics>,
            base.5,
            DateProperty::<Impl, OFFSET>,
            IsCalendarOpenProperty::<Impl, OFFSET>,
            DateFormatProperty::<Impl, OFFSET>,
            PlaceholderTextProperty::<Impl, OFFSET>,
            HeaderProperty::<Impl, OFFSET>,
            HeaderTemplateProperty::<Impl, OFFSET>,
            CalendarViewStyleProperty::<Impl, OFFSET>,
            MinDateProperty::<Impl, OFFSET>,
            MaxDateProperty::<Impl, OFFSET>,
            IsTodayHighlightedProperty::<Impl, OFFSET>,
            DisplayModeProperty::<Impl, OFFSET>,
            FirstDayOfWeekProperty::<Impl, OFFSET>,
            DayOfWeekFormatProperty::<Impl, OFFSET>,
            CalendarIdentifierProperty::<Impl, OFFSET>,
            IsOutOfScopeEnabledProperty::<Impl, OFFSET>,
            IsGroupLabelVisibleProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePickerStatics2Impl: Sized {
    fn LightDismissOverlayModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePickerStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePickerStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePickerStatics2Vtbl {
    pub const fn new<Impl: ICalendarDatePickerStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarDatePickerStatics2Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: ICalendarDatePickerStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICalendarDatePickerStatics2>, base.5, LightDismissOverlayModeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarDatePickerStatics3Impl: Sized {
    fn DescriptionProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarDatePickerStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarDatePickerStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarDatePickerStatics3Vtbl {
    pub const fn new<Impl: ICalendarDatePickerStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarDatePickerStatics3Vtbl {
        unsafe extern "system" fn DescriptionProperty<Impl: ICalendarDatePickerStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICalendarDatePickerStatics3>, base.5, DescriptionProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewImpl: Sized {
    fn CalendarIdentifier(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCalendarIdentifier(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn DayOfWeekFormat(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDayOfWeekFormat(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn IsGroupLabelVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsGroupLabelVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn DisplayMode(&self) -> ::windows::core::Result<CalendarViewDisplayMode>;
    fn SetDisplayMode(&self, value: CalendarViewDisplayMode) -> ::windows::core::Result<()>;
    fn FirstDayOfWeek(&self) -> ::windows::core::Result<super::super::super::Globalization::DayOfWeek>;
    fn SetFirstDayOfWeek(&self, value: super::super::super::Globalization::DayOfWeek) -> ::windows::core::Result<()>;
    fn IsOutOfScopeEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsOutOfScopeEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsTodayHighlighted(&self) -> ::windows::core::Result<bool>;
    fn SetIsTodayHighlighted(&self, value: bool) -> ::windows::core::Result<()>;
    fn MaxDate(&self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMaxDate(&self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn MinDate(&self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMinDate(&self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn NumberOfWeeksInView(&self) -> ::windows::core::Result<i32>;
    fn SetNumberOfWeeksInView(&self, value: i32) -> ::windows::core::Result<()>;
    fn SelectedDates(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::DateTime>>;
    fn SelectionMode(&self) -> ::windows::core::Result<CalendarViewSelectionMode>;
    fn SetSelectionMode(&self, value: CalendarViewSelectionMode) -> ::windows::core::Result<()>;
    fn TemplateSettings(&self) -> ::windows::core::Result<Primitives::CalendarViewTemplateSettings>;
    fn FocusBorderBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetFocusBorderBrush(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedHoverBorderBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedHoverBorderBrush(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedPressedBorderBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedPressedBorderBrush(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedBorderBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedBorderBrush(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn HoverBorderBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetHoverBorderBrush(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn PressedBorderBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetPressedBorderBrush(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemBorderBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemBorderBrush(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn OutOfScopeBackground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetOutOfScopeBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemBackground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn PressedForeground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetPressedForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayForeground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BlackoutForeground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBlackoutForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedForeground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn OutOfScopeForeground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetOutOfScopeForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemForeground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn DayItemFontFamily(&self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetDayItemFontFamily(&self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn DayItemFontSize(&self) -> ::windows::core::Result<f64>;
    fn SetDayItemFontSize(&self, value: f64) -> ::windows::core::Result<()>;
    fn DayItemFontStyle(&self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetDayItemFontStyle(&self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn DayItemFontWeight(&self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetDayItemFontWeight(&self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn TodayFontWeight(&self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetTodayFontWeight(&self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FirstOfMonthLabelFontFamily(&self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFirstOfMonthLabelFontFamily(&self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FirstOfMonthLabelFontSize(&self) -> ::windows::core::Result<f64>;
    fn SetFirstOfMonthLabelFontSize(&self, value: f64) -> ::windows::core::Result<()>;
    fn FirstOfMonthLabelFontStyle(&self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFirstOfMonthLabelFontStyle(&self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FirstOfMonthLabelFontWeight(&self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFirstOfMonthLabelFontWeight(&self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn MonthYearItemFontFamily(&self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetMonthYearItemFontFamily(&self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn MonthYearItemFontSize(&self) -> ::windows::core::Result<f64>;
    fn SetMonthYearItemFontSize(&self, value: f64) -> ::windows::core::Result<()>;
    fn MonthYearItemFontStyle(&self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetMonthYearItemFontStyle(&self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn MonthYearItemFontWeight(&self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetMonthYearItemFontWeight(&self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FirstOfYearDecadeLabelFontFamily(&self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFirstOfYearDecadeLabelFontFamily(&self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FirstOfYearDecadeLabelFontSize(&self) -> ::windows::core::Result<f64>;
    fn SetFirstOfYearDecadeLabelFontSize(&self, value: f64) -> ::windows::core::Result<()>;
    fn FirstOfYearDecadeLabelFontStyle(&self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFirstOfYearDecadeLabelFontStyle(&self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FirstOfYearDecadeLabelFontWeight(&self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFirstOfYearDecadeLabelFontWeight(&self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn HorizontalDayItemAlignment(&self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalDayItemAlignment(&self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalDayItemAlignment(&self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalDayItemAlignment(&self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
    fn HorizontalFirstOfMonthLabelAlignment(&self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalFirstOfMonthLabelAlignment(&self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalFirstOfMonthLabelAlignment(&self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalFirstOfMonthLabelAlignment(&self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
    fn CalendarItemBorderThickness(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetCalendarItemBorderThickness(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CalendarViewDayItemStyle(&self) -> ::windows::core::Result<super::Style>;
    fn SetCalendarViewDayItemStyle(&self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn CalendarViewDayItemChanging(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCalendarViewDayItemChanging(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectedDatesChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewSelectedDatesChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectedDatesChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SetDisplayDate(&self, date: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn SetYearDecadeDisplayDimensions(&self, columns: i32, rows: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarView";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewVtbl {
    pub const fn new<Impl: ICalendarViewImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarViewVtbl {
        unsafe extern "system" fn CalendarIdentifier<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarIdentifier<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCalendarIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayOfWeekFormat<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayOfWeekFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayOfWeekFormat<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDayOfWeekFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsGroupLabelVisible<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsGroupLabelVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsGroupLabelVisible<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsGroupLabelVisible(value).into()
        }
        unsafe extern "system" fn DisplayMode<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut CalendarViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayMode<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: CalendarViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDisplayMode(value).into()
        }
        unsafe extern "system" fn FirstDayOfWeek<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Globalization::DayOfWeek) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstDayOfWeek() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstDayOfWeek<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::super::Globalization::DayOfWeek) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFirstDayOfWeek(value).into()
        }
        unsafe extern "system" fn IsOutOfScopeEnabled<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsOutOfScopeEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsOutOfScopeEnabled<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsOutOfScopeEnabled(value).into()
        }
        unsafe extern "system" fn IsTodayHighlighted<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTodayHighlighted() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTodayHighlighted<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsTodayHighlighted(value).into()
        }
        unsafe extern "system" fn MaxDate<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxDate<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinDate<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinDate<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMinDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NumberOfWeeksInView<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NumberOfWeeksInView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNumberOfWeeksInView<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetNumberOfWeeksInView(value).into()
        }
        unsafe extern "system" fn SelectedDates<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedDates() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionMode<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut CalendarViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionMode<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: CalendarViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionMode(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FocusBorderBrush<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FocusBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFocusBorderBrush<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFocusBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedHoverBorderBrush<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedHoverBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedHoverBorderBrush<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedHoverBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedPressedBorderBrush<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedPressedBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedPressedBorderBrush<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedPressedBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedBorderBrush<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedBorderBrush<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HoverBorderBrush<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HoverBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHoverBorderBrush<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHoverBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PressedBorderBrush<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PressedBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPressedBorderBrush<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPressedBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemBorderBrush<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarItemBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemBorderBrush<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCalendarItemBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OutOfScopeBackground<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OutOfScopeBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutOfScopeBackground<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOutOfScopeBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemBackground<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarItemBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemBackground<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCalendarItemBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PressedForeground<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PressedForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPressedForeground<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPressedForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayForeground<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodayForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayForeground<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTodayForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BlackoutForeground<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BlackoutForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlackoutForeground<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBlackoutForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedForeground<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedForeground<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OutOfScopeForeground<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OutOfScopeForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutOfScopeForeground<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOutOfScopeForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemForeground<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarItemForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemForeground<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCalendarItemForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayItemFontFamily<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayItemFontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayItemFontFamily<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDayItemFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayItemFontSize<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayItemFontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayItemFontSize<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDayItemFontSize(value).into()
        }
        unsafe extern "system" fn DayItemFontStyle<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayItemFontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayItemFontStyle<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDayItemFontStyle(value).into()
        }
        unsafe extern "system" fn DayItemFontWeight<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayItemFontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayItemFontWeight<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDayItemFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayFontWeight<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodayFontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayFontWeight<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTodayFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfMonthLabelFontFamily<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfMonthLabelFontFamily<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFirstOfMonthLabelFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfMonthLabelFontSize<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfMonthLabelFontSize<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFirstOfMonthLabelFontSize(value).into()
        }
        unsafe extern "system" fn FirstOfMonthLabelFontStyle<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfMonthLabelFontStyle<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFirstOfMonthLabelFontStyle(value).into()
        }
        unsafe extern "system" fn FirstOfMonthLabelFontWeight<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfMonthLabelFontWeight<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFirstOfMonthLabelFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MonthYearItemFontFamily<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthYearItemFontFamily<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMonthYearItemFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MonthYearItemFontSize<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthYearItemFontSize<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMonthYearItemFontSize(value).into()
        }
        unsafe extern "system" fn MonthYearItemFontStyle<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthYearItemFontStyle<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMonthYearItemFontStyle(value).into()
        }
        unsafe extern "system" fn MonthYearItemFontWeight<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthYearItemFontWeight<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMonthYearItemFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontFamily<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfYearDecadeLabelFontFamily<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFirstOfYearDecadeLabelFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontSize<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfYearDecadeLabelFontSize<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFirstOfYearDecadeLabelFontSize(value).into()
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontStyle<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfYearDecadeLabelFontStyle<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFirstOfYearDecadeLabelFontStyle(value).into()
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontWeight<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfYearDecadeLabelFontWeight<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFirstOfYearDecadeLabelFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HorizontalDayItemAlignment<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalDayItemAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalDayItemAlignment<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalDayItemAlignment(value).into()
        }
        unsafe extern "system" fn VerticalDayItemAlignment<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalDayItemAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalDayItemAlignment<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalDayItemAlignment(value).into()
        }
        unsafe extern "system" fn HorizontalFirstOfMonthLabelAlignment<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalFirstOfMonthLabelAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalFirstOfMonthLabelAlignment<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalFirstOfMonthLabelAlignment(value).into()
        }
        unsafe extern "system" fn VerticalFirstOfMonthLabelAlignment<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalFirstOfMonthLabelAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalFirstOfMonthLabelAlignment<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalFirstOfMonthLabelAlignment(value).into()
        }
        unsafe extern "system" fn CalendarItemBorderThickness<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarItemBorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemBorderThickness<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCalendarItemBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarViewDayItemStyle<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarViewDayItemStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarViewDayItemStyle<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCalendarViewDayItemStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarViewDayItemChanging<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarViewDayItemChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCalendarViewDayItemChanging<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveCalendarViewDayItemChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedDatesChanged<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedDatesChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewSelectedDatesChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewSelectedDatesChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectedDatesChanged<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSelectedDatesChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetDisplayDate<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, date: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDisplayDate(&*(&date as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetYearDecadeDisplayDimensions<Impl: ICalendarViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, columns: i32, rows: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetYearDecadeDisplayDimensions(columns, rows).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ICalendarView>,
            base.5,
            CalendarIdentifier::<Impl, OFFSET>,
            SetCalendarIdentifier::<Impl, OFFSET>,
            DayOfWeekFormat::<Impl, OFFSET>,
            SetDayOfWeekFormat::<Impl, OFFSET>,
            IsGroupLabelVisible::<Impl, OFFSET>,
            SetIsGroupLabelVisible::<Impl, OFFSET>,
            DisplayMode::<Impl, OFFSET>,
            SetDisplayMode::<Impl, OFFSET>,
            FirstDayOfWeek::<Impl, OFFSET>,
            SetFirstDayOfWeek::<Impl, OFFSET>,
            IsOutOfScopeEnabled::<Impl, OFFSET>,
            SetIsOutOfScopeEnabled::<Impl, OFFSET>,
            IsTodayHighlighted::<Impl, OFFSET>,
            SetIsTodayHighlighted::<Impl, OFFSET>,
            MaxDate::<Impl, OFFSET>,
            SetMaxDate::<Impl, OFFSET>,
            MinDate::<Impl, OFFSET>,
            SetMinDate::<Impl, OFFSET>,
            NumberOfWeeksInView::<Impl, OFFSET>,
            SetNumberOfWeeksInView::<Impl, OFFSET>,
            SelectedDates::<Impl, OFFSET>,
            SelectionMode::<Impl, OFFSET>,
            SetSelectionMode::<Impl, OFFSET>,
            TemplateSettings::<Impl, OFFSET>,
            FocusBorderBrush::<Impl, OFFSET>,
            SetFocusBorderBrush::<Impl, OFFSET>,
            SelectedHoverBorderBrush::<Impl, OFFSET>,
            SetSelectedHoverBorderBrush::<Impl, OFFSET>,
            SelectedPressedBorderBrush::<Impl, OFFSET>,
            SetSelectedPressedBorderBrush::<Impl, OFFSET>,
            SelectedBorderBrush::<Impl, OFFSET>,
            SetSelectedBorderBrush::<Impl, OFFSET>,
            HoverBorderBrush::<Impl, OFFSET>,
            SetHoverBorderBrush::<Impl, OFFSET>,
            PressedBorderBrush::<Impl, OFFSET>,
            SetPressedBorderBrush::<Impl, OFFSET>,
            CalendarItemBorderBrush::<Impl, OFFSET>,
            SetCalendarItemBorderBrush::<Impl, OFFSET>,
            OutOfScopeBackground::<Impl, OFFSET>,
            SetOutOfScopeBackground::<Impl, OFFSET>,
            CalendarItemBackground::<Impl, OFFSET>,
            SetCalendarItemBackground::<Impl, OFFSET>,
            PressedForeground::<Impl, OFFSET>,
            SetPressedForeground::<Impl, OFFSET>,
            TodayForeground::<Impl, OFFSET>,
            SetTodayForeground::<Impl, OFFSET>,
            BlackoutForeground::<Impl, OFFSET>,
            SetBlackoutForeground::<Impl, OFFSET>,
            SelectedForeground::<Impl, OFFSET>,
            SetSelectedForeground::<Impl, OFFSET>,
            OutOfScopeForeground::<Impl, OFFSET>,
            SetOutOfScopeForeground::<Impl, OFFSET>,
            CalendarItemForeground::<Impl, OFFSET>,
            SetCalendarItemForeground::<Impl, OFFSET>,
            DayItemFontFamily::<Impl, OFFSET>,
            SetDayItemFontFamily::<Impl, OFFSET>,
            DayItemFontSize::<Impl, OFFSET>,
            SetDayItemFontSize::<Impl, OFFSET>,
            DayItemFontStyle::<Impl, OFFSET>,
            SetDayItemFontStyle::<Impl, OFFSET>,
            DayItemFontWeight::<Impl, OFFSET>,
            SetDayItemFontWeight::<Impl, OFFSET>,
            TodayFontWeight::<Impl, OFFSET>,
            SetTodayFontWeight::<Impl, OFFSET>,
            FirstOfMonthLabelFontFamily::<Impl, OFFSET>,
            SetFirstOfMonthLabelFontFamily::<Impl, OFFSET>,
            FirstOfMonthLabelFontSize::<Impl, OFFSET>,
            SetFirstOfMonthLabelFontSize::<Impl, OFFSET>,
            FirstOfMonthLabelFontStyle::<Impl, OFFSET>,
            SetFirstOfMonthLabelFontStyle::<Impl, OFFSET>,
            FirstOfMonthLabelFontWeight::<Impl, OFFSET>,
            SetFirstOfMonthLabelFontWeight::<Impl, OFFSET>,
            MonthYearItemFontFamily::<Impl, OFFSET>,
            SetMonthYearItemFontFamily::<Impl, OFFSET>,
            MonthYearItemFontSize::<Impl, OFFSET>,
            SetMonthYearItemFontSize::<Impl, OFFSET>,
            MonthYearItemFontStyle::<Impl, OFFSET>,
            SetMonthYearItemFontStyle::<Impl, OFFSET>,
            MonthYearItemFontWeight::<Impl, OFFSET>,
            SetMonthYearItemFontWeight::<Impl, OFFSET>,
            FirstOfYearDecadeLabelFontFamily::<Impl, OFFSET>,
            SetFirstOfYearDecadeLabelFontFamily::<Impl, OFFSET>,
            FirstOfYearDecadeLabelFontSize::<Impl, OFFSET>,
            SetFirstOfYearDecadeLabelFontSize::<Impl, OFFSET>,
            FirstOfYearDecadeLabelFontStyle::<Impl, OFFSET>,
            SetFirstOfYearDecadeLabelFontStyle::<Impl, OFFSET>,
            FirstOfYearDecadeLabelFontWeight::<Impl, OFFSET>,
            SetFirstOfYearDecadeLabelFontWeight::<Impl, OFFSET>,
            HorizontalDayItemAlignment::<Impl, OFFSET>,
            SetHorizontalDayItemAlignment::<Impl, OFFSET>,
            VerticalDayItemAlignment::<Impl, OFFSET>,
            SetVerticalDayItemAlignment::<Impl, OFFSET>,
            HorizontalFirstOfMonthLabelAlignment::<Impl, OFFSET>,
            SetHorizontalFirstOfMonthLabelAlignment::<Impl, OFFSET>,
            VerticalFirstOfMonthLabelAlignment::<Impl, OFFSET>,
            SetVerticalFirstOfMonthLabelAlignment::<Impl, OFFSET>,
            CalendarItemBorderThickness::<Impl, OFFSET>,
            SetCalendarItemBorderThickness::<Impl, OFFSET>,
            CalendarViewDayItemStyle::<Impl, OFFSET>,
            SetCalendarViewDayItemStyle::<Impl, OFFSET>,
            CalendarViewDayItemChanging::<Impl, OFFSET>,
            RemoveCalendarViewDayItemChanging::<Impl, OFFSET>,
            SelectedDatesChanged::<Impl, OFFSET>,
            RemoveSelectedDatesChanged::<Impl, OFFSET>,
            SetDisplayDate::<Impl, OFFSET>,
            SetYearDecadeDisplayDimensions::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarView2Impl: Sized {
    fn SelectedDisabledBorderBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedDisabledBorderBrush(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodaySelectedInnerBorderBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodaySelectedInnerBorderBrush(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BlackoutStrikethroughBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBlackoutStrikethroughBrush(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BlackoutBackground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBlackoutBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemHoverBackground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemHoverBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemPressedBackground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemPressedBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CalendarItemDisabledBackground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetCalendarItemDisabledBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayBackground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayBlackoutBackground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayBlackoutBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayHoverBackground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayHoverBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayPressedBackground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayPressedBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayDisabledBackground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayDisabledBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TodayBlackoutForeground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetTodayBlackoutForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedHoverForeground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedHoverForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedPressedForeground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedPressedForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn SelectedDisabledForeground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetSelectedDisabledForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn OutOfScopeHoverForeground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetOutOfScopeHoverForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn OutOfScopePressedForeground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetOutOfScopePressedForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn DisabledForeground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetDisabledForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn DayItemMargin(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetDayItemMargin(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn MonthYearItemMargin(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetMonthYearItemMargin(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn FirstOfMonthLabelMargin(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetFirstOfMonthLabelMargin(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn FirstOfYearDecadeLabelMargin(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetFirstOfYearDecadeLabelMargin(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CalendarItemCornerRadius(&self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCalendarItemCornerRadius(&self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarView2";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarView2Vtbl {
    pub const fn new<Impl: ICalendarView2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarView2Vtbl {
        unsafe extern "system" fn SelectedDisabledBorderBrush<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedDisabledBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedDisabledBorderBrush<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedDisabledBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodaySelectedInnerBorderBrush<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodaySelectedInnerBorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodaySelectedInnerBorderBrush<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTodaySelectedInnerBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BlackoutStrikethroughBrush<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BlackoutStrikethroughBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlackoutStrikethroughBrush<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBlackoutStrikethroughBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BlackoutBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BlackoutBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlackoutBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBlackoutBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemHoverBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarItemHoverBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemHoverBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCalendarItemHoverBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemPressedBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarItemPressedBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemPressedBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCalendarItemPressedBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemDisabledBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarItemDisabledBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemDisabledBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCalendarItemDisabledBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodayBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTodayBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayBlackoutBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodayBlackoutBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayBlackoutBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTodayBlackoutBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayHoverBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodayHoverBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayHoverBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTodayHoverBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayPressedBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodayPressedBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayPressedBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTodayPressedBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayDisabledBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodayDisabledBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayDisabledBackground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTodayDisabledBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TodayBlackoutForeground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodayBlackoutForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTodayBlackoutForeground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTodayBlackoutForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedHoverForeground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedHoverForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedHoverForeground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedHoverForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedPressedForeground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedPressedForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedPressedForeground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedPressedForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedDisabledForeground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedDisabledForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedDisabledForeground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedDisabledForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OutOfScopeHoverForeground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OutOfScopeHoverForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutOfScopeHoverForeground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOutOfScopeHoverForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OutOfScopePressedForeground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OutOfScopePressedForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutOfScopePressedForeground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOutOfScopePressedForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisabledForeground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisabledForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisabledForeground<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDisabledForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayItemMargin<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayItemMargin() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayItemMargin<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDayItemMargin(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MonthYearItemMargin<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthYearItemMargin() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthYearItemMargin<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMonthYearItemMargin(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfMonthLabelMargin<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelMargin() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfMonthLabelMargin<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFirstOfMonthLabelMargin(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelMargin<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelMargin() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFirstOfYearDecadeLabelMargin<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFirstOfYearDecadeLabelMargin(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarItemCornerRadius<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarItemCornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarItemCornerRadius<Impl: ICalendarView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCalendarItemCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ICalendarView2>,
            base.5,
            SelectedDisabledBorderBrush::<Impl, OFFSET>,
            SetSelectedDisabledBorderBrush::<Impl, OFFSET>,
            TodaySelectedInnerBorderBrush::<Impl, OFFSET>,
            SetTodaySelectedInnerBorderBrush::<Impl, OFFSET>,
            BlackoutStrikethroughBrush::<Impl, OFFSET>,
            SetBlackoutStrikethroughBrush::<Impl, OFFSET>,
            BlackoutBackground::<Impl, OFFSET>,
            SetBlackoutBackground::<Impl, OFFSET>,
            CalendarItemHoverBackground::<Impl, OFFSET>,
            SetCalendarItemHoverBackground::<Impl, OFFSET>,
            CalendarItemPressedBackground::<Impl, OFFSET>,
            SetCalendarItemPressedBackground::<Impl, OFFSET>,
            CalendarItemDisabledBackground::<Impl, OFFSET>,
            SetCalendarItemDisabledBackground::<Impl, OFFSET>,
            TodayBackground::<Impl, OFFSET>,
            SetTodayBackground::<Impl, OFFSET>,
            TodayBlackoutBackground::<Impl, OFFSET>,
            SetTodayBlackoutBackground::<Impl, OFFSET>,
            TodayHoverBackground::<Impl, OFFSET>,
            SetTodayHoverBackground::<Impl, OFFSET>,
            TodayPressedBackground::<Impl, OFFSET>,
            SetTodayPressedBackground::<Impl, OFFSET>,
            TodayDisabledBackground::<Impl, OFFSET>,
            SetTodayDisabledBackground::<Impl, OFFSET>,
            TodayBlackoutForeground::<Impl, OFFSET>,
            SetTodayBlackoutForeground::<Impl, OFFSET>,
            SelectedHoverForeground::<Impl, OFFSET>,
            SetSelectedHoverForeground::<Impl, OFFSET>,
            SelectedPressedForeground::<Impl, OFFSET>,
            SetSelectedPressedForeground::<Impl, OFFSET>,
            SelectedDisabledForeground::<Impl, OFFSET>,
            SetSelectedDisabledForeground::<Impl, OFFSET>,
            OutOfScopeHoverForeground::<Impl, OFFSET>,
            SetOutOfScopeHoverForeground::<Impl, OFFSET>,
            OutOfScopePressedForeground::<Impl, OFFSET>,
            SetOutOfScopePressedForeground::<Impl, OFFSET>,
            DisabledForeground::<Impl, OFFSET>,
            SetDisabledForeground::<Impl, OFFSET>,
            DayItemMargin::<Impl, OFFSET>,
            SetDayItemMargin::<Impl, OFFSET>,
            MonthYearItemMargin::<Impl, OFFSET>,
            SetMonthYearItemMargin::<Impl, OFFSET>,
            FirstOfMonthLabelMargin::<Impl, OFFSET>,
            SetFirstOfMonthLabelMargin::<Impl, OFFSET>,
            FirstOfYearDecadeLabelMargin::<Impl, OFFSET>,
            SetFirstOfYearDecadeLabelMargin::<Impl, OFFSET>,
            CalendarItemCornerRadius::<Impl, OFFSET>,
            SetCalendarItemCornerRadius::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewDayItemImpl: Sized {
    fn IsBlackout(&self) -> ::windows::core::Result<bool>;
    fn SetIsBlackout(&self, value: bool) -> ::windows::core::Result<()>;
    fn Date(&self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetDensityColors(&self, colors: &::core::option::Option<super::super::super::Foundation::Collections::IIterable<super::super::Color>>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewDayItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewDayItem";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewDayItemVtbl {
    pub const fn new<Impl: ICalendarViewDayItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarViewDayItemVtbl {
        unsafe extern "system" fn IsBlackout<Impl: ICalendarViewDayItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsBlackout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsBlackout<Impl: ICalendarViewDayItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsBlackout(value).into()
        }
        unsafe extern "system" fn Date<Impl: ICalendarViewDayItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Date() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDensityColors<Impl: ICalendarViewDayItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, colors: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDensityColors(&*(&colors as *const <super::super::super::Foundation::Collections::IIterable<super::super::Color> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IIterable<super::super::Color> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICalendarViewDayItem>, base.5, IsBlackout::<Impl, OFFSET>, SetIsBlackout::<Impl, OFFSET>, Date::<Impl, OFFSET>, SetDensityColors::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewDayItemChangingEventArgsImpl: Sized {
    fn InRecycleQueue(&self) -> ::windows::core::Result<bool>;
    fn Item(&self) -> ::windows::core::Result<CalendarViewDayItem>;
    fn Phase(&self) -> ::windows::core::Result<u32>;
    fn RegisterUpdateCallback(&self, callback: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs>>) -> ::windows::core::Result<()>;
    fn RegisterUpdateCallbackWithPhase(&self, callbackphase: u32, callback: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs>>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewDayItemChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewDayItemChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewDayItemChangingEventArgsVtbl {
    pub const fn new<Impl: ICalendarViewDayItemChangingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarViewDayItemChangingEventArgsVtbl {
        unsafe extern "system" fn InRecycleQueue<Impl: ICalendarViewDayItemChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InRecycleQueue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: ICalendarViewDayItemChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Phase<Impl: ICalendarViewDayItemChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Phase() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterUpdateCallback<Impl: ICalendarViewDayItemChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, callback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RegisterUpdateCallback(&*(&callback as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RegisterUpdateCallbackWithPhase<Impl: ICalendarViewDayItemChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, callbackphase: u32, callback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RegisterUpdateCallbackWithPhase(callbackphase, &*(&callback as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CalendarView, CalendarViewDayItemChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICalendarViewDayItemChangingEventArgs>, base.5, InRecycleQueue::<Impl, OFFSET>, Item::<Impl, OFFSET>, Phase::<Impl, OFFSET>, RegisterUpdateCallback::<Impl, OFFSET>, RegisterUpdateCallbackWithPhase::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewDayItemFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CalendarViewDayItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewDayItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewDayItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewDayItemFactoryVtbl {
    pub const fn new<Impl: ICalendarViewDayItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarViewDayItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICalendarViewDayItemFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICalendarViewDayItemFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewDayItemStaticsImpl: Sized {
    fn IsBlackoutProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewDayItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewDayItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewDayItemStaticsVtbl {
    pub const fn new<Impl: ICalendarViewDayItemStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarViewDayItemStaticsVtbl {
        unsafe extern "system" fn IsBlackoutProperty<Impl: ICalendarViewDayItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsBlackoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DateProperty<Impl: ICalendarViewDayItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICalendarViewDayItemStatics>, base.5, IsBlackoutProperty::<Impl, OFFSET>, DateProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CalendarView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewFactoryVtbl {
    pub const fn new<Impl: ICalendarViewFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICalendarViewFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICalendarViewFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewSelectedDatesChangedEventArgsImpl: Sized {
    fn AddedDates(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<super::super::super::Foundation::DateTime>>;
    fn RemovedDates(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<super::super::super::Foundation::DateTime>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewSelectedDatesChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewSelectedDatesChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewSelectedDatesChangedEventArgsVtbl {
    pub const fn new<Impl: ICalendarViewSelectedDatesChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarViewSelectedDatesChangedEventArgsVtbl {
        unsafe extern "system" fn AddedDates<Impl: ICalendarViewSelectedDatesChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddedDates() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovedDates<Impl: ICalendarViewSelectedDatesChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemovedDates() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICalendarViewSelectedDatesChangedEventArgs>, base.5, AddedDates::<Impl, OFFSET>, RemovedDates::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewStaticsImpl: Sized {
    fn CalendarIdentifierProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayOfWeekFormatProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsGroupLabelVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstDayOfWeekProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsOutOfScopeEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTodayHighlightedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxDateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinDateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn NumberOfWeeksInViewProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedDatesProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TemplateSettingsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FocusBorderBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedHoverBorderBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedPressedBorderBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedBorderBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HoverBorderBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PressedBorderBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemBorderBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OutOfScopeBackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemBackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PressedForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BlackoutForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OutOfScopeForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayItemFontFamilyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayItemFontSizeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayItemFontStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayItemFontWeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayFontWeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfMonthLabelFontFamilyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfMonthLabelFontSizeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfMonthLabelFontStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfMonthLabelFontWeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthYearItemFontFamilyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthYearItemFontSizeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthYearItemFontStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthYearItemFontWeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfYearDecadeLabelFontFamilyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfYearDecadeLabelFontSizeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfYearDecadeLabelFontStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfYearDecadeLabelFontWeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalDayItemAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalDayItemAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalFirstOfMonthLabelAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalFirstOfMonthLabelAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemBorderThicknessProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarViewDayItemStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewStaticsVtbl {
    pub const fn new<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarViewStaticsVtbl {
        unsafe extern "system" fn CalendarIdentifierProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayOfWeekFormatProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayOfWeekFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsGroupLabelVisibleProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsGroupLabelVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayModeProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstDayOfWeekProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstDayOfWeekProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsOutOfScopeEnabledProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsOutOfScopeEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTodayHighlightedProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTodayHighlightedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxDateProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxDateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinDateProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinDateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NumberOfWeeksInViewProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NumberOfWeeksInViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedDatesProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedDatesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionModeProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TemplateSettingsProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettingsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FocusBorderBrushProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FocusBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedHoverBorderBrushProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedHoverBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedPressedBorderBrushProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedPressedBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedBorderBrushProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HoverBorderBrushProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HoverBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PressedBorderBrushProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PressedBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemBorderBrushProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarItemBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OutOfScopeBackgroundProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OutOfScopeBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemBackgroundProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarItemBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PressedForegroundProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PressedForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayForegroundProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodayForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BlackoutForegroundProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BlackoutForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedForegroundProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OutOfScopeForegroundProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OutOfScopeForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemForegroundProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarItemForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayItemFontFamilyProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayItemFontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayItemFontSizeProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayItemFontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayItemFontStyleProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayItemFontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayItemFontWeightProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayItemFontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayFontWeightProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodayFontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfMonthLabelFontFamilyProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfMonthLabelFontSizeProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfMonthLabelFontStyleProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfMonthLabelFontWeightProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelFontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthYearItemFontFamilyProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthYearItemFontSizeProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthYearItemFontStyleProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthYearItemFontWeightProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthYearItemFontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontFamilyProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontSizeProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontStyleProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelFontWeightProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelFontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalDayItemAlignmentProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalDayItemAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalDayItemAlignmentProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalDayItemAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalFirstOfMonthLabelAlignmentProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalFirstOfMonthLabelAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalFirstOfMonthLabelAlignmentProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalFirstOfMonthLabelAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemBorderThicknessProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarItemBorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarViewDayItemStyleProperty<Impl: ICalendarViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarViewDayItemStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ICalendarViewStatics>,
            base.5,
            CalendarIdentifierProperty::<Impl, OFFSET>,
            DayOfWeekFormatProperty::<Impl, OFFSET>,
            IsGroupLabelVisibleProperty::<Impl, OFFSET>,
            DisplayModeProperty::<Impl, OFFSET>,
            FirstDayOfWeekProperty::<Impl, OFFSET>,
            IsOutOfScopeEnabledProperty::<Impl, OFFSET>,
            IsTodayHighlightedProperty::<Impl, OFFSET>,
            MaxDateProperty::<Impl, OFFSET>,
            MinDateProperty::<Impl, OFFSET>,
            NumberOfWeeksInViewProperty::<Impl, OFFSET>,
            SelectedDatesProperty::<Impl, OFFSET>,
            SelectionModeProperty::<Impl, OFFSET>,
            TemplateSettingsProperty::<Impl, OFFSET>,
            FocusBorderBrushProperty::<Impl, OFFSET>,
            SelectedHoverBorderBrushProperty::<Impl, OFFSET>,
            SelectedPressedBorderBrushProperty::<Impl, OFFSET>,
            SelectedBorderBrushProperty::<Impl, OFFSET>,
            HoverBorderBrushProperty::<Impl, OFFSET>,
            PressedBorderBrushProperty::<Impl, OFFSET>,
            CalendarItemBorderBrushProperty::<Impl, OFFSET>,
            OutOfScopeBackgroundProperty::<Impl, OFFSET>,
            CalendarItemBackgroundProperty::<Impl, OFFSET>,
            PressedForegroundProperty::<Impl, OFFSET>,
            TodayForegroundProperty::<Impl, OFFSET>,
            BlackoutForegroundProperty::<Impl, OFFSET>,
            SelectedForegroundProperty::<Impl, OFFSET>,
            OutOfScopeForegroundProperty::<Impl, OFFSET>,
            CalendarItemForegroundProperty::<Impl, OFFSET>,
            DayItemFontFamilyProperty::<Impl, OFFSET>,
            DayItemFontSizeProperty::<Impl, OFFSET>,
            DayItemFontStyleProperty::<Impl, OFFSET>,
            DayItemFontWeightProperty::<Impl, OFFSET>,
            TodayFontWeightProperty::<Impl, OFFSET>,
            FirstOfMonthLabelFontFamilyProperty::<Impl, OFFSET>,
            FirstOfMonthLabelFontSizeProperty::<Impl, OFFSET>,
            FirstOfMonthLabelFontStyleProperty::<Impl, OFFSET>,
            FirstOfMonthLabelFontWeightProperty::<Impl, OFFSET>,
            MonthYearItemFontFamilyProperty::<Impl, OFFSET>,
            MonthYearItemFontSizeProperty::<Impl, OFFSET>,
            MonthYearItemFontStyleProperty::<Impl, OFFSET>,
            MonthYearItemFontWeightProperty::<Impl, OFFSET>,
            FirstOfYearDecadeLabelFontFamilyProperty::<Impl, OFFSET>,
            FirstOfYearDecadeLabelFontSizeProperty::<Impl, OFFSET>,
            FirstOfYearDecadeLabelFontStyleProperty::<Impl, OFFSET>,
            FirstOfYearDecadeLabelFontWeightProperty::<Impl, OFFSET>,
            HorizontalDayItemAlignmentProperty::<Impl, OFFSET>,
            VerticalDayItemAlignmentProperty::<Impl, OFFSET>,
            HorizontalFirstOfMonthLabelAlignmentProperty::<Impl, OFFSET>,
            VerticalFirstOfMonthLabelAlignmentProperty::<Impl, OFFSET>,
            CalendarItemBorderThicknessProperty::<Impl, OFFSET>,
            CalendarViewDayItemStyleProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICalendarViewStatics2Impl: Sized {
    fn SelectedDisabledBorderBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodaySelectedInnerBorderBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BlackoutStrikethroughBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BlackoutBackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemHoverBackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemPressedBackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemDisabledBackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayBackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayBlackoutBackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayHoverBackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayPressedBackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayDisabledBackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TodayBlackoutForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedHoverForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedPressedForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedDisabledForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OutOfScopeHoverForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OutOfScopePressedForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisabledForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayItemMarginProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthYearItemMarginProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfMonthLabelMarginProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FirstOfYearDecadeLabelMarginProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarItemCornerRadiusProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICalendarViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICalendarViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ICalendarViewStatics2Vtbl {
    pub const fn new<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICalendarViewStatics2Vtbl {
        unsafe extern "system" fn SelectedDisabledBorderBrushProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedDisabledBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodaySelectedInnerBorderBrushProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodaySelectedInnerBorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BlackoutStrikethroughBrushProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BlackoutStrikethroughBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BlackoutBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BlackoutBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemHoverBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarItemHoverBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemPressedBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarItemPressedBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemDisabledBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarItemDisabledBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodayBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayBlackoutBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodayBlackoutBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayHoverBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodayHoverBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayPressedBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodayPressedBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayDisabledBackgroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodayDisabledBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TodayBlackoutForegroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TodayBlackoutForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedHoverForegroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedHoverForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedPressedForegroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedPressedForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedDisabledForegroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedDisabledForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OutOfScopeHoverForegroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OutOfScopeHoverForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OutOfScopePressedForegroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OutOfScopePressedForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisabledForegroundProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisabledForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayItemMarginProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayItemMarginProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthYearItemMarginProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthYearItemMarginProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfMonthLabelMarginProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfMonthLabelMarginProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstOfYearDecadeLabelMarginProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstOfYearDecadeLabelMarginProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarItemCornerRadiusProperty<Impl: ICalendarViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarItemCornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ICalendarViewStatics2>,
            base.5,
            SelectedDisabledBorderBrushProperty::<Impl, OFFSET>,
            TodaySelectedInnerBorderBrushProperty::<Impl, OFFSET>,
            BlackoutStrikethroughBrushProperty::<Impl, OFFSET>,
            BlackoutBackgroundProperty::<Impl, OFFSET>,
            CalendarItemHoverBackgroundProperty::<Impl, OFFSET>,
            CalendarItemPressedBackgroundProperty::<Impl, OFFSET>,
            CalendarItemDisabledBackgroundProperty::<Impl, OFFSET>,
            TodayBackgroundProperty::<Impl, OFFSET>,
            TodayBlackoutBackgroundProperty::<Impl, OFFSET>,
            TodayHoverBackgroundProperty::<Impl, OFFSET>,
            TodayPressedBackgroundProperty::<Impl, OFFSET>,
            TodayDisabledBackgroundProperty::<Impl, OFFSET>,
            TodayBlackoutForegroundProperty::<Impl, OFFSET>,
            SelectedHoverForegroundProperty::<Impl, OFFSET>,
            SelectedPressedForegroundProperty::<Impl, OFFSET>,
            SelectedDisabledForegroundProperty::<Impl, OFFSET>,
            OutOfScopeHoverForegroundProperty::<Impl, OFFSET>,
            OutOfScopePressedForegroundProperty::<Impl, OFFSET>,
            DisabledForegroundProperty::<Impl, OFFSET>,
            DayItemMarginProperty::<Impl, OFFSET>,
            MonthYearItemMarginProperty::<Impl, OFFSET>,
            FirstOfMonthLabelMarginProperty::<Impl, OFFSET>,
            FirstOfYearDecadeLabelMarginProperty::<Impl, OFFSET>,
            CalendarItemCornerRadiusProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICandidateWindowBoundsChangedEventArgsImpl: Sized {
    fn Bounds(&self) -> ::windows::core::Result<super::super::super::Foundation::Rect>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICandidateWindowBoundsChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICandidateWindowBoundsChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ICandidateWindowBoundsChangedEventArgsVtbl {
    pub const fn new<Impl: ICandidateWindowBoundsChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICandidateWindowBoundsChangedEventArgsVtbl {
        unsafe extern "system" fn Bounds<Impl: ICandidateWindowBoundsChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::Rect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Bounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICandidateWindowBoundsChangedEventArgs>, base.5, Bounds::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICanvasImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICanvas {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICanvas";
}
#[cfg(feature = "implement_exclusive")]
impl ICanvasVtbl {
    pub const fn new<Impl: ICanvasImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICanvasVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICanvas>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICanvasFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Canvas>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICanvasFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICanvasFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICanvasFactoryVtbl {
    pub const fn new<Impl: ICanvasFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICanvasFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICanvasFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICanvasFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICanvasStaticsImpl: Sized {
    fn LeftProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetLeft(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<f64>;
    fn SetLeft(&self, element: &::core::option::Option<super::UIElement>, length: f64) -> ::windows::core::Result<()>;
    fn TopProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetTop(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<f64>;
    fn SetTop(&self, element: &::core::option::Option<super::UIElement>, length: f64) -> ::windows::core::Result<()>;
    fn ZIndexProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetZIndex(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<i32>;
    fn SetZIndex(&self, element: &::core::option::Option<super::UIElement>, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICanvasStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICanvasStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICanvasStaticsVtbl {
    pub const fn new<Impl: ICanvasStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICanvasStaticsVtbl {
        unsafe extern "system" fn LeftProperty<Impl: ICanvasStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LeftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLeft<Impl: ICanvasStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLeft(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeft<Impl: ICanvasStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, length: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLeft(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), length).into()
        }
        unsafe extern "system" fn TopProperty<Impl: ICanvasStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TopProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTop<Impl: ICanvasStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTop(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTop<Impl: ICanvasStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, length: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTop(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), length).into()
        }
        unsafe extern "system" fn ZIndexProperty<Impl: ICanvasStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ZIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetZIndex<Impl: ICanvasStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetZIndex(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZIndex<Impl: ICanvasStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetZIndex(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICanvasStatics>, base.5, LeftProperty::<Impl, OFFSET>, GetLeft::<Impl, OFFSET>, SetLeft::<Impl, OFFSET>, TopProperty::<Impl, OFFSET>, GetTop::<Impl, OFFSET>, SetTop::<Impl, OFFSET>, ZIndexProperty::<Impl, OFFSET>, GetZIndex::<Impl, OFFSET>, SetZIndex::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICaptureElementImpl: Sized {
    fn Source(&self) -> ::windows::core::Result<super::super::super::Media::Capture::MediaCapture>;
    fn SetSource(&self, value: &::core::option::Option<super::super::super::Media::Capture::MediaCapture>) -> ::windows::core::Result<()>;
    fn Stretch(&self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICaptureElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICaptureElement";
}
#[cfg(feature = "implement_exclusive")]
impl ICaptureElementVtbl {
    pub const fn new<Impl: ICaptureElementImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICaptureElementVtbl {
        unsafe extern "system" fn Source<Impl: ICaptureElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: ICaptureElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::super::super::Media::Capture::MediaCapture as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Capture::MediaCapture as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stretch<Impl: ICaptureElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: ICaptureElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICaptureElement>, base.5, Source::<Impl, OFFSET>, SetSource::<Impl, OFFSET>, Stretch::<Impl, OFFSET>, SetStretch::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICaptureElementStaticsImpl: Sized {
    fn SourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICaptureElementStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICaptureElementStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICaptureElementStaticsVtbl {
    pub const fn new<Impl: ICaptureElementStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICaptureElementStaticsVtbl {
        unsafe extern "system" fn SourceProperty<Impl: ICaptureElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchProperty<Impl: ICaptureElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICaptureElementStatics>, base.5, SourceProperty::<Impl, OFFSET>, StretchProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICheckBoxImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICheckBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICheckBox";
}
#[cfg(feature = "implement_exclusive")]
impl ICheckBoxVtbl {
    pub const fn new<Impl: ICheckBoxImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICheckBoxVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICheckBox>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICheckBoxFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CheckBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICheckBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICheckBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICheckBoxFactoryVtbl {
    pub const fn new<Impl: ICheckBoxFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICheckBoxFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICheckBoxFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICheckBoxFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IChoosingGroupHeaderContainerEventArgsImpl: Sized {
    fn GroupHeaderContainer(&self) -> ::windows::core::Result<ListViewBaseHeaderItem>;
    fn SetGroupHeaderContainer(&self, value: &::core::option::Option<ListViewBaseHeaderItem>) -> ::windows::core::Result<()>;
    fn GroupIndex(&self) -> ::windows::core::Result<i32>;
    fn Group(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IChoosingGroupHeaderContainerEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IChoosingGroupHeaderContainerEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IChoosingGroupHeaderContainerEventArgsVtbl {
    pub const fn new<Impl: IChoosingGroupHeaderContainerEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IChoosingGroupHeaderContainerEventArgsVtbl {
        unsafe extern "system" fn GroupHeaderContainer<Impl: IChoosingGroupHeaderContainerEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GroupHeaderContainer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupHeaderContainer<Impl: IChoosingGroupHeaderContainerEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetGroupHeaderContainer(&*(&value as *const <ListViewBaseHeaderItem as ::windows::core::Abi>::Abi as *const <ListViewBaseHeaderItem as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GroupIndex<Impl: IChoosingGroupHeaderContainerEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GroupIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Group<Impl: IChoosingGroupHeaderContainerEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Group() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IChoosingGroupHeaderContainerEventArgs>, base.5, GroupHeaderContainer::<Impl, OFFSET>, SetGroupHeaderContainer::<Impl, OFFSET>, GroupIndex::<Impl, OFFSET>, Group::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IChoosingItemContainerEventArgsImpl: Sized {
    fn ItemIndex(&self) -> ::windows::core::Result<i32>;
    fn Item(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn ItemContainer(&self) -> ::windows::core::Result<Primitives::SelectorItem>;
    fn SetItemContainer(&self, value: &::core::option::Option<Primitives::SelectorItem>) -> ::windows::core::Result<()>;
    fn IsContainerPrepared(&self) -> ::windows::core::Result<bool>;
    fn SetIsContainerPrepared(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IChoosingItemContainerEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IChoosingItemContainerEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IChoosingItemContainerEventArgsVtbl {
    pub const fn new<Impl: IChoosingItemContainerEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IChoosingItemContainerEventArgsVtbl {
        unsafe extern "system" fn ItemIndex<Impl: IChoosingItemContainerEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IChoosingItemContainerEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainer<Impl: IChoosingItemContainerEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemContainer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainer<Impl: IChoosingItemContainerEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemContainer(&*(&value as *const <Primitives::SelectorItem as ::windows::core::Abi>::Abi as *const <Primitives::SelectorItem as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsContainerPrepared<Impl: IChoosingItemContainerEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsContainerPrepared() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsContainerPrepared<Impl: IChoosingItemContainerEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsContainerPrepared(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IChoosingItemContainerEventArgs>, base.5, ItemIndex::<Impl, OFFSET>, Item::<Impl, OFFSET>, ItemContainer::<Impl, OFFSET>, SetItemContainer::<Impl, OFFSET>, IsContainerPrepared::<Impl, OFFSET>, SetIsContainerPrepared::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICleanUpVirtualizedItemEventArgsImpl: Sized {
    fn Value(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn UIElement(&self) -> ::windows::core::Result<super::UIElement>;
    fn Cancel(&self) -> ::windows::core::Result<bool>;
    fn SetCancel(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICleanUpVirtualizedItemEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICleanUpVirtualizedItemEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ICleanUpVirtualizedItemEventArgsVtbl {
    pub const fn new<Impl: ICleanUpVirtualizedItemEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICleanUpVirtualizedItemEventArgsVtbl {
        unsafe extern "system" fn Value<Impl: ICleanUpVirtualizedItemEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Value() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UIElement<Impl: ICleanUpVirtualizedItemEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UIElement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: ICleanUpVirtualizedItemEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: ICleanUpVirtualizedItemEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICleanUpVirtualizedItemEventArgs>, base.5, Value::<Impl, OFFSET>, UIElement::<Impl, OFFSET>, Cancel::<Impl, OFFSET>, SetCancel::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IColorChangedEventArgsImpl: Sized {
    fn OldColor(&self) -> ::windows::core::Result<super::super::Color>;
    fn NewColor(&self) -> ::windows::core::Result<super::super::Color>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IColorChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColorChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IColorChangedEventArgsVtbl {
    pub const fn new<Impl: IColorChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IColorChangedEventArgsVtbl {
        unsafe extern "system" fn OldColor<Impl: IColorChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OldColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewColor<Impl: IColorChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NewColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IColorChangedEventArgs>, base.5, OldColor::<Impl, OFFSET>, NewColor::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IColorPickerImpl: Sized {
    fn Color(&self) -> ::windows::core::Result<super::super::Color>;
    fn SetColor(&self, value: &super::super::Color) -> ::windows::core::Result<()>;
    fn PreviousColor(&self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::Color>>;
    fn SetPreviousColor(&self, value: &::core::option::Option<super::super::super::Foundation::IReference<super::super::Color>>) -> ::windows::core::Result<()>;
    fn IsAlphaEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsAlphaEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorSpectrumVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsColorSpectrumVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorPreviewVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsColorPreviewVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorSliderVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsColorSliderVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsAlphaSliderVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsAlphaSliderVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsMoreButtonVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsMoreButtonVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorChannelTextInputVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsColorChannelTextInputVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsAlphaTextInputVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsAlphaTextInputVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsHexInputVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsHexInputVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn MinHue(&self) -> ::windows::core::Result<i32>;
    fn SetMinHue(&self, value: i32) -> ::windows::core::Result<()>;
    fn MaxHue(&self) -> ::windows::core::Result<i32>;
    fn SetMaxHue(&self, value: i32) -> ::windows::core::Result<()>;
    fn MinSaturation(&self) -> ::windows::core::Result<i32>;
    fn SetMinSaturation(&self, value: i32) -> ::windows::core::Result<()>;
    fn MaxSaturation(&self) -> ::windows::core::Result<i32>;
    fn SetMaxSaturation(&self, value: i32) -> ::windows::core::Result<()>;
    fn MinValue(&self) -> ::windows::core::Result<i32>;
    fn SetMinValue(&self, value: i32) -> ::windows::core::Result<()>;
    fn MaxValue(&self) -> ::windows::core::Result<i32>;
    fn SetMaxValue(&self, value: i32) -> ::windows::core::Result<()>;
    fn ColorSpectrumShape(&self) -> ::windows::core::Result<ColorSpectrumShape>;
    fn SetColorSpectrumShape(&self, value: ColorSpectrumShape) -> ::windows::core::Result<()>;
    fn ColorSpectrumComponents(&self) -> ::windows::core::Result<ColorSpectrumComponents>;
    fn SetColorSpectrumComponents(&self, value: ColorSpectrumComponents) -> ::windows::core::Result<()>;
    fn ColorChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ColorPicker, ColorChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveColorChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IColorPicker {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColorPicker";
}
#[cfg(feature = "implement_exclusive")]
impl IColorPickerVtbl {
    pub const fn new<Impl: IColorPickerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IColorPickerVtbl {
        unsafe extern "system" fn Color<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Color() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColor<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetColor(&*(&value as *const <super::super::Color as ::windows::core::Abi>::Abi as *const <super::super::Color as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PreviousColor<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PreviousColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreviousColor<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPreviousColor(&*(&value as *const <super::super::super::Foundation::IReference<super::super::Color> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<super::super::Color> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsAlphaEnabled<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsAlphaEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsAlphaEnabled<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsAlphaEnabled(value).into()
        }
        unsafe extern "system" fn IsColorSpectrumVisible<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsColorSpectrumVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorSpectrumVisible<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsColorSpectrumVisible(value).into()
        }
        unsafe extern "system" fn IsColorPreviewVisible<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsColorPreviewVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorPreviewVisible<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsColorPreviewVisible(value).into()
        }
        unsafe extern "system" fn IsColorSliderVisible<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsColorSliderVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorSliderVisible<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsColorSliderVisible(value).into()
        }
        unsafe extern "system" fn IsAlphaSliderVisible<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsAlphaSliderVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsAlphaSliderVisible<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsAlphaSliderVisible(value).into()
        }
        unsafe extern "system" fn IsMoreButtonVisible<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsMoreButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsMoreButtonVisible<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsMoreButtonVisible(value).into()
        }
        unsafe extern "system" fn IsColorChannelTextInputVisible<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsColorChannelTextInputVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorChannelTextInputVisible<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsColorChannelTextInputVisible(value).into()
        }
        unsafe extern "system" fn IsAlphaTextInputVisible<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsAlphaTextInputVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsAlphaTextInputVisible<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsAlphaTextInputVisible(value).into()
        }
        unsafe extern "system" fn IsHexInputVisible<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsHexInputVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHexInputVisible<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsHexInputVisible(value).into()
        }
        unsafe extern "system" fn MinHue<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinHue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinHue<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMinHue(value).into()
        }
        unsafe extern "system" fn MaxHue<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxHue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxHue<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxHue(value).into()
        }
        unsafe extern "system" fn MinSaturation<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinSaturation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinSaturation<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMinSaturation(value).into()
        }
        unsafe extern "system" fn MaxSaturation<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxSaturation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxSaturation<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxSaturation(value).into()
        }
        unsafe extern "system" fn MinValue<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinValue<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMinValue(value).into()
        }
        unsafe extern "system" fn MaxValue<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxValue<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxValue(value).into()
        }
        unsafe extern "system" fn ColorSpectrumShape<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ColorSpectrumShape) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ColorSpectrumShape() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColorSpectrumShape<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ColorSpectrumShape) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetColorSpectrumShape(value).into()
        }
        unsafe extern "system" fn ColorSpectrumComponents<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ColorSpectrumComponents) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ColorSpectrumComponents() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColorSpectrumComponents<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ColorSpectrumComponents) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetColorSpectrumComponents(value).into()
        }
        unsafe extern "system" fn ColorChanged<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ColorChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ColorPicker, ColorChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ColorPicker, ColorChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveColorChanged<Impl: IColorPickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveColorChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IColorPicker>,
            base.5,
            Color::<Impl, OFFSET>,
            SetColor::<Impl, OFFSET>,
            PreviousColor::<Impl, OFFSET>,
            SetPreviousColor::<Impl, OFFSET>,
            IsAlphaEnabled::<Impl, OFFSET>,
            SetIsAlphaEnabled::<Impl, OFFSET>,
            IsColorSpectrumVisible::<Impl, OFFSET>,
            SetIsColorSpectrumVisible::<Impl, OFFSET>,
            IsColorPreviewVisible::<Impl, OFFSET>,
            SetIsColorPreviewVisible::<Impl, OFFSET>,
            IsColorSliderVisible::<Impl, OFFSET>,
            SetIsColorSliderVisible::<Impl, OFFSET>,
            IsAlphaSliderVisible::<Impl, OFFSET>,
            SetIsAlphaSliderVisible::<Impl, OFFSET>,
            IsMoreButtonVisible::<Impl, OFFSET>,
            SetIsMoreButtonVisible::<Impl, OFFSET>,
            IsColorChannelTextInputVisible::<Impl, OFFSET>,
            SetIsColorChannelTextInputVisible::<Impl, OFFSET>,
            IsAlphaTextInputVisible::<Impl, OFFSET>,
            SetIsAlphaTextInputVisible::<Impl, OFFSET>,
            IsHexInputVisible::<Impl, OFFSET>,
            SetIsHexInputVisible::<Impl, OFFSET>,
            MinHue::<Impl, OFFSET>,
            SetMinHue::<Impl, OFFSET>,
            MaxHue::<Impl, OFFSET>,
            SetMaxHue::<Impl, OFFSET>,
            MinSaturation::<Impl, OFFSET>,
            SetMinSaturation::<Impl, OFFSET>,
            MaxSaturation::<Impl, OFFSET>,
            SetMaxSaturation::<Impl, OFFSET>,
            MinValue::<Impl, OFFSET>,
            SetMinValue::<Impl, OFFSET>,
            MaxValue::<Impl, OFFSET>,
            SetMaxValue::<Impl, OFFSET>,
            ColorSpectrumShape::<Impl, OFFSET>,
            SetColorSpectrumShape::<Impl, OFFSET>,
            ColorSpectrumComponents::<Impl, OFFSET>,
            SetColorSpectrumComponents::<Impl, OFFSET>,
            ColorChanged::<Impl, OFFSET>,
            RemoveColorChanged::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IColorPickerFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ColorPicker>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IColorPickerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColorPickerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IColorPickerFactoryVtbl {
    pub const fn new<Impl: IColorPickerFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IColorPickerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IColorPickerFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IColorPickerFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IColorPickerStaticsImpl: Sized {
    fn ColorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PreviousColorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsAlphaEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorSpectrumVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorPreviewVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorSliderVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsAlphaSliderVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsMoreButtonVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorChannelTextInputVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsAlphaTextInputVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHexInputVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinHueProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxHueProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinSaturationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxSaturationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinValueProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxValueProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ColorSpectrumShapeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ColorSpectrumComponentsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IColorPickerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColorPickerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IColorPickerStaticsVtbl {
    pub const fn new<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IColorPickerStaticsVtbl {
        unsafe extern "system" fn ColorProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreviousColorProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PreviousColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsAlphaEnabledProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsAlphaEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorSpectrumVisibleProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsColorSpectrumVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorPreviewVisibleProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsColorPreviewVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorSliderVisibleProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsColorSliderVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsAlphaSliderVisibleProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsAlphaSliderVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsMoreButtonVisibleProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsMoreButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorChannelTextInputVisibleProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsColorChannelTextInputVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsAlphaTextInputVisibleProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsAlphaTextInputVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHexInputVisibleProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsHexInputVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinHueProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinHueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxHueProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxHueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinSaturationProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinSaturationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxSaturationProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxSaturationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinValueProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxValueProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ColorSpectrumShapeProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ColorSpectrumShapeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ColorSpectrumComponentsProperty<Impl: IColorPickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ColorSpectrumComponentsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IColorPickerStatics>,
            base.5,
            ColorProperty::<Impl, OFFSET>,
            PreviousColorProperty::<Impl, OFFSET>,
            IsAlphaEnabledProperty::<Impl, OFFSET>,
            IsColorSpectrumVisibleProperty::<Impl, OFFSET>,
            IsColorPreviewVisibleProperty::<Impl, OFFSET>,
            IsColorSliderVisibleProperty::<Impl, OFFSET>,
            IsAlphaSliderVisibleProperty::<Impl, OFFSET>,
            IsMoreButtonVisibleProperty::<Impl, OFFSET>,
            IsColorChannelTextInputVisibleProperty::<Impl, OFFSET>,
            IsAlphaTextInputVisibleProperty::<Impl, OFFSET>,
            IsHexInputVisibleProperty::<Impl, OFFSET>,
            MinHueProperty::<Impl, OFFSET>,
            MaxHueProperty::<Impl, OFFSET>,
            MinSaturationProperty::<Impl, OFFSET>,
            MaxSaturationProperty::<Impl, OFFSET>,
            MinValueProperty::<Impl, OFFSET>,
            MaxValueProperty::<Impl, OFFSET>,
            ColorSpectrumShapeProperty::<Impl, OFFSET>,
            ColorSpectrumComponentsProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IColumnDefinitionImpl: Sized {
    fn Width(&self) -> ::windows::core::Result<super::GridLength>;
    fn SetWidth(&self, value: &super::GridLength) -> ::windows::core::Result<()>;
    fn MaxWidth(&self) -> ::windows::core::Result<f64>;
    fn SetMaxWidth(&self, value: f64) -> ::windows::core::Result<()>;
    fn MinWidth(&self) -> ::windows::core::Result<f64>;
    fn SetMinWidth(&self, value: f64) -> ::windows::core::Result<()>;
    fn ActualWidth(&self) -> ::windows::core::Result<f64>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IColumnDefinition {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColumnDefinition";
}
#[cfg(feature = "implement_exclusive")]
impl IColumnDefinitionVtbl {
    pub const fn new<Impl: IColumnDefinitionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IColumnDefinitionVtbl {
        unsafe extern "system" fn Width<Impl: IColumnDefinitionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Width() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWidth<Impl: IColumnDefinitionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetWidth(&*(&value as *const <super::GridLength as ::windows::core::Abi>::Abi as *const <super::GridLength as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxWidth<Impl: IColumnDefinitionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxWidth<Impl: IColumnDefinitionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxWidth(value).into()
        }
        unsafe extern "system" fn MinWidth<Impl: IColumnDefinitionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinWidth<Impl: IColumnDefinitionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMinWidth(value).into()
        }
        unsafe extern "system" fn ActualWidth<Impl: IColumnDefinitionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ActualWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IColumnDefinition>, base.5, Width::<Impl, OFFSET>, SetWidth::<Impl, OFFSET>, MaxWidth::<Impl, OFFSET>, SetMaxWidth::<Impl, OFFSET>, MinWidth::<Impl, OFFSET>, SetMinWidth::<Impl, OFFSET>, ActualWidth::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IColumnDefinitionStaticsImpl: Sized {
    fn WidthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxWidthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinWidthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IColumnDefinitionStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IColumnDefinitionStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IColumnDefinitionStaticsVtbl {
    pub const fn new<Impl: IColumnDefinitionStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IColumnDefinitionStaticsVtbl {
        unsafe extern "system" fn WidthProperty<Impl: IColumnDefinitionStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxWidthProperty<Impl: IColumnDefinitionStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinWidthProperty<Impl: IColumnDefinitionStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IColumnDefinitionStatics>, base.5, WidthProperty::<Impl, OFFSET>, MaxWidthProperty::<Impl, OFFSET>, MinWidthProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxImpl: Sized {
    fn IsDropDownOpen(&self) -> ::windows::core::Result<bool>;
    fn SetIsDropDownOpen(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsEditable(&self) -> ::windows::core::Result<bool>;
    fn IsSelectionBoxHighlighted(&self) -> ::windows::core::Result<bool>;
    fn MaxDropDownHeight(&self) -> ::windows::core::Result<f64>;
    fn SetMaxDropDownHeight(&self, value: f64) -> ::windows::core::Result<()>;
    fn SelectionBoxItem(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SelectionBoxItemTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn TemplateSettings(&self) -> ::windows::core::Result<Primitives::ComboBoxTemplateSettings>;
    fn DropDownClosed(&self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDropDownClosed(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DropDownOpened(&self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDropDownOpened(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxVtbl {
    pub const fn new<Impl: IComboBoxImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComboBoxVtbl {
        unsafe extern "system" fn IsDropDownOpen<Impl: IComboBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDropDownOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDropDownOpen<Impl: IComboBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsDropDownOpen(value).into()
        }
        unsafe extern "system" fn IsEditable<Impl: IComboBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsEditable() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSelectionBoxHighlighted<Impl: IComboBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSelectionBoxHighlighted() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxDropDownHeight<Impl: IComboBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxDropDownHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxDropDownHeight<Impl: IComboBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxDropDownHeight(value).into()
        }
        unsafe extern "system" fn SelectionBoxItem<Impl: IComboBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionBoxItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionBoxItemTemplate<Impl: IComboBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionBoxItemTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TemplateSettings<Impl: IComboBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DropDownClosed<Impl: IComboBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DropDownClosed(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDropDownClosed<Impl: IComboBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveDropDownClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DropDownOpened<Impl: IComboBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DropDownOpened(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDropDownOpened<Impl: IComboBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveDropDownOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IComboBox>,
            base.5,
            IsDropDownOpen::<Impl, OFFSET>,
            SetIsDropDownOpen::<Impl, OFFSET>,
            IsEditable::<Impl, OFFSET>,
            IsSelectionBoxHighlighted::<Impl, OFFSET>,
            MaxDropDownHeight::<Impl, OFFSET>,
            SetMaxDropDownHeight::<Impl, OFFSET>,
            SelectionBoxItem::<Impl, OFFSET>,
            SelectionBoxItemTemplate::<Impl, OFFSET>,
            TemplateSettings::<Impl, OFFSET>,
            DropDownClosed::<Impl, OFFSET>,
            RemoveDropDownClosed::<Impl, OFFSET>,
            DropDownOpened::<Impl, OFFSET>,
            RemoveDropDownOpened::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBox2Impl: Sized {
    fn Header(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn PlaceholderText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox2";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBox2Vtbl {
    pub const fn new<Impl: IComboBox2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComboBox2Vtbl {
        unsafe extern "system" fn Header<Impl: IComboBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IComboBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IComboBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IComboBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: IComboBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: IComboBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComboBox2>, base.5, Header::<Impl, OFFSET>, SetHeader::<Impl, OFFSET>, HeaderTemplate::<Impl, OFFSET>, SetHeaderTemplate::<Impl, OFFSET>, PlaceholderText::<Impl, OFFSET>, SetPlaceholderText::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBox3Impl: Sized {
    fn LightDismissOverlayMode(&self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
    fn IsTextSearchEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsTextSearchEnabled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBox3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox3";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBox3Vtbl {
    pub const fn new<Impl: IComboBox3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComboBox3Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: IComboBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: IComboBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        unsafe extern "system" fn IsTextSearchEnabled<Impl: IComboBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextSearchEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextSearchEnabled<Impl: IComboBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsTextSearchEnabled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComboBox3>, base.5, LightDismissOverlayMode::<Impl, OFFSET>, SetLightDismissOverlayMode::<Impl, OFFSET>, IsTextSearchEnabled::<Impl, OFFSET>, SetIsTextSearchEnabled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBox4Impl: Sized {
    fn SelectionChangedTrigger(&self) -> ::windows::core::Result<ComboBoxSelectionChangedTrigger>;
    fn SetSelectionChangedTrigger(&self, value: ComboBoxSelectionChangedTrigger) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBox4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox4";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBox4Vtbl {
    pub const fn new<Impl: IComboBox4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComboBox4Vtbl {
        unsafe extern "system" fn SelectionChangedTrigger<Impl: IComboBox4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ComboBoxSelectionChangedTrigger) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionChangedTrigger() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionChangedTrigger<Impl: IComboBox4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ComboBoxSelectionChangedTrigger) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionChangedTrigger(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComboBox4>, base.5, SelectionChangedTrigger::<Impl, OFFSET>, SetSelectionChangedTrigger::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBox5Impl: Sized {
    fn PlaceholderForeground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetPlaceholderForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBox5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox5";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBox5Vtbl {
    pub const fn new<Impl: IComboBox5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComboBox5Vtbl {
        unsafe extern "system" fn PlaceholderForeground<Impl: IComboBox5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderForeground<Impl: IComboBox5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlaceholderForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComboBox5>, base.5, PlaceholderForeground::<Impl, OFFSET>, SetPlaceholderForeground::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBox6Impl: Sized {
    fn SetIsEditable(&self, value: bool) -> ::windows::core::Result<()>;
    fn Text(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn TextBoxStyle(&self) -> ::windows::core::Result<super::Style>;
    fn SetTextBoxStyle(&self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn Description(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn TextSubmitted(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ComboBox, ComboBoxTextSubmittedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextSubmitted(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBox6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBox6";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBox6Vtbl {
    pub const fn new<Impl: IComboBox6Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComboBox6Vtbl {
        unsafe extern "system" fn SetIsEditable<Impl: IComboBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsEditable(value).into()
        }
        unsafe extern "system" fn Text<Impl: IComboBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: IComboBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextBoxStyle<Impl: IComboBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextBoxStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextBoxStyle<Impl: IComboBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextBoxStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Description<Impl: IComboBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: IComboBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextSubmitted<Impl: IComboBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextSubmitted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ComboBox, ComboBoxTextSubmittedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ComboBox, ComboBoxTextSubmittedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextSubmitted<Impl: IComboBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveTextSubmitted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComboBox6>, base.5, SetIsEditable::<Impl, OFFSET>, Text::<Impl, OFFSET>, SetText::<Impl, OFFSET>, TextBoxStyle::<Impl, OFFSET>, SetTextBoxStyle::<Impl, OFFSET>, Description::<Impl, OFFSET>, SetDescription::<Impl, OFFSET>, TextSubmitted::<Impl, OFFSET>, RemoveTextSubmitted::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ComboBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxFactoryVtbl {
    pub const fn new<Impl: IComboBoxFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComboBoxFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IComboBoxFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComboBoxFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxItemImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxItem";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxItemVtbl {
    pub const fn new<Impl: IComboBoxItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComboBoxItemVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComboBoxItem>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxItemFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ComboBoxItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxItemFactoryVtbl {
    pub const fn new<Impl: IComboBoxItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComboBoxItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IComboBoxItemFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComboBoxItemFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxOverridesImpl: Sized {
    fn OnDropDownClosed(&self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnDropDownOpened(&self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxOverridesVtbl {
    pub const fn new<Impl: IComboBoxOverridesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComboBoxOverridesVtbl {
        unsafe extern "system" fn OnDropDownClosed<Impl: IComboBoxOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnDropDownClosed(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDropDownOpened<Impl: IComboBoxOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnDropDownOpened(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComboBoxOverrides>, base.5, OnDropDownClosed::<Impl, OFFSET>, OnDropDownOpened::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStaticsImpl: Sized {
    fn IsDropDownOpenProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxDropDownHeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStaticsVtbl {
    pub const fn new<Impl: IComboBoxStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComboBoxStaticsVtbl {
        unsafe extern "system" fn IsDropDownOpenProperty<Impl: IComboBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDropDownOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxDropDownHeightProperty<Impl: IComboBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxDropDownHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComboBoxStatics>, base.5, IsDropDownOpenProperty::<Impl, OFFSET>, MaxDropDownHeightProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStatics2Impl: Sized {
    fn HeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStatics2Vtbl {
    pub const fn new<Impl: IComboBoxStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComboBoxStatics2Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IComboBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IComboBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: IComboBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComboBoxStatics2>, base.5, HeaderProperty::<Impl, OFFSET>, HeaderTemplateProperty::<Impl, OFFSET>, PlaceholderTextProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStatics3Impl: Sized {
    fn LightDismissOverlayModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextSearchEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStatics3Vtbl {
    pub const fn new<Impl: IComboBoxStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComboBoxStatics3Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: IComboBoxStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextSearchEnabledProperty<Impl: IComboBoxStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextSearchEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComboBoxStatics3>, base.5, LightDismissOverlayModeProperty::<Impl, OFFSET>, IsTextSearchEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStatics4Impl: Sized {
    fn SelectionChangedTriggerProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStatics4Vtbl {
    pub const fn new<Impl: IComboBoxStatics4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComboBoxStatics4Vtbl {
        unsafe extern "system" fn SelectionChangedTriggerProperty<Impl: IComboBoxStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionChangedTriggerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComboBoxStatics4>, base.5, SelectionChangedTriggerProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStatics5Impl: Sized {
    fn PlaceholderForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStatics5Vtbl {
    pub const fn new<Impl: IComboBoxStatics5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComboBoxStatics5Vtbl {
        unsafe extern "system" fn PlaceholderForegroundProperty<Impl: IComboBoxStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComboBoxStatics5>, base.5, PlaceholderForegroundProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxStatics6Impl: Sized {
    fn IsEditableProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextBoxStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DescriptionProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxStatics6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxStatics6";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxStatics6Vtbl {
    pub const fn new<Impl: IComboBoxStatics6Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComboBoxStatics6Vtbl {
        unsafe extern "system" fn IsEditableProperty<Impl: IComboBoxStatics6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsEditableProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextProperty<Impl: IComboBoxStatics6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextBoxStyleProperty<Impl: IComboBoxStatics6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextBoxStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DescriptionProperty<Impl: IComboBoxStatics6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComboBoxStatics6>, base.5, IsEditableProperty::<Impl, OFFSET>, TextProperty::<Impl, OFFSET>, TextBoxStyleProperty::<Impl, OFFSET>, DescriptionProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IComboBoxTextSubmittedEventArgsImpl: Sized {
    fn Text(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Handled(&self) -> ::windows::core::Result<bool>;
    fn SetHandled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IComboBoxTextSubmittedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IComboBoxTextSubmittedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IComboBoxTextSubmittedEventArgsVtbl {
    pub const fn new<Impl: IComboBoxTextSubmittedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IComboBoxTextSubmittedEventArgsVtbl {
        unsafe extern "system" fn Text<Impl: IComboBoxTextSubmittedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Handled<Impl: IComboBoxTextSubmittedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IComboBoxTextSubmittedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IComboBoxTextSubmittedEventArgs>, base.5, Text::<Impl, OFFSET>, Handled::<Impl, OFFSET>, SetHandled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarImpl: Sized {
    fn PrimaryCommands(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<ICommandBarElement>>;
    fn SecondaryCommands(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<ICommandBarElement>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBar {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBar";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarVtbl {
    pub const fn new<Impl: ICommandBarImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICommandBarVtbl {
        unsafe extern "system" fn PrimaryCommands<Impl: ICommandBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrimaryCommands() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryCommands<Impl: ICommandBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SecondaryCommands() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICommandBar>, base.5, PrimaryCommands::<Impl, OFFSET>, SecondaryCommands::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBar2Impl: Sized {
    fn CommandBarOverflowPresenterStyle(&self) -> ::windows::core::Result<super::Style>;
    fn SetCommandBarOverflowPresenterStyle(&self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn CommandBarTemplateSettings(&self) -> ::windows::core::Result<Primitives::CommandBarTemplateSettings>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBar2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBar2";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBar2Vtbl {
    pub const fn new<Impl: ICommandBar2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICommandBar2Vtbl {
        unsafe extern "system" fn CommandBarOverflowPresenterStyle<Impl: ICommandBar2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CommandBarOverflowPresenterStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommandBarOverflowPresenterStyle<Impl: ICommandBar2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCommandBarOverflowPresenterStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CommandBarTemplateSettings<Impl: ICommandBar2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CommandBarTemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICommandBar2>, base.5, CommandBarOverflowPresenterStyle::<Impl, OFFSET>, SetCommandBarOverflowPresenterStyle::<Impl, OFFSET>, CommandBarTemplateSettings::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBar3Impl: Sized {
    fn DefaultLabelPosition(&self) -> ::windows::core::Result<CommandBarDefaultLabelPosition>;
    fn SetDefaultLabelPosition(&self, value: CommandBarDefaultLabelPosition) -> ::windows::core::Result<()>;
    fn OverflowButtonVisibility(&self) -> ::windows::core::Result<CommandBarOverflowButtonVisibility>;
    fn SetOverflowButtonVisibility(&self, value: CommandBarOverflowButtonVisibility) -> ::windows::core::Result<()>;
    fn IsDynamicOverflowEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsDynamicOverflowEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn DynamicOverflowItemsChanging(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<CommandBar, DynamicOverflowItemsChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDynamicOverflowItemsChanging(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBar3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBar3";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBar3Vtbl {
    pub const fn new<Impl: ICommandBar3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICommandBar3Vtbl {
        unsafe extern "system" fn DefaultLabelPosition<Impl: ICommandBar3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut CommandBarDefaultLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultLabelPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultLabelPosition<Impl: ICommandBar3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: CommandBarDefaultLabelPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDefaultLabelPosition(value).into()
        }
        unsafe extern "system" fn OverflowButtonVisibility<Impl: ICommandBar3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut CommandBarOverflowButtonVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OverflowButtonVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOverflowButtonVisibility<Impl: ICommandBar3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: CommandBarOverflowButtonVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOverflowButtonVisibility(value).into()
        }
        unsafe extern "system" fn IsDynamicOverflowEnabled<Impl: ICommandBar3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDynamicOverflowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDynamicOverflowEnabled<Impl: ICommandBar3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsDynamicOverflowEnabled(value).into()
        }
        unsafe extern "system" fn DynamicOverflowItemsChanging<Impl: ICommandBar3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowItemsChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<CommandBar, DynamicOverflowItemsChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<CommandBar, DynamicOverflowItemsChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDynamicOverflowItemsChanging<Impl: ICommandBar3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveDynamicOverflowItemsChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICommandBar3>, base.5, DefaultLabelPosition::<Impl, OFFSET>, SetDefaultLabelPosition::<Impl, OFFSET>, OverflowButtonVisibility::<Impl, OFFSET>, SetOverflowButtonVisibility::<Impl, OFFSET>, IsDynamicOverflowEnabled::<Impl, OFFSET>, SetIsDynamicOverflowEnabled::<Impl, OFFSET>, DynamicOverflowItemsChanging::<Impl, OFFSET>, RemoveDynamicOverflowItemsChanging::<Impl, OFFSET>)
    }
}
pub trait ICommandBarElementImpl: Sized {
    fn IsCompact(&self) -> ::windows::core::Result<bool>;
    fn SetIsCompact(&self, value: bool) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ICommandBarElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarElement";
}
impl ICommandBarElementVtbl {
    pub const fn new<Impl: ICommandBarElementImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICommandBarElementVtbl {
        unsafe extern "system" fn IsCompact<Impl: ICommandBarElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCompact() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCompact<Impl: ICommandBarElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsCompact(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICommandBarElement>, base.5, IsCompact::<Impl, OFFSET>, SetIsCompact::<Impl, OFFSET>)
    }
}
pub trait ICommandBarElement2Impl: Sized {
    fn IsInOverflow(&self) -> ::windows::core::Result<bool>;
    fn DynamicOverflowOrder(&self) -> ::windows::core::Result<i32>;
    fn SetDynamicOverflowOrder(&self, value: i32) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ICommandBarElement2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarElement2";
}
impl ICommandBarElement2Vtbl {
    pub const fn new<Impl: ICommandBarElement2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICommandBarElement2Vtbl {
        unsafe extern "system" fn IsInOverflow<Impl: ICommandBarElement2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsInOverflow() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DynamicOverflowOrder<Impl: ICommandBarElement2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DynamicOverflowOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDynamicOverflowOrder<Impl: ICommandBarElement2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDynamicOverflowOrder(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICommandBarElement2>, base.5, IsInOverflow::<Impl, OFFSET>, DynamicOverflowOrder::<Impl, OFFSET>, SetDynamicOverflowOrder::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CommandBar>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarFactoryVtbl {
    pub const fn new<Impl: ICommandBarFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICommandBarFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICommandBarFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICommandBarFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarFlyoutImpl: Sized {
    fn PrimaryCommands(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<ICommandBarElement>>;
    fn SecondaryCommands(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<ICommandBarElement>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarFlyoutVtbl {
    pub const fn new<Impl: ICommandBarFlyoutImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICommandBarFlyoutVtbl {
        unsafe extern "system" fn PrimaryCommands<Impl: ICommandBarFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrimaryCommands() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryCommands<Impl: ICommandBarFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SecondaryCommands() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICommandBarFlyout>, base.5, PrimaryCommands::<Impl, OFFSET>, SecondaryCommands::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarFlyoutFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CommandBarFlyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarFlyoutFactoryVtbl {
    pub const fn new<Impl: ICommandBarFlyoutFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICommandBarFlyoutFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICommandBarFlyoutFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICommandBarFlyoutFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarOverflowPresenterImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarOverflowPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarOverflowPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarOverflowPresenterVtbl {
    pub const fn new<Impl: ICommandBarOverflowPresenterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICommandBarOverflowPresenterVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICommandBarOverflowPresenter>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarOverflowPresenterFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<CommandBarOverflowPresenter>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarOverflowPresenterFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarOverflowPresenterFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarOverflowPresenterFactoryVtbl {
    pub const fn new<Impl: ICommandBarOverflowPresenterFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICommandBarOverflowPresenterFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ICommandBarOverflowPresenterFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICommandBarOverflowPresenterFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarStaticsImpl: Sized {
    fn PrimaryCommandsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryCommandsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarStaticsVtbl {
    pub const fn new<Impl: ICommandBarStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICommandBarStaticsVtbl {
        unsafe extern "system" fn PrimaryCommandsProperty<Impl: ICommandBarStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrimaryCommandsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryCommandsProperty<Impl: ICommandBarStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SecondaryCommandsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICommandBarStatics>, base.5, PrimaryCommandsProperty::<Impl, OFFSET>, SecondaryCommandsProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarStatics2Impl: Sized {
    fn CommandBarOverflowPresenterStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarStatics2Vtbl {
    pub const fn new<Impl: ICommandBarStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICommandBarStatics2Vtbl {
        unsafe extern "system" fn CommandBarOverflowPresenterStyleProperty<Impl: ICommandBarStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CommandBarOverflowPresenterStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICommandBarStatics2>, base.5, CommandBarOverflowPresenterStyleProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ICommandBarStatics3Impl: Sized {
    fn DefaultLabelPositionProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OverflowButtonVisibilityProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsDynamicOverflowEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ICommandBarStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ICommandBarStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl ICommandBarStatics3Vtbl {
    pub const fn new<Impl: ICommandBarStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICommandBarStatics3Vtbl {
        unsafe extern "system" fn DefaultLabelPositionProperty<Impl: ICommandBarStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultLabelPositionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverflowButtonVisibilityProperty<Impl: ICommandBarStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OverflowButtonVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsDynamicOverflowEnabledProperty<Impl: ICommandBarStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDynamicOverflowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ICommandBarStatics3>, base.5, DefaultLabelPositionProperty::<Impl, OFFSET>, OverflowButtonVisibilityProperty::<Impl, OFFSET>, IsDynamicOverflowEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContainerContentChangingEventArgsImpl: Sized {
    fn ItemContainer(&self) -> ::windows::core::Result<Primitives::SelectorItem>;
    fn InRecycleQueue(&self) -> ::windows::core::Result<bool>;
    fn ItemIndex(&self) -> ::windows::core::Result<i32>;
    fn Item(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn Phase(&self) -> ::windows::core::Result<u32>;
    fn Handled(&self) -> ::windows::core::Result<bool>;
    fn SetHandled(&self, value: bool) -> ::windows::core::Result<()>;
    fn RegisterUpdateCallback(&self, callback: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs>>) -> ::windows::core::Result<()>;
    fn RegisterUpdateCallbackWithPhase(&self, callbackphase: u32, callback: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs>>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContainerContentChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContainerContentChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IContainerContentChangingEventArgsVtbl {
    pub const fn new<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContainerContentChangingEventArgsVtbl {
        unsafe extern "system" fn ItemContainer<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemContainer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InRecycleQueue<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InRecycleQueue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemIndex<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Item<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Phase<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Phase() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Handled<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        unsafe extern "system" fn RegisterUpdateCallback<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, callback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RegisterUpdateCallback(&*(&callback as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RegisterUpdateCallbackWithPhase<Impl: IContainerContentChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, callbackphase: u32, callback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RegisterUpdateCallbackWithPhase(callbackphase, &*(&callback as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContainerContentChangingEventArgs>, base.5, ItemContainer::<Impl, OFFSET>, InRecycleQueue::<Impl, OFFSET>, ItemIndex::<Impl, OFFSET>, Item::<Impl, OFFSET>, Phase::<Impl, OFFSET>, Handled::<Impl, OFFSET>, SetHandled::<Impl, OFFSET>, RegisterUpdateCallback::<Impl, OFFSET>, RegisterUpdateCallbackWithPhase::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentControlImpl: Sized {
    fn Content(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetContent(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn ContentTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetContentTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ContentTemplateSelector(&self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetContentTemplateSelector(&self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn ContentTransitions(&self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetContentTransitions(&self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentControl";
}
#[cfg(feature = "implement_exclusive")]
impl IContentControlVtbl {
    pub const fn new<Impl: IContentControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentControlVtbl {
        unsafe extern "system" fn Content<Impl: IContentControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IContentControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTemplate<Impl: IContentControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTemplate<Impl: IContentControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContentTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTemplateSelector<Impl: IContentControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTemplateSelector<Impl: IContentControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContentTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTransitions<Impl: IContentControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTransitions<Impl: IContentControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContentTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentControl>, base.5, Content::<Impl, OFFSET>, SetContent::<Impl, OFFSET>, ContentTemplate::<Impl, OFFSET>, SetContentTemplate::<Impl, OFFSET>, ContentTemplateSelector::<Impl, OFFSET>, SetContentTemplateSelector::<Impl, OFFSET>, ContentTransitions::<Impl, OFFSET>, SetContentTransitions::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentControl2Impl: Sized {
    fn ContentTemplateRoot(&self) -> ::windows::core::Result<super::UIElement>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentControl2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentControl2";
}
#[cfg(feature = "implement_exclusive")]
impl IContentControl2Vtbl {
    pub const fn new<Impl: IContentControl2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentControl2Vtbl {
        unsafe extern "system" fn ContentTemplateRoot<Impl: IContentControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentTemplateRoot() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentControl2>, base.5, ContentTemplateRoot::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentControlFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ContentControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IContentControlFactoryVtbl {
    pub const fn new<Impl: IContentControlFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentControlFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IContentControlFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentControlFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentControlOverridesImpl: Sized {
    fn OnContentChanged(&self, oldcontent: &::core::option::Option<::windows::core::IInspectable>, newcontent: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnContentTemplateChanged(&self, oldcontenttemplate: &::core::option::Option<super::DataTemplate>, newcontenttemplate: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn OnContentTemplateSelectorChanged(&self, oldcontenttemplateselector: &::core::option::Option<DataTemplateSelector>, newcontenttemplateselector: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentControlOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentControlOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IContentControlOverridesVtbl {
    pub const fn new<Impl: IContentControlOverridesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentControlOverridesVtbl {
        unsafe extern "system" fn OnContentChanged<Impl: IContentControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, oldcontent: *mut ::core::ffi::c_void, newcontent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnContentChanged(&*(&oldcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&newcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnContentTemplateChanged<Impl: IContentControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, oldcontenttemplate: ::windows::core::RawPtr, newcontenttemplate: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnContentTemplateChanged(&*(&oldcontenttemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType), &*(&newcontenttemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnContentTemplateSelectorChanged<Impl: IContentControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, oldcontenttemplateselector: ::windows::core::RawPtr, newcontenttemplateselector: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnContentTemplateSelectorChanged(&*(&oldcontenttemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType), &*(&newcontenttemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentControlOverrides>, base.5, OnContentChanged::<Impl, OFFSET>, OnContentTemplateChanged::<Impl, OFFSET>, OnContentTemplateSelectorChanged::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentControlStaticsImpl: Sized {
    fn ContentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTemplateSelectorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTransitionsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IContentControlStaticsVtbl {
    pub const fn new<Impl: IContentControlStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentControlStaticsVtbl {
        unsafe extern "system" fn ContentProperty<Impl: IContentControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTemplateProperty<Impl: IContentControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTemplateSelectorProperty<Impl: IContentControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentTemplateSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTransitionsProperty<Impl: IContentControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentControlStatics>, base.5, ContentProperty::<Impl, OFFSET>, ContentTemplateProperty::<Impl, OFFSET>, ContentTemplateSelectorProperty::<Impl, OFFSET>, ContentTransitionsProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogImpl: Sized {
    fn Title(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetTitle(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn TitleTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetTitleTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn FullSizeDesired(&self) -> ::windows::core::Result<bool>;
    fn SetFullSizeDesired(&self, value: bool) -> ::windows::core::Result<()>;
    fn PrimaryButtonText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPrimaryButtonText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SecondaryButtonText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSecondaryButtonText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PrimaryButtonCommand(&self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetPrimaryButtonCommand(&self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn SecondaryButtonCommand(&self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetSecondaryButtonCommand(&self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn PrimaryButtonCommandParameter(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetPrimaryButtonCommandParameter(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SecondaryButtonCommandParameter(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetSecondaryButtonCommandParameter(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn IsPrimaryButtonEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsPrimaryButtonEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsSecondaryButtonEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsSecondaryButtonEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn Closing(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosing(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Closed(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosed(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Opened(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogOpenedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpened(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PrimaryButtonClick(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePrimaryButtonClick(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SecondaryButtonClick(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSecondaryButtonClick(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Hide(&self) -> ::windows::core::Result<()>;
    fn ShowAsync(&self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<ContentDialogResult>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialog {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialog";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogVtbl {
    pub const fn new<Impl: IContentDialogImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentDialogVtbl {
        unsafe extern "system" fn Title<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Title() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitle<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTitle(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TitleTemplate<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TitleTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitleTemplate<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTitleTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FullSizeDesired<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FullSizeDesired() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFullSizeDesired<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFullSizeDesired(value).into()
        }
        unsafe extern "system" fn PrimaryButtonText<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrimaryButtonText<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPrimaryButtonText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryButtonText<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSecondaryButtonText<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSecondaryButtonText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrimaryButtonCommand<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonCommand() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrimaryButtonCommand<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPrimaryButtonCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryButtonCommand<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonCommand() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSecondaryButtonCommand<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSecondaryButtonCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrimaryButtonCommandParameter<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonCommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrimaryButtonCommandParameter<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPrimaryButtonCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryButtonCommandParameter<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonCommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSecondaryButtonCommandParameter<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSecondaryButtonCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsPrimaryButtonEnabled<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPrimaryButtonEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPrimaryButtonEnabled<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsPrimaryButtonEnabled(value).into()
        }
        unsafe extern "system" fn IsSecondaryButtonEnabled<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSecondaryButtonEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSecondaryButtonEnabled<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsSecondaryButtonEnabled(value).into()
        }
        unsafe extern "system" fn Closing<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Closing(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosing<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveClosing(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Closed<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Closed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogClosedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosed<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Opened<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Opened(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogOpenedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogOpenedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpened<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrimaryButtonClick<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonClick(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePrimaryButtonClick<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePrimaryButtonClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryButtonClick<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonClick(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSecondaryButtonClick<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSecondaryButtonClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Hide<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Hide().into()
        }
        unsafe extern "system" fn ShowAsync<Impl: IContentDialogImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IContentDialog>,
            base.5,
            Title::<Impl, OFFSET>,
            SetTitle::<Impl, OFFSET>,
            TitleTemplate::<Impl, OFFSET>,
            SetTitleTemplate::<Impl, OFFSET>,
            FullSizeDesired::<Impl, OFFSET>,
            SetFullSizeDesired::<Impl, OFFSET>,
            PrimaryButtonText::<Impl, OFFSET>,
            SetPrimaryButtonText::<Impl, OFFSET>,
            SecondaryButtonText::<Impl, OFFSET>,
            SetSecondaryButtonText::<Impl, OFFSET>,
            PrimaryButtonCommand::<Impl, OFFSET>,
            SetPrimaryButtonCommand::<Impl, OFFSET>,
            SecondaryButtonCommand::<Impl, OFFSET>,
            SetSecondaryButtonCommand::<Impl, OFFSET>,
            PrimaryButtonCommandParameter::<Impl, OFFSET>,
            SetPrimaryButtonCommandParameter::<Impl, OFFSET>,
            SecondaryButtonCommandParameter::<Impl, OFFSET>,
            SetSecondaryButtonCommandParameter::<Impl, OFFSET>,
            IsPrimaryButtonEnabled::<Impl, OFFSET>,
            SetIsPrimaryButtonEnabled::<Impl, OFFSET>,
            IsSecondaryButtonEnabled::<Impl, OFFSET>,
            SetIsSecondaryButtonEnabled::<Impl, OFFSET>,
            Closing::<Impl, OFFSET>,
            RemoveClosing::<Impl, OFFSET>,
            Closed::<Impl, OFFSET>,
            RemoveClosed::<Impl, OFFSET>,
            Opened::<Impl, OFFSET>,
            RemoveOpened::<Impl, OFFSET>,
            PrimaryButtonClick::<Impl, OFFSET>,
            RemovePrimaryButtonClick::<Impl, OFFSET>,
            SecondaryButtonClick::<Impl, OFFSET>,
            RemoveSecondaryButtonClick::<Impl, OFFSET>,
            Hide::<Impl, OFFSET>,
            ShowAsync::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialog2Impl: Sized {
    fn CloseButtonText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCloseButtonText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn CloseButtonCommand(&self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetCloseButtonCommand(&self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn CloseButtonCommandParameter(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetCloseButtonCommandParameter(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn PrimaryButtonStyle(&self) -> ::windows::core::Result<super::Style>;
    fn SetPrimaryButtonStyle(&self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn SecondaryButtonStyle(&self) -> ::windows::core::Result<super::Style>;
    fn SetSecondaryButtonStyle(&self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn CloseButtonStyle(&self) -> ::windows::core::Result<super::Style>;
    fn SetCloseButtonStyle(&self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn DefaultButton(&self) -> ::windows::core::Result<ContentDialogButton>;
    fn SetDefaultButton(&self, value: ContentDialogButton) -> ::windows::core::Result<()>;
    fn CloseButtonClick(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCloseButtonClick(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialog2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialog2";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialog2Vtbl {
    pub const fn new<Impl: IContentDialog2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentDialog2Vtbl {
        unsafe extern "system" fn CloseButtonText<Impl: IContentDialog2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CloseButtonText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCloseButtonText<Impl: IContentDialog2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCloseButtonText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CloseButtonCommand<Impl: IContentDialog2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CloseButtonCommand() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCloseButtonCommand<Impl: IContentDialog2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCloseButtonCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CloseButtonCommandParameter<Impl: IContentDialog2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CloseButtonCommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCloseButtonCommandParameter<Impl: IContentDialog2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCloseButtonCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrimaryButtonStyle<Impl: IContentDialog2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrimaryButtonStyle<Impl: IContentDialog2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPrimaryButtonStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryButtonStyle<Impl: IContentDialog2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSecondaryButtonStyle<Impl: IContentDialog2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSecondaryButtonStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CloseButtonStyle<Impl: IContentDialog2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CloseButtonStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCloseButtonStyle<Impl: IContentDialog2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCloseButtonStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DefaultButton<Impl: IContentDialog2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ContentDialogButton) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultButton() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultButton<Impl: IContentDialog2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ContentDialogButton) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDefaultButton(value).into()
        }
        unsafe extern "system" fn CloseButtonClick<Impl: IContentDialog2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CloseButtonClick(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ContentDialog, ContentDialogButtonClickEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCloseButtonClick<Impl: IContentDialog2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveCloseButtonClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IContentDialog2>,
            base.5,
            CloseButtonText::<Impl, OFFSET>,
            SetCloseButtonText::<Impl, OFFSET>,
            CloseButtonCommand::<Impl, OFFSET>,
            SetCloseButtonCommand::<Impl, OFFSET>,
            CloseButtonCommandParameter::<Impl, OFFSET>,
            SetCloseButtonCommandParameter::<Impl, OFFSET>,
            PrimaryButtonStyle::<Impl, OFFSET>,
            SetPrimaryButtonStyle::<Impl, OFFSET>,
            SecondaryButtonStyle::<Impl, OFFSET>,
            SetSecondaryButtonStyle::<Impl, OFFSET>,
            CloseButtonStyle::<Impl, OFFSET>,
            SetCloseButtonStyle::<Impl, OFFSET>,
            DefaultButton::<Impl, OFFSET>,
            SetDefaultButton::<Impl, OFFSET>,
            CloseButtonClick::<Impl, OFFSET>,
            RemoveCloseButtonClick::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialog3Impl: Sized {
    fn ShowAsyncWithPlacement(&self, placement: ContentDialogPlacement) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<ContentDialogResult>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialog3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialog3";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialog3Vtbl {
    pub const fn new<Impl: IContentDialog3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentDialog3Vtbl {
        unsafe extern "system" fn ShowAsyncWithPlacement<Impl: IContentDialog3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, placement: ContentDialogPlacement, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowAsyncWithPlacement(placement) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentDialog3>, base.5, ShowAsyncWithPlacement::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogButtonClickDeferralImpl: Sized {
    fn Complete(&self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogButtonClickDeferral {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogButtonClickDeferral";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogButtonClickDeferralVtbl {
    pub const fn new<Impl: IContentDialogButtonClickDeferralImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentDialogButtonClickDeferralVtbl {
        unsafe extern "system" fn Complete<Impl: IContentDialogButtonClickDeferralImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Complete().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentDialogButtonClickDeferral>, base.5, Complete::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogButtonClickEventArgsImpl: Sized {
    fn Cancel(&self) -> ::windows::core::Result<bool>;
    fn SetCancel(&self, value: bool) -> ::windows::core::Result<()>;
    fn GetDeferral(&self) -> ::windows::core::Result<ContentDialogButtonClickDeferral>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogButtonClickEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogButtonClickEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogButtonClickEventArgsVtbl {
    pub const fn new<Impl: IContentDialogButtonClickEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentDialogButtonClickEventArgsVtbl {
        unsafe extern "system" fn Cancel<Impl: IContentDialogButtonClickEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: IContentDialogButtonClickEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        unsafe extern "system" fn GetDeferral<Impl: IContentDialogButtonClickEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDeferral() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentDialogButtonClickEventArgs>, base.5, Cancel::<Impl, OFFSET>, SetCancel::<Impl, OFFSET>, GetDeferral::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogClosedEventArgsImpl: Sized {
    fn Result(&self) -> ::windows::core::Result<ContentDialogResult>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogClosedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogClosedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogClosedEventArgsVtbl {
    pub const fn new<Impl: IContentDialogClosedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentDialogClosedEventArgsVtbl {
        unsafe extern "system" fn Result<Impl: IContentDialogClosedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ContentDialogResult) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Result() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentDialogClosedEventArgs>, base.5, Result::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogClosingDeferralImpl: Sized {
    fn Complete(&self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogClosingDeferral {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogClosingDeferral";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogClosingDeferralVtbl {
    pub const fn new<Impl: IContentDialogClosingDeferralImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentDialogClosingDeferralVtbl {
        unsafe extern "system" fn Complete<Impl: IContentDialogClosingDeferralImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Complete().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentDialogClosingDeferral>, base.5, Complete::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogClosingEventArgsImpl: Sized {
    fn Result(&self) -> ::windows::core::Result<ContentDialogResult>;
    fn Cancel(&self) -> ::windows::core::Result<bool>;
    fn SetCancel(&self, value: bool) -> ::windows::core::Result<()>;
    fn GetDeferral(&self) -> ::windows::core::Result<ContentDialogClosingDeferral>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogClosingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogClosingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogClosingEventArgsVtbl {
    pub const fn new<Impl: IContentDialogClosingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentDialogClosingEventArgsVtbl {
        unsafe extern "system" fn Result<Impl: IContentDialogClosingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ContentDialogResult) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Result() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: IContentDialogClosingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: IContentDialogClosingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        unsafe extern "system" fn GetDeferral<Impl: IContentDialogClosingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDeferral() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentDialogClosingEventArgs>, base.5, Result::<Impl, OFFSET>, Cancel::<Impl, OFFSET>, SetCancel::<Impl, OFFSET>, GetDeferral::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ContentDialog>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogFactoryVtbl {
    pub const fn new<Impl: IContentDialogFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentDialogFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IContentDialogFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentDialogFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogOpenedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogOpenedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogOpenedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogOpenedEventArgsVtbl {
    pub const fn new<Impl: IContentDialogOpenedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentDialogOpenedEventArgsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentDialogOpenedEventArgs>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogStaticsImpl: Sized {
    fn TitleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TitleTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FullSizeDesiredProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PrimaryButtonTextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryButtonTextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PrimaryButtonCommandProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryButtonCommandProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PrimaryButtonCommandParameterProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryButtonCommandParameterProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPrimaryButtonEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSecondaryButtonEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogStaticsVtbl {
    pub const fn new<Impl: IContentDialogStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentDialogStaticsVtbl {
        unsafe extern "system" fn TitleProperty<Impl: IContentDialogStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TitleTemplateProperty<Impl: IContentDialogStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TitleTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FullSizeDesiredProperty<Impl: IContentDialogStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FullSizeDesiredProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrimaryButtonTextProperty<Impl: IContentDialogStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryButtonTextProperty<Impl: IContentDialogStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrimaryButtonCommandProperty<Impl: IContentDialogStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonCommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryButtonCommandProperty<Impl: IContentDialogStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonCommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrimaryButtonCommandParameterProperty<Impl: IContentDialogStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonCommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryButtonCommandParameterProperty<Impl: IContentDialogStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonCommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPrimaryButtonEnabledProperty<Impl: IContentDialogStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPrimaryButtonEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSecondaryButtonEnabledProperty<Impl: IContentDialogStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSecondaryButtonEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IContentDialogStatics>,
            base.5,
            TitleProperty::<Impl, OFFSET>,
            TitleTemplateProperty::<Impl, OFFSET>,
            FullSizeDesiredProperty::<Impl, OFFSET>,
            PrimaryButtonTextProperty::<Impl, OFFSET>,
            SecondaryButtonTextProperty::<Impl, OFFSET>,
            PrimaryButtonCommandProperty::<Impl, OFFSET>,
            SecondaryButtonCommandProperty::<Impl, OFFSET>,
            PrimaryButtonCommandParameterProperty::<Impl, OFFSET>,
            SecondaryButtonCommandParameterProperty::<Impl, OFFSET>,
            IsPrimaryButtonEnabledProperty::<Impl, OFFSET>,
            IsSecondaryButtonEnabledProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentDialogStatics2Impl: Sized {
    fn CloseButtonTextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CloseButtonCommandProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CloseButtonCommandParameterProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PrimaryButtonStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryButtonStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CloseButtonStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DefaultButtonProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentDialogStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentDialogStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IContentDialogStatics2Vtbl {
    pub const fn new<Impl: IContentDialogStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentDialogStatics2Vtbl {
        unsafe extern "system" fn CloseButtonTextProperty<Impl: IContentDialogStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CloseButtonTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloseButtonCommandProperty<Impl: IContentDialogStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CloseButtonCommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloseButtonCommandParameterProperty<Impl: IContentDialogStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CloseButtonCommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrimaryButtonStyleProperty<Impl: IContentDialogStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrimaryButtonStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryButtonStyleProperty<Impl: IContentDialogStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SecondaryButtonStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloseButtonStyleProperty<Impl: IContentDialogStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CloseButtonStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultButtonProperty<Impl: IContentDialogStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultButtonProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentDialogStatics2>, base.5, CloseButtonTextProperty::<Impl, OFFSET>, CloseButtonCommandProperty::<Impl, OFFSET>, CloseButtonCommandParameterProperty::<Impl, OFFSET>, PrimaryButtonStyleProperty::<Impl, OFFSET>, SecondaryButtonStyleProperty::<Impl, OFFSET>, CloseButtonStyleProperty::<Impl, OFFSET>, DefaultButtonProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentLinkChangedEventArgsImpl: Sized {
    fn ChangeKind(&self) -> ::windows::core::Result<ContentLinkChangeKind>;
    fn ContentLinkInfo(&self) -> ::windows::core::Result<super::super::Text::ContentLinkInfo>;
    fn TextRange(&self) -> ::windows::core::Result<super::Documents::TextRange>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentLinkChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentLinkChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IContentLinkChangedEventArgsVtbl {
    pub const fn new<Impl: IContentLinkChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentLinkChangedEventArgsVtbl {
        unsafe extern "system" fn ChangeKind<Impl: IContentLinkChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ContentLinkChangeKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChangeKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentLinkInfo<Impl: IContentLinkChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentLinkInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextRange<Impl: IContentLinkChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Documents::TextRange) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextRange() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentLinkChangedEventArgs>, base.5, ChangeKind::<Impl, OFFSET>, ContentLinkInfo::<Impl, OFFSET>, TextRange::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterImpl: Sized {
    fn Content(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetContent(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn ContentTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetContentTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ContentTemplateSelector(&self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetContentTemplateSelector(&self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn ContentTransitions(&self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetContentTransitions(&self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
    fn FontSize(&self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FontStretch(&self) -> ::windows::core::Result<super::super::Text::FontStretch>;
    fn SetFontStretch(&self, value: super::super::Text::FontStretch) -> ::windows::core::Result<()>;
    fn CharacterSpacing(&self) -> ::windows::core::Result<i32>;
    fn SetCharacterSpacing(&self, value: i32) -> ::windows::core::Result<()>;
    fn Foreground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterVtbl {
    pub const fn new<Impl: IContentPresenterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentPresenterVtbl {
        unsafe extern "system" fn Content<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTemplate<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTemplate<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContentTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTemplateSelector<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTemplateSelector<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContentTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTransitions<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTransitions<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContentTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontSize<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        unsafe extern "system" fn FontStretch<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStretch<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontStretch(value).into()
        }
        unsafe extern "system" fn CharacterSpacing<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CharacterSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterSpacing<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCharacterSpacing(value).into()
        }
        unsafe extern "system" fn Foreground<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: IContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IContentPresenter>,
            base.5,
            Content::<Impl, OFFSET>,
            SetContent::<Impl, OFFSET>,
            ContentTemplate::<Impl, OFFSET>,
            SetContentTemplate::<Impl, OFFSET>,
            ContentTemplateSelector::<Impl, OFFSET>,
            SetContentTemplateSelector::<Impl, OFFSET>,
            ContentTransitions::<Impl, OFFSET>,
            SetContentTransitions::<Impl, OFFSET>,
            FontSize::<Impl, OFFSET>,
            SetFontSize::<Impl, OFFSET>,
            FontFamily::<Impl, OFFSET>,
            SetFontFamily::<Impl, OFFSET>,
            FontWeight::<Impl, OFFSET>,
            SetFontWeight::<Impl, OFFSET>,
            FontStyle::<Impl, OFFSET>,
            SetFontStyle::<Impl, OFFSET>,
            FontStretch::<Impl, OFFSET>,
            SetFontStretch::<Impl, OFFSET>,
            CharacterSpacing::<Impl, OFFSET>,
            SetCharacterSpacing::<Impl, OFFSET>,
            Foreground::<Impl, OFFSET>,
            SetForeground::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenter2Impl: Sized {
    fn OpticalMarginAlignment(&self) -> ::windows::core::Result<super::OpticalMarginAlignment>;
    fn SetOpticalMarginAlignment(&self, value: super::OpticalMarginAlignment) -> ::windows::core::Result<()>;
    fn TextLineBounds(&self) -> ::windows::core::Result<super::TextLineBounds>;
    fn SetTextLineBounds(&self, value: super::TextLineBounds) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenter2";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenter2Vtbl {
    pub const fn new<Impl: IContentPresenter2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentPresenter2Vtbl {
        unsafe extern "system" fn OpticalMarginAlignment<Impl: IContentPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOpticalMarginAlignment<Impl: IContentPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOpticalMarginAlignment(value).into()
        }
        unsafe extern "system" fn TextLineBounds<Impl: IContentPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextLineBounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextLineBounds<Impl: IContentPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextLineBounds(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentPresenter2>, base.5, OpticalMarginAlignment::<Impl, OFFSET>, SetOpticalMarginAlignment::<Impl, OFFSET>, TextLineBounds::<Impl, OFFSET>, SetTextLineBounds::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenter3Impl: Sized {
    fn IsTextScaleFactorEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenter3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenter3";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenter3Vtbl {
    pub const fn new<Impl: IContentPresenter3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentPresenter3Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: IContentPresenter3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: IContentPresenter3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentPresenter3>, base.5, IsTextScaleFactorEnabled::<Impl, OFFSET>, SetIsTextScaleFactorEnabled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenter4Impl: Sized {
    fn TextWrapping(&self) -> ::windows::core::Result<super::TextWrapping>;
    fn SetTextWrapping(&self, value: super::TextWrapping) -> ::windows::core::Result<()>;
    fn MaxLines(&self) -> ::windows::core::Result<i32>;
    fn SetMaxLines(&self, value: i32) -> ::windows::core::Result<()>;
    fn LineStackingStrategy(&self) -> ::windows::core::Result<super::LineStackingStrategy>;
    fn SetLineStackingStrategy(&self, value: super::LineStackingStrategy) -> ::windows::core::Result<()>;
    fn LineHeight(&self) -> ::windows::core::Result<f64>;
    fn SetLineHeight(&self, value: f64) -> ::windows::core::Result<()>;
    fn BorderBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CornerRadius(&self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
    fn Padding(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn Background(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn HorizontalContentAlignment(&self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalContentAlignment(&self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalContentAlignment(&self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalContentAlignment(&self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenter4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenter4";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenter4Vtbl {
    pub const fn new<Impl: IContentPresenter4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentPresenter4Vtbl {
        unsafe extern "system" fn TextWrapping<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextWrapping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextWrapping<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextWrapping(value).into()
        }
        unsafe extern "system" fn MaxLines<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxLines() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLines<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxLines(value).into()
        }
        unsafe extern "system" fn LineStackingStrategy<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategy() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineStackingStrategy<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLineStackingStrategy(value).into()
        }
        unsafe extern "system" fn LineHeight<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LineHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineHeight<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLineHeight(value).into()
        }
        unsafe extern "system" fn BorderBrush<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Background<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Background() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackground<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HorizontalContentAlignment<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalContentAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalContentAlignment<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalContentAlignment(value).into()
        }
        unsafe extern "system" fn VerticalContentAlignment<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalContentAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalContentAlignment<Impl: IContentPresenter4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalContentAlignment(value).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IContentPresenter4>,
            base.5,
            TextWrapping::<Impl, OFFSET>,
            SetTextWrapping::<Impl, OFFSET>,
            MaxLines::<Impl, OFFSET>,
            SetMaxLines::<Impl, OFFSET>,
            LineStackingStrategy::<Impl, OFFSET>,
            SetLineStackingStrategy::<Impl, OFFSET>,
            LineHeight::<Impl, OFFSET>,
            SetLineHeight::<Impl, OFFSET>,
            BorderBrush::<Impl, OFFSET>,
            SetBorderBrush::<Impl, OFFSET>,
            BorderThickness::<Impl, OFFSET>,
            SetBorderThickness::<Impl, OFFSET>,
            CornerRadius::<Impl, OFFSET>,
            SetCornerRadius::<Impl, OFFSET>,
            Padding::<Impl, OFFSET>,
            SetPadding::<Impl, OFFSET>,
            Background::<Impl, OFFSET>,
            SetBackground::<Impl, OFFSET>,
            HorizontalContentAlignment::<Impl, OFFSET>,
            SetHorizontalContentAlignment::<Impl, OFFSET>,
            VerticalContentAlignment::<Impl, OFFSET>,
            SetVerticalContentAlignment::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenter5Impl: Sized {
    fn BackgroundTransition(&self) -> ::windows::core::Result<super::BrushTransition>;
    fn SetBackgroundTransition(&self, value: &::core::option::Option<super::BrushTransition>) -> ::windows::core::Result<()>;
    fn BackgroundSizing(&self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&self, value: BackgroundSizing) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenter5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenter5";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenter5Vtbl {
    pub const fn new<Impl: IContentPresenter5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentPresenter5Vtbl {
        unsafe extern "system" fn BackgroundTransition<Impl: IContentPresenter5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundTransition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundTransition<Impl: IContentPresenter5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBackgroundTransition(&*(&value as *const <super::BrushTransition as ::windows::core::Abi>::Abi as *const <super::BrushTransition as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BackgroundSizing<Impl: IContentPresenter5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IContentPresenter5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentPresenter5>, base.5, BackgroundTransition::<Impl, OFFSET>, SetBackgroundTransition::<Impl, OFFSET>, BackgroundSizing::<Impl, OFFSET>, SetBackgroundSizing::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ContentPresenter>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterFactoryVtbl {
    pub const fn new<Impl: IContentPresenterFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentPresenterFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IContentPresenterFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentPresenterFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterOverridesImpl: Sized {
    fn OnContentTemplateChanged(&self, oldcontenttemplate: &::core::option::Option<super::DataTemplate>, newcontenttemplate: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn OnContentTemplateSelectorChanged(&self, oldcontenttemplateselector: &::core::option::Option<DataTemplateSelector>, newcontenttemplateselector: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterOverridesVtbl {
    pub const fn new<Impl: IContentPresenterOverridesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentPresenterOverridesVtbl {
        unsafe extern "system" fn OnContentTemplateChanged<Impl: IContentPresenterOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, oldcontenttemplate: ::windows::core::RawPtr, newcontenttemplate: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnContentTemplateChanged(&*(&oldcontenttemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType), &*(&newcontenttemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnContentTemplateSelectorChanged<Impl: IContentPresenterOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, oldcontenttemplateselector: ::windows::core::RawPtr, newcontenttemplateselector: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnContentTemplateSelectorChanged(&*(&oldcontenttemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType), &*(&newcontenttemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentPresenterOverrides>, base.5, OnContentTemplateChanged::<Impl, OFFSET>, OnContentTemplateSelectorChanged::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterStaticsImpl: Sized {
    fn ContentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTemplateSelectorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTransitionsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontSizeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStretchProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterSpacingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterStaticsVtbl {
    pub const fn new<Impl: IContentPresenterStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentPresenterStaticsVtbl {
        unsafe extern "system" fn ContentProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTemplateProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTemplateSelectorProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentTemplateSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTransitionsProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontSizeProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStretchProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterSpacingProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CharacterSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForegroundProperty<Impl: IContentPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IContentPresenterStatics>,
            base.5,
            ContentProperty::<Impl, OFFSET>,
            ContentTemplateProperty::<Impl, OFFSET>,
            ContentTemplateSelectorProperty::<Impl, OFFSET>,
            ContentTransitionsProperty::<Impl, OFFSET>,
            FontSizeProperty::<Impl, OFFSET>,
            FontFamilyProperty::<Impl, OFFSET>,
            FontWeightProperty::<Impl, OFFSET>,
            FontStyleProperty::<Impl, OFFSET>,
            FontStretchProperty::<Impl, OFFSET>,
            CharacterSpacingProperty::<Impl, OFFSET>,
            ForegroundProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterStatics2Impl: Sized {
    fn OpticalMarginAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextLineBoundsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterStatics2Vtbl {
    pub const fn new<Impl: IContentPresenterStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentPresenterStatics2Vtbl {
        unsafe extern "system" fn OpticalMarginAlignmentProperty<Impl: IContentPresenterStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextLineBoundsProperty<Impl: IContentPresenterStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextLineBoundsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentPresenterStatics2>, base.5, OpticalMarginAlignmentProperty::<Impl, OFFSET>, TextLineBoundsProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterStatics3Impl: Sized {
    fn IsTextScaleFactorEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterStatics3Vtbl {
    pub const fn new<Impl: IContentPresenterStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentPresenterStatics3Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: IContentPresenterStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentPresenterStatics3>, base.5, IsTextScaleFactorEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterStatics4Impl: Sized {
    fn TextWrappingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxLinesProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineStackingStrategyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineHeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalContentAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalContentAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterStatics4Vtbl {
    pub const fn new<Impl: IContentPresenterStatics4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentPresenterStatics4Vtbl {
        unsafe extern "system" fn TextWrappingProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextWrappingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxLinesProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxLinesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineStackingStrategyProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineHeightProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LineHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderBrushProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackgroundProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalContentAlignmentProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalContentAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalContentAlignmentProperty<Impl: IContentPresenterStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalContentAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IContentPresenterStatics4>,
            base.5,
            TextWrappingProperty::<Impl, OFFSET>,
            MaxLinesProperty::<Impl, OFFSET>,
            LineStackingStrategyProperty::<Impl, OFFSET>,
            LineHeightProperty::<Impl, OFFSET>,
            BorderBrushProperty::<Impl, OFFSET>,
            BorderThicknessProperty::<Impl, OFFSET>,
            CornerRadiusProperty::<Impl, OFFSET>,
            PaddingProperty::<Impl, OFFSET>,
            BackgroundProperty::<Impl, OFFSET>,
            HorizontalContentAlignmentProperty::<Impl, OFFSET>,
            VerticalContentAlignmentProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContentPresenterStatics5Impl: Sized {
    fn BackgroundSizingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContentPresenterStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContentPresenterStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IContentPresenterStatics5Vtbl {
    pub const fn new<Impl: IContentPresenterStatics5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContentPresenterStatics5Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IContentPresenterStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContentPresenterStatics5>, base.5, BackgroundSizingProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IContextMenuEventArgsImpl: Sized {
    fn Handled(&self) -> ::windows::core::Result<bool>;
    fn SetHandled(&self, value: bool) -> ::windows::core::Result<()>;
    fn CursorLeft(&self) -> ::windows::core::Result<f64>;
    fn CursorTop(&self) -> ::windows::core::Result<f64>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IContextMenuEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IContextMenuEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IContextMenuEventArgsVtbl {
    pub const fn new<Impl: IContextMenuEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IContextMenuEventArgsVtbl {
        unsafe extern "system" fn Handled<Impl: IContextMenuEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IContextMenuEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        unsafe extern "system" fn CursorLeft<Impl: IContextMenuEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CursorLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CursorTop<Impl: IContextMenuEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CursorTop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IContextMenuEventArgs>, base.5, Handled::<Impl, OFFSET>, SetHandled::<Impl, OFFSET>, CursorLeft::<Impl, OFFSET>, CursorTop::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlImpl: Sized {
    fn FontSize(&self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FontStretch(&self) -> ::windows::core::Result<super::super::Text::FontStretch>;
    fn SetFontStretch(&self, value: super::super::Text::FontStretch) -> ::windows::core::Result<()>;
    fn CharacterSpacing(&self) -> ::windows::core::Result<i32>;
    fn SetCharacterSpacing(&self, value: i32) -> ::windows::core::Result<()>;
    fn Foreground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn IsTabStop(&self) -> ::windows::core::Result<bool>;
    fn SetIsTabStop(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn TabIndex(&self) -> ::windows::core::Result<i32>;
    fn SetTabIndex(&self, value: i32) -> ::windows::core::Result<()>;
    fn TabNavigation(&self) -> ::windows::core::Result<super::Input::KeyboardNavigationMode>;
    fn SetTabNavigation(&self, value: super::Input::KeyboardNavigationMode) -> ::windows::core::Result<()>;
    fn Template(&self) -> ::windows::core::Result<ControlTemplate>;
    fn SetTemplate(&self, value: &::core::option::Option<ControlTemplate>) -> ::windows::core::Result<()>;
    fn Padding(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn HorizontalContentAlignment(&self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalContentAlignment(&self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalContentAlignment(&self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalContentAlignment(&self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
    fn Background(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn BorderBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn FocusState(&self) -> ::windows::core::Result<super::FocusState>;
    fn IsEnabledChanged(&self, handler: &::core::option::Option<super::DependencyPropertyChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsEnabledChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ApplyTemplate(&self) -> ::windows::core::Result<bool>;
    fn Focus(&self, value: super::FocusState) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl";
}
#[cfg(feature = "implement_exclusive")]
impl IControlVtbl {
    pub const fn new<Impl: IControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IControlVtbl {
        unsafe extern "system" fn FontSize<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        unsafe extern "system" fn FontStretch<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStretch<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontStretch(value).into()
        }
        unsafe extern "system" fn CharacterSpacing<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CharacterSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterSpacing<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCharacterSpacing(value).into()
        }
        unsafe extern "system" fn Foreground<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsTabStop<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTabStop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTabStop<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsTabStop(value).into()
        }
        unsafe extern "system" fn IsEnabled<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsEnabled<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsEnabled(value).into()
        }
        unsafe extern "system" fn TabIndex<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TabIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTabIndex<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTabIndex(value).into()
        }
        unsafe extern "system" fn TabNavigation<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Input::KeyboardNavigationMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TabNavigation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTabNavigation<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Input::KeyboardNavigationMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTabNavigation(value).into()
        }
        unsafe extern "system" fn Template<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Template() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTemplate<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTemplate(&*(&value as *const <ControlTemplate as ::windows::core::Abi>::Abi as *const <ControlTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HorizontalContentAlignment<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalContentAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalContentAlignment<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalContentAlignment(value).into()
        }
        unsafe extern "system" fn VerticalContentAlignment<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalContentAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalContentAlignment<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalContentAlignment(value).into()
        }
        unsafe extern "system" fn Background<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Background() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackground<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderBrush<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FocusState<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::FocusState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FocusState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEnabledChanged<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsEnabledChanged(&*(&handler as *const <super::DependencyPropertyChangedEventHandler as ::windows::core::Abi>::Abi as *const <super::DependencyPropertyChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsEnabledChanged<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveIsEnabledChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ApplyTemplate<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ApplyTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Focus<Impl: IControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::FocusState, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Focus(value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IControl>,
            base.5,
            FontSize::<Impl, OFFSET>,
            SetFontSize::<Impl, OFFSET>,
            FontFamily::<Impl, OFFSET>,
            SetFontFamily::<Impl, OFFSET>,
            FontWeight::<Impl, OFFSET>,
            SetFontWeight::<Impl, OFFSET>,
            FontStyle::<Impl, OFFSET>,
            SetFontStyle::<Impl, OFFSET>,
            FontStretch::<Impl, OFFSET>,
            SetFontStretch::<Impl, OFFSET>,
            CharacterSpacing::<Impl, OFFSET>,
            SetCharacterSpacing::<Impl, OFFSET>,
            Foreground::<Impl, OFFSET>,
            SetForeground::<Impl, OFFSET>,
            IsTabStop::<Impl, OFFSET>,
            SetIsTabStop::<Impl, OFFSET>,
            IsEnabled::<Impl, OFFSET>,
            SetIsEnabled::<Impl, OFFSET>,
            TabIndex::<Impl, OFFSET>,
            SetTabIndex::<Impl, OFFSET>,
            TabNavigation::<Impl, OFFSET>,
            SetTabNavigation::<Impl, OFFSET>,
            Template::<Impl, OFFSET>,
            SetTemplate::<Impl, OFFSET>,
            Padding::<Impl, OFFSET>,
            SetPadding::<Impl, OFFSET>,
            HorizontalContentAlignment::<Impl, OFFSET>,
            SetHorizontalContentAlignment::<Impl, OFFSET>,
            VerticalContentAlignment::<Impl, OFFSET>,
            SetVerticalContentAlignment::<Impl, OFFSET>,
            Background::<Impl, OFFSET>,
            SetBackground::<Impl, OFFSET>,
            BorderThickness::<Impl, OFFSET>,
            SetBorderThickness::<Impl, OFFSET>,
            BorderBrush::<Impl, OFFSET>,
            SetBorderBrush::<Impl, OFFSET>,
            FocusState::<Impl, OFFSET>,
            IsEnabledChanged::<Impl, OFFSET>,
            RemoveIsEnabledChanged::<Impl, OFFSET>,
            ApplyTemplate::<Impl, OFFSET>,
            Focus::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControl2Impl: Sized {
    fn IsTextScaleFactorEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControl2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl2";
}
#[cfg(feature = "implement_exclusive")]
impl IControl2Vtbl {
    pub const fn new<Impl: IControl2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IControl2Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: IControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: IControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IControl2>, base.5, IsTextScaleFactorEnabled::<Impl, OFFSET>, SetIsTextScaleFactorEnabled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControl3Impl: Sized {
    fn UseSystemFocusVisuals(&self) -> ::windows::core::Result<bool>;
    fn SetUseSystemFocusVisuals(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControl3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl3";
}
#[cfg(feature = "implement_exclusive")]
impl IControl3Vtbl {
    pub const fn new<Impl: IControl3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IControl3Vtbl {
        unsafe extern "system" fn UseSystemFocusVisuals<Impl: IControl3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UseSystemFocusVisuals() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUseSystemFocusVisuals<Impl: IControl3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetUseSystemFocusVisuals(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IControl3>, base.5, UseSystemFocusVisuals::<Impl, OFFSET>, SetUseSystemFocusVisuals::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControl4Impl: Sized {
    fn IsFocusEngagementEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsFocusEngagementEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsFocusEngaged(&self) -> ::windows::core::Result<bool>;
    fn SetIsFocusEngaged(&self, value: bool) -> ::windows::core::Result<()>;
    fn RequiresPointer(&self) -> ::windows::core::Result<RequiresPointer>;
    fn SetRequiresPointer(&self, value: RequiresPointer) -> ::windows::core::Result<()>;
    fn XYFocusLeft(&self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusLeft(&self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusRight(&self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusRight(&self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusUp(&self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusUp(&self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusDown(&self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusDown(&self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn ElementSoundMode(&self) -> ::windows::core::Result<super::ElementSoundMode>;
    fn SetElementSoundMode(&self, value: super::ElementSoundMode) -> ::windows::core::Result<()>;
    fn FocusEngaged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Control, FocusEngagedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFocusEngaged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn FocusDisengaged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Control, FocusDisengagedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFocusDisengaged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn RemoveFocusEngagement(&self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControl4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl4";
}
#[cfg(feature = "implement_exclusive")]
impl IControl4Vtbl {
    pub const fn new<Impl: IControl4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IControl4Vtbl {
        unsafe extern "system" fn IsFocusEngagementEnabled<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFocusEngagementEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFocusEngagementEnabled<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsFocusEngagementEnabled(value).into()
        }
        unsafe extern "system" fn IsFocusEngaged<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFocusEngaged() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFocusEngaged<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsFocusEngaged(value).into()
        }
        unsafe extern "system" fn RequiresPointer<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut RequiresPointer) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RequiresPointer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRequiresPointer<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: RequiresPointer) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetRequiresPointer(value).into()
        }
        unsafe extern "system" fn XYFocusLeft<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).XYFocusLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusLeft<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetXYFocusLeft(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusRight<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).XYFocusRight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusRight<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetXYFocusRight(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusUp<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).XYFocusUp() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusUp<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetXYFocusUp(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusDown<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).XYFocusDown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusDown<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetXYFocusDown(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ElementSoundMode<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::ElementSoundMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ElementSoundMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetElementSoundMode<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::ElementSoundMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetElementSoundMode(value).into()
        }
        unsafe extern "system" fn FocusEngaged<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FocusEngaged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Control, FocusEngagedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Control, FocusEngagedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFocusEngaged<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveFocusEngaged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FocusDisengaged<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FocusDisengaged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Control, FocusDisengagedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Control, FocusDisengagedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFocusDisengaged<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveFocusDisengaged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RemoveFocusEngagement<Impl: IControl4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveFocusEngagement().into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IControl4>,
            base.5,
            IsFocusEngagementEnabled::<Impl, OFFSET>,
            SetIsFocusEngagementEnabled::<Impl, OFFSET>,
            IsFocusEngaged::<Impl, OFFSET>,
            SetIsFocusEngaged::<Impl, OFFSET>,
            RequiresPointer::<Impl, OFFSET>,
            SetRequiresPointer::<Impl, OFFSET>,
            XYFocusLeft::<Impl, OFFSET>,
            SetXYFocusLeft::<Impl, OFFSET>,
            XYFocusRight::<Impl, OFFSET>,
            SetXYFocusRight::<Impl, OFFSET>,
            XYFocusUp::<Impl, OFFSET>,
            SetXYFocusUp::<Impl, OFFSET>,
            XYFocusDown::<Impl, OFFSET>,
            SetXYFocusDown::<Impl, OFFSET>,
            ElementSoundMode::<Impl, OFFSET>,
            SetElementSoundMode::<Impl, OFFSET>,
            FocusEngaged::<Impl, OFFSET>,
            RemoveFocusEngaged::<Impl, OFFSET>,
            FocusDisengaged::<Impl, OFFSET>,
            RemoveFocusDisengaged::<Impl, OFFSET>,
            RemoveFocusEngagement::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControl5Impl: Sized {
    fn DefaultStyleResourceUri(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetDefaultStyleResourceUri(&self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControl5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl5";
}
#[cfg(feature = "implement_exclusive")]
impl IControl5Vtbl {
    pub const fn new<Impl: IControl5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IControl5Vtbl {
        unsafe extern "system" fn DefaultStyleResourceUri<Impl: IControl5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultStyleResourceUri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultStyleResourceUri<Impl: IControl5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDefaultStyleResourceUri(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IControl5>, base.5, DefaultStyleResourceUri::<Impl, OFFSET>, SetDefaultStyleResourceUri::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControl7Impl: Sized {
    fn BackgroundSizing(&self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&self, value: BackgroundSizing) -> ::windows::core::Result<()>;
    fn CornerRadius(&self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControl7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControl7";
}
#[cfg(feature = "implement_exclusive")]
impl IControl7Vtbl {
    pub const fn new<Impl: IControl7Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IControl7Vtbl {
        unsafe extern "system" fn BackgroundSizing<Impl: IControl7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IControl7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IControl7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IControl7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IControl7>, base.5, BackgroundSizing::<Impl, OFFSET>, SetBackgroundSizing::<Impl, OFFSET>, CornerRadius::<Impl, OFFSET>, SetCornerRadius::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Control>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IControlFactoryVtbl {
    pub const fn new<Impl: IControlFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IControlFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IControlFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IControlFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlOverridesImpl: Sized {
    fn OnPointerEntered(&self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerPressed(&self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerMoved(&self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerReleased(&self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerExited(&self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerCaptureLost(&self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerCanceled(&self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPointerWheelChanged(&self, e: &::core::option::Option<super::Input::PointerRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnTapped(&self, e: &::core::option::Option<super::Input::TappedRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnDoubleTapped(&self, e: &::core::option::Option<super::Input::DoubleTappedRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnHolding(&self, e: &::core::option::Option<super::Input::HoldingRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnRightTapped(&self, e: &::core::option::Option<super::Input::RightTappedRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnManipulationStarting(&self, e: &::core::option::Option<super::Input::ManipulationStartingRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnManipulationInertiaStarting(&self, e: &::core::option::Option<super::Input::ManipulationInertiaStartingRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnManipulationStarted(&self, e: &::core::option::Option<super::Input::ManipulationStartedRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnManipulationDelta(&self, e: &::core::option::Option<super::Input::ManipulationDeltaRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnManipulationCompleted(&self, e: &::core::option::Option<super::Input::ManipulationCompletedRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnKeyUp(&self, e: &::core::option::Option<super::Input::KeyRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnKeyDown(&self, e: &::core::option::Option<super::Input::KeyRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnGotFocus(&self, e: &::core::option::Option<super::RoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnLostFocus(&self, e: &::core::option::Option<super::RoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnDragEnter(&self, e: &::core::option::Option<super::DragEventArgs>) -> ::windows::core::Result<()>;
    fn OnDragLeave(&self, e: &::core::option::Option<super::DragEventArgs>) -> ::windows::core::Result<()>;
    fn OnDragOver(&self, e: &::core::option::Option<super::DragEventArgs>) -> ::windows::core::Result<()>;
    fn OnDrop(&self, e: &::core::option::Option<super::DragEventArgs>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IControlOverridesVtbl {
    pub const fn new<Impl: IControlOverridesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IControlOverridesVtbl {
        unsafe extern "system" fn OnPointerEntered<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnPointerEntered(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerPressed<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnPointerPressed(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerMoved<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnPointerMoved(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerReleased<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnPointerReleased(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerExited<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnPointerExited(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerCaptureLost<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnPointerCaptureLost(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerCanceled<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnPointerCanceled(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPointerWheelChanged<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnPointerWheelChanged(&*(&e as *const <super::Input::PointerRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::PointerRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnTapped<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnTapped(&*(&e as *const <super::Input::TappedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::TappedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDoubleTapped<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnDoubleTapped(&*(&e as *const <super::Input::DoubleTappedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::DoubleTappedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnHolding<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnHolding(&*(&e as *const <super::Input::HoldingRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::HoldingRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnRightTapped<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnRightTapped(&*(&e as *const <super::Input::RightTappedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::RightTappedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnManipulationStarting<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnManipulationStarting(&*(&e as *const <super::Input::ManipulationStartingRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::ManipulationStartingRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnManipulationInertiaStarting<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnManipulationInertiaStarting(&*(&e as *const <super::Input::ManipulationInertiaStartingRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::ManipulationInertiaStartingRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnManipulationStarted<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnManipulationStarted(&*(&e as *const <super::Input::ManipulationStartedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::ManipulationStartedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnManipulationDelta<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnManipulationDelta(&*(&e as *const <super::Input::ManipulationDeltaRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::ManipulationDeltaRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnManipulationCompleted<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnManipulationCompleted(&*(&e as *const <super::Input::ManipulationCompletedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::ManipulationCompletedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnKeyUp<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnKeyUp(&*(&e as *const <super::Input::KeyRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::KeyRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnKeyDown<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnKeyDown(&*(&e as *const <super::Input::KeyRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::KeyRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnGotFocus<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnGotFocus(&*(&e as *const <super::RoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::RoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnLostFocus<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnLostFocus(&*(&e as *const <super::RoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::RoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDragEnter<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnDragEnter(&*(&e as *const <super::DragEventArgs as ::windows::core::Abi>::Abi as *const <super::DragEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDragLeave<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnDragLeave(&*(&e as *const <super::DragEventArgs as ::windows::core::Abi>::Abi as *const <super::DragEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDragOver<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnDragOver(&*(&e as *const <super::DragEventArgs as ::windows::core::Abi>::Abi as *const <super::DragEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnDrop<Impl: IControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnDrop(&*(&e as *const <super::DragEventArgs as ::windows::core::Abi>::Abi as *const <super::DragEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IControlOverrides>,
            base.5,
            OnPointerEntered::<Impl, OFFSET>,
            OnPointerPressed::<Impl, OFFSET>,
            OnPointerMoved::<Impl, OFFSET>,
            OnPointerReleased::<Impl, OFFSET>,
            OnPointerExited::<Impl, OFFSET>,
            OnPointerCaptureLost::<Impl, OFFSET>,
            OnPointerCanceled::<Impl, OFFSET>,
            OnPointerWheelChanged::<Impl, OFFSET>,
            OnTapped::<Impl, OFFSET>,
            OnDoubleTapped::<Impl, OFFSET>,
            OnHolding::<Impl, OFFSET>,
            OnRightTapped::<Impl, OFFSET>,
            OnManipulationStarting::<Impl, OFFSET>,
            OnManipulationInertiaStarting::<Impl, OFFSET>,
            OnManipulationStarted::<Impl, OFFSET>,
            OnManipulationDelta::<Impl, OFFSET>,
            OnManipulationCompleted::<Impl, OFFSET>,
            OnKeyUp::<Impl, OFFSET>,
            OnKeyDown::<Impl, OFFSET>,
            OnGotFocus::<Impl, OFFSET>,
            OnLostFocus::<Impl, OFFSET>,
            OnDragEnter::<Impl, OFFSET>,
            OnDragLeave::<Impl, OFFSET>,
            OnDragOver::<Impl, OFFSET>,
            OnDrop::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlOverrides6Impl: Sized {
    fn OnPreviewKeyDown(&self, e: &::core::option::Option<super::Input::KeyRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnPreviewKeyUp(&self, e: &::core::option::Option<super::Input::KeyRoutedEventArgs>) -> ::windows::core::Result<()>;
    fn OnCharacterReceived(&self, e: &::core::option::Option<super::Input::CharacterReceivedRoutedEventArgs>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlOverrides6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlOverrides6";
}
#[cfg(feature = "implement_exclusive")]
impl IControlOverrides6Vtbl {
    pub const fn new<Impl: IControlOverrides6Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IControlOverrides6Vtbl {
        unsafe extern "system" fn OnPreviewKeyDown<Impl: IControlOverrides6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnPreviewKeyDown(&*(&e as *const <super::Input::KeyRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::KeyRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnPreviewKeyUp<Impl: IControlOverrides6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnPreviewKeyUp(&*(&e as *const <super::Input::KeyRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::KeyRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnCharacterReceived<Impl: IControlOverrides6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnCharacterReceived(&*(&e as *const <super::Input::CharacterReceivedRoutedEventArgs as ::windows::core::Abi>::Abi as *const <super::Input::CharacterReceivedRoutedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IControlOverrides6>, base.5, OnPreviewKeyDown::<Impl, OFFSET>, OnPreviewKeyUp::<Impl, OFFSET>, OnCharacterReceived::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlProtectedImpl: Sized {
    fn DefaultStyleKey(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDefaultStyleKey(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn GetTemplateChild(&self, childname: &::windows::core::HSTRING) -> ::windows::core::Result<super::DependencyObject>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlProtected {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlProtected";
}
#[cfg(feature = "implement_exclusive")]
impl IControlProtectedVtbl {
    pub const fn new<Impl: IControlProtectedImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IControlProtectedVtbl {
        unsafe extern "system" fn DefaultStyleKey<Impl: IControlProtectedImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultStyleKey() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultStyleKey<Impl: IControlProtectedImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDefaultStyleKey(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetTemplateChild<Impl: IControlProtectedImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, childname: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTemplateChild(&*(&childname as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IControlProtected>, base.5, DefaultStyleKey::<Impl, OFFSET>, SetDefaultStyleKey::<Impl, OFFSET>, GetTemplateChild::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStaticsImpl: Sized {
    fn FontSizeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStretchProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterSpacingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTabStopProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TabIndexProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TabNavigationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalContentAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalContentAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DefaultStyleKeyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FocusStateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStaticsVtbl {
    pub const fn new<Impl: IControlStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IControlStaticsVtbl {
        unsafe extern "system" fn FontSizeProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStretchProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterSpacingProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CharacterSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForegroundProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTabStopProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTabStopProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEnabledProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TabIndexProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TabIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TabNavigationProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TabNavigationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TemplateProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalContentAlignmentProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalContentAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalContentAlignmentProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalContentAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackgroundProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderBrushProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultStyleKeyProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultStyleKeyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FocusStateProperty<Impl: IControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FocusStateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IControlStatics>,
            base.5,
            FontSizeProperty::<Impl, OFFSET>,
            FontFamilyProperty::<Impl, OFFSET>,
            FontWeightProperty::<Impl, OFFSET>,
            FontStyleProperty::<Impl, OFFSET>,
            FontStretchProperty::<Impl, OFFSET>,
            CharacterSpacingProperty::<Impl, OFFSET>,
            ForegroundProperty::<Impl, OFFSET>,
            IsTabStopProperty::<Impl, OFFSET>,
            IsEnabledProperty::<Impl, OFFSET>,
            TabIndexProperty::<Impl, OFFSET>,
            TabNavigationProperty::<Impl, OFFSET>,
            TemplateProperty::<Impl, OFFSET>,
            PaddingProperty::<Impl, OFFSET>,
            HorizontalContentAlignmentProperty::<Impl, OFFSET>,
            VerticalContentAlignmentProperty::<Impl, OFFSET>,
            BackgroundProperty::<Impl, OFFSET>,
            BorderThicknessProperty::<Impl, OFFSET>,
            BorderBrushProperty::<Impl, OFFSET>,
            DefaultStyleKeyProperty::<Impl, OFFSET>,
            FocusStateProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStatics2Impl: Sized {
    fn IsTextScaleFactorEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStatics2Vtbl {
    pub const fn new<Impl: IControlStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IControlStatics2Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: IControlStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IControlStatics2>, base.5, IsTextScaleFactorEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStatics3Impl: Sized {
    fn UseSystemFocusVisualsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTemplateFocusTargetProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsTemplateFocusTarget(&self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<bool>;
    fn SetIsTemplateFocusTarget(&self, element: &::core::option::Option<super::FrameworkElement>, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStatics3Vtbl {
    pub const fn new<Impl: IControlStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IControlStatics3Vtbl {
        unsafe extern "system" fn UseSystemFocusVisualsProperty<Impl: IControlStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UseSystemFocusVisualsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTemplateFocusTargetProperty<Impl: IControlStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTemplateFocusTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsTemplateFocusTarget<Impl: IControlStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIsTemplateFocusTarget(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTemplateFocusTarget<Impl: IControlStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsTemplateFocusTarget(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IControlStatics3>, base.5, UseSystemFocusVisualsProperty::<Impl, OFFSET>, IsTemplateFocusTargetProperty::<Impl, OFFSET>, GetIsTemplateFocusTarget::<Impl, OFFSET>, SetIsTemplateFocusTarget::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStatics4Impl: Sized {
    fn IsFocusEngagementEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFocusEngagedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RequiresPointerProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusLeftProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusRightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusUpProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusDownProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ElementSoundModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStatics4Vtbl {
    pub const fn new<Impl: IControlStatics4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IControlStatics4Vtbl {
        unsafe extern "system" fn IsFocusEngagementEnabledProperty<Impl: IControlStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFocusEngagementEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFocusEngagedProperty<Impl: IControlStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFocusEngagedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RequiresPointerProperty<Impl: IControlStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RequiresPointerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusLeftProperty<Impl: IControlStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).XYFocusLeftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusRightProperty<Impl: IControlStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).XYFocusRightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusUpProperty<Impl: IControlStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).XYFocusUpProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusDownProperty<Impl: IControlStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).XYFocusDownProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ElementSoundModeProperty<Impl: IControlStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ElementSoundModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IControlStatics4>, base.5, IsFocusEngagementEnabledProperty::<Impl, OFFSET>, IsFocusEngagedProperty::<Impl, OFFSET>, RequiresPointerProperty::<Impl, OFFSET>, XYFocusLeftProperty::<Impl, OFFSET>, XYFocusRightProperty::<Impl, OFFSET>, XYFocusUpProperty::<Impl, OFFSET>, XYFocusDownProperty::<Impl, OFFSET>, ElementSoundModeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStatics5Impl: Sized {
    fn DefaultStyleResourceUriProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTemplateKeyTipTargetProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsTemplateKeyTipTarget(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsTemplateKeyTipTarget(&self, element: &::core::option::Option<super::DependencyObject>, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStatics5Vtbl {
    pub const fn new<Impl: IControlStatics5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IControlStatics5Vtbl {
        unsafe extern "system" fn DefaultStyleResourceUriProperty<Impl: IControlStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultStyleResourceUriProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTemplateKeyTipTargetProperty<Impl: IControlStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTemplateKeyTipTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsTemplateKeyTipTarget<Impl: IControlStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIsTemplateKeyTipTarget(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTemplateKeyTipTarget<Impl: IControlStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsTemplateKeyTipTarget(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IControlStatics5>, base.5, DefaultStyleResourceUriProperty::<Impl, OFFSET>, IsTemplateKeyTipTargetProperty::<Impl, OFFSET>, GetIsTemplateKeyTipTarget::<Impl, OFFSET>, SetIsTemplateKeyTipTarget::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlStatics7Impl: Sized {
    fn BackgroundSizingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlStatics7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlStatics7";
}
#[cfg(feature = "implement_exclusive")]
impl IControlStatics7Vtbl {
    pub const fn new<Impl: IControlStatics7Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IControlStatics7Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IControlStatics7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IControlStatics7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IControlStatics7>, base.5, BackgroundSizingProperty::<Impl, OFFSET>, CornerRadiusProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IControlTemplateImpl: Sized {
    fn TargetType(&self) -> ::windows::core::Result<super::Interop::TypeName>;
    fn SetTargetType(&self, value: &super::Interop::TypeName) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IControlTemplate {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IControlTemplate";
}
#[cfg(feature = "implement_exclusive")]
impl IControlTemplateVtbl {
    pub const fn new<Impl: IControlTemplateImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IControlTemplateVtbl {
        unsafe extern "system" fn TargetType<Impl: IControlTemplateImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<super::Interop::TypeName>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TargetType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTargetType<Impl: IControlTemplateImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<super::Interop::TypeName>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTargetType(&*(&value as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IControlTemplate>, base.5, TargetType::<Impl, OFFSET>, SetTargetType::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDataTemplateSelectorImpl: Sized {
    fn SelectTemplate(&self, item: &::core::option::Option<::windows::core::IInspectable>, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::DataTemplate>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDataTemplateSelector {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDataTemplateSelector";
}
#[cfg(feature = "implement_exclusive")]
impl IDataTemplateSelectorVtbl {
    pub const fn new<Impl: IDataTemplateSelectorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDataTemplateSelectorVtbl {
        unsafe extern "system" fn SelectTemplate<Impl: IDataTemplateSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectTemplate(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDataTemplateSelector>, base.5, SelectTemplate::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDataTemplateSelector2Impl: Sized {
    fn SelectTemplateForItem(&self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DataTemplate>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDataTemplateSelector2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDataTemplateSelector2";
}
#[cfg(feature = "implement_exclusive")]
impl IDataTemplateSelector2Vtbl {
    pub const fn new<Impl: IDataTemplateSelector2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDataTemplateSelector2Vtbl {
        unsafe extern "system" fn SelectTemplateForItem<Impl: IDataTemplateSelector2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectTemplateForItem(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDataTemplateSelector2>, base.5, SelectTemplateForItem::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDataTemplateSelectorFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<DataTemplateSelector>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDataTemplateSelectorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDataTemplateSelectorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IDataTemplateSelectorFactoryVtbl {
    pub const fn new<Impl: IDataTemplateSelectorFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDataTemplateSelectorFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IDataTemplateSelectorFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDataTemplateSelectorFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDataTemplateSelectorOverridesImpl: Sized {
    fn SelectTemplateCore(&self, item: &::core::option::Option<::windows::core::IInspectable>, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::DataTemplate>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDataTemplateSelectorOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDataTemplateSelectorOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IDataTemplateSelectorOverridesVtbl {
    pub const fn new<Impl: IDataTemplateSelectorOverridesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDataTemplateSelectorOverridesVtbl {
        unsafe extern "system" fn SelectTemplateCore<Impl: IDataTemplateSelectorOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectTemplateCore(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDataTemplateSelectorOverrides>, base.5, SelectTemplateCore::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDataTemplateSelectorOverrides2Impl: Sized {
    fn SelectTemplateForItemCore(&self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DataTemplate>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDataTemplateSelectorOverrides2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDataTemplateSelectorOverrides2";
}
#[cfg(feature = "implement_exclusive")]
impl IDataTemplateSelectorOverrides2Vtbl {
    pub const fn new<Impl: IDataTemplateSelectorOverrides2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDataTemplateSelectorOverrides2Vtbl {
        unsafe extern "system" fn SelectTemplateForItemCore<Impl: IDataTemplateSelectorOverrides2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectTemplateForItemCore(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDataTemplateSelectorOverrides2>, base.5, SelectTemplateForItemCore::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickedEventArgsImpl: Sized {
    fn OldDate(&self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn NewDate(&self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickedEventArgsVtbl {
    pub const fn new<Impl: IDatePickedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePickedEventArgsVtbl {
        unsafe extern "system" fn OldDate<Impl: IDatePickedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OldDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewDate<Impl: IDatePickedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NewDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDatePickedEventArgs>, base.5, OldDate::<Impl, OFFSET>, NewDate::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerImpl: Sized {
    fn Header(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn CalendarIdentifier(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCalendarIdentifier(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Date(&self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetDate(&self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn DayVisible(&self) -> ::windows::core::Result<bool>;
    fn SetDayVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn MonthVisible(&self) -> ::windows::core::Result<bool>;
    fn SetMonthVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn YearVisible(&self) -> ::windows::core::Result<bool>;
    fn SetYearVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn DayFormat(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDayFormat(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn MonthFormat(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetMonthFormat(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn YearFormat(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetYearFormat(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn MinYear(&self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMinYear(&self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn MaxYear(&self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMaxYear(&self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn Orientation(&self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&self, value: Orientation) -> ::windows::core::Result<()>;
    fn DateChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<DatePickerValueChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDateChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePicker {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePicker";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerVtbl {
    pub const fn new<Impl: IDatePickerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePickerVtbl {
        unsafe extern "system" fn Header<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CalendarIdentifier<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarIdentifier<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCalendarIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Date<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Date() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDate<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayVisible<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayVisible<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDayVisible(value).into()
        }
        unsafe extern "system" fn MonthVisible<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthVisible<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMonthVisible(value).into()
        }
        unsafe extern "system" fn YearVisible<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).YearVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetYearVisible<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetYearVisible(value).into()
        }
        unsafe extern "system" fn DayFormat<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayFormat<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDayFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MonthFormat<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthFormat<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMonthFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn YearFormat<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).YearFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetYearFormat<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetYearFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinYear<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinYear() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinYear<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMinYear(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxYear<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxYear() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxYear<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxYear(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Orientation<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn DateChanged<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DateChanged(&*(&handler as *const <super::super::super::Foundation::EventHandler<DatePickerValueChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<DatePickerValueChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDateChanged<Impl: IDatePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveDateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IDatePicker>,
            base.5,
            Header::<Impl, OFFSET>,
            SetHeader::<Impl, OFFSET>,
            HeaderTemplate::<Impl, OFFSET>,
            SetHeaderTemplate::<Impl, OFFSET>,
            CalendarIdentifier::<Impl, OFFSET>,
            SetCalendarIdentifier::<Impl, OFFSET>,
            Date::<Impl, OFFSET>,
            SetDate::<Impl, OFFSET>,
            DayVisible::<Impl, OFFSET>,
            SetDayVisible::<Impl, OFFSET>,
            MonthVisible::<Impl, OFFSET>,
            SetMonthVisible::<Impl, OFFSET>,
            YearVisible::<Impl, OFFSET>,
            SetYearVisible::<Impl, OFFSET>,
            DayFormat::<Impl, OFFSET>,
            SetDayFormat::<Impl, OFFSET>,
            MonthFormat::<Impl, OFFSET>,
            SetMonthFormat::<Impl, OFFSET>,
            YearFormat::<Impl, OFFSET>,
            SetYearFormat::<Impl, OFFSET>,
            MinYear::<Impl, OFFSET>,
            SetMinYear::<Impl, OFFSET>,
            MaxYear::<Impl, OFFSET>,
            SetMaxYear::<Impl, OFFSET>,
            Orientation::<Impl, OFFSET>,
            SetOrientation::<Impl, OFFSET>,
            DateChanged::<Impl, OFFSET>,
            RemoveDateChanged::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePicker2Impl: Sized {
    fn LightDismissOverlayMode(&self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePicker2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePicker2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePicker2Vtbl {
    pub const fn new<Impl: IDatePicker2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePicker2Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: IDatePicker2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: IDatePicker2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDatePicker2>, base.5, LightDismissOverlayMode::<Impl, OFFSET>, SetLightDismissOverlayMode::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePicker3Impl: Sized {
    fn SelectedDate(&self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
    fn SetSelectedDate(&self, value: &::core::option::Option<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>) -> ::windows::core::Result<()>;
    fn SelectedDateChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<DatePicker, DatePickerSelectedValueChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectedDateChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePicker3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePicker3";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePicker3Vtbl {
    pub const fn new<Impl: IDatePicker3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePicker3Vtbl {
        unsafe extern "system" fn SelectedDate<Impl: IDatePicker3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedDate<Impl: IDatePicker3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedDate(&*(&value as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedDateChanged<Impl: IDatePicker3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedDateChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<DatePicker, DatePickerSelectedValueChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<DatePicker, DatePickerSelectedValueChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectedDateChanged<Impl: IDatePicker3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSelectedDateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDatePicker3>, base.5, SelectedDate::<Impl, OFFSET>, SetSelectedDate::<Impl, OFFSET>, SelectedDateChanged::<Impl, OFFSET>, RemoveSelectedDateChanged::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<DatePicker>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFactoryVtbl {
    pub const fn new<Impl: IDatePickerFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePickerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IDatePickerFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDatePickerFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutImpl: Sized {
    fn CalendarIdentifier(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCalendarIdentifier(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Date(&self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetDate(&self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn DayVisible(&self) -> ::windows::core::Result<bool>;
    fn SetDayVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn MonthVisible(&self) -> ::windows::core::Result<bool>;
    fn SetMonthVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn YearVisible(&self) -> ::windows::core::Result<bool>;
    fn SetYearVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn MinYear(&self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMinYear(&self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn MaxYear(&self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn SetMaxYear(&self, value: &super::super::super::Foundation::DateTime) -> ::windows::core::Result<()>;
    fn DatePicked(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<DatePickerFlyout, DatePickedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDatePicked(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ShowAtAsync(&self, target: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutVtbl {
    pub const fn new<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePickerFlyoutVtbl {
        unsafe extern "system" fn CalendarIdentifier<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCalendarIdentifier<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCalendarIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Date<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Date() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDate<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDate(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DayVisible<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayVisible<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDayVisible(value).into()
        }
        unsafe extern "system" fn MonthVisible<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthVisible<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMonthVisible(value).into()
        }
        unsafe extern "system" fn YearVisible<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).YearVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetYearVisible<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetYearVisible(value).into()
        }
        unsafe extern "system" fn MinYear<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinYear() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinYear<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMinYear(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxYear<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxYear() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxYear<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxYear(&*(&value as *const <super::super::super::Foundation::DateTime as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::DateTime as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DatePicked<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DatePicked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<DatePickerFlyout, DatePickedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<DatePickerFlyout, DatePickedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDatePicked<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveDatePicked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ShowAtAsync<Impl: IDatePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, target: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowAtAsync(&*(&target as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IDatePickerFlyout>,
            base.5,
            CalendarIdentifier::<Impl, OFFSET>,
            SetCalendarIdentifier::<Impl, OFFSET>,
            Date::<Impl, OFFSET>,
            SetDate::<Impl, OFFSET>,
            DayVisible::<Impl, OFFSET>,
            SetDayVisible::<Impl, OFFSET>,
            MonthVisible::<Impl, OFFSET>,
            SetMonthVisible::<Impl, OFFSET>,
            YearVisible::<Impl, OFFSET>,
            SetYearVisible::<Impl, OFFSET>,
            MinYear::<Impl, OFFSET>,
            SetMinYear::<Impl, OFFSET>,
            MaxYear::<Impl, OFFSET>,
            SetMaxYear::<Impl, OFFSET>,
            DatePicked::<Impl, OFFSET>,
            RemoveDatePicked::<Impl, OFFSET>,
            ShowAtAsync::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyout2Impl: Sized {
    fn DayFormat(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDayFormat(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn MonthFormat(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetMonthFormat(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn YearFormat(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetYearFormat(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyout2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyout2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyout2Vtbl {
    pub const fn new<Impl: IDatePickerFlyout2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePickerFlyout2Vtbl {
        unsafe extern "system" fn DayFormat<Impl: IDatePickerFlyout2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDayFormat<Impl: IDatePickerFlyout2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDayFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MonthFormat<Impl: IDatePickerFlyout2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMonthFormat<Impl: IDatePickerFlyout2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMonthFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn YearFormat<Impl: IDatePickerFlyout2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).YearFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetYearFormat<Impl: IDatePickerFlyout2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetYearFormat(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDatePickerFlyout2>, base.5, DayFormat::<Impl, OFFSET>, SetDayFormat::<Impl, OFFSET>, MonthFormat::<Impl, OFFSET>, SetMonthFormat::<Impl, OFFSET>, YearFormat::<Impl, OFFSET>, SetYearFormat::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutItemImpl: Sized {
    fn PrimaryText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPrimaryText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SecondaryText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSecondaryText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutItem";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutItemVtbl {
    pub const fn new<Impl: IDatePickerFlyoutItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePickerFlyoutItemVtbl {
        unsafe extern "system" fn PrimaryText<Impl: IDatePickerFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrimaryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPrimaryText<Impl: IDatePickerFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPrimaryText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SecondaryText<Impl: IDatePickerFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SecondaryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSecondaryText<Impl: IDatePickerFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSecondaryText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDatePickerFlyoutItem>, base.5, PrimaryText::<Impl, OFFSET>, SetPrimaryText::<Impl, OFFSET>, SecondaryText::<Impl, OFFSET>, SetSecondaryText::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutItemStaticsImpl: Sized {
    fn PrimaryTextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SecondaryTextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutItemStaticsVtbl {
    pub const fn new<Impl: IDatePickerFlyoutItemStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePickerFlyoutItemStaticsVtbl {
        unsafe extern "system" fn PrimaryTextProperty<Impl: IDatePickerFlyoutItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrimaryTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SecondaryTextProperty<Impl: IDatePickerFlyoutItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SecondaryTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDatePickerFlyoutItemStatics>, base.5, PrimaryTextProperty::<Impl, OFFSET>, SecondaryTextProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutPresenterImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutPresenterVtbl {
    pub const fn new<Impl: IDatePickerFlyoutPresenterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePickerFlyoutPresenterVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDatePickerFlyoutPresenter>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutPresenter2Impl: Sized {
    fn IsDefaultShadowEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsDefaultShadowEnabled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenter2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutPresenter2Vtbl {
    pub const fn new<Impl: IDatePickerFlyoutPresenter2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePickerFlyoutPresenter2Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabled<Impl: IDatePickerFlyoutPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDefaultShadowEnabled<Impl: IDatePickerFlyoutPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsDefaultShadowEnabled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDatePickerFlyoutPresenter2>, base.5, IsDefaultShadowEnabled::<Impl, OFFSET>, SetIsDefaultShadowEnabled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutPresenterStatics2Impl: Sized {
    fn IsDefaultShadowEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutPresenterStatics2Vtbl {
    pub const fn new<Impl: IDatePickerFlyoutPresenterStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePickerFlyoutPresenterStatics2Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabledProperty<Impl: IDatePickerFlyoutPresenterStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDatePickerFlyoutPresenterStatics2>, base.5, IsDefaultShadowEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutStaticsImpl: Sized {
    fn CalendarIdentifierProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn YearVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinYearProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxYearProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutStaticsVtbl {
    pub const fn new<Impl: IDatePickerFlyoutStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePickerFlyoutStaticsVtbl {
        unsafe extern "system" fn CalendarIdentifierProperty<Impl: IDatePickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DateProperty<Impl: IDatePickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayVisibleProperty<Impl: IDatePickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthVisibleProperty<Impl: IDatePickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn YearVisibleProperty<Impl: IDatePickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).YearVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinYearProperty<Impl: IDatePickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinYearProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxYearProperty<Impl: IDatePickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxYearProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDatePickerFlyoutStatics>, base.5, CalendarIdentifierProperty::<Impl, OFFSET>, DateProperty::<Impl, OFFSET>, DayVisibleProperty::<Impl, OFFSET>, MonthVisibleProperty::<Impl, OFFSET>, YearVisibleProperty::<Impl, OFFSET>, MinYearProperty::<Impl, OFFSET>, MaxYearProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerFlyoutStatics2Impl: Sized {
    fn DayFormatProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthFormatProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn YearFormatProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerFlyoutStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerFlyoutStatics2Vtbl {
    pub const fn new<Impl: IDatePickerFlyoutStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePickerFlyoutStatics2Vtbl {
        unsafe extern "system" fn DayFormatProperty<Impl: IDatePickerFlyoutStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthFormatProperty<Impl: IDatePickerFlyoutStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn YearFormatProperty<Impl: IDatePickerFlyoutStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).YearFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDatePickerFlyoutStatics2>, base.5, DayFormatProperty::<Impl, OFFSET>, MonthFormatProperty::<Impl, OFFSET>, YearFormatProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerSelectedValueChangedEventArgsImpl: Sized {
    fn OldDate(&self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
    fn NewDate(&self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::DateTime>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerSelectedValueChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerSelectedValueChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerSelectedValueChangedEventArgsVtbl {
    pub const fn new<Impl: IDatePickerSelectedValueChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePickerSelectedValueChangedEventArgsVtbl {
        unsafe extern "system" fn OldDate<Impl: IDatePickerSelectedValueChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OldDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewDate<Impl: IDatePickerSelectedValueChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NewDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDatePickerSelectedValueChangedEventArgs>, base.5, OldDate::<Impl, OFFSET>, NewDate::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerStaticsImpl: Sized {
    fn HeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CalendarIdentifierProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn YearVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DayFormatProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MonthFormatProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn YearFormatProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinYearProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxYearProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerStaticsVtbl {
    pub const fn new<Impl: IDatePickerStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePickerStaticsVtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CalendarIdentifierProperty<Impl: IDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CalendarIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DateProperty<Impl: IDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayVisibleProperty<Impl: IDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthVisibleProperty<Impl: IDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn YearVisibleProperty<Impl: IDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).YearVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DayFormatProperty<Impl: IDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DayFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonthFormatProperty<Impl: IDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonthFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn YearFormatProperty<Impl: IDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).YearFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinYearProperty<Impl: IDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinYearProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxYearProperty<Impl: IDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxYearProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IDatePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IDatePickerStatics>,
            base.5,
            HeaderProperty::<Impl, OFFSET>,
            HeaderTemplateProperty::<Impl, OFFSET>,
            CalendarIdentifierProperty::<Impl, OFFSET>,
            DateProperty::<Impl, OFFSET>,
            DayVisibleProperty::<Impl, OFFSET>,
            MonthVisibleProperty::<Impl, OFFSET>,
            YearVisibleProperty::<Impl, OFFSET>,
            DayFormatProperty::<Impl, OFFSET>,
            MonthFormatProperty::<Impl, OFFSET>,
            YearFormatProperty::<Impl, OFFSET>,
            MinYearProperty::<Impl, OFFSET>,
            MaxYearProperty::<Impl, OFFSET>,
            OrientationProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerStatics2Impl: Sized {
    fn LightDismissOverlayModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerStatics2Vtbl {
    pub const fn new<Impl: IDatePickerStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePickerStatics2Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: IDatePickerStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDatePickerStatics2>, base.5, LightDismissOverlayModeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerStatics3Impl: Sized {
    fn SelectedDateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerStatics3Vtbl {
    pub const fn new<Impl: IDatePickerStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePickerStatics3Vtbl {
        unsafe extern "system" fn SelectedDateProperty<Impl: IDatePickerStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedDateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDatePickerStatics3>, base.5, SelectedDateProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDatePickerValueChangedEventArgsImpl: Sized {
    fn OldDate(&self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
    fn NewDate(&self) -> ::windows::core::Result<super::super::super::Foundation::DateTime>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDatePickerValueChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDatePickerValueChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IDatePickerValueChangedEventArgsVtbl {
    pub const fn new<Impl: IDatePickerValueChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDatePickerValueChangedEventArgsVtbl {
        unsafe extern "system" fn OldDate<Impl: IDatePickerValueChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OldDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewDate<Impl: IDatePickerValueChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::DateTime) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NewDate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDatePickerValueChangedEventArgs>, base.5, OldDate::<Impl, OFFSET>, NewDate::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDragItemsCompletedEventArgsImpl: Sized {
    fn Items(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<::windows::core::IInspectable>>;
    fn DropResult(&self) -> ::windows::core::Result<super::super::super::ApplicationModel::DataTransfer::DataPackageOperation>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDragItemsCompletedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDragItemsCompletedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IDragItemsCompletedEventArgsVtbl {
    pub const fn new<Impl: IDragItemsCompletedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDragItemsCompletedEventArgsVtbl {
        unsafe extern "system" fn Items<Impl: IDragItemsCompletedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DropResult<Impl: IDragItemsCompletedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::ApplicationModel::DataTransfer::DataPackageOperation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DropResult() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDragItemsCompletedEventArgs>, base.5, Items::<Impl, OFFSET>, DropResult::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDragItemsStartingEventArgsImpl: Sized {
    fn Cancel(&self) -> ::windows::core::Result<bool>;
    fn SetCancel(&self, value: bool) -> ::windows::core::Result<()>;
    fn Items(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn Data(&self) -> ::windows::core::Result<super::super::super::ApplicationModel::DataTransfer::DataPackage>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDragItemsStartingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDragItemsStartingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IDragItemsStartingEventArgsVtbl {
    pub const fn new<Impl: IDragItemsStartingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDragItemsStartingEventArgsVtbl {
        unsafe extern "system" fn Cancel<Impl: IDragItemsStartingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: IDragItemsStartingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        unsafe extern "system" fn Items<Impl: IDragItemsStartingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Data<Impl: IDragItemsStartingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Data() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDragItemsStartingEventArgs>, base.5, Cancel::<Impl, OFFSET>, SetCancel::<Impl, OFFSET>, Items::<Impl, OFFSET>, Data::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDropDownButtonImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDropDownButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDropDownButton";
}
#[cfg(feature = "implement_exclusive")]
impl IDropDownButtonVtbl {
    pub const fn new<Impl: IDropDownButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDropDownButtonVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDropDownButton>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDropDownButtonAutomationPeerImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDropDownButtonAutomationPeer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDropDownButtonAutomationPeer";
}
#[cfg(feature = "implement_exclusive")]
impl IDropDownButtonAutomationPeerVtbl {
    pub const fn new<Impl: IDropDownButtonAutomationPeerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDropDownButtonAutomationPeerVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDropDownButtonAutomationPeer>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDropDownButtonAutomationPeerFactoryImpl: Sized {
    fn CreateInstance(&self, owner: &::core::option::Option<DropDownButton>, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<DropDownButtonAutomationPeer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDropDownButtonAutomationPeerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDropDownButtonAutomationPeerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IDropDownButtonAutomationPeerFactoryVtbl {
    pub const fn new<Impl: IDropDownButtonAutomationPeerFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDropDownButtonAutomationPeerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IDropDownButtonAutomationPeerFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, owner: ::windows::core::RawPtr, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&owner as *const <DropDownButton as ::windows::core::Abi>::Abi as *const <DropDownButton as ::windows::core::DefaultType>::DefaultType), &*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDropDownButtonAutomationPeerFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDropDownButtonFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<DropDownButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDropDownButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDropDownButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IDropDownButtonFactoryVtbl {
    pub const fn new<Impl: IDropDownButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDropDownButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IDropDownButtonFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDropDownButtonFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IDynamicOverflowItemsChangingEventArgsImpl: Sized {
    fn Action(&self) -> ::windows::core::Result<CommandBarDynamicOverflowAction>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IDynamicOverflowItemsChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IDynamicOverflowItemsChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IDynamicOverflowItemsChangingEventArgsVtbl {
    pub const fn new<Impl: IDynamicOverflowItemsChangingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDynamicOverflowItemsChangingEventArgsVtbl {
        unsafe extern "system" fn Action<Impl: IDynamicOverflowItemsChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut CommandBarDynamicOverflowAction) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Action() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDynamicOverflowItemsChangingEventArgs>, base.5, Action::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipViewImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipView";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipViewVtbl {
    pub const fn new<Impl: IFlipViewImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFlipViewVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFlipView>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipView2Impl: Sized {
    fn UseTouchAnimationsForAllNavigation(&self) -> ::windows::core::Result<bool>;
    fn SetUseTouchAnimationsForAllNavigation(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipView2";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipView2Vtbl {
    pub const fn new<Impl: IFlipView2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFlipView2Vtbl {
        unsafe extern "system" fn UseTouchAnimationsForAllNavigation<Impl: IFlipView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UseTouchAnimationsForAllNavigation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUseTouchAnimationsForAllNavigation<Impl: IFlipView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetUseTouchAnimationsForAllNavigation(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFlipView2>, base.5, UseTouchAnimationsForAllNavigation::<Impl, OFFSET>, SetUseTouchAnimationsForAllNavigation::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipViewFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<FlipView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipViewFactoryVtbl {
    pub const fn new<Impl: IFlipViewFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFlipViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFlipViewFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFlipViewFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipViewItemImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipViewItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipViewItem";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipViewItemVtbl {
    pub const fn new<Impl: IFlipViewItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFlipViewItemVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFlipViewItem>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipViewItemFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<FlipViewItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipViewItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipViewItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipViewItemFactoryVtbl {
    pub const fn new<Impl: IFlipViewItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFlipViewItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFlipViewItemFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFlipViewItemFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlipViewStatics2Impl: Sized {
    fn UseTouchAnimationsForAllNavigationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlipViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlipViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IFlipViewStatics2Vtbl {
    pub const fn new<Impl: IFlipViewStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFlipViewStatics2Vtbl {
        unsafe extern "system" fn UseTouchAnimationsForAllNavigationProperty<Impl: IFlipViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UseTouchAnimationsForAllNavigationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFlipViewStatics2>, base.5, UseTouchAnimationsForAllNavigationProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutImpl: Sized {
    fn Content(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetContent(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn FlyoutPresenterStyle(&self) -> ::windows::core::Result<super::Style>;
    fn SetFlyoutPresenterStyle(&self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutVtbl {
    pub const fn new<Impl: IFlyoutImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFlyoutVtbl {
        unsafe extern "system" fn Content<Impl: IFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FlyoutPresenterStyle<Impl: IFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FlyoutPresenterStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFlyoutPresenterStyle<Impl: IFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFlyoutPresenterStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFlyout>, base.5, Content::<Impl, OFFSET>, SetContent::<Impl, OFFSET>, FlyoutPresenterStyle::<Impl, OFFSET>, SetFlyoutPresenterStyle::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Flyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutFactoryVtbl {
    pub const fn new<Impl: IFlyoutFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFlyoutFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFlyoutFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFlyoutFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutPresenterImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutPresenterVtbl {
    pub const fn new<Impl: IFlyoutPresenterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFlyoutPresenterVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFlyoutPresenter>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutPresenter2Impl: Sized {
    fn IsDefaultShadowEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsDefaultShadowEnabled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutPresenter2";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutPresenter2Vtbl {
    pub const fn new<Impl: IFlyoutPresenter2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFlyoutPresenter2Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabled<Impl: IFlyoutPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDefaultShadowEnabled<Impl: IFlyoutPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsDefaultShadowEnabled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFlyoutPresenter2>, base.5, IsDefaultShadowEnabled::<Impl, OFFSET>, SetIsDefaultShadowEnabled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutPresenterFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<FlyoutPresenter>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutPresenterFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutPresenterFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutPresenterFactoryVtbl {
    pub const fn new<Impl: IFlyoutPresenterFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFlyoutPresenterFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFlyoutPresenterFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFlyoutPresenterFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutPresenterStatics2Impl: Sized {
    fn IsDefaultShadowEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutPresenterStatics2Vtbl {
    pub const fn new<Impl: IFlyoutPresenterStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFlyoutPresenterStatics2Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabledProperty<Impl: IFlyoutPresenterStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFlyoutPresenterStatics2>, base.5, IsDefaultShadowEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFlyoutStaticsImpl: Sized {
    fn ContentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FlyoutPresenterStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IFlyoutStaticsVtbl {
    pub const fn new<Impl: IFlyoutStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFlyoutStaticsVtbl {
        unsafe extern "system" fn ContentProperty<Impl: IFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FlyoutPresenterStyleProperty<Impl: IFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FlyoutPresenterStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFlyoutStatics>, base.5, ContentProperty::<Impl, OFFSET>, FlyoutPresenterStyleProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFocusDisengagedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFocusDisengagedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFocusDisengagedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IFocusDisengagedEventArgsVtbl {
    pub const fn new<Impl: IFocusDisengagedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFocusDisengagedEventArgsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFocusDisengagedEventArgs>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFocusEngagedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFocusEngagedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFocusEngagedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IFocusEngagedEventArgsVtbl {
    pub const fn new<Impl: IFocusEngagedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFocusEngagedEventArgsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFocusEngagedEventArgs>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFocusEngagedEventArgs2Impl: Sized {
    fn Handled(&self) -> ::windows::core::Result<bool>;
    fn SetHandled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFocusEngagedEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFocusEngagedEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl IFocusEngagedEventArgs2Vtbl {
    pub const fn new<Impl: IFocusEngagedEventArgs2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFocusEngagedEventArgs2Vtbl {
        unsafe extern "system" fn Handled<Impl: IFocusEngagedEventArgs2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IFocusEngagedEventArgs2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFocusEngagedEventArgs2>, base.5, Handled::<Impl, OFFSET>, SetHandled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconImpl: Sized {
    fn Glyph(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetGlyph(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn FontSize(&self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIcon {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIcon";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconVtbl {
    pub const fn new<Impl: IFontIconImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFontIconVtbl {
        unsafe extern "system" fn Glyph<Impl: IFontIconImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Glyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyph<Impl: IFontIconImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontSize<Impl: IFontIconImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: IFontIconImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: IFontIconImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: IFontIconImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: IFontIconImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: IFontIconImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: IFontIconImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: IFontIconImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFontIcon>, base.5, Glyph::<Impl, OFFSET>, SetGlyph::<Impl, OFFSET>, FontSize::<Impl, OFFSET>, SetFontSize::<Impl, OFFSET>, FontFamily::<Impl, OFFSET>, SetFontFamily::<Impl, OFFSET>, FontWeight::<Impl, OFFSET>, SetFontWeight::<Impl, OFFSET>, FontStyle::<Impl, OFFSET>, SetFontStyle::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIcon2Impl: Sized {
    fn IsTextScaleFactorEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIcon2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIcon2";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIcon2Vtbl {
    pub const fn new<Impl: IFontIcon2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFontIcon2Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: IFontIcon2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: IFontIcon2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFontIcon2>, base.5, IsTextScaleFactorEnabled::<Impl, OFFSET>, SetIsTextScaleFactorEnabled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIcon3Impl: Sized {
    fn MirroredWhenRightToLeft(&self) -> ::windows::core::Result<bool>;
    fn SetMirroredWhenRightToLeft(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIcon3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIcon3";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIcon3Vtbl {
    pub const fn new<Impl: IFontIcon3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFontIcon3Vtbl {
        unsafe extern "system" fn MirroredWhenRightToLeft<Impl: IFontIcon3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MirroredWhenRightToLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMirroredWhenRightToLeft<Impl: IFontIcon3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMirroredWhenRightToLeft(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFontIcon3>, base.5, MirroredWhenRightToLeft::<Impl, OFFSET>, SetMirroredWhenRightToLeft::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<FontIcon>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconFactoryVtbl {
    pub const fn new<Impl: IFontIconFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFontIconFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFontIconFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFontIconFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconSourceImpl: Sized {
    fn Glyph(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetGlyph(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn FontSize(&self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn IsTextScaleFactorEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn MirroredWhenRightToLeft(&self) -> ::windows::core::Result<bool>;
    fn SetMirroredWhenRightToLeft(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconSource {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconSource";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconSourceVtbl {
    pub const fn new<Impl: IFontIconSourceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFontIconSourceVtbl {
        unsafe extern "system" fn Glyph<Impl: IFontIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Glyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyph<Impl: IFontIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontSize<Impl: IFontIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: IFontIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: IFontIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: IFontIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: IFontIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: IFontIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: IFontIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: IFontIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: IFontIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: IFontIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        unsafe extern "system" fn MirroredWhenRightToLeft<Impl: IFontIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MirroredWhenRightToLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMirroredWhenRightToLeft<Impl: IFontIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMirroredWhenRightToLeft(value).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IFontIconSource>,
            base.5,
            Glyph::<Impl, OFFSET>,
            SetGlyph::<Impl, OFFSET>,
            FontSize::<Impl, OFFSET>,
            SetFontSize::<Impl, OFFSET>,
            FontFamily::<Impl, OFFSET>,
            SetFontFamily::<Impl, OFFSET>,
            FontWeight::<Impl, OFFSET>,
            SetFontWeight::<Impl, OFFSET>,
            FontStyle::<Impl, OFFSET>,
            SetFontStyle::<Impl, OFFSET>,
            IsTextScaleFactorEnabled::<Impl, OFFSET>,
            SetIsTextScaleFactorEnabled::<Impl, OFFSET>,
            MirroredWhenRightToLeft::<Impl, OFFSET>,
            SetMirroredWhenRightToLeft::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconSourceFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<FontIconSource>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconSourceFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconSourceFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconSourceFactoryVtbl {
    pub const fn new<Impl: IFontIconSourceFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFontIconSourceFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFontIconSourceFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFontIconSourceFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconSourceStaticsImpl: Sized {
    fn GlyphProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontSizeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextScaleFactorEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MirroredWhenRightToLeftProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconSourceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconSourceStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconSourceStaticsVtbl {
    pub const fn new<Impl: IFontIconSourceStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFontIconSourceStaticsVtbl {
        unsafe extern "system" fn GlyphProperty<Impl: IFontIconSourceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontSizeProperty<Impl: IFontIconSourceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: IFontIconSourceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: IFontIconSourceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: IFontIconSourceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: IFontIconSourceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MirroredWhenRightToLeftProperty<Impl: IFontIconSourceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MirroredWhenRightToLeftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFontIconSourceStatics>, base.5, GlyphProperty::<Impl, OFFSET>, FontSizeProperty::<Impl, OFFSET>, FontFamilyProperty::<Impl, OFFSET>, FontWeightProperty::<Impl, OFFSET>, FontStyleProperty::<Impl, OFFSET>, IsTextScaleFactorEnabledProperty::<Impl, OFFSET>, MirroredWhenRightToLeftProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconStaticsImpl: Sized {
    fn GlyphProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontSizeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconStaticsVtbl {
    pub const fn new<Impl: IFontIconStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFontIconStaticsVtbl {
        unsafe extern "system" fn GlyphProperty<Impl: IFontIconStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontSizeProperty<Impl: IFontIconStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: IFontIconStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: IFontIconStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: IFontIconStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFontIconStatics>, base.5, GlyphProperty::<Impl, OFFSET>, FontSizeProperty::<Impl, OFFSET>, FontFamilyProperty::<Impl, OFFSET>, FontWeightProperty::<Impl, OFFSET>, FontStyleProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconStatics2Impl: Sized {
    fn IsTextScaleFactorEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconStatics2Vtbl {
    pub const fn new<Impl: IFontIconStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFontIconStatics2Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: IFontIconStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFontIconStatics2>, base.5, IsTextScaleFactorEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFontIconStatics3Impl: Sized {
    fn MirroredWhenRightToLeftProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFontIconStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFontIconStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IFontIconStatics3Vtbl {
    pub const fn new<Impl: IFontIconStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFontIconStatics3Vtbl {
        unsafe extern "system" fn MirroredWhenRightToLeftProperty<Impl: IFontIconStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MirroredWhenRightToLeftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFontIconStatics3>, base.5, MirroredWhenRightToLeftProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrameImpl: Sized {
    fn CacheSize(&self) -> ::windows::core::Result<i32>;
    fn SetCacheSize(&self, value: i32) -> ::windows::core::Result<()>;
    fn CanGoBack(&self) -> ::windows::core::Result<bool>;
    fn CanGoForward(&self) -> ::windows::core::Result<bool>;
    fn CurrentSourcePageType(&self) -> ::windows::core::Result<super::Interop::TypeName>;
    fn SourcePageType(&self) -> ::windows::core::Result<super::Interop::TypeName>;
    fn SetSourcePageType(&self, value: &super::Interop::TypeName) -> ::windows::core::Result<()>;
    fn BackStackDepth(&self) -> ::windows::core::Result<i32>;
    fn Navigated(&self, handler: &::core::option::Option<super::Navigation::NavigatedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigated(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Navigating(&self, handler: &::core::option::Option<super::Navigation::NavigatingCancelEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigating(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn NavigationFailed(&self, handler: &::core::option::Option<super::Navigation::NavigationFailedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigationFailed(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn NavigationStopped(&self, handler: &::core::option::Option<super::Navigation::NavigationStoppedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigationStopped(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn GoBack(&self) -> ::windows::core::Result<()>;
    fn GoForward(&self) -> ::windows::core::Result<()>;
    fn Navigate(&self, sourcepagetype: &super::Interop::TypeName, parameter: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<bool>;
    fn GetNavigationState(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetNavigationState(&self, navigationstate: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrame {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrame";
}
#[cfg(feature = "implement_exclusive")]
impl IFrameVtbl {
    pub const fn new<Impl: IFrameImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFrameVtbl {
        unsafe extern "system" fn CacheSize<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CacheSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCacheSize<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCacheSize(value).into()
        }
        unsafe extern "system" fn CanGoBack<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanGoBack() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanGoForward<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanGoForward() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentSourcePageType<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<super::Interop::TypeName>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentSourcePageType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourcePageType<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<super::Interop::TypeName>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourcePageType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourcePageType<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<super::Interop::TypeName>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSourcePageType(&*(&value as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BackStackDepth<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackStackDepth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Navigated<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Navigated(&*(&handler as *const <super::Navigation::NavigatedEventHandler as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigatedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigated<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveNavigated(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Navigating<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Navigating(&*(&handler as *const <super::Navigation::NavigatingCancelEventHandler as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigatingCancelEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigating<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveNavigating(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigationFailed<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NavigationFailed(&*(&handler as *const <super::Navigation::NavigationFailedEventHandler as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigationFailedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigationFailed<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveNavigationFailed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigationStopped<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NavigationStopped(&*(&handler as *const <super::Navigation::NavigationStoppedEventHandler as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigationStoppedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigationStopped<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveNavigationStopped(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GoBack<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).GoBack().into()
        }
        unsafe extern "system" fn GoForward<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).GoForward().into()
        }
        unsafe extern "system" fn Navigate<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sourcepagetype: ::core::mem::ManuallyDrop<super::Interop::TypeName>, parameter: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Navigate(&*(&sourcepagetype as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType), &*(&parameter as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNavigationState<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNavigationState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNavigationState<Impl: IFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, navigationstate: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetNavigationState(&*(&navigationstate as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IFrame>,
            base.5,
            CacheSize::<Impl, OFFSET>,
            SetCacheSize::<Impl, OFFSET>,
            CanGoBack::<Impl, OFFSET>,
            CanGoForward::<Impl, OFFSET>,
            CurrentSourcePageType::<Impl, OFFSET>,
            SourcePageType::<Impl, OFFSET>,
            SetSourcePageType::<Impl, OFFSET>,
            BackStackDepth::<Impl, OFFSET>,
            Navigated::<Impl, OFFSET>,
            RemoveNavigated::<Impl, OFFSET>,
            Navigating::<Impl, OFFSET>,
            RemoveNavigating::<Impl, OFFSET>,
            NavigationFailed::<Impl, OFFSET>,
            RemoveNavigationFailed::<Impl, OFFSET>,
            NavigationStopped::<Impl, OFFSET>,
            RemoveNavigationStopped::<Impl, OFFSET>,
            GoBack::<Impl, OFFSET>,
            GoForward::<Impl, OFFSET>,
            Navigate::<Impl, OFFSET>,
            GetNavigationState::<Impl, OFFSET>,
            SetNavigationState::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrame2Impl: Sized {
    fn BackStack(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::Navigation::PageStackEntry>>;
    fn ForwardStack(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::Navigation::PageStackEntry>>;
    fn Navigate(&self, sourcepagetype: &super::Interop::TypeName, parameter: &::core::option::Option<::windows::core::IInspectable>, infooverride: &::core::option::Option<super::Media::Animation::NavigationTransitionInfo>) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrame2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrame2";
}
#[cfg(feature = "implement_exclusive")]
impl IFrame2Vtbl {
    pub const fn new<Impl: IFrame2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFrame2Vtbl {
        unsafe extern "system" fn BackStack<Impl: IFrame2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackStack() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForwardStack<Impl: IFrame2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ForwardStack() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Navigate<Impl: IFrame2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sourcepagetype: ::core::mem::ManuallyDrop<super::Interop::TypeName>, parameter: *mut ::core::ffi::c_void, infooverride: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Navigate(
                &*(&sourcepagetype as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType),
                &*(&parameter as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType),
                &*(&infooverride as *const <super::Media::Animation::NavigationTransitionInfo as ::windows::core::Abi>::Abi as *const <super::Media::Animation::NavigationTransitionInfo as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFrame2>, base.5, BackStack::<Impl, OFFSET>, ForwardStack::<Impl, OFFSET>, Navigate::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrame3Impl: Sized {
    fn GoBack(&self, transitioninfooverride: &::core::option::Option<super::Media::Animation::NavigationTransitionInfo>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrame3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrame3";
}
#[cfg(feature = "implement_exclusive")]
impl IFrame3Vtbl {
    pub const fn new<Impl: IFrame3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFrame3Vtbl {
        unsafe extern "system" fn GoBack<Impl: IFrame3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, transitioninfooverride: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).GoBack(&*(&transitioninfooverride as *const <super::Media::Animation::NavigationTransitionInfo as ::windows::core::Abi>::Abi as *const <super::Media::Animation::NavigationTransitionInfo as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFrame3>, base.5, GoBack::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrame4Impl: Sized {
    fn SetNavigationStateWithNavigationControl(&self, navigationstate: &::windows::core::HSTRING, suppressnavigate: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrame4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrame4";
}
#[cfg(feature = "implement_exclusive")]
impl IFrame4Vtbl {
    pub const fn new<Impl: IFrame4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFrame4Vtbl {
        unsafe extern "system" fn SetNavigationStateWithNavigationControl<Impl: IFrame4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, navigationstate: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, suppressnavigate: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetNavigationStateWithNavigationControl(&*(&navigationstate as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), suppressnavigate).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFrame4>, base.5, SetNavigationStateWithNavigationControl::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrame5Impl: Sized {
    fn IsNavigationStackEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsNavigationStackEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn NavigateToType(&self, sourcepagetype: &super::Interop::TypeName, parameter: &::core::option::Option<::windows::core::IInspectable>, navigationoptions: &::core::option::Option<super::Navigation::FrameNavigationOptions>) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrame5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrame5";
}
#[cfg(feature = "implement_exclusive")]
impl IFrame5Vtbl {
    pub const fn new<Impl: IFrame5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFrame5Vtbl {
        unsafe extern "system" fn IsNavigationStackEnabled<Impl: IFrame5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsNavigationStackEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsNavigationStackEnabled<Impl: IFrame5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsNavigationStackEnabled(value).into()
        }
        unsafe extern "system" fn NavigateToType<Impl: IFrame5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sourcepagetype: ::core::mem::ManuallyDrop<super::Interop::TypeName>, parameter: *mut ::core::ffi::c_void, navigationoptions: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NavigateToType(
                &*(&sourcepagetype as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType),
                &*(&parameter as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType),
                &*(&navigationoptions as *const <super::Navigation::FrameNavigationOptions as ::windows::core::Abi>::Abi as *const <super::Navigation::FrameNavigationOptions as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFrame5>, base.5, IsNavigationStackEnabled::<Impl, OFFSET>, SetIsNavigationStackEnabled::<Impl, OFFSET>, NavigateToType::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrameFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Frame>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrameFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrameFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IFrameFactoryVtbl {
    pub const fn new<Impl: IFrameFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFrameFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IFrameFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFrameFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrameStaticsImpl: Sized {
    fn CacheSizeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanGoBackProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanGoForwardProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CurrentSourcePageTypeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SourcePageTypeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackStackDepthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrameStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrameStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IFrameStaticsVtbl {
    pub const fn new<Impl: IFrameStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFrameStaticsVtbl {
        unsafe extern "system" fn CacheSizeProperty<Impl: IFrameStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CacheSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanGoBackProperty<Impl: IFrameStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanGoBackProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanGoForwardProperty<Impl: IFrameStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanGoForwardProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentSourcePageTypeProperty<Impl: IFrameStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentSourcePageTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourcePageTypeProperty<Impl: IFrameStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourcePageTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackStackDepthProperty<Impl: IFrameStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackStackDepthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFrameStatics>, base.5, CacheSizeProperty::<Impl, OFFSET>, CanGoBackProperty::<Impl, OFFSET>, CanGoForwardProperty::<Impl, OFFSET>, CurrentSourcePageTypeProperty::<Impl, OFFSET>, SourcePageTypeProperty::<Impl, OFFSET>, BackStackDepthProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrameStatics2Impl: Sized {
    fn BackStackProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForwardStackProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrameStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrameStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IFrameStatics2Vtbl {
    pub const fn new<Impl: IFrameStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFrameStatics2Vtbl {
        unsafe extern "system" fn BackStackProperty<Impl: IFrameStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackStackProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForwardStackProperty<Impl: IFrameStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ForwardStackProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFrameStatics2>, base.5, BackStackProperty::<Impl, OFFSET>, ForwardStackProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IFrameStatics5Impl: Sized {
    fn IsNavigationStackEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IFrameStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IFrameStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IFrameStatics5Vtbl {
    pub const fn new<Impl: IFrameStatics5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFrameStatics5Vtbl {
        unsafe extern "system" fn IsNavigationStackEnabledProperty<Impl: IFrameStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsNavigationStackEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFrameStatics5>, base.5, IsNavigationStackEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridImpl: Sized {
    fn RowDefinitions(&self) -> ::windows::core::Result<RowDefinitionCollection>;
    fn ColumnDefinitions(&self) -> ::windows::core::Result<ColumnDefinitionCollection>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGrid {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGrid";
}
#[cfg(feature = "implement_exclusive")]
impl IGridVtbl {
    pub const fn new<Impl: IGridImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGridVtbl {
        unsafe extern "system" fn RowDefinitions<Impl: IGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RowDefinitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ColumnDefinitions<Impl: IGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ColumnDefinitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGrid>, base.5, RowDefinitions::<Impl, OFFSET>, ColumnDefinitions::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGrid2Impl: Sized {
    fn BorderBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CornerRadius(&self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
    fn Padding(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGrid2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGrid2";
}
#[cfg(feature = "implement_exclusive")]
impl IGrid2Vtbl {
    pub const fn new<Impl: IGrid2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGrid2Vtbl {
        unsafe extern "system" fn BorderBrush<Impl: IGrid2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IGrid2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IGrid2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IGrid2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IGrid2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IGrid2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IGrid2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IGrid2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGrid2>, base.5, BorderBrush::<Impl, OFFSET>, SetBorderBrush::<Impl, OFFSET>, BorderThickness::<Impl, OFFSET>, SetBorderThickness::<Impl, OFFSET>, CornerRadius::<Impl, OFFSET>, SetCornerRadius::<Impl, OFFSET>, Padding::<Impl, OFFSET>, SetPadding::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGrid3Impl: Sized {
    fn RowSpacing(&self) -> ::windows::core::Result<f64>;
    fn SetRowSpacing(&self, value: f64) -> ::windows::core::Result<()>;
    fn ColumnSpacing(&self) -> ::windows::core::Result<f64>;
    fn SetColumnSpacing(&self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGrid3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGrid3";
}
#[cfg(feature = "implement_exclusive")]
impl IGrid3Vtbl {
    pub const fn new<Impl: IGrid3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGrid3Vtbl {
        unsafe extern "system" fn RowSpacing<Impl: IGrid3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RowSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRowSpacing<Impl: IGrid3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetRowSpacing(value).into()
        }
        unsafe extern "system" fn ColumnSpacing<Impl: IGrid3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ColumnSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColumnSpacing<Impl: IGrid3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetColumnSpacing(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGrid3>, base.5, RowSpacing::<Impl, OFFSET>, SetRowSpacing::<Impl, OFFSET>, ColumnSpacing::<Impl, OFFSET>, SetColumnSpacing::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGrid4Impl: Sized {
    fn BackgroundSizing(&self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&self, value: BackgroundSizing) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGrid4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGrid4";
}
#[cfg(feature = "implement_exclusive")]
impl IGrid4Vtbl {
    pub const fn new<Impl: IGrid4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGrid4Vtbl {
        unsafe extern "system" fn BackgroundSizing<Impl: IGrid4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IGrid4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGrid4>, base.5, BackgroundSizing::<Impl, OFFSET>, SetBackgroundSizing::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Grid>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGridFactoryVtbl {
    pub const fn new<Impl: IGridFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGridFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGridFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGridFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridStaticsImpl: Sized {
    fn RowProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetRow(&self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<i32>;
    fn SetRow(&self, element: &::core::option::Option<super::FrameworkElement>, value: i32) -> ::windows::core::Result<()>;
    fn ColumnProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetColumn(&self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<i32>;
    fn SetColumn(&self, element: &::core::option::Option<super::FrameworkElement>, value: i32) -> ::windows::core::Result<()>;
    fn RowSpanProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetRowSpan(&self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<i32>;
    fn SetRowSpan(&self, element: &::core::option::Option<super::FrameworkElement>, value: i32) -> ::windows::core::Result<()>;
    fn ColumnSpanProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetColumnSpan(&self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<i32>;
    fn SetColumnSpan(&self, element: &::core::option::Option<super::FrameworkElement>, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IGridStaticsVtbl {
    pub const fn new<Impl: IGridStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGridStaticsVtbl {
        unsafe extern "system" fn RowProperty<Impl: IGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRow<Impl: IGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRow(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRow<Impl: IGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetRow(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn ColumnProperty<Impl: IGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ColumnProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetColumn<Impl: IGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetColumn(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColumn<Impl: IGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetColumn(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn RowSpanProperty<Impl: IGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RowSpanProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRowSpan<Impl: IGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRowSpan(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRowSpan<Impl: IGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetRowSpan(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn ColumnSpanProperty<Impl: IGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ColumnSpanProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetColumnSpan<Impl: IGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetColumnSpan(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColumnSpan<Impl: IGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetColumnSpan(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGridStatics>, base.5, RowProperty::<Impl, OFFSET>, GetRow::<Impl, OFFSET>, SetRow::<Impl, OFFSET>, ColumnProperty::<Impl, OFFSET>, GetColumn::<Impl, OFFSET>, SetColumn::<Impl, OFFSET>, RowSpanProperty::<Impl, OFFSET>, GetRowSpan::<Impl, OFFSET>, SetRowSpan::<Impl, OFFSET>, ColumnSpanProperty::<Impl, OFFSET>, GetColumnSpan::<Impl, OFFSET>, SetColumnSpan::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridStatics2Impl: Sized {
    fn BorderBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IGridStatics2Vtbl {
    pub const fn new<Impl: IGridStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGridStatics2Vtbl {
        unsafe extern "system" fn BorderBrushProperty<Impl: IGridStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IGridStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IGridStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IGridStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGridStatics2>, base.5, BorderBrushProperty::<Impl, OFFSET>, BorderThicknessProperty::<Impl, OFFSET>, CornerRadiusProperty::<Impl, OFFSET>, PaddingProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridStatics3Impl: Sized {
    fn RowSpacingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ColumnSpacingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IGridStatics3Vtbl {
    pub const fn new<Impl: IGridStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGridStatics3Vtbl {
        unsafe extern "system" fn RowSpacingProperty<Impl: IGridStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RowSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ColumnSpacingProperty<Impl: IGridStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ColumnSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGridStatics3>, base.5, RowSpacingProperty::<Impl, OFFSET>, ColumnSpacingProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridStatics4Impl: Sized {
    fn BackgroundSizingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IGridStatics4Vtbl {
    pub const fn new<Impl: IGridStatics4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGridStatics4Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IGridStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGridStatics4>, base.5, BackgroundSizingProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridViewImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridView";
}
#[cfg(feature = "implement_exclusive")]
impl IGridViewVtbl {
    pub const fn new<Impl: IGridViewImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGridViewVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGridView>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridViewFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GridView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGridViewFactoryVtbl {
    pub const fn new<Impl: IGridViewFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGridViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGridViewFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGridViewFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridViewHeaderItemImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridViewHeaderItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridViewHeaderItem";
}
#[cfg(feature = "implement_exclusive")]
impl IGridViewHeaderItemVtbl {
    pub const fn new<Impl: IGridViewHeaderItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGridViewHeaderItemVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGridViewHeaderItem>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridViewHeaderItemFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GridViewHeaderItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridViewHeaderItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridViewHeaderItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGridViewHeaderItemFactoryVtbl {
    pub const fn new<Impl: IGridViewHeaderItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGridViewHeaderItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGridViewHeaderItemFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGridViewHeaderItemFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridViewItemImpl: Sized {
    fn TemplateSettings(&self) -> ::windows::core::Result<Primitives::GridViewItemTemplateSettings>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridViewItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridViewItem";
}
#[cfg(feature = "implement_exclusive")]
impl IGridViewItemVtbl {
    pub const fn new<Impl: IGridViewItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGridViewItemVtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IGridViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGridViewItem>, base.5, TemplateSettings::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGridViewItemFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GridViewItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGridViewItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGridViewItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGridViewItemFactoryVtbl {
    pub const fn new<Impl: IGridViewItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGridViewItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGridViewItemFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGridViewItemFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupItemImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupItem";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupItemVtbl {
    pub const fn new<Impl: IGroupItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGroupItemVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGroupItem>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupItemFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GroupItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupItemFactoryVtbl {
    pub const fn new<Impl: IGroupItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGroupItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGroupItemFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGroupItemFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyleImpl: Sized {
    fn Panel(&self) -> ::windows::core::Result<ItemsPanelTemplate>;
    fn SetPanel(&self, value: &::core::option::Option<ItemsPanelTemplate>) -> ::windows::core::Result<()>;
    fn ContainerStyle(&self) -> ::windows::core::Result<super::Style>;
    fn SetContainerStyle(&self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn ContainerStyleSelector(&self) -> ::windows::core::Result<StyleSelector>;
    fn SetContainerStyleSelector(&self, value: &::core::option::Option<StyleSelector>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn HeaderTemplateSelector(&self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetHeaderTemplateSelector(&self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn HidesIfEmpty(&self) -> ::windows::core::Result<bool>;
    fn SetHidesIfEmpty(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyle {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyle";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyleVtbl {
    pub const fn new<Impl: IGroupStyleImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGroupStyleVtbl {
        unsafe extern "system" fn Panel<Impl: IGroupStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Panel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPanel<Impl: IGroupStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPanel(&*(&value as *const <ItemsPanelTemplate as ::windows::core::Abi>::Abi as *const <ItemsPanelTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContainerStyle<Impl: IGroupStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContainerStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContainerStyle<Impl: IGroupStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContainerStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContainerStyleSelector<Impl: IGroupStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContainerStyleSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContainerStyleSelector<Impl: IGroupStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContainerStyleSelector(&*(&value as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IGroupStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IGroupStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplateSelector<Impl: IGroupStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplateSelector<Impl: IGroupStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HidesIfEmpty<Impl: IGroupStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HidesIfEmpty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHidesIfEmpty<Impl: IGroupStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHidesIfEmpty(value).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IGroupStyle>,
            base.5,
            Panel::<Impl, OFFSET>,
            SetPanel::<Impl, OFFSET>,
            ContainerStyle::<Impl, OFFSET>,
            SetContainerStyle::<Impl, OFFSET>,
            ContainerStyleSelector::<Impl, OFFSET>,
            SetContainerStyleSelector::<Impl, OFFSET>,
            HeaderTemplate::<Impl, OFFSET>,
            SetHeaderTemplate::<Impl, OFFSET>,
            HeaderTemplateSelector::<Impl, OFFSET>,
            SetHeaderTemplateSelector::<Impl, OFFSET>,
            HidesIfEmpty::<Impl, OFFSET>,
            SetHidesIfEmpty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyle2Impl: Sized {
    fn HeaderContainerStyle(&self) -> ::windows::core::Result<super::Style>;
    fn SetHeaderContainerStyle(&self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyle2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyle2";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyle2Vtbl {
    pub const fn new<Impl: IGroupStyle2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGroupStyle2Vtbl {
        unsafe extern "system" fn HeaderContainerStyle<Impl: IGroupStyle2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderContainerStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderContainerStyle<Impl: IGroupStyle2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderContainerStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGroupStyle2>, base.5, HeaderContainerStyle::<Impl, OFFSET>, SetHeaderContainerStyle::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyleFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GroupStyle>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyleFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyleFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyleFactoryVtbl {
    pub const fn new<Impl: IGroupStyleFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGroupStyleFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGroupStyleFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGroupStyleFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyleSelectorImpl: Sized {
    fn SelectGroupStyle(&self, group: &::core::option::Option<::windows::core::IInspectable>, level: u32) -> ::windows::core::Result<GroupStyle>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyleSelector {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyleSelector";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyleSelectorVtbl {
    pub const fn new<Impl: IGroupStyleSelectorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGroupStyleSelectorVtbl {
        unsafe extern "system" fn SelectGroupStyle<Impl: IGroupStyleSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, group: *mut ::core::ffi::c_void, level: u32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectGroupStyle(&*(&group as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), level) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGroupStyleSelector>, base.5, SelectGroupStyle::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyleSelectorFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<GroupStyleSelector>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyleSelectorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyleSelectorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyleSelectorFactoryVtbl {
    pub const fn new<Impl: IGroupStyleSelectorFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGroupStyleSelectorFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IGroupStyleSelectorFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGroupStyleSelectorFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IGroupStyleSelectorOverridesImpl: Sized {
    fn SelectGroupStyleCore(&self, group: &::core::option::Option<::windows::core::IInspectable>, level: u32) -> ::windows::core::Result<GroupStyle>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IGroupStyleSelectorOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IGroupStyleSelectorOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IGroupStyleSelectorOverridesVtbl {
    pub const fn new<Impl: IGroupStyleSelectorOverridesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IGroupStyleSelectorOverridesVtbl {
        unsafe extern "system" fn SelectGroupStyleCore<Impl: IGroupStyleSelectorOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, group: *mut ::core::ffi::c_void, level: u32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectGroupStyleCore(&*(&group as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), level) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IGroupStyleSelectorOverrides>, base.5, SelectGroupStyleCore::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingPanelClosedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingPanelClosedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingPanelClosedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingPanelClosedEventArgsVtbl {
    pub const fn new<Impl: IHandwritingPanelClosedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHandwritingPanelClosedEventArgsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IHandwritingPanelClosedEventArgs>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingPanelOpenedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingPanelOpenedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingPanelOpenedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingPanelOpenedEventArgsVtbl {
    pub const fn new<Impl: IHandwritingPanelOpenedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHandwritingPanelOpenedEventArgsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IHandwritingPanelOpenedEventArgs>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingViewImpl: Sized {
    fn PlacementTarget(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetPlacementTarget(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn PlacementAlignment(&self) -> ::windows::core::Result<HandwritingPanelPlacementAlignment>;
    fn SetPlacementAlignment(&self, value: HandwritingPanelPlacementAlignment) -> ::windows::core::Result<()>;
    fn IsOpen(&self) -> ::windows::core::Result<bool>;
    fn AreCandidatesEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetAreCandidatesEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn Opened(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelOpenedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpened(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Closed(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelClosedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosed(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TryClose(&self) -> ::windows::core::Result<bool>;
    fn TryOpen(&self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingView";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingViewVtbl {
    pub const fn new<Impl: IHandwritingViewImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHandwritingViewVtbl {
        unsafe extern "system" fn PlacementTarget<Impl: IHandwritingViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlacementTarget() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacementTarget<Impl: IHandwritingViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlacementTarget(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlacementAlignment<Impl: IHandwritingViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut HandwritingPanelPlacementAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlacementAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacementAlignment<Impl: IHandwritingViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: HandwritingPanelPlacementAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlacementAlignment(value).into()
        }
        unsafe extern "system" fn IsOpen<Impl: IHandwritingViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AreCandidatesEnabled<Impl: IHandwritingViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AreCandidatesEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreCandidatesEnabled<Impl: IHandwritingViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAreCandidatesEnabled(value).into()
        }
        unsafe extern "system" fn Opened<Impl: IHandwritingViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Opened(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelOpenedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelOpenedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpened<Impl: IHandwritingViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Closed<Impl: IHandwritingViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Closed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelClosedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingPanelClosedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosed<Impl: IHandwritingViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TryClose<Impl: IHandwritingViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TryClose() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TryOpen<Impl: IHandwritingViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TryOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IHandwritingView>,
            base.5,
            PlacementTarget::<Impl, OFFSET>,
            SetPlacementTarget::<Impl, OFFSET>,
            PlacementAlignment::<Impl, OFFSET>,
            SetPlacementAlignment::<Impl, OFFSET>,
            IsOpen::<Impl, OFFSET>,
            AreCandidatesEnabled::<Impl, OFFSET>,
            SetAreCandidatesEnabled::<Impl, OFFSET>,
            Opened::<Impl, OFFSET>,
            RemoveOpened::<Impl, OFFSET>,
            Closed::<Impl, OFFSET>,
            RemoveClosed::<Impl, OFFSET>,
            TryClose::<Impl, OFFSET>,
            TryOpen::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingView2Impl: Sized {
    fn IsSwitchToKeyboardEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsSwitchToKeyboardEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsCommandBarOpen(&self) -> ::windows::core::Result<bool>;
    fn SetIsCommandBarOpen(&self, value: bool) -> ::windows::core::Result<()>;
    fn InputDeviceTypes(&self) -> ::windows::core::Result<super::super::Core::CoreInputDeviceTypes>;
    fn SetInputDeviceTypes(&self, value: super::super::Core::CoreInputDeviceTypes) -> ::windows::core::Result<()>;
    fn CandidatesChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewCandidatesChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCandidatesChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextSubmitted(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewTextSubmittedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextSubmitted(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn GetCandidates(&self, candidatessessionid: u32) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<::windows::core::HSTRING>>;
    fn SelectCandidate(&self, candidatessessionid: u32, selectedcandidateindex: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingView2";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingView2Vtbl {
    pub const fn new<Impl: IHandwritingView2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHandwritingView2Vtbl {
        unsafe extern "system" fn IsSwitchToKeyboardEnabled<Impl: IHandwritingView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSwitchToKeyboardEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSwitchToKeyboardEnabled<Impl: IHandwritingView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsSwitchToKeyboardEnabled(value).into()
        }
        unsafe extern "system" fn IsCommandBarOpen<Impl: IHandwritingView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCommandBarOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCommandBarOpen<Impl: IHandwritingView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsCommandBarOpen(value).into()
        }
        unsafe extern "system" fn InputDeviceTypes<Impl: IHandwritingView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Core::CoreInputDeviceTypes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InputDeviceTypes() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputDeviceTypes<Impl: IHandwritingView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Core::CoreInputDeviceTypes) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetInputDeviceTypes(value).into()
        }
        unsafe extern "system" fn CandidatesChanged<Impl: IHandwritingView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CandidatesChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewCandidatesChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewCandidatesChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCandidatesChanged<Impl: IHandwritingView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveCandidatesChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextSubmitted<Impl: IHandwritingView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextSubmitted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewTextSubmittedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<HandwritingView, HandwritingViewTextSubmittedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextSubmitted<Impl: IHandwritingView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveTextSubmitted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetCandidates<Impl: IHandwritingView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, candidatessessionid: u32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCandidates(candidatessessionid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectCandidate<Impl: IHandwritingView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, candidatessessionid: u32, selectedcandidateindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SelectCandidate(candidatessessionid, selectedcandidateindex).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IHandwritingView2>,
            base.5,
            IsSwitchToKeyboardEnabled::<Impl, OFFSET>,
            SetIsSwitchToKeyboardEnabled::<Impl, OFFSET>,
            IsCommandBarOpen::<Impl, OFFSET>,
            SetIsCommandBarOpen::<Impl, OFFSET>,
            InputDeviceTypes::<Impl, OFFSET>,
            SetInputDeviceTypes::<Impl, OFFSET>,
            CandidatesChanged::<Impl, OFFSET>,
            RemoveCandidatesChanged::<Impl, OFFSET>,
            TextSubmitted::<Impl, OFFSET>,
            RemoveTextSubmitted::<Impl, OFFSET>,
            GetCandidates::<Impl, OFFSET>,
            SelectCandidate::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingViewCandidatesChangedEventArgsImpl: Sized {
    fn CandidatesSessionId(&self) -> ::windows::core::Result<u32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingViewCandidatesChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingViewCandidatesChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingViewCandidatesChangedEventArgsVtbl {
    pub const fn new<Impl: IHandwritingViewCandidatesChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHandwritingViewCandidatesChangedEventArgsVtbl {
        unsafe extern "system" fn CandidatesSessionId<Impl: IHandwritingViewCandidatesChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CandidatesSessionId() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IHandwritingViewCandidatesChangedEventArgs>, base.5, CandidatesSessionId::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingViewFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<HandwritingView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingViewFactoryVtbl {
    pub const fn new<Impl: IHandwritingViewFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHandwritingViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IHandwritingViewFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IHandwritingViewFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingViewStaticsImpl: Sized {
    fn PlacementTargetProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlacementAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsOpenProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AreCandidatesEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingViewStaticsVtbl {
    pub const fn new<Impl: IHandwritingViewStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHandwritingViewStaticsVtbl {
        unsafe extern "system" fn PlacementTargetProperty<Impl: IHandwritingViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlacementTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlacementAlignmentProperty<Impl: IHandwritingViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlacementAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsOpenProperty<Impl: IHandwritingViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AreCandidatesEnabledProperty<Impl: IHandwritingViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AreCandidatesEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IHandwritingViewStatics>, base.5, PlacementTargetProperty::<Impl, OFFSET>, PlacementAlignmentProperty::<Impl, OFFSET>, IsOpenProperty::<Impl, OFFSET>, AreCandidatesEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingViewStatics2Impl: Sized {
    fn IsSwitchToKeyboardEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCommandBarOpenProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingViewStatics2Vtbl {
    pub const fn new<Impl: IHandwritingViewStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHandwritingViewStatics2Vtbl {
        unsafe extern "system" fn IsSwitchToKeyboardEnabledProperty<Impl: IHandwritingViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSwitchToKeyboardEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCommandBarOpenProperty<Impl: IHandwritingViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCommandBarOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IHandwritingViewStatics2>, base.5, IsSwitchToKeyboardEnabledProperty::<Impl, OFFSET>, IsCommandBarOpenProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHandwritingViewTextSubmittedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHandwritingViewTextSubmittedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHandwritingViewTextSubmittedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IHandwritingViewTextSubmittedEventArgsVtbl {
    pub const fn new<Impl: IHandwritingViewTextSubmittedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHandwritingViewTextSubmittedEventArgsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IHandwritingViewTextSubmittedEventArgs>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubImpl: Sized {
    fn Header(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn Orientation(&self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&self, value: Orientation) -> ::windows::core::Result<()>;
    fn DefaultSectionIndex(&self) -> ::windows::core::Result<i32>;
    fn SetDefaultSectionIndex(&self, value: i32) -> ::windows::core::Result<()>;
    fn Sections(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<HubSection>>;
    fn SectionsInView(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<HubSection>>;
    fn SectionHeaders(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<::windows::core::IInspectable>>;
    fn SectionHeaderClick(&self, handler: &::core::option::Option<HubSectionHeaderClickEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSectionHeaderClick(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SectionsInViewChanged(&self, handler: &::core::option::Option<SectionsInViewChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSectionsInViewChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ScrollToSection(&self, section: &::core::option::Option<HubSection>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHub {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHub";
}
#[cfg(feature = "implement_exclusive")]
impl IHubVtbl {
    pub const fn new<Impl: IHubImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHubVtbl {
        unsafe extern "system" fn Header<Impl: IHubImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IHubImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IHubImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IHubImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Orientation<Impl: IHubImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IHubImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn DefaultSectionIndex<Impl: IHubImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultSectionIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultSectionIndex<Impl: IHubImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDefaultSectionIndex(value).into()
        }
        unsafe extern "system" fn Sections<Impl: IHubImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Sections() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SectionsInView<Impl: IHubImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SectionsInView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SectionHeaders<Impl: IHubImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SectionHeaders() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SectionHeaderClick<Impl: IHubImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SectionHeaderClick(&*(&handler as *const <HubSectionHeaderClickEventHandler as ::windows::core::Abi>::Abi as *const <HubSectionHeaderClickEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSectionHeaderClick<Impl: IHubImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSectionHeaderClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SectionsInViewChanged<Impl: IHubImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SectionsInViewChanged(&*(&handler as *const <SectionsInViewChangedEventHandler as ::windows::core::Abi>::Abi as *const <SectionsInViewChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSectionsInViewChanged<Impl: IHubImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSectionsInViewChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ScrollToSection<Impl: IHubImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, section: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ScrollToSection(&*(&section as *const <HubSection as ::windows::core::Abi>::Abi as *const <HubSection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IHub>,
            base.5,
            Header::<Impl, OFFSET>,
            SetHeader::<Impl, OFFSET>,
            HeaderTemplate::<Impl, OFFSET>,
            SetHeaderTemplate::<Impl, OFFSET>,
            Orientation::<Impl, OFFSET>,
            SetOrientation::<Impl, OFFSET>,
            DefaultSectionIndex::<Impl, OFFSET>,
            SetDefaultSectionIndex::<Impl, OFFSET>,
            Sections::<Impl, OFFSET>,
            SectionsInView::<Impl, OFFSET>,
            SectionHeaders::<Impl, OFFSET>,
            SectionHeaderClick::<Impl, OFFSET>,
            RemoveSectionHeaderClick::<Impl, OFFSET>,
            SectionsInViewChanged::<Impl, OFFSET>,
            RemoveSectionsInViewChanged::<Impl, OFFSET>,
            ScrollToSection::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Hub>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IHubFactoryVtbl {
    pub const fn new<Impl: IHubFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHubFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IHubFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IHubFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubSectionImpl: Sized {
    fn Header(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ContentTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetContentTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn IsHeaderInteractive(&self) -> ::windows::core::Result<bool>;
    fn SetIsHeaderInteractive(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubSection {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubSection";
}
#[cfg(feature = "implement_exclusive")]
impl IHubSectionVtbl {
    pub const fn new<Impl: IHubSectionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHubSectionVtbl {
        unsafe extern "system" fn Header<Impl: IHubSectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IHubSectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IHubSectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IHubSectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentTemplate<Impl: IHubSectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentTemplate<Impl: IHubSectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContentTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsHeaderInteractive<Impl: IHubSectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsHeaderInteractive() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHeaderInteractive<Impl: IHubSectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsHeaderInteractive(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IHubSection>, base.5, Header::<Impl, OFFSET>, SetHeader::<Impl, OFFSET>, HeaderTemplate::<Impl, OFFSET>, SetHeaderTemplate::<Impl, OFFSET>, ContentTemplate::<Impl, OFFSET>, SetContentTemplate::<Impl, OFFSET>, IsHeaderInteractive::<Impl, OFFSET>, SetIsHeaderInteractive::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubSectionFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<HubSection>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubSectionFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubSectionFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IHubSectionFactoryVtbl {
    pub const fn new<Impl: IHubSectionFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHubSectionFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IHubSectionFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IHubSectionFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubSectionHeaderClickEventArgsImpl: Sized {
    fn Section(&self) -> ::windows::core::Result<HubSection>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubSectionHeaderClickEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubSectionHeaderClickEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IHubSectionHeaderClickEventArgsVtbl {
    pub const fn new<Impl: IHubSectionHeaderClickEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHubSectionHeaderClickEventArgsVtbl {
        unsafe extern "system" fn Section<Impl: IHubSectionHeaderClickEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Section() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IHubSectionHeaderClickEventArgs>, base.5, Section::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubSectionStaticsImpl: Sized {
    fn HeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHeaderInteractiveProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubSectionStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubSectionStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IHubSectionStaticsVtbl {
    pub const fn new<Impl: IHubSectionStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHubSectionStaticsVtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IHubSectionStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IHubSectionStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentTemplateProperty<Impl: IHubSectionStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHeaderInteractiveProperty<Impl: IHubSectionStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsHeaderInteractiveProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IHubSectionStatics>, base.5, HeaderProperty::<Impl, OFFSET>, HeaderTemplateProperty::<Impl, OFFSET>, ContentTemplateProperty::<Impl, OFFSET>, IsHeaderInteractiveProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHubStaticsImpl: Sized {
    fn HeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DefaultSectionIndexProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SemanticZoomOwnerProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsActiveViewProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomedInViewProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHubStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHubStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IHubStaticsVtbl {
    pub const fn new<Impl: IHubStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHubStaticsVtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IHubStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IHubStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IHubStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultSectionIndexProperty<Impl: IHubStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultSectionIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SemanticZoomOwnerProperty<Impl: IHubStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SemanticZoomOwnerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsActiveViewProperty<Impl: IHubStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsActiveViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomedInViewProperty<Impl: IHubStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsZoomedInViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IHubStatics>, base.5, HeaderProperty::<Impl, OFFSET>, HeaderTemplateProperty::<Impl, OFFSET>, OrientationProperty::<Impl, OFFSET>, DefaultSectionIndexProperty::<Impl, OFFSET>, SemanticZoomOwnerProperty::<Impl, OFFSET>, IsActiveViewProperty::<Impl, OFFSET>, IsZoomedInViewProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHyperlinkButtonImpl: Sized {
    fn NavigateUri(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetNavigateUri(&self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHyperlinkButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHyperlinkButton";
}
#[cfg(feature = "implement_exclusive")]
impl IHyperlinkButtonVtbl {
    pub const fn new<Impl: IHyperlinkButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHyperlinkButtonVtbl {
        unsafe extern "system" fn NavigateUri<Impl: IHyperlinkButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NavigateUri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNavigateUri<Impl: IHyperlinkButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetNavigateUri(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IHyperlinkButton>, base.5, NavigateUri::<Impl, OFFSET>, SetNavigateUri::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHyperlinkButtonFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<HyperlinkButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHyperlinkButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHyperlinkButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IHyperlinkButtonFactoryVtbl {
    pub const fn new<Impl: IHyperlinkButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHyperlinkButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IHyperlinkButtonFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IHyperlinkButtonFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IHyperlinkButtonStaticsImpl: Sized {
    fn NavigateUriProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IHyperlinkButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IHyperlinkButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IHyperlinkButtonStaticsVtbl {
    pub const fn new<Impl: IHyperlinkButtonStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IHyperlinkButtonStaticsVtbl {
        unsafe extern "system" fn NavigateUriProperty<Impl: IHyperlinkButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NavigateUriProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IHyperlinkButtonStatics>, base.5, NavigateUriProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconElementImpl: Sized {
    fn Foreground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconElement";
}
#[cfg(feature = "implement_exclusive")]
impl IIconElementVtbl {
    pub const fn new<Impl: IIconElementImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIconElementVtbl {
        unsafe extern "system" fn Foreground<Impl: IIconElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: IIconElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIconElement>, base.5, Foreground::<Impl, OFFSET>, SetForeground::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconElementFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconElementFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconElementFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IIconElementFactoryVtbl {
    pub const fn new<Impl: IIconElementFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIconElementFactoryVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIconElementFactory>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconElementStaticsImpl: Sized {
    fn ForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconElementStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconElementStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IIconElementStaticsVtbl {
    pub const fn new<Impl: IIconElementStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIconElementStaticsVtbl {
        unsafe extern "system" fn ForegroundProperty<Impl: IIconElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIconElementStatics>, base.5, ForegroundProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconSourceImpl: Sized {
    fn Foreground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconSource {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSource";
}
#[cfg(feature = "implement_exclusive")]
impl IIconSourceVtbl {
    pub const fn new<Impl: IIconSourceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIconSourceVtbl {
        unsafe extern "system" fn Foreground<Impl: IIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: IIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIconSource>, base.5, Foreground::<Impl, OFFSET>, SetForeground::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconSourceElementImpl: Sized {
    fn IconSource(&self) -> ::windows::core::Result<IconSource>;
    fn SetIconSource(&self, value: &::core::option::Option<IconSource>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconSourceElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSourceElement";
}
#[cfg(feature = "implement_exclusive")]
impl IIconSourceElementVtbl {
    pub const fn new<Impl: IIconSourceElementImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIconSourceElementVtbl {
        unsafe extern "system" fn IconSource<Impl: IIconSourceElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IconSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIconSource<Impl: IIconSourceElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIconSource(&*(&value as *const <IconSource as ::windows::core::Abi>::Abi as *const <IconSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIconSourceElement>, base.5, IconSource::<Impl, OFFSET>, SetIconSource::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconSourceElementFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<IconSourceElement>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconSourceElementFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSourceElementFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IIconSourceElementFactoryVtbl {
    pub const fn new<Impl: IIconSourceElementFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIconSourceElementFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IIconSourceElementFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIconSourceElementFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconSourceElementStaticsImpl: Sized {
    fn IconSourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconSourceElementStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSourceElementStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IIconSourceElementStaticsVtbl {
    pub const fn new<Impl: IIconSourceElementStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIconSourceElementStaticsVtbl {
        unsafe extern "system" fn IconSourceProperty<Impl: IIconSourceElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IconSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIconSourceElementStatics>, base.5, IconSourceProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconSourceFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconSourceFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSourceFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IIconSourceFactoryVtbl {
    pub const fn new<Impl: IIconSourceFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIconSourceFactoryVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIconSourceFactory>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIconSourceStaticsImpl: Sized {
    fn ForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIconSourceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIconSourceStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IIconSourceStaticsVtbl {
    pub const fn new<Impl: IIconSourceStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIconSourceStaticsVtbl {
        unsafe extern "system" fn ForegroundProperty<Impl: IIconSourceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIconSourceStatics>, base.5, ForegroundProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IImageImpl: Sized {
    fn Source(&self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetSource(&self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn Stretch(&self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
    fn NineGrid(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetNineGrid(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn PlayToSource(&self) -> ::windows::core::Result<super::super::super::Media::PlayTo::PlayToSource>;
    fn ImageFailed(&self, handler: &::core::option::Option<super::ExceptionRoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveImageFailed(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ImageOpened(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveImageOpened(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IImage {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IImage";
}
#[cfg(feature = "implement_exclusive")]
impl IImageVtbl {
    pub const fn new<Impl: IImageImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IImageVtbl {
        unsafe extern "system" fn Source<Impl: IImageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IImageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stretch<Impl: IImageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: IImageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        unsafe extern "system" fn NineGrid<Impl: IImageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NineGrid() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNineGrid<Impl: IImageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetNineGrid(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlayToSource<Impl: IImageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayToSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ImageFailed<Impl: IImageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ImageFailed(&*(&handler as *const <super::ExceptionRoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::ExceptionRoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveImageFailed<Impl: IImageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveImageFailed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ImageOpened<Impl: IImageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ImageOpened(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveImageOpened<Impl: IImageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveImageOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IImage>, base.5, Source::<Impl, OFFSET>, SetSource::<Impl, OFFSET>, Stretch::<Impl, OFFSET>, SetStretch::<Impl, OFFSET>, NineGrid::<Impl, OFFSET>, SetNineGrid::<Impl, OFFSET>, PlayToSource::<Impl, OFFSET>, ImageFailed::<Impl, OFFSET>, RemoveImageFailed::<Impl, OFFSET>, ImageOpened::<Impl, OFFSET>, RemoveImageOpened::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IImage2Impl: Sized {
    fn GetAsCastingSource(&self) -> ::windows::core::Result<super::super::super::Media::Casting::CastingSource>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IImage2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IImage2";
}
#[cfg(feature = "implement_exclusive")]
impl IImage2Vtbl {
    pub const fn new<Impl: IImage2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IImage2Vtbl {
        unsafe extern "system" fn GetAsCastingSource<Impl: IImage2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAsCastingSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IImage2>, base.5, GetAsCastingSource::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IImage3Impl: Sized {
    fn GetAlphaMask(&self) -> ::windows::core::Result<super::super::Composition::CompositionBrush>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IImage3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IImage3";
}
#[cfg(feature = "implement_exclusive")]
impl IImage3Vtbl {
    pub const fn new<Impl: IImage3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IImage3Vtbl {
        unsafe extern "system" fn GetAlphaMask<Impl: IImage3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlphaMask() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IImage3>, base.5, GetAlphaMask::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IImageStaticsImpl: Sized {
    fn SourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn NineGridProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlayToSourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IImageStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IImageStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IImageStaticsVtbl {
    pub const fn new<Impl: IImageStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IImageStaticsVtbl {
        unsafe extern "system" fn SourceProperty<Impl: IImageStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchProperty<Impl: IImageStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NineGridProperty<Impl: IImageStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NineGridProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayToSourceProperty<Impl: IImageStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayToSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IImageStatics>, base.5, SourceProperty::<Impl, OFFSET>, StretchProperty::<Impl, OFFSET>, NineGridProperty::<Impl, OFFSET>, PlayToSourceProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkCanvasImpl: Sized {
    fn InkPresenter(&self) -> ::windows::core::Result<super::super::Input::Inking::InkPresenter>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkCanvas {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkCanvas";
}
#[cfg(feature = "implement_exclusive")]
impl IInkCanvasVtbl {
    pub const fn new<Impl: IInkCanvasImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkCanvasVtbl {
        unsafe extern "system" fn InkPresenter<Impl: IInkCanvasImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InkPresenter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkCanvas>, base.5, InkPresenter::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkCanvasFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkCanvas>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkCanvasFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkCanvasFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkCanvasFactoryVtbl {
    pub const fn new<Impl: IInkCanvasFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkCanvasFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkCanvasFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkCanvasFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarImpl: Sized {
    fn InitialControls(&self) -> ::windows::core::Result<InkToolbarInitialControls>;
    fn SetInitialControls(&self, value: InkToolbarInitialControls) -> ::windows::core::Result<()>;
    fn Children(&self) -> ::windows::core::Result<super::DependencyObjectCollection>;
    fn ActiveTool(&self) -> ::windows::core::Result<InkToolbarToolButton>;
    fn SetActiveTool(&self, value: &::core::option::Option<InkToolbarToolButton>) -> ::windows::core::Result<()>;
    fn InkDrawingAttributes(&self) -> ::windows::core::Result<super::super::Input::Inking::InkDrawingAttributes>;
    fn IsRulerButtonChecked(&self) -> ::windows::core::Result<bool>;
    fn SetIsRulerButtonChecked(&self, value: bool) -> ::windows::core::Result<()>;
    fn TargetInkCanvas(&self) -> ::windows::core::Result<InkCanvas>;
    fn SetTargetInkCanvas(&self, value: &::core::option::Option<InkCanvas>) -> ::windows::core::Result<()>;
    fn ActiveToolChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveActiveToolChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn InkDrawingAttributesChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveInkDrawingAttributesChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn EraseAllClicked(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveEraseAllClicked(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn IsRulerButtonCheckedChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsRulerButtonCheckedChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn GetToolButton(&self, tool: InkToolbarTool) -> ::windows::core::Result<InkToolbarToolButton>;
    fn GetToggleButton(&self, tool: InkToolbarToggle) -> ::windows::core::Result<InkToolbarToggleButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbar {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbar";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarVtbl {
    pub const fn new<Impl: IInkToolbarImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarVtbl {
        unsafe extern "system" fn InitialControls<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarInitialControls) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitialControls() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInitialControls<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: InkToolbarInitialControls) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetInitialControls(value).into()
        }
        unsafe extern "system" fn Children<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Children() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ActiveTool<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ActiveTool() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetActiveTool<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetActiveTool(&*(&value as *const <InkToolbarToolButton as ::windows::core::Abi>::Abi as *const <InkToolbarToolButton as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn InkDrawingAttributes<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InkDrawingAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRulerButtonChecked<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsRulerButtonChecked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsRulerButtonChecked<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsRulerButtonChecked(value).into()
        }
        unsafe extern "system" fn TargetInkCanvas<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TargetInkCanvas() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTargetInkCanvas<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTargetInkCanvas(&*(&value as *const <InkCanvas as ::windows::core::Abi>::Abi as *const <InkCanvas as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ActiveToolChanged<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ActiveToolChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveActiveToolChanged<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveActiveToolChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn InkDrawingAttributesChanged<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InkDrawingAttributesChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveInkDrawingAttributesChanged<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveInkDrawingAttributesChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn EraseAllClicked<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EraseAllClicked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveEraseAllClicked<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveEraseAllClicked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsRulerButtonCheckedChanged<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsRulerButtonCheckedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsRulerButtonCheckedChanged<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveIsRulerButtonCheckedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetToolButton<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tool: InkToolbarTool, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetToolButton(tool) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetToggleButton<Impl: IInkToolbarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tool: InkToolbarToggle, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetToggleButton(tool) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IInkToolbar>,
            base.5,
            InitialControls::<Impl, OFFSET>,
            SetInitialControls::<Impl, OFFSET>,
            Children::<Impl, OFFSET>,
            ActiveTool::<Impl, OFFSET>,
            SetActiveTool::<Impl, OFFSET>,
            InkDrawingAttributes::<Impl, OFFSET>,
            IsRulerButtonChecked::<Impl, OFFSET>,
            SetIsRulerButtonChecked::<Impl, OFFSET>,
            TargetInkCanvas::<Impl, OFFSET>,
            SetTargetInkCanvas::<Impl, OFFSET>,
            ActiveToolChanged::<Impl, OFFSET>,
            RemoveActiveToolChanged::<Impl, OFFSET>,
            InkDrawingAttributesChanged::<Impl, OFFSET>,
            RemoveInkDrawingAttributesChanged::<Impl, OFFSET>,
            EraseAllClicked::<Impl, OFFSET>,
            RemoveEraseAllClicked::<Impl, OFFSET>,
            IsRulerButtonCheckedChanged::<Impl, OFFSET>,
            RemoveIsRulerButtonCheckedChanged::<Impl, OFFSET>,
            GetToolButton::<Impl, OFFSET>,
            GetToggleButton::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbar2Impl: Sized {
    fn IsStencilButtonChecked(&self) -> ::windows::core::Result<bool>;
    fn SetIsStencilButtonChecked(&self, value: bool) -> ::windows::core::Result<()>;
    fn ButtonFlyoutPlacement(&self) -> ::windows::core::Result<InkToolbarButtonFlyoutPlacement>;
    fn SetButtonFlyoutPlacement(&self, value: InkToolbarButtonFlyoutPlacement) -> ::windows::core::Result<()>;
    fn Orientation(&self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&self, value: Orientation) -> ::windows::core::Result<()>;
    fn IsStencilButtonCheckedChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbar, InkToolbarIsStencilButtonCheckedChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsStencilButtonCheckedChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn GetMenuButton(&self, menu: InkToolbarMenuKind) -> ::windows::core::Result<InkToolbarMenuButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbar2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbar2";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbar2Vtbl {
    pub const fn new<Impl: IInkToolbar2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbar2Vtbl {
        unsafe extern "system" fn IsStencilButtonChecked<Impl: IInkToolbar2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsStencilButtonChecked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsStencilButtonChecked<Impl: IInkToolbar2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsStencilButtonChecked(value).into()
        }
        unsafe extern "system" fn ButtonFlyoutPlacement<Impl: IInkToolbar2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarButtonFlyoutPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ButtonFlyoutPlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetButtonFlyoutPlacement<Impl: IInkToolbar2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: InkToolbarButtonFlyoutPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetButtonFlyoutPlacement(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: IInkToolbar2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IInkToolbar2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn IsStencilButtonCheckedChanged<Impl: IInkToolbar2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsStencilButtonCheckedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, InkToolbarIsStencilButtonCheckedChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbar, InkToolbarIsStencilButtonCheckedChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsStencilButtonCheckedChanged<Impl: IInkToolbar2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveIsStencilButtonCheckedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetMenuButton<Impl: IInkToolbar2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, menu: InkToolbarMenuKind, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMenuButton(menu) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbar2>, base.5, IsStencilButtonChecked::<Impl, OFFSET>, SetIsStencilButtonChecked::<Impl, OFFSET>, ButtonFlyoutPlacement::<Impl, OFFSET>, SetButtonFlyoutPlacement::<Impl, OFFSET>, Orientation::<Impl, OFFSET>, SetOrientation::<Impl, OFFSET>, IsStencilButtonCheckedChanged::<Impl, OFFSET>, RemoveIsStencilButtonCheckedChanged::<Impl, OFFSET>, GetMenuButton::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbar3Impl: Sized {
    fn TargetInkPresenter(&self) -> ::windows::core::Result<super::super::Input::Inking::InkPresenter>;
    fn SetTargetInkPresenter(&self, value: &::core::option::Option<super::super::Input::Inking::InkPresenter>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbar3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbar3";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbar3Vtbl {
    pub const fn new<Impl: IInkToolbar3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbar3Vtbl {
        unsafe extern "system" fn TargetInkPresenter<Impl: IInkToolbar3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TargetInkPresenter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTargetInkPresenter<Impl: IInkToolbar3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTargetInkPresenter(&*(&value as *const <super::super::Input::Inking::InkPresenter as ::windows::core::Abi>::Abi as *const <super::super::Input::Inking::InkPresenter as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbar3>, base.5, TargetInkPresenter::<Impl, OFFSET>, SetTargetInkPresenter::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarBallpointPenButtonImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarBallpointPenButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarBallpointPenButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarBallpointPenButtonVtbl {
    pub const fn new<Impl: IInkToolbarBallpointPenButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarBallpointPenButtonVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarBallpointPenButton>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarBallpointPenButtonFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarBallpointPenButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarBallpointPenButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarBallpointPenButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarBallpointPenButtonFactoryVtbl {
    pub const fn new<Impl: IInkToolbarBallpointPenButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarBallpointPenButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarBallpointPenButtonFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarBallpointPenButtonFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomPenImpl: Sized {
    fn CreateInkDrawingAttributes(&self, brush: &::core::option::Option<super::Media::Brush>, strokewidth: f64) -> ::windows::core::Result<super::super::Input::Inking::InkDrawingAttributes>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomPen {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPen";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomPenVtbl {
    pub const fn new<Impl: IInkToolbarCustomPenImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarCustomPenVtbl {
        unsafe extern "system" fn CreateInkDrawingAttributes<Impl: IInkToolbarCustomPenImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brush: ::windows::core::RawPtr, strokewidth: f64, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInkDrawingAttributes(&*(&brush as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType), strokewidth) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarCustomPen>, base.5, CreateInkDrawingAttributes::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomPenButtonImpl: Sized {
    fn CustomPen(&self) -> ::windows::core::Result<InkToolbarCustomPen>;
    fn SetCustomPen(&self, value: &::core::option::Option<InkToolbarCustomPen>) -> ::windows::core::Result<()>;
    fn ConfigurationContent(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetConfigurationContent(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomPenButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomPenButtonVtbl {
    pub const fn new<Impl: IInkToolbarCustomPenButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarCustomPenButtonVtbl {
        unsafe extern "system" fn CustomPen<Impl: IInkToolbarCustomPenButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CustomPen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCustomPen<Impl: IInkToolbarCustomPenButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCustomPen(&*(&value as *const <InkToolbarCustomPen as ::windows::core::Abi>::Abi as *const <InkToolbarCustomPen as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ConfigurationContent<Impl: IInkToolbarCustomPenButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConfigurationContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetConfigurationContent<Impl: IInkToolbarCustomPenButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetConfigurationContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarCustomPenButton>, base.5, CustomPen::<Impl, OFFSET>, SetCustomPen::<Impl, OFFSET>, ConfigurationContent::<Impl, OFFSET>, SetConfigurationContent::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomPenButtonFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarCustomPenButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomPenButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomPenButtonFactoryVtbl {
    pub const fn new<Impl: IInkToolbarCustomPenButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarCustomPenButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarCustomPenButtonFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarCustomPenButtonFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomPenButtonStaticsImpl: Sized {
    fn CustomPenProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ConfigurationContentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomPenButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomPenButtonStaticsVtbl {
    pub const fn new<Impl: IInkToolbarCustomPenButtonStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarCustomPenButtonStaticsVtbl {
        unsafe extern "system" fn CustomPenProperty<Impl: IInkToolbarCustomPenButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CustomPenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConfigurationContentProperty<Impl: IInkToolbarCustomPenButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConfigurationContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarCustomPenButtonStatics>, base.5, CustomPenProperty::<Impl, OFFSET>, ConfigurationContentProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomPenFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarCustomPen>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomPenFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomPenFactoryVtbl {
    pub const fn new<Impl: IInkToolbarCustomPenFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarCustomPenFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarCustomPenFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarCustomPenFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomPenOverridesImpl: Sized {
    fn CreateInkDrawingAttributesCore(&self, brush: &::core::option::Option<super::Media::Brush>, strokewidth: f64) -> ::windows::core::Result<super::super::Input::Inking::InkDrawingAttributes>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomPenOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomPenOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomPenOverridesVtbl {
    pub const fn new<Impl: IInkToolbarCustomPenOverridesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarCustomPenOverridesVtbl {
        unsafe extern "system" fn CreateInkDrawingAttributesCore<Impl: IInkToolbarCustomPenOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, brush: ::windows::core::RawPtr, strokewidth: f64, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInkDrawingAttributesCore(&*(&brush as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType), strokewidth) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarCustomPenOverrides>, base.5, CreateInkDrawingAttributesCore::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomToggleButtonImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomToggleButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomToggleButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomToggleButtonVtbl {
    pub const fn new<Impl: IInkToolbarCustomToggleButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarCustomToggleButtonVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarCustomToggleButton>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomToggleButtonFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarCustomToggleButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomToggleButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomToggleButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomToggleButtonFactoryVtbl {
    pub const fn new<Impl: IInkToolbarCustomToggleButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarCustomToggleButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarCustomToggleButtonFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarCustomToggleButtonFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomToolButtonImpl: Sized {
    fn ConfigurationContent(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetConfigurationContent(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomToolButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomToolButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomToolButtonVtbl {
    pub const fn new<Impl: IInkToolbarCustomToolButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarCustomToolButtonVtbl {
        unsafe extern "system" fn ConfigurationContent<Impl: IInkToolbarCustomToolButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConfigurationContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetConfigurationContent<Impl: IInkToolbarCustomToolButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetConfigurationContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarCustomToolButton>, base.5, ConfigurationContent::<Impl, OFFSET>, SetConfigurationContent::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomToolButtonFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarCustomToolButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomToolButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomToolButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomToolButtonFactoryVtbl {
    pub const fn new<Impl: IInkToolbarCustomToolButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarCustomToolButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarCustomToolButtonFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarCustomToolButtonFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarCustomToolButtonStaticsImpl: Sized {
    fn ConfigurationContentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarCustomToolButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarCustomToolButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarCustomToolButtonStaticsVtbl {
    pub const fn new<Impl: IInkToolbarCustomToolButtonStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarCustomToolButtonStaticsVtbl {
        unsafe extern "system" fn ConfigurationContentProperty<Impl: IInkToolbarCustomToolButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConfigurationContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarCustomToolButtonStatics>, base.5, ConfigurationContentProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarEraserButtonImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarEraserButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarEraserButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarEraserButtonVtbl {
    pub const fn new<Impl: IInkToolbarEraserButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarEraserButtonVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarEraserButton>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarEraserButton2Impl: Sized {
    fn IsClearAllVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsClearAllVisible(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarEraserButton2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarEraserButton2";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarEraserButton2Vtbl {
    pub const fn new<Impl: IInkToolbarEraserButton2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarEraserButton2Vtbl {
        unsafe extern "system" fn IsClearAllVisible<Impl: IInkToolbarEraserButton2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsClearAllVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsClearAllVisible<Impl: IInkToolbarEraserButton2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsClearAllVisible(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarEraserButton2>, base.5, IsClearAllVisible::<Impl, OFFSET>, SetIsClearAllVisible::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarEraserButtonFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarEraserButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarEraserButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarEraserButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarEraserButtonFactoryVtbl {
    pub const fn new<Impl: IInkToolbarEraserButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarEraserButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarEraserButtonFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarEraserButtonFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarEraserButtonStatics2Impl: Sized {
    fn IsClearAllVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarEraserButtonStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarEraserButtonStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarEraserButtonStatics2Vtbl {
    pub const fn new<Impl: IInkToolbarEraserButtonStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarEraserButtonStatics2Vtbl {
        unsafe extern "system" fn IsClearAllVisibleProperty<Impl: IInkToolbarEraserButtonStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsClearAllVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarEraserButtonStatics2>, base.5, IsClearAllVisibleProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbar>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarFactoryVtbl {
    pub const fn new<Impl: IInkToolbarFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarFlyoutItemImpl: Sized {
    fn Kind(&self) -> ::windows::core::Result<InkToolbarFlyoutItemKind>;
    fn SetKind(&self, value: InkToolbarFlyoutItemKind) -> ::windows::core::Result<()>;
    fn IsChecked(&self) -> ::windows::core::Result<bool>;
    fn SetIsChecked(&self, value: bool) -> ::windows::core::Result<()>;
    fn Checked(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveChecked(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Unchecked(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveUnchecked(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarFlyoutItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarFlyoutItem";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarFlyoutItemVtbl {
    pub const fn new<Impl: IInkToolbarFlyoutItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarFlyoutItemVtbl {
        unsafe extern "system" fn Kind<Impl: IInkToolbarFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarFlyoutItemKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Kind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetKind<Impl: IInkToolbarFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: InkToolbarFlyoutItemKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetKind(value).into()
        }
        unsafe extern "system" fn IsChecked<Impl: IInkToolbarFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsChecked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsChecked<Impl: IInkToolbarFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsChecked(value).into()
        }
        unsafe extern "system" fn Checked<Impl: IInkToolbarFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Checked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveChecked<Impl: IInkToolbarFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveChecked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Unchecked<Impl: IInkToolbarFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Unchecked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<InkToolbarFlyoutItem, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveUnchecked<Impl: IInkToolbarFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveUnchecked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarFlyoutItem>, base.5, Kind::<Impl, OFFSET>, SetKind::<Impl, OFFSET>, IsChecked::<Impl, OFFSET>, SetIsChecked::<Impl, OFFSET>, Checked::<Impl, OFFSET>, RemoveChecked::<Impl, OFFSET>, Unchecked::<Impl, OFFSET>, RemoveUnchecked::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarFlyoutItemFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarFlyoutItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarFlyoutItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarFlyoutItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarFlyoutItemFactoryVtbl {
    pub const fn new<Impl: IInkToolbarFlyoutItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarFlyoutItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarFlyoutItemFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarFlyoutItemFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarFlyoutItemStaticsImpl: Sized {
    fn KindProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCheckedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarFlyoutItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarFlyoutItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarFlyoutItemStaticsVtbl {
    pub const fn new<Impl: IInkToolbarFlyoutItemStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarFlyoutItemStaticsVtbl {
        unsafe extern "system" fn KindProperty<Impl: IInkToolbarFlyoutItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KindProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCheckedProperty<Impl: IInkToolbarFlyoutItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCheckedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarFlyoutItemStatics>, base.5, KindProperty::<Impl, OFFSET>, IsCheckedProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarHighlighterButtonImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarHighlighterButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarHighlighterButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarHighlighterButtonVtbl {
    pub const fn new<Impl: IInkToolbarHighlighterButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarHighlighterButtonVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarHighlighterButton>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarHighlighterButtonFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarHighlighterButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarHighlighterButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarHighlighterButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarHighlighterButtonFactoryVtbl {
    pub const fn new<Impl: IInkToolbarHighlighterButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarHighlighterButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarHighlighterButtonFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarHighlighterButtonFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarIsStencilButtonCheckedChangedEventArgsImpl: Sized {
    fn StencilButton(&self) -> ::windows::core::Result<InkToolbarStencilButton>;
    fn StencilKind(&self) -> ::windows::core::Result<InkToolbarStencilKind>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarIsStencilButtonCheckedChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarIsStencilButtonCheckedChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarIsStencilButtonCheckedChangedEventArgsVtbl {
    pub const fn new<Impl: IInkToolbarIsStencilButtonCheckedChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarIsStencilButtonCheckedChangedEventArgsVtbl {
        unsafe extern "system" fn StencilButton<Impl: IInkToolbarIsStencilButtonCheckedChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StencilButton() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StencilKind<Impl: IInkToolbarIsStencilButtonCheckedChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarStencilKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StencilKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarIsStencilButtonCheckedChangedEventArgs>, base.5, StencilButton::<Impl, OFFSET>, StencilKind::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarMenuButtonImpl: Sized {
    fn MenuKind(&self) -> ::windows::core::Result<InkToolbarMenuKind>;
    fn IsExtensionGlyphShown(&self) -> ::windows::core::Result<bool>;
    fn SetIsExtensionGlyphShown(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarMenuButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarMenuButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarMenuButtonVtbl {
    pub const fn new<Impl: IInkToolbarMenuButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarMenuButtonVtbl {
        unsafe extern "system" fn MenuKind<Impl: IInkToolbarMenuButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarMenuKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExtensionGlyphShown<Impl: IInkToolbarMenuButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsExtensionGlyphShown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsExtensionGlyphShown<Impl: IInkToolbarMenuButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsExtensionGlyphShown(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarMenuButton>, base.5, MenuKind::<Impl, OFFSET>, IsExtensionGlyphShown::<Impl, OFFSET>, SetIsExtensionGlyphShown::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarMenuButtonFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarMenuButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarMenuButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarMenuButtonFactoryVtbl {
    pub const fn new<Impl: IInkToolbarMenuButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarMenuButtonFactoryVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarMenuButtonFactory>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarMenuButtonStaticsImpl: Sized {
    fn IsExtensionGlyphShownProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarMenuButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarMenuButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarMenuButtonStaticsVtbl {
    pub const fn new<Impl: IInkToolbarMenuButtonStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarMenuButtonStaticsVtbl {
        unsafe extern "system" fn IsExtensionGlyphShownProperty<Impl: IInkToolbarMenuButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsExtensionGlyphShownProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarMenuButtonStatics>, base.5, IsExtensionGlyphShownProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPenButtonImpl: Sized {
    fn Palette(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::Media::Brush>>;
    fn SetPalette(&self, value: &::core::option::Option<super::super::super::Foundation::Collections::IVector<super::Media::Brush>>) -> ::windows::core::Result<()>;
    fn MinStrokeWidth(&self) -> ::windows::core::Result<f64>;
    fn SetMinStrokeWidth(&self, value: f64) -> ::windows::core::Result<()>;
    fn MaxStrokeWidth(&self) -> ::windows::core::Result<f64>;
    fn SetMaxStrokeWidth(&self, value: f64) -> ::windows::core::Result<()>;
    fn SelectedBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SelectedBrushIndex(&self) -> ::windows::core::Result<i32>;
    fn SetSelectedBrushIndex(&self, value: i32) -> ::windows::core::Result<()>;
    fn SelectedStrokeWidth(&self) -> ::windows::core::Result<f64>;
    fn SetSelectedStrokeWidth(&self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPenButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPenButtonVtbl {
    pub const fn new<Impl: IInkToolbarPenButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarPenButtonVtbl {
        unsafe extern "system" fn Palette<Impl: IInkToolbarPenButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Palette() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPalette<Impl: IInkToolbarPenButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPalette(&*(&value as *const <super::super::super::Foundation::Collections::IVector<super::Media::Brush> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IVector<super::Media::Brush> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinStrokeWidth<Impl: IInkToolbarPenButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinStrokeWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinStrokeWidth<Impl: IInkToolbarPenButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMinStrokeWidth(value).into()
        }
        unsafe extern "system" fn MaxStrokeWidth<Impl: IInkToolbarPenButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxStrokeWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxStrokeWidth<Impl: IInkToolbarPenButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxStrokeWidth(value).into()
        }
        unsafe extern "system" fn SelectedBrush<Impl: IInkToolbarPenButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedBrushIndex<Impl: IInkToolbarPenButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedBrushIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedBrushIndex<Impl: IInkToolbarPenButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedBrushIndex(value).into()
        }
        unsafe extern "system" fn SelectedStrokeWidth<Impl: IInkToolbarPenButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedStrokeWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedStrokeWidth<Impl: IInkToolbarPenButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedStrokeWidth(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarPenButton>, base.5, Palette::<Impl, OFFSET>, SetPalette::<Impl, OFFSET>, MinStrokeWidth::<Impl, OFFSET>, SetMinStrokeWidth::<Impl, OFFSET>, MaxStrokeWidth::<Impl, OFFSET>, SetMaxStrokeWidth::<Impl, OFFSET>, SelectedBrush::<Impl, OFFSET>, SelectedBrushIndex::<Impl, OFFSET>, SetSelectedBrushIndex::<Impl, OFFSET>, SelectedStrokeWidth::<Impl, OFFSET>, SetSelectedStrokeWidth::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPenButtonFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPenButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPenButtonFactoryVtbl {
    pub const fn new<Impl: IInkToolbarPenButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarPenButtonFactoryVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarPenButtonFactory>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPenButtonStaticsImpl: Sized {
    fn PaletteProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinStrokeWidthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxStrokeWidthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedBrushIndexProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedStrokeWidthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPenButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPenButtonStaticsVtbl {
    pub const fn new<Impl: IInkToolbarPenButtonStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarPenButtonStaticsVtbl {
        unsafe extern "system" fn PaletteProperty<Impl: IInkToolbarPenButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaletteProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinStrokeWidthProperty<Impl: IInkToolbarPenButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinStrokeWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxStrokeWidthProperty<Impl: IInkToolbarPenButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxStrokeWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedBrushProperty<Impl: IInkToolbarPenButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedBrushIndexProperty<Impl: IInkToolbarPenButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedBrushIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedStrokeWidthProperty<Impl: IInkToolbarPenButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedStrokeWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarPenButtonStatics>, base.5, PaletteProperty::<Impl, OFFSET>, MinStrokeWidthProperty::<Impl, OFFSET>, MaxStrokeWidthProperty::<Impl, OFFSET>, SelectedBrushProperty::<Impl, OFFSET>, SelectedBrushIndexProperty::<Impl, OFFSET>, SelectedStrokeWidthProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPenConfigurationControlImpl: Sized {
    fn PenButton(&self) -> ::windows::core::Result<InkToolbarPenButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPenConfigurationControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenConfigurationControl";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPenConfigurationControlVtbl {
    pub const fn new<Impl: IInkToolbarPenConfigurationControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarPenConfigurationControlVtbl {
        unsafe extern "system" fn PenButton<Impl: IInkToolbarPenConfigurationControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PenButton() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarPenConfigurationControl>, base.5, PenButton::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPenConfigurationControlFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarPenConfigurationControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPenConfigurationControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenConfigurationControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPenConfigurationControlFactoryVtbl {
    pub const fn new<Impl: IInkToolbarPenConfigurationControlFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarPenConfigurationControlFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarPenConfigurationControlFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarPenConfigurationControlFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPenConfigurationControlStaticsImpl: Sized {
    fn PenButtonProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPenConfigurationControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPenConfigurationControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPenConfigurationControlStaticsVtbl {
    pub const fn new<Impl: IInkToolbarPenConfigurationControlStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarPenConfigurationControlStaticsVtbl {
        unsafe extern "system" fn PenButtonProperty<Impl: IInkToolbarPenConfigurationControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PenButtonProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarPenConfigurationControlStatics>, base.5, PenButtonProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPencilButtonImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPencilButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPencilButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPencilButtonVtbl {
    pub const fn new<Impl: IInkToolbarPencilButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarPencilButtonVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarPencilButton>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarPencilButtonFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarPencilButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarPencilButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarPencilButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarPencilButtonFactoryVtbl {
    pub const fn new<Impl: IInkToolbarPencilButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarPencilButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarPencilButtonFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarPencilButtonFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
pub trait IInkToolbarRulerButtonImpl: Sized {
    fn Ruler(&self) -> ::windows::core::Result<super::super::Input::Inking::InkPresenterRuler>;
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarRulerButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarRulerButton";
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
impl IInkToolbarRulerButtonVtbl {
    pub const fn new<Impl: IInkToolbarRulerButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarRulerButtonVtbl {
        unsafe extern "system" fn Ruler<Impl: IInkToolbarRulerButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Ruler() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarRulerButton>, base.5, Ruler::<Impl, OFFSET>)
    }
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
pub trait IInkToolbarRulerButtonFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarRulerButton>;
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarRulerButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarRulerButtonFactory";
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
impl IInkToolbarRulerButtonFactoryVtbl {
    pub const fn new<Impl: IInkToolbarRulerButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarRulerButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarRulerButtonFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarRulerButtonFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
pub trait IInkToolbarRulerButtonStaticsImpl: Sized {
    fn RulerProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
impl ::windows::core::RuntimeName for IInkToolbarRulerButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarRulerButtonStatics";
}
#[cfg(all(feature = "deprecated", feature = "implement_exclusive"))]
impl IInkToolbarRulerButtonStaticsVtbl {
    pub const fn new<Impl: IInkToolbarRulerButtonStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarRulerButtonStaticsVtbl {
        unsafe extern "system" fn RulerProperty<Impl: IInkToolbarRulerButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RulerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarRulerButtonStatics>, base.5, RulerProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarStaticsImpl: Sized {
    fn InitialControlsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ChildrenProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ActiveToolProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InkDrawingAttributesProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsRulerButtonCheckedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TargetInkCanvasProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarStaticsVtbl {
    pub const fn new<Impl: IInkToolbarStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarStaticsVtbl {
        unsafe extern "system" fn InitialControlsProperty<Impl: IInkToolbarStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitialControlsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChildrenProperty<Impl: IInkToolbarStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChildrenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ActiveToolProperty<Impl: IInkToolbarStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ActiveToolProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InkDrawingAttributesProperty<Impl: IInkToolbarStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InkDrawingAttributesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRulerButtonCheckedProperty<Impl: IInkToolbarStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsRulerButtonCheckedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TargetInkCanvasProperty<Impl: IInkToolbarStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TargetInkCanvasProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarStatics>, base.5, InitialControlsProperty::<Impl, OFFSET>, ChildrenProperty::<Impl, OFFSET>, ActiveToolProperty::<Impl, OFFSET>, InkDrawingAttributesProperty::<Impl, OFFSET>, IsRulerButtonCheckedProperty::<Impl, OFFSET>, TargetInkCanvasProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarStatics2Impl: Sized {
    fn IsStencilButtonCheckedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ButtonFlyoutPlacementProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarStatics2Vtbl {
    pub const fn new<Impl: IInkToolbarStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarStatics2Vtbl {
        unsafe extern "system" fn IsStencilButtonCheckedProperty<Impl: IInkToolbarStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsStencilButtonCheckedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ButtonFlyoutPlacementProperty<Impl: IInkToolbarStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ButtonFlyoutPlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IInkToolbarStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarStatics2>, base.5, IsStencilButtonCheckedProperty::<Impl, OFFSET>, ButtonFlyoutPlacementProperty::<Impl, OFFSET>, OrientationProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarStatics3Impl: Sized {
    fn TargetInkPresenterProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarStatics3Vtbl {
    pub const fn new<Impl: IInkToolbarStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarStatics3Vtbl {
        unsafe extern "system" fn TargetInkPresenterProperty<Impl: IInkToolbarStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TargetInkPresenterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarStatics3>, base.5, TargetInkPresenterProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarStencilButtonImpl: Sized {
    fn Ruler(&self) -> ::windows::core::Result<super::super::Input::Inking::InkPresenterRuler>;
    fn Protractor(&self) -> ::windows::core::Result<super::super::Input::Inking::InkPresenterProtractor>;
    fn SelectedStencil(&self) -> ::windows::core::Result<InkToolbarStencilKind>;
    fn SetSelectedStencil(&self, value: InkToolbarStencilKind) -> ::windows::core::Result<()>;
    fn IsRulerItemVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsRulerItemVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsProtractorItemVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsProtractorItemVisible(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarStencilButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStencilButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarStencilButtonVtbl {
    pub const fn new<Impl: IInkToolbarStencilButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarStencilButtonVtbl {
        unsafe extern "system" fn Ruler<Impl: IInkToolbarStencilButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Ruler() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Protractor<Impl: IInkToolbarStencilButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Protractor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedStencil<Impl: IInkToolbarStencilButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarStencilKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedStencil() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedStencil<Impl: IInkToolbarStencilButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: InkToolbarStencilKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedStencil(value).into()
        }
        unsafe extern "system" fn IsRulerItemVisible<Impl: IInkToolbarStencilButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsRulerItemVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsRulerItemVisible<Impl: IInkToolbarStencilButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsRulerItemVisible(value).into()
        }
        unsafe extern "system" fn IsProtractorItemVisible<Impl: IInkToolbarStencilButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsProtractorItemVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsProtractorItemVisible<Impl: IInkToolbarStencilButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsProtractorItemVisible(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarStencilButton>, base.5, Ruler::<Impl, OFFSET>, Protractor::<Impl, OFFSET>, SelectedStencil::<Impl, OFFSET>, SetSelectedStencil::<Impl, OFFSET>, IsRulerItemVisible::<Impl, OFFSET>, SetIsRulerItemVisible::<Impl, OFFSET>, IsProtractorItemVisible::<Impl, OFFSET>, SetIsProtractorItemVisible::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarStencilButtonFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<InkToolbarStencilButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarStencilButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStencilButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarStencilButtonFactoryVtbl {
    pub const fn new<Impl: IInkToolbarStencilButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarStencilButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IInkToolbarStencilButtonFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarStencilButtonFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarStencilButtonStaticsImpl: Sized {
    fn RulerProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ProtractorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedStencilProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsRulerItemVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsProtractorItemVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarStencilButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarStencilButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarStencilButtonStaticsVtbl {
    pub const fn new<Impl: IInkToolbarStencilButtonStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarStencilButtonStaticsVtbl {
        unsafe extern "system" fn RulerProperty<Impl: IInkToolbarStencilButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RulerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProtractorProperty<Impl: IInkToolbarStencilButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProtractorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedStencilProperty<Impl: IInkToolbarStencilButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedStencilProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRulerItemVisibleProperty<Impl: IInkToolbarStencilButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsRulerItemVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsProtractorItemVisibleProperty<Impl: IInkToolbarStencilButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsProtractorItemVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarStencilButtonStatics>, base.5, RulerProperty::<Impl, OFFSET>, ProtractorProperty::<Impl, OFFSET>, SelectedStencilProperty::<Impl, OFFSET>, IsRulerItemVisibleProperty::<Impl, OFFSET>, IsProtractorItemVisibleProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarToggleButtonImpl: Sized {
    fn ToggleKind(&self) -> ::windows::core::Result<InkToolbarToggle>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarToggleButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarToggleButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarToggleButtonVtbl {
    pub const fn new<Impl: IInkToolbarToggleButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarToggleButtonVtbl {
        unsafe extern "system" fn ToggleKind<Impl: IInkToolbarToggleButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarToggle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ToggleKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarToggleButton>, base.5, ToggleKind::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarToggleButtonFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarToggleButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarToggleButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarToggleButtonFactoryVtbl {
    pub const fn new<Impl: IInkToolbarToggleButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarToggleButtonFactoryVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarToggleButtonFactory>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarToolButtonImpl: Sized {
    fn ToolKind(&self) -> ::windows::core::Result<InkToolbarTool>;
    fn IsExtensionGlyphShown(&self) -> ::windows::core::Result<bool>;
    fn SetIsExtensionGlyphShown(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarToolButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarToolButton";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarToolButtonVtbl {
    pub const fn new<Impl: IInkToolbarToolButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarToolButtonVtbl {
        unsafe extern "system" fn ToolKind<Impl: IInkToolbarToolButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut InkToolbarTool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ToolKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExtensionGlyphShown<Impl: IInkToolbarToolButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsExtensionGlyphShown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsExtensionGlyphShown<Impl: IInkToolbarToolButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsExtensionGlyphShown(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarToolButton>, base.5, ToolKind::<Impl, OFFSET>, IsExtensionGlyphShown::<Impl, OFFSET>, SetIsExtensionGlyphShown::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarToolButtonFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarToolButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarToolButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarToolButtonFactoryVtbl {
    pub const fn new<Impl: IInkToolbarToolButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarToolButtonFactoryVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarToolButtonFactory>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IInkToolbarToolButtonStaticsImpl: Sized {
    fn IsExtensionGlyphShownProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IInkToolbarToolButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInkToolbarToolButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IInkToolbarToolButtonStaticsVtbl {
    pub const fn new<Impl: IInkToolbarToolButtonStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInkToolbarToolButtonStaticsVtbl {
        unsafe extern "system" fn IsExtensionGlyphShownProperty<Impl: IInkToolbarToolButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsExtensionGlyphShownProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInkToolbarToolButtonStatics>, base.5, IsExtensionGlyphShownProperty::<Impl, OFFSET>)
    }
}
pub trait IInsertionPanelImpl: Sized {
    fn GetInsertionIndexes(&self, position: &super::super::super::Foundation::Point, first: &mut i32, second: &mut i32) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IInsertionPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IInsertionPanel";
}
impl IInsertionPanelVtbl {
    pub const fn new<Impl: IInsertionPanelImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IInsertionPanelVtbl {
        unsafe extern "system" fn GetInsertionIndexes<Impl: IInsertionPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, position: super::super::super::Foundation::Point, first: *mut i32, second: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).GetInsertionIndexes(&*(&position as *const <super::super::super::Foundation::Point as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Point as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&first), ::core::mem::transmute_copy(&second)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IInsertionPanel>, base.5, GetInsertionIndexes::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IIsTextTrimmedChangedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IIsTextTrimmedChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IIsTextTrimmedChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IIsTextTrimmedChangedEventArgsVtbl {
    pub const fn new<Impl: IIsTextTrimmedChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IIsTextTrimmedChangedEventArgsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IIsTextTrimmedChangedEventArgs>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemClickEventArgsImpl: Sized {
    fn ClickedItem(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemClickEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemClickEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IItemClickEventArgsVtbl {
    pub const fn new<Impl: IItemClickEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemClickEventArgsVtbl {
        unsafe extern "system" fn ClickedItem<Impl: IItemClickEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ClickedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IItemClickEventArgs>, base.5, ClickedItem::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemContainerGeneratorImpl: Sized {
    fn ItemsChanged(&self, handler: &::core::option::Option<Primitives::ItemsChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveItemsChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ItemFromContainer(&self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn ContainerFromItem(&self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DependencyObject>;
    fn IndexFromContainer(&self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<i32>;
    fn ContainerFromIndex(&self, index: i32) -> ::windows::core::Result<super::DependencyObject>;
    fn GetItemContainerGeneratorForPanel(&self, panel: &::core::option::Option<Panel>) -> ::windows::core::Result<ItemContainerGenerator>;
    fn StartAt(&self, position: &Primitives::GeneratorPosition, direction: Primitives::GeneratorDirection, allowstartatrealizeditem: bool) -> ::windows::core::Result<()>;
    fn Stop(&self) -> ::windows::core::Result<()>;
    fn GenerateNext(&self, isnewlyrealized: &mut bool) -> ::windows::core::Result<super::DependencyObject>;
    fn PrepareItemContainer(&self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn RemoveAll(&self) -> ::windows::core::Result<()>;
    fn Remove(&self, position: &Primitives::GeneratorPosition, count: i32) -> ::windows::core::Result<()>;
    fn GeneratorPositionFromIndex(&self, itemindex: i32) -> ::windows::core::Result<Primitives::GeneratorPosition>;
    fn IndexFromGeneratorPosition(&self, position: &Primitives::GeneratorPosition) -> ::windows::core::Result<i32>;
    fn Recycle(&self, position: &Primitives::GeneratorPosition, count: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemContainerGenerator {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemContainerGenerator";
}
#[cfg(feature = "implement_exclusive")]
impl IItemContainerGeneratorVtbl {
    pub const fn new<Impl: IItemContainerGeneratorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemContainerGeneratorVtbl {
        unsafe extern "system" fn ItemsChanged<Impl: IItemContainerGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemsChanged(&*(&handler as *const <Primitives::ItemsChangedEventHandler as ::windows::core::Abi>::Abi as *const <Primitives::ItemsChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveItemsChanged<Impl: IItemContainerGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveItemsChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemFromContainer<Impl: IItemContainerGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromItem<Impl: IItemContainerGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContainerFromItem(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IndexFromContainer<Impl: IItemContainerGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IndexFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromIndex<Impl: IItemContainerGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: i32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContainerFromIndex(index) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetItemContainerGeneratorForPanel<Impl: IItemContainerGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, panel: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetItemContainerGeneratorForPanel(&*(&panel as *const <Panel as ::windows::core::Abi>::Abi as *const <Panel as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StartAt<Impl: IItemContainerGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, position: Primitives::GeneratorPosition, direction: Primitives::GeneratorDirection, allowstartatrealizeditem: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).StartAt(&*(&position as *const <Primitives::GeneratorPosition as ::windows::core::Abi>::Abi as *const <Primitives::GeneratorPosition as ::windows::core::DefaultType>::DefaultType), direction, allowstartatrealizeditem).into()
        }
        unsafe extern "system" fn Stop<Impl: IItemContainerGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn GenerateNext<Impl: IItemContainerGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, isnewlyrealized: *mut bool, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GenerateNext(::core::mem::transmute_copy(&isnewlyrealized)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrepareItemContainer<Impl: IItemContainerGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).PrepareItemContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RemoveAll<Impl: IItemContainerGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveAll().into()
        }
        unsafe extern "system" fn Remove<Impl: IItemContainerGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, position: Primitives::GeneratorPosition, count: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Remove(&*(&position as *const <Primitives::GeneratorPosition as ::windows::core::Abi>::Abi as *const <Primitives::GeneratorPosition as ::windows::core::DefaultType>::DefaultType), count).into()
        }
        unsafe extern "system" fn GeneratorPositionFromIndex<Impl: IItemContainerGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, itemindex: i32, result__: *mut Primitives::GeneratorPosition) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GeneratorPositionFromIndex(itemindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IndexFromGeneratorPosition<Impl: IItemContainerGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, position: Primitives::GeneratorPosition, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IndexFromGeneratorPosition(&*(&position as *const <Primitives::GeneratorPosition as ::windows::core::Abi>::Abi as *const <Primitives::GeneratorPosition as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Recycle<Impl: IItemContainerGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, position: Primitives::GeneratorPosition, count: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Recycle(&*(&position as *const <Primitives::GeneratorPosition as ::windows::core::Abi>::Abi as *const <Primitives::GeneratorPosition as ::windows::core::DefaultType>::DefaultType), count).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IItemContainerGenerator>,
            base.5,
            ItemsChanged::<Impl, OFFSET>,
            RemoveItemsChanged::<Impl, OFFSET>,
            ItemFromContainer::<Impl, OFFSET>,
            ContainerFromItem::<Impl, OFFSET>,
            IndexFromContainer::<Impl, OFFSET>,
            ContainerFromIndex::<Impl, OFFSET>,
            GetItemContainerGeneratorForPanel::<Impl, OFFSET>,
            StartAt::<Impl, OFFSET>,
            Stop::<Impl, OFFSET>,
            GenerateNext::<Impl, OFFSET>,
            PrepareItemContainer::<Impl, OFFSET>,
            RemoveAll::<Impl, OFFSET>,
            Remove::<Impl, OFFSET>,
            GeneratorPositionFromIndex::<Impl, OFFSET>,
            IndexFromGeneratorPosition::<Impl, OFFSET>,
            Recycle::<Impl, OFFSET>,
        )
    }
}
pub trait IItemContainerMappingImpl: Sized {
    fn ItemFromContainer(&self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn ContainerFromItem(&self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DependencyObject>;
    fn IndexFromContainer(&self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<i32>;
    fn ContainerFromIndex(&self, index: i32) -> ::windows::core::Result<super::DependencyObject>;
}
impl ::windows::core::RuntimeName for IItemContainerMapping {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemContainerMapping";
}
impl IItemContainerMappingVtbl {
    pub const fn new<Impl: IItemContainerMappingImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemContainerMappingVtbl {
        unsafe extern "system" fn ItemFromContainer<Impl: IItemContainerMappingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromItem<Impl: IItemContainerMappingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContainerFromItem(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IndexFromContainer<Impl: IItemContainerMappingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IndexFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromIndex<Impl: IItemContainerMappingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: i32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContainerFromIndex(index) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IItemContainerMapping>, base.5, ItemFromContainer::<Impl, OFFSET>, ContainerFromItem::<Impl, OFFSET>, IndexFromContainer::<Impl, OFFSET>, ContainerFromIndex::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsControlImpl: Sized {
    fn ItemsSource(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetItemsSource(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn Items(&self) -> ::windows::core::Result<ItemCollection>;
    fn ItemTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetItemTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ItemTemplateSelector(&self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetItemTemplateSelector(&self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn ItemsPanel(&self) -> ::windows::core::Result<ItemsPanelTemplate>;
    fn SetItemsPanel(&self, value: &::core::option::Option<ItemsPanelTemplate>) -> ::windows::core::Result<()>;
    fn DisplayMemberPath(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDisplayMemberPath(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn ItemContainerStyle(&self) -> ::windows::core::Result<super::Style>;
    fn SetItemContainerStyle(&self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn ItemContainerStyleSelector(&self) -> ::windows::core::Result<StyleSelector>;
    fn SetItemContainerStyleSelector(&self, value: &::core::option::Option<StyleSelector>) -> ::windows::core::Result<()>;
    fn ItemContainerGenerator(&self) -> ::windows::core::Result<ItemContainerGenerator>;
    fn ItemContainerTransitions(&self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetItemContainerTransitions(&self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
    fn GroupStyle(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IObservableVector<GroupStyle>>;
    fn GroupStyleSelector(&self) -> ::windows::core::Result<GroupStyleSelector>;
    fn SetGroupStyleSelector(&self, value: &::core::option::Option<GroupStyleSelector>) -> ::windows::core::Result<()>;
    fn IsGrouping(&self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControl";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsControlVtbl {
    pub const fn new<Impl: IItemsControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsControlVtbl {
        unsafe extern "system" fn ItemsSource<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemsSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsSource<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemsSource(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Items<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplate<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemTemplate<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemTemplateSelector<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemTemplateSelector<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemsPanel<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemsPanel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsPanel<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemsPanel(&*(&value as *const <ItemsPanelTemplate as ::windows::core::Abi>::Abi as *const <ItemsPanelTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisplayMemberPath<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayMemberPath() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayMemberPath<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDisplayMemberPath(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerStyle<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerStyle<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemContainerStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerStyleSelector<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerStyleSelector<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemContainerStyleSelector(&*(&value as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerGenerator<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemContainerGenerator() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerTransitions<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemContainerTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerTransitions<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemContainerTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GroupStyle<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GroupStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupStyleSelector<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GroupStyleSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupStyleSelector<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetGroupStyleSelector(&*(&value as *const <GroupStyleSelector as ::windows::core::Abi>::Abi as *const <GroupStyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsGrouping<Impl: IItemsControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsGrouping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IItemsControl>,
            base.5,
            ItemsSource::<Impl, OFFSET>,
            SetItemsSource::<Impl, OFFSET>,
            Items::<Impl, OFFSET>,
            ItemTemplate::<Impl, OFFSET>,
            SetItemTemplate::<Impl, OFFSET>,
            ItemTemplateSelector::<Impl, OFFSET>,
            SetItemTemplateSelector::<Impl, OFFSET>,
            ItemsPanel::<Impl, OFFSET>,
            SetItemsPanel::<Impl, OFFSET>,
            DisplayMemberPath::<Impl, OFFSET>,
            SetDisplayMemberPath::<Impl, OFFSET>,
            ItemContainerStyle::<Impl, OFFSET>,
            SetItemContainerStyle::<Impl, OFFSET>,
            ItemContainerStyleSelector::<Impl, OFFSET>,
            SetItemContainerStyleSelector::<Impl, OFFSET>,
            ItemContainerGenerator::<Impl, OFFSET>,
            ItemContainerTransitions::<Impl, OFFSET>,
            SetItemContainerTransitions::<Impl, OFFSET>,
            GroupStyle::<Impl, OFFSET>,
            GroupStyleSelector::<Impl, OFFSET>,
            SetGroupStyleSelector::<Impl, OFFSET>,
            IsGrouping::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsControl2Impl: Sized {
    fn ItemsPanelRoot(&self) -> ::windows::core::Result<Panel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsControl2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControl2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsControl2Vtbl {
    pub const fn new<Impl: IItemsControl2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsControl2Vtbl {
        unsafe extern "system" fn ItemsPanelRoot<Impl: IItemsControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemsPanelRoot() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IItemsControl2>, base.5, ItemsPanelRoot::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsControl3Impl: Sized {
    fn GroupHeaderContainerFromItemContainer(&self, itemcontainer: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::DependencyObject>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsControl3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControl3";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsControl3Vtbl {
    pub const fn new<Impl: IItemsControl3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsControl3Vtbl {
        unsafe extern "system" fn GroupHeaderContainerFromItemContainer<Impl: IItemsControl3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, itemcontainer: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GroupHeaderContainerFromItemContainer(&*(&itemcontainer as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IItemsControl3>, base.5, GroupHeaderContainerFromItemContainer::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsControlFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ItemsControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsControlFactoryVtbl {
    pub const fn new<Impl: IItemsControlFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsControlFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IItemsControlFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IItemsControlFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsControlOverridesImpl: Sized {
    fn IsItemItsOwnContainerOverride(&self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<bool>;
    fn GetContainerForItemOverride(&self) -> ::windows::core::Result<super::DependencyObject>;
    fn ClearContainerForItemOverride(&self, element: &::core::option::Option<super::DependencyObject>, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn PrepareContainerForItemOverride(&self, element: &::core::option::Option<super::DependencyObject>, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnItemsChanged(&self, e: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnItemContainerStyleChanged(&self, olditemcontainerstyle: &::core::option::Option<super::Style>, newitemcontainerstyle: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn OnItemContainerStyleSelectorChanged(&self, olditemcontainerstyleselector: &::core::option::Option<StyleSelector>, newitemcontainerstyleselector: &::core::option::Option<StyleSelector>) -> ::windows::core::Result<()>;
    fn OnItemTemplateChanged(&self, olditemtemplate: &::core::option::Option<super::DataTemplate>, newitemtemplate: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn OnItemTemplateSelectorChanged(&self, olditemtemplateselector: &::core::option::Option<DataTemplateSelector>, newitemtemplateselector: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn OnGroupStyleSelectorChanged(&self, oldgroupstyleselector: &::core::option::Option<GroupStyleSelector>, newgroupstyleselector: &::core::option::Option<GroupStyleSelector>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsControlOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControlOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsControlOverridesVtbl {
    pub const fn new<Impl: IItemsControlOverridesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsControlOverridesVtbl {
        unsafe extern "system" fn IsItemItsOwnContainerOverride<Impl: IItemsControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsItemItsOwnContainerOverride(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetContainerForItemOverride<Impl: IItemsControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetContainerForItemOverride() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClearContainerForItemOverride<Impl: IItemsControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, item: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ClearContainerForItemOverride(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), &*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrepareContainerForItemOverride<Impl: IItemsControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, item: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).PrepareContainerForItemOverride(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), &*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnItemsChanged<Impl: IItemsControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnItemsChanged(&*(&e as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnItemContainerStyleChanged<Impl: IItemsControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, olditemcontainerstyle: ::windows::core::RawPtr, newitemcontainerstyle: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnItemContainerStyleChanged(&*(&olditemcontainerstyle as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType), &*(&newitemcontainerstyle as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnItemContainerStyleSelectorChanged<Impl: IItemsControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, olditemcontainerstyleselector: ::windows::core::RawPtr, newitemcontainerstyleselector: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnItemContainerStyleSelectorChanged(&*(&olditemcontainerstyleselector as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType), &*(&newitemcontainerstyleselector as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnItemTemplateChanged<Impl: IItemsControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, olditemtemplate: ::windows::core::RawPtr, newitemtemplate: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnItemTemplateChanged(&*(&olditemtemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType), &*(&newitemtemplate as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnItemTemplateSelectorChanged<Impl: IItemsControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, olditemtemplateselector: ::windows::core::RawPtr, newitemtemplateselector: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnItemTemplateSelectorChanged(&*(&olditemtemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType), &*(&newitemtemplateselector as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnGroupStyleSelectorChanged<Impl: IItemsControlOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, oldgroupstyleselector: ::windows::core::RawPtr, newgroupstyleselector: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnGroupStyleSelectorChanged(&*(&oldgroupstyleselector as *const <GroupStyleSelector as ::windows::core::Abi>::Abi as *const <GroupStyleSelector as ::windows::core::DefaultType>::DefaultType), &*(&newgroupstyleselector as *const <GroupStyleSelector as ::windows::core::Abi>::Abi as *const <GroupStyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IItemsControlOverrides>,
            base.5,
            IsItemItsOwnContainerOverride::<Impl, OFFSET>,
            GetContainerForItemOverride::<Impl, OFFSET>,
            ClearContainerForItemOverride::<Impl, OFFSET>,
            PrepareContainerForItemOverride::<Impl, OFFSET>,
            OnItemsChanged::<Impl, OFFSET>,
            OnItemContainerStyleChanged::<Impl, OFFSET>,
            OnItemContainerStyleSelectorChanged::<Impl, OFFSET>,
            OnItemTemplateChanged::<Impl, OFFSET>,
            OnItemTemplateSelectorChanged::<Impl, OFFSET>,
            OnGroupStyleSelectorChanged::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsControlStaticsImpl: Sized {
    fn ItemsSourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemTemplateSelectorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemsPanelProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayMemberPathProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerStyleSelectorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerTransitionsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GroupStyleSelectorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsGroupingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetItemsOwner(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ItemsControl>;
    fn ItemsControlFromItemContainer(&self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ItemsControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsControlStaticsVtbl {
    pub const fn new<Impl: IItemsControlStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsControlStaticsVtbl {
        unsafe extern "system" fn ItemsSourceProperty<Impl: IItemsControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemsSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplateProperty<Impl: IItemsControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplateSelectorProperty<Impl: IItemsControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemTemplateSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsPanelProperty<Impl: IItemsControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemsPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayMemberPathProperty<Impl: IItemsControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayMemberPathProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerStyleProperty<Impl: IItemsControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerStyleSelectorProperty<Impl: IItemsControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerTransitionsProperty<Impl: IItemsControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemContainerTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupStyleSelectorProperty<Impl: IItemsControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GroupStyleSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsGroupingProperty<Impl: IItemsControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsGroupingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetItemsOwner<Impl: IItemsControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetItemsOwner(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsControlFromItemContainer<Impl: IItemsControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemsControlFromItemContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IItemsControlStatics>,
            base.5,
            ItemsSourceProperty::<Impl, OFFSET>,
            ItemTemplateProperty::<Impl, OFFSET>,
            ItemTemplateSelectorProperty::<Impl, OFFSET>,
            ItemsPanelProperty::<Impl, OFFSET>,
            DisplayMemberPathProperty::<Impl, OFFSET>,
            ItemContainerStyleProperty::<Impl, OFFSET>,
            ItemContainerStyleSelectorProperty::<Impl, OFFSET>,
            ItemContainerTransitionsProperty::<Impl, OFFSET>,
            GroupStyleSelectorProperty::<Impl, OFFSET>,
            IsGroupingProperty::<Impl, OFFSET>,
            GetItemsOwner::<Impl, OFFSET>,
            ItemsControlFromItemContainer::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsPanelTemplateImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsPanelTemplate {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPanelTemplate";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsPanelTemplateVtbl {
    pub const fn new<Impl: IItemsPanelTemplateImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsPanelTemplateVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IItemsPanelTemplate>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsPickedEventArgsImpl: Sized {
    fn AddedItems(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn RemovedItems(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsPickedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPickedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsPickedEventArgsVtbl {
    pub const fn new<Impl: IItemsPickedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsPickedEventArgsVtbl {
        unsafe extern "system" fn AddedItems<Impl: IItemsPickedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovedItems<Impl: IItemsPickedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemovedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IItemsPickedEventArgs>, base.5, AddedItems::<Impl, OFFSET>, RemovedItems::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsPresenterImpl: Sized {
    fn Header(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn HeaderTransitions(&self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetHeaderTransitions(&self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
    fn Padding(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsPresenterVtbl {
    pub const fn new<Impl: IItemsPresenterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsPresenterVtbl {
        unsafe extern "system" fn Header<Impl: IItemsPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IItemsPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IItemsPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IItemsPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTransitions<Impl: IItemsPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTransitions<Impl: IItemsPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IItemsPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IItemsPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IItemsPresenter>, base.5, Header::<Impl, OFFSET>, SetHeader::<Impl, OFFSET>, HeaderTemplate::<Impl, OFFSET>, SetHeaderTemplate::<Impl, OFFSET>, HeaderTransitions::<Impl, OFFSET>, SetHeaderTransitions::<Impl, OFFSET>, Padding::<Impl, OFFSET>, SetPadding::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsPresenter2Impl: Sized {
    fn Footer(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetFooter(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn FooterTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetFooterTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn FooterTransitions(&self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetFooterTransitions(&self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPresenter2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsPresenter2Vtbl {
    pub const fn new<Impl: IItemsPresenter2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsPresenter2Vtbl {
        unsafe extern "system" fn Footer<Impl: IItemsPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Footer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooter<Impl: IItemsPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFooter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FooterTemplate<Impl: IItemsPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FooterTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooterTemplate<Impl: IItemsPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFooterTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FooterTransitions<Impl: IItemsPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FooterTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooterTransitions<Impl: IItemsPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFooterTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IItemsPresenter2>, base.5, Footer::<Impl, OFFSET>, SetFooter::<Impl, OFFSET>, FooterTemplate::<Impl, OFFSET>, SetFooterTemplate::<Impl, OFFSET>, FooterTransitions::<Impl, OFFSET>, SetFooterTransitions::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsPresenterStaticsImpl: Sized {
    fn HeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTransitionsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsPresenterStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPresenterStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsPresenterStaticsVtbl {
    pub const fn new<Impl: IItemsPresenterStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsPresenterStaticsVtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IItemsPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IItemsPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTransitionsProperty<Impl: IItemsPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IItemsPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IItemsPresenterStatics>, base.5, HeaderProperty::<Impl, OFFSET>, HeaderTemplateProperty::<Impl, OFFSET>, HeaderTransitionsProperty::<Impl, OFFSET>, PaddingProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsPresenterStatics2Impl: Sized {
    fn FooterProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FooterTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FooterTransitionsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsPresenterStatics2Vtbl {
    pub const fn new<Impl: IItemsPresenterStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsPresenterStatics2Vtbl {
        unsafe extern "system" fn FooterProperty<Impl: IItemsPresenterStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FooterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FooterTemplateProperty<Impl: IItemsPresenterStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FooterTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FooterTransitionsProperty<Impl: IItemsPresenterStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FooterTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IItemsPresenterStatics2>, base.5, FooterProperty::<Impl, OFFSET>, FooterTemplateProperty::<Impl, OFFSET>, FooterTransitionsProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsStackPanelImpl: Sized {
    fn GroupPadding(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetGroupPadding(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn Orientation(&self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&self, value: Orientation) -> ::windows::core::Result<()>;
    fn FirstCacheIndex(&self) -> ::windows::core::Result<i32>;
    fn FirstVisibleIndex(&self) -> ::windows::core::Result<i32>;
    fn LastVisibleIndex(&self) -> ::windows::core::Result<i32>;
    fn LastCacheIndex(&self) -> ::windows::core::Result<i32>;
    fn ScrollingDirection(&self) -> ::windows::core::Result<PanelScrollingDirection>;
    fn GroupHeaderPlacement(&self) -> ::windows::core::Result<Primitives::GroupHeaderPlacement>;
    fn SetGroupHeaderPlacement(&self, value: Primitives::GroupHeaderPlacement) -> ::windows::core::Result<()>;
    fn ItemsUpdatingScrollMode(&self) -> ::windows::core::Result<ItemsUpdatingScrollMode>;
    fn SetItemsUpdatingScrollMode(&self, value: ItemsUpdatingScrollMode) -> ::windows::core::Result<()>;
    fn CacheLength(&self) -> ::windows::core::Result<f64>;
    fn SetCacheLength(&self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsStackPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsStackPanel";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsStackPanelVtbl {
    pub const fn new<Impl: IItemsStackPanelImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsStackPanelVtbl {
        unsafe extern "system" fn GroupPadding<Impl: IItemsStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GroupPadding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupPadding<Impl: IItemsStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetGroupPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Orientation<Impl: IItemsStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IItemsStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn FirstCacheIndex<Impl: IItemsStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstCacheIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstVisibleIndex<Impl: IItemsStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstVisibleIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LastVisibleIndex<Impl: IItemsStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LastVisibleIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LastCacheIndex<Impl: IItemsStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LastCacheIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollingDirection<Impl: IItemsStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut PanelScrollingDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ScrollingDirection() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupHeaderPlacement<Impl: IItemsStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::GroupHeaderPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GroupHeaderPlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupHeaderPlacement<Impl: IItemsStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Primitives::GroupHeaderPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetGroupHeaderPlacement(value).into()
        }
        unsafe extern "system" fn ItemsUpdatingScrollMode<Impl: IItemsStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ItemsUpdatingScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemsUpdatingScrollMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsUpdatingScrollMode<Impl: IItemsStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ItemsUpdatingScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemsUpdatingScrollMode(value).into()
        }
        unsafe extern "system" fn CacheLength<Impl: IItemsStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CacheLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCacheLength<Impl: IItemsStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCacheLength(value).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IItemsStackPanel>,
            base.5,
            GroupPadding::<Impl, OFFSET>,
            SetGroupPadding::<Impl, OFFSET>,
            Orientation::<Impl, OFFSET>,
            SetOrientation::<Impl, OFFSET>,
            FirstCacheIndex::<Impl, OFFSET>,
            FirstVisibleIndex::<Impl, OFFSET>,
            LastVisibleIndex::<Impl, OFFSET>,
            LastCacheIndex::<Impl, OFFSET>,
            ScrollingDirection::<Impl, OFFSET>,
            GroupHeaderPlacement::<Impl, OFFSET>,
            SetGroupHeaderPlacement::<Impl, OFFSET>,
            ItemsUpdatingScrollMode::<Impl, OFFSET>,
            SetItemsUpdatingScrollMode::<Impl, OFFSET>,
            CacheLength::<Impl, OFFSET>,
            SetCacheLength::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsStackPanel2Impl: Sized {
    fn AreStickyGroupHeadersEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetAreStickyGroupHeadersEnabled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsStackPanel2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsStackPanel2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsStackPanel2Vtbl {
    pub const fn new<Impl: IItemsStackPanel2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsStackPanel2Vtbl {
        unsafe extern "system" fn AreStickyGroupHeadersEnabled<Impl: IItemsStackPanel2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AreStickyGroupHeadersEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreStickyGroupHeadersEnabled<Impl: IItemsStackPanel2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAreStickyGroupHeadersEnabled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IItemsStackPanel2>, base.5, AreStickyGroupHeadersEnabled::<Impl, OFFSET>, SetAreStickyGroupHeadersEnabled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsStackPanelStaticsImpl: Sized {
    fn GroupPaddingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GroupHeaderPlacementProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CacheLengthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsStackPanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsStackPanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsStackPanelStaticsVtbl {
    pub const fn new<Impl: IItemsStackPanelStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsStackPanelStaticsVtbl {
        unsafe extern "system" fn GroupPaddingProperty<Impl: IItemsStackPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GroupPaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IItemsStackPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupHeaderPlacementProperty<Impl: IItemsStackPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GroupHeaderPlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CacheLengthProperty<Impl: IItemsStackPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CacheLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IItemsStackPanelStatics>, base.5, GroupPaddingProperty::<Impl, OFFSET>, OrientationProperty::<Impl, OFFSET>, GroupHeaderPlacementProperty::<Impl, OFFSET>, CacheLengthProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsStackPanelStatics2Impl: Sized {
    fn AreStickyGroupHeadersEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsStackPanelStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsStackPanelStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsStackPanelStatics2Vtbl {
    pub const fn new<Impl: IItemsStackPanelStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsStackPanelStatics2Vtbl {
        unsafe extern "system" fn AreStickyGroupHeadersEnabledProperty<Impl: IItemsStackPanelStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AreStickyGroupHeadersEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IItemsStackPanelStatics2>, base.5, AreStickyGroupHeadersEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsWrapGridImpl: Sized {
    fn GroupPadding(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetGroupPadding(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn Orientation(&self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&self, value: Orientation) -> ::windows::core::Result<()>;
    fn MaximumRowsOrColumns(&self) -> ::windows::core::Result<i32>;
    fn SetMaximumRowsOrColumns(&self, value: i32) -> ::windows::core::Result<()>;
    fn ItemWidth(&self) -> ::windows::core::Result<f64>;
    fn SetItemWidth(&self, value: f64) -> ::windows::core::Result<()>;
    fn ItemHeight(&self) -> ::windows::core::Result<f64>;
    fn SetItemHeight(&self, value: f64) -> ::windows::core::Result<()>;
    fn FirstCacheIndex(&self) -> ::windows::core::Result<i32>;
    fn FirstVisibleIndex(&self) -> ::windows::core::Result<i32>;
    fn LastVisibleIndex(&self) -> ::windows::core::Result<i32>;
    fn LastCacheIndex(&self) -> ::windows::core::Result<i32>;
    fn ScrollingDirection(&self) -> ::windows::core::Result<PanelScrollingDirection>;
    fn GroupHeaderPlacement(&self) -> ::windows::core::Result<Primitives::GroupHeaderPlacement>;
    fn SetGroupHeaderPlacement(&self, value: Primitives::GroupHeaderPlacement) -> ::windows::core::Result<()>;
    fn CacheLength(&self) -> ::windows::core::Result<f64>;
    fn SetCacheLength(&self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsWrapGrid {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsWrapGrid";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsWrapGridVtbl {
    pub const fn new<Impl: IItemsWrapGridImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsWrapGridVtbl {
        unsafe extern "system" fn GroupPadding<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GroupPadding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupPadding<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetGroupPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Orientation<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn MaximumRowsOrColumns<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumns() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaximumRowsOrColumns<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaximumRowsOrColumns(value).into()
        }
        unsafe extern "system" fn ItemWidth<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemWidth<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemWidth(value).into()
        }
        unsafe extern "system" fn ItemHeight<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemHeight<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemHeight(value).into()
        }
        unsafe extern "system" fn FirstCacheIndex<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstCacheIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FirstVisibleIndex<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FirstVisibleIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LastVisibleIndex<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LastVisibleIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LastCacheIndex<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LastCacheIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollingDirection<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut PanelScrollingDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ScrollingDirection() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupHeaderPlacement<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::GroupHeaderPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GroupHeaderPlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupHeaderPlacement<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Primitives::GroupHeaderPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetGroupHeaderPlacement(value).into()
        }
        unsafe extern "system" fn CacheLength<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CacheLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCacheLength<Impl: IItemsWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCacheLength(value).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IItemsWrapGrid>,
            base.5,
            GroupPadding::<Impl, OFFSET>,
            SetGroupPadding::<Impl, OFFSET>,
            Orientation::<Impl, OFFSET>,
            SetOrientation::<Impl, OFFSET>,
            MaximumRowsOrColumns::<Impl, OFFSET>,
            SetMaximumRowsOrColumns::<Impl, OFFSET>,
            ItemWidth::<Impl, OFFSET>,
            SetItemWidth::<Impl, OFFSET>,
            ItemHeight::<Impl, OFFSET>,
            SetItemHeight::<Impl, OFFSET>,
            FirstCacheIndex::<Impl, OFFSET>,
            FirstVisibleIndex::<Impl, OFFSET>,
            LastVisibleIndex::<Impl, OFFSET>,
            LastCacheIndex::<Impl, OFFSET>,
            ScrollingDirection::<Impl, OFFSET>,
            GroupHeaderPlacement::<Impl, OFFSET>,
            SetGroupHeaderPlacement::<Impl, OFFSET>,
            CacheLength::<Impl, OFFSET>,
            SetCacheLength::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsWrapGrid2Impl: Sized {
    fn AreStickyGroupHeadersEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetAreStickyGroupHeadersEnabled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsWrapGrid2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsWrapGrid2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsWrapGrid2Vtbl {
    pub const fn new<Impl: IItemsWrapGrid2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsWrapGrid2Vtbl {
        unsafe extern "system" fn AreStickyGroupHeadersEnabled<Impl: IItemsWrapGrid2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AreStickyGroupHeadersEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreStickyGroupHeadersEnabled<Impl: IItemsWrapGrid2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAreStickyGroupHeadersEnabled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IItemsWrapGrid2>, base.5, AreStickyGroupHeadersEnabled::<Impl, OFFSET>, SetAreStickyGroupHeadersEnabled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsWrapGridStaticsImpl: Sized {
    fn GroupPaddingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaximumRowsOrColumnsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemWidthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemHeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GroupHeaderPlacementProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CacheLengthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsWrapGridStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsWrapGridStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsWrapGridStaticsVtbl {
    pub const fn new<Impl: IItemsWrapGridStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsWrapGridStaticsVtbl {
        unsafe extern "system" fn GroupPaddingProperty<Impl: IItemsWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GroupPaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IItemsWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaximumRowsOrColumnsProperty<Impl: IItemsWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumnsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemWidthProperty<Impl: IItemsWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemHeightProperty<Impl: IItemsWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GroupHeaderPlacementProperty<Impl: IItemsWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GroupHeaderPlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CacheLengthProperty<Impl: IItemsWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CacheLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IItemsWrapGridStatics>, base.5, GroupPaddingProperty::<Impl, OFFSET>, OrientationProperty::<Impl, OFFSET>, MaximumRowsOrColumnsProperty::<Impl, OFFSET>, ItemWidthProperty::<Impl, OFFSET>, ItemHeightProperty::<Impl, OFFSET>, GroupHeaderPlacementProperty::<Impl, OFFSET>, CacheLengthProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IItemsWrapGridStatics2Impl: Sized {
    fn AreStickyGroupHeadersEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IItemsWrapGridStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IItemsWrapGridStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IItemsWrapGridStatics2Vtbl {
    pub const fn new<Impl: IItemsWrapGridStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IItemsWrapGridStatics2Vtbl {
        unsafe extern "system" fn AreStickyGroupHeadersEnabledProperty<Impl: IItemsWrapGridStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AreStickyGroupHeadersEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IItemsWrapGridStatics2>, base.5, AreStickyGroupHeadersEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBoxImpl: Sized {
    fn SelectedItems(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn SelectionMode(&self) -> ::windows::core::Result<SelectionMode>;
    fn SetSelectionMode(&self, value: SelectionMode) -> ::windows::core::Result<()>;
    fn ScrollIntoView(&self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectAll(&self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBox";
}
#[cfg(feature = "implement_exclusive")]
impl IListBoxVtbl {
    pub const fn new<Impl: IListBoxImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListBoxVtbl {
        unsafe extern "system" fn SelectedItems<Impl: IListBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionMode<Impl: IListBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut SelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionMode<Impl: IListBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: SelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionMode(value).into()
        }
        unsafe extern "system" fn ScrollIntoView<Impl: IListBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ScrollIntoView(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: IListBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListBox>, base.5, SelectedItems::<Impl, OFFSET>, SelectionMode::<Impl, OFFSET>, SetSelectionMode::<Impl, OFFSET>, ScrollIntoView::<Impl, OFFSET>, SelectAll::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBox2Impl: Sized {
    fn SingleSelectionFollowsFocus(&self) -> ::windows::core::Result<bool>;
    fn SetSingleSelectionFollowsFocus(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBox2";
}
#[cfg(feature = "implement_exclusive")]
impl IListBox2Vtbl {
    pub const fn new<Impl: IListBox2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListBox2Vtbl {
        unsafe extern "system" fn SingleSelectionFollowsFocus<Impl: IListBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSingleSelectionFollowsFocus<Impl: IListBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSingleSelectionFollowsFocus(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListBox2>, base.5, SingleSelectionFollowsFocus::<Impl, OFFSET>, SetSingleSelectionFollowsFocus::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBoxFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListBoxFactoryVtbl {
    pub const fn new<Impl: IListBoxFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListBoxFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListBoxFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListBoxFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBoxItemImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBoxItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBoxItem";
}
#[cfg(feature = "implement_exclusive")]
impl IListBoxItemVtbl {
    pub const fn new<Impl: IListBoxItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListBoxItemVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListBoxItem>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBoxItemFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListBoxItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBoxItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBoxItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListBoxItemFactoryVtbl {
    pub const fn new<Impl: IListBoxItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListBoxItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListBoxItemFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListBoxItemFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBoxStaticsImpl: Sized {
    fn SelectionModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IListBoxStaticsVtbl {
    pub const fn new<Impl: IListBoxStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListBoxStaticsVtbl {
        unsafe extern "system" fn SelectionModeProperty<Impl: IListBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListBoxStatics>, base.5, SelectionModeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListBoxStatics2Impl: Sized {
    fn SingleSelectionFollowsFocusProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IListBoxStatics2Vtbl {
    pub const fn new<Impl: IListBoxStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListBoxStatics2Vtbl {
        unsafe extern "system" fn SingleSelectionFollowsFocusProperty<Impl: IListBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListBoxStatics2>, base.5, SingleSelectionFollowsFocusProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListPickerFlyoutImpl: Sized {
    fn ItemsSource(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetItemsSource(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn ItemTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetItemTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn DisplayMemberPath(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDisplayMemberPath(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectionMode(&self) -> ::windows::core::Result<ListPickerFlyoutSelectionMode>;
    fn SetSelectionMode(&self, value: ListPickerFlyoutSelectionMode) -> ::windows::core::Result<()>;
    fn SelectedIndex(&self) -> ::windows::core::Result<i32>;
    fn SetSelectedIndex(&self, value: i32) -> ::windows::core::Result<()>;
    fn SelectedItem(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetSelectedItem(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectedValue(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetSelectedValue(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectedValuePath(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSelectedValuePath(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectedItems(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn ItemsPicked(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListPickerFlyout, ItemsPickedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveItemsPicked(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ShowAtAsync(&self, target: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::Foundation::Collections::IVectorView<::windows::core::IInspectable>>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListPickerFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListPickerFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl IListPickerFlyoutVtbl {
    pub const fn new<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListPickerFlyoutVtbl {
        unsafe extern "system" fn ItemsSource<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemsSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsSource<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemsSource(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemTemplate<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemTemplate<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisplayMemberPath<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayMemberPath() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayMemberPath<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDisplayMemberPath(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionMode<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ListPickerFlyoutSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionMode<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ListPickerFlyoutSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionMode(value).into()
        }
        unsafe extern "system" fn SelectedIndex<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedIndex<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedIndex(value).into()
        }
        unsafe extern "system" fn SelectedItem<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedItem<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedItem(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedValue<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedValue<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedValue(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedValuePath<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedValuePath() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedValuePath<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedValuePath(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedItems<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsPicked<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemsPicked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ListPickerFlyout, ItemsPickedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListPickerFlyout, ItemsPickedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveItemsPicked<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveItemsPicked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ShowAtAsync<Impl: IListPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, target: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowAtAsync(&*(&target as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IListPickerFlyout>,
            base.5,
            ItemsSource::<Impl, OFFSET>,
            SetItemsSource::<Impl, OFFSET>,
            ItemTemplate::<Impl, OFFSET>,
            SetItemTemplate::<Impl, OFFSET>,
            DisplayMemberPath::<Impl, OFFSET>,
            SetDisplayMemberPath::<Impl, OFFSET>,
            SelectionMode::<Impl, OFFSET>,
            SetSelectionMode::<Impl, OFFSET>,
            SelectedIndex::<Impl, OFFSET>,
            SetSelectedIndex::<Impl, OFFSET>,
            SelectedItem::<Impl, OFFSET>,
            SetSelectedItem::<Impl, OFFSET>,
            SelectedValue::<Impl, OFFSET>,
            SetSelectedValue::<Impl, OFFSET>,
            SelectedValuePath::<Impl, OFFSET>,
            SetSelectedValuePath::<Impl, OFFSET>,
            SelectedItems::<Impl, OFFSET>,
            ItemsPicked::<Impl, OFFSET>,
            RemoveItemsPicked::<Impl, OFFSET>,
            ShowAtAsync::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListPickerFlyoutPresenterImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListPickerFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListPickerFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IListPickerFlyoutPresenterVtbl {
    pub const fn new<Impl: IListPickerFlyoutPresenterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListPickerFlyoutPresenterVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListPickerFlyoutPresenter>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListPickerFlyoutStaticsImpl: Sized {
    fn ItemsSourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayMemberPathProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedIndexProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedItemProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedValueProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedValuePathProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListPickerFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListPickerFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IListPickerFlyoutStaticsVtbl {
    pub const fn new<Impl: IListPickerFlyoutStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListPickerFlyoutStaticsVtbl {
        unsafe extern "system" fn ItemsSourceProperty<Impl: IListPickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemsSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplateProperty<Impl: IListPickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayMemberPathProperty<Impl: IListPickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayMemberPathProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionModeProperty<Impl: IListPickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedIndexProperty<Impl: IListPickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedItemProperty<Impl: IListPickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedItemProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedValueProperty<Impl: IListPickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedValuePathProperty<Impl: IListPickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedValuePathProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListPickerFlyoutStatics>, base.5, ItemsSourceProperty::<Impl, OFFSET>, ItemTemplateProperty::<Impl, OFFSET>, DisplayMemberPathProperty::<Impl, OFFSET>, SelectionModeProperty::<Impl, OFFSET>, SelectedIndexProperty::<Impl, OFFSET>, SelectedItemProperty::<Impl, OFFSET>, SelectedValueProperty::<Impl, OFFSET>, SelectedValuePathProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListView";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewVtbl {
    pub const fn new<Impl: IListViewImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListView>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseImpl: Sized {
    fn SelectedItems(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn SelectionMode(&self) -> ::windows::core::Result<ListViewSelectionMode>;
    fn SetSelectionMode(&self, value: ListViewSelectionMode) -> ::windows::core::Result<()>;
    fn IsSwipeEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsSwipeEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn CanDragItems(&self) -> ::windows::core::Result<bool>;
    fn SetCanDragItems(&self, value: bool) -> ::windows::core::Result<()>;
    fn CanReorderItems(&self) -> ::windows::core::Result<bool>;
    fn SetCanReorderItems(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsItemClickEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsItemClickEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn DataFetchSize(&self) -> ::windows::core::Result<f64>;
    fn SetDataFetchSize(&self, value: f64) -> ::windows::core::Result<()>;
    fn IncrementalLoadingThreshold(&self) -> ::windows::core::Result<f64>;
    fn SetIncrementalLoadingThreshold(&self, value: f64) -> ::windows::core::Result<()>;
    fn IncrementalLoadingTrigger(&self) -> ::windows::core::Result<IncrementalLoadingTrigger>;
    fn SetIncrementalLoadingTrigger(&self, value: IncrementalLoadingTrigger) -> ::windows::core::Result<()>;
    fn ItemClick(&self, handler: &::core::option::Option<ItemClickEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveItemClick(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DragItemsStarting(&self, handler: &::core::option::Option<DragItemsStartingEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDragItemsStarting(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ScrollIntoView(&self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectAll(&self) -> ::windows::core::Result<()>;
    fn LoadMoreItemsAsync(&self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::Data::LoadMoreItemsResult>>;
    fn ScrollIntoViewWithAlignment(&self, item: &::core::option::Option<::windows::core::IInspectable>, alignment: ScrollIntoViewAlignment) -> ::windows::core::Result<()>;
    fn Header(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn HeaderTransitions(&self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetHeaderTransitions(&self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBase {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseVtbl {
    pub const fn new<Impl: IListViewBaseImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewBaseVtbl {
        unsafe extern "system" fn SelectedItems<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionMode<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ListViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionMode<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ListViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionMode(value).into()
        }
        unsafe extern "system" fn IsSwipeEnabled<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSwipeEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSwipeEnabled<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsSwipeEnabled(value).into()
        }
        unsafe extern "system" fn CanDragItems<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanDragItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanDragItems<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCanDragItems(value).into()
        }
        unsafe extern "system" fn CanReorderItems<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanReorderItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanReorderItems<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCanReorderItems(value).into()
        }
        unsafe extern "system" fn IsItemClickEnabled<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsItemClickEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsItemClickEnabled<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsItemClickEnabled(value).into()
        }
        unsafe extern "system" fn DataFetchSize<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DataFetchSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDataFetchSize<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDataFetchSize(value).into()
        }
        unsafe extern "system" fn IncrementalLoadingThreshold<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IncrementalLoadingThreshold() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIncrementalLoadingThreshold<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIncrementalLoadingThreshold(value).into()
        }
        unsafe extern "system" fn IncrementalLoadingTrigger<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut IncrementalLoadingTrigger) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IncrementalLoadingTrigger() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIncrementalLoadingTrigger<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: IncrementalLoadingTrigger) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIncrementalLoadingTrigger(value).into()
        }
        unsafe extern "system" fn ItemClick<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemClick(&*(&handler as *const <ItemClickEventHandler as ::windows::core::Abi>::Abi as *const <ItemClickEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveItemClick<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveItemClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DragItemsStarting<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DragItemsStarting(&*(&handler as *const <DragItemsStartingEventHandler as ::windows::core::Abi>::Abi as *const <DragItemsStartingEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDragItemsStarting<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveDragItemsStarting(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ScrollIntoView<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ScrollIntoView(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        unsafe extern "system" fn LoadMoreItemsAsync<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LoadMoreItemsAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollIntoViewWithAlignment<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, alignment: ScrollIntoViewAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ScrollIntoViewWithAlignment(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), alignment).into()
        }
        unsafe extern "system" fn Header<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTransitions<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTransitions<Impl: IListViewBaseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IListViewBase>,
            base.5,
            SelectedItems::<Impl, OFFSET>,
            SelectionMode::<Impl, OFFSET>,
            SetSelectionMode::<Impl, OFFSET>,
            IsSwipeEnabled::<Impl, OFFSET>,
            SetIsSwipeEnabled::<Impl, OFFSET>,
            CanDragItems::<Impl, OFFSET>,
            SetCanDragItems::<Impl, OFFSET>,
            CanReorderItems::<Impl, OFFSET>,
            SetCanReorderItems::<Impl, OFFSET>,
            IsItemClickEnabled::<Impl, OFFSET>,
            SetIsItemClickEnabled::<Impl, OFFSET>,
            DataFetchSize::<Impl, OFFSET>,
            SetDataFetchSize::<Impl, OFFSET>,
            IncrementalLoadingThreshold::<Impl, OFFSET>,
            SetIncrementalLoadingThreshold::<Impl, OFFSET>,
            IncrementalLoadingTrigger::<Impl, OFFSET>,
            SetIncrementalLoadingTrigger::<Impl, OFFSET>,
            ItemClick::<Impl, OFFSET>,
            RemoveItemClick::<Impl, OFFSET>,
            DragItemsStarting::<Impl, OFFSET>,
            RemoveDragItemsStarting::<Impl, OFFSET>,
            ScrollIntoView::<Impl, OFFSET>,
            SelectAll::<Impl, OFFSET>,
            LoadMoreItemsAsync::<Impl, OFFSET>,
            ScrollIntoViewWithAlignment::<Impl, OFFSET>,
            Header::<Impl, OFFSET>,
            SetHeader::<Impl, OFFSET>,
            HeaderTemplate::<Impl, OFFSET>,
            SetHeaderTemplate::<Impl, OFFSET>,
            HeaderTransitions::<Impl, OFFSET>,
            SetHeaderTransitions::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBase2Impl: Sized {
    fn ShowsScrollingPlaceholders(&self) -> ::windows::core::Result<bool>;
    fn SetShowsScrollingPlaceholders(&self, value: bool) -> ::windows::core::Result<()>;
    fn ContainerContentChanging(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContainerContentChanging(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SetDesiredContainerUpdateDuration(&self, duration: &super::super::super::Foundation::TimeSpan) -> ::windows::core::Result<()>;
    fn Footer(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetFooter(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn FooterTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetFooterTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn FooterTransitions(&self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetFooterTransitions(&self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBase2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase2";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBase2Vtbl {
    pub const fn new<Impl: IListViewBase2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewBase2Vtbl {
        unsafe extern "system" fn ShowsScrollingPlaceholders<Impl: IListViewBase2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowsScrollingPlaceholders() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowsScrollingPlaceholders<Impl: IListViewBase2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetShowsScrollingPlaceholders(value).into()
        }
        unsafe extern "system" fn ContainerContentChanging<Impl: IListViewBase2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContainerContentChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ContainerContentChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContainerContentChanging<Impl: IListViewBase2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveContainerContentChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetDesiredContainerUpdateDuration<Impl: IListViewBase2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, duration: super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDesiredContainerUpdateDuration(&*(&duration as *const <super::super::super::Foundation::TimeSpan as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TimeSpan as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Footer<Impl: IListViewBase2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Footer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooter<Impl: IListViewBase2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFooter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FooterTemplate<Impl: IListViewBase2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FooterTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooterTemplate<Impl: IListViewBase2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFooterTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FooterTransitions<Impl: IListViewBase2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FooterTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFooterTransitions<Impl: IListViewBase2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFooterTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IListViewBase2>,
            base.5,
            ShowsScrollingPlaceholders::<Impl, OFFSET>,
            SetShowsScrollingPlaceholders::<Impl, OFFSET>,
            ContainerContentChanging::<Impl, OFFSET>,
            RemoveContainerContentChanging::<Impl, OFFSET>,
            SetDesiredContainerUpdateDuration::<Impl, OFFSET>,
            Footer::<Impl, OFFSET>,
            SetFooter::<Impl, OFFSET>,
            FooterTemplate::<Impl, OFFSET>,
            SetFooterTemplate::<Impl, OFFSET>,
            FooterTransitions::<Impl, OFFSET>,
            SetFooterTransitions::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBase3Impl: Sized {
    fn ReorderMode(&self) -> ::windows::core::Result<ListViewReorderMode>;
    fn SetReorderMode(&self, value: ListViewReorderMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBase3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase3";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBase3Vtbl {
    pub const fn new<Impl: IListViewBase3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewBase3Vtbl {
        unsafe extern "system" fn ReorderMode<Impl: IListViewBase3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ListViewReorderMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReorderMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetReorderMode<Impl: IListViewBase3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ListViewReorderMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetReorderMode(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListViewBase3>, base.5, ReorderMode::<Impl, OFFSET>, SetReorderMode::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBase4Impl: Sized {
    fn SelectedRanges(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<super::Data::ItemIndexRange>>;
    fn IsMultiSelectCheckBoxEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsMultiSelectCheckBoxEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn DragItemsCompleted(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, DragItemsCompletedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDragItemsCompleted(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ChoosingItemContainer(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingItemContainerEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveChoosingItemContainer(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ChoosingGroupHeaderContainer(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingGroupHeaderContainerEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveChoosingGroupHeaderContainer(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectRange(&self, itemindexrange: &::core::option::Option<super::Data::ItemIndexRange>) -> ::windows::core::Result<()>;
    fn DeselectRange(&self, itemindexrange: &::core::option::Option<super::Data::ItemIndexRange>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBase4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase4";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBase4Vtbl {
    pub const fn new<Impl: IListViewBase4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewBase4Vtbl {
        unsafe extern "system" fn SelectedRanges<Impl: IListViewBase4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedRanges() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsMultiSelectCheckBoxEnabled<Impl: IListViewBase4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsMultiSelectCheckBoxEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsMultiSelectCheckBoxEnabled<Impl: IListViewBase4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsMultiSelectCheckBoxEnabled(value).into()
        }
        unsafe extern "system" fn DragItemsCompleted<Impl: IListViewBase4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DragItemsCompleted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, DragItemsCompletedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, DragItemsCompletedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDragItemsCompleted<Impl: IListViewBase4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveDragItemsCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ChoosingItemContainer<Impl: IListViewBase4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChoosingItemContainer(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingItemContainerEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingItemContainerEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveChoosingItemContainer<Impl: IListViewBase4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveChoosingItemContainer(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ChoosingGroupHeaderContainer<Impl: IListViewBase4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChoosingGroupHeaderContainer(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingGroupHeaderContainerEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ListViewBase, ChoosingGroupHeaderContainerEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveChoosingGroupHeaderContainer<Impl: IListViewBase4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveChoosingGroupHeaderContainer(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectRange<Impl: IListViewBase4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, itemindexrange: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SelectRange(&*(&itemindexrange as *const <super::Data::ItemIndexRange as ::windows::core::Abi>::Abi as *const <super::Data::ItemIndexRange as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DeselectRange<Impl: IListViewBase4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, itemindexrange: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).DeselectRange(&*(&itemindexrange as *const <super::Data::ItemIndexRange as ::windows::core::Abi>::Abi as *const <super::Data::ItemIndexRange as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IListViewBase4>,
            base.5,
            SelectedRanges::<Impl, OFFSET>,
            IsMultiSelectCheckBoxEnabled::<Impl, OFFSET>,
            SetIsMultiSelectCheckBoxEnabled::<Impl, OFFSET>,
            DragItemsCompleted::<Impl, OFFSET>,
            RemoveDragItemsCompleted::<Impl, OFFSET>,
            ChoosingItemContainer::<Impl, OFFSET>,
            RemoveChoosingItemContainer::<Impl, OFFSET>,
            ChoosingGroupHeaderContainer::<Impl, OFFSET>,
            RemoveChoosingGroupHeaderContainer::<Impl, OFFSET>,
            SelectRange::<Impl, OFFSET>,
            DeselectRange::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBase5Impl: Sized {
    fn SingleSelectionFollowsFocus(&self) -> ::windows::core::Result<bool>;
    fn SetSingleSelectionFollowsFocus(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsDragSource(&self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBase5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase5";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBase5Vtbl {
    pub const fn new<Impl: IListViewBase5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewBase5Vtbl {
        unsafe extern "system" fn SingleSelectionFollowsFocus<Impl: IListViewBase5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSingleSelectionFollowsFocus<Impl: IListViewBase5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSingleSelectionFollowsFocus(value).into()
        }
        unsafe extern "system" fn IsDragSource<Impl: IListViewBase5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDragSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListViewBase5>, base.5, SingleSelectionFollowsFocus::<Impl, OFFSET>, SetSingleSelectionFollowsFocus::<Impl, OFFSET>, IsDragSource::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBase6Impl: Sized {
    fn TryStartConnectedAnimationAsync(&self, animation: &::core::option::Option<super::Media::Animation::ConnectedAnimation>, item: &::core::option::Option<::windows::core::IInspectable>, elementname: &::windows::core::HSTRING) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<bool>>;
    fn PrepareConnectedAnimation(&self, key: &::windows::core::HSTRING, item: &::core::option::Option<::windows::core::IInspectable>, elementname: &::windows::core::HSTRING) -> ::windows::core::Result<super::Media::Animation::ConnectedAnimation>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBase6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBase6";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBase6Vtbl {
    pub const fn new<Impl: IListViewBase6Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewBase6Vtbl {
        unsafe extern "system" fn TryStartConnectedAnimationAsync<Impl: IListViewBase6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, animation: ::windows::core::RawPtr, item: *mut ::core::ffi::c_void, elementname: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TryStartConnectedAnimationAsync(
                &*(&animation as *const <super::Media::Animation::ConnectedAnimation as ::windows::core::Abi>::Abi as *const <super::Media::Animation::ConnectedAnimation as ::windows::core::DefaultType>::DefaultType),
                &*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType),
                &*(&elementname as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PrepareConnectedAnimation<Impl: IListViewBase6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, key: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, item: *mut ::core::ffi::c_void, elementname: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrepareConnectedAnimation(
                &*(&key as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType),
                &*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType),
                &*(&elementname as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListViewBase6>, base.5, TryStartConnectedAnimationAsync::<Impl, OFFSET>, PrepareConnectedAnimation::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListViewBase>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseFactoryVtbl {
    pub const fn new<Impl: IListViewBaseFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewBaseFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListViewBaseFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListViewBaseFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseHeaderItemImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseHeaderItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseHeaderItem";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseHeaderItemVtbl {
    pub const fn new<Impl: IListViewBaseHeaderItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewBaseHeaderItemVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListViewBaseHeaderItem>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseHeaderItemFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseHeaderItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseHeaderItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseHeaderItemFactoryVtbl {
    pub const fn new<Impl: IListViewBaseHeaderItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewBaseHeaderItemFactoryVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListViewBaseHeaderItemFactory>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseStaticsImpl: Sized {
    fn SelectionModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSwipeEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanDragItemsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanReorderItemsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsItemClickEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DataFetchSizeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IncrementalLoadingThresholdProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IncrementalLoadingTriggerProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SemanticZoomOwnerProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsActiveViewProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomedInViewProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTransitionsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseStaticsVtbl {
    pub const fn new<Impl: IListViewBaseStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewBaseStaticsVtbl {
        unsafe extern "system" fn SelectionModeProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSwipeEnabledProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSwipeEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanDragItemsProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanDragItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanReorderItemsProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanReorderItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsItemClickEnabledProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsItemClickEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DataFetchSizeProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DataFetchSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IncrementalLoadingThresholdProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IncrementalLoadingThresholdProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IncrementalLoadingTriggerProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IncrementalLoadingTriggerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SemanticZoomOwnerProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SemanticZoomOwnerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsActiveViewProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsActiveViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomedInViewProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsZoomedInViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTransitionsProperty<Impl: IListViewBaseStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IListViewBaseStatics>,
            base.5,
            SelectionModeProperty::<Impl, OFFSET>,
            IsSwipeEnabledProperty::<Impl, OFFSET>,
            CanDragItemsProperty::<Impl, OFFSET>,
            CanReorderItemsProperty::<Impl, OFFSET>,
            IsItemClickEnabledProperty::<Impl, OFFSET>,
            DataFetchSizeProperty::<Impl, OFFSET>,
            IncrementalLoadingThresholdProperty::<Impl, OFFSET>,
            IncrementalLoadingTriggerProperty::<Impl, OFFSET>,
            SemanticZoomOwnerProperty::<Impl, OFFSET>,
            IsActiveViewProperty::<Impl, OFFSET>,
            IsZoomedInViewProperty::<Impl, OFFSET>,
            HeaderProperty::<Impl, OFFSET>,
            HeaderTemplateProperty::<Impl, OFFSET>,
            HeaderTransitionsProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseStatics2Impl: Sized {
    fn ShowsScrollingPlaceholdersProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FooterProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FooterTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FooterTransitionsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseStatics2Vtbl {
    pub const fn new<Impl: IListViewBaseStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewBaseStatics2Vtbl {
        unsafe extern "system" fn ShowsScrollingPlaceholdersProperty<Impl: IListViewBaseStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowsScrollingPlaceholdersProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FooterProperty<Impl: IListViewBaseStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FooterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FooterTemplateProperty<Impl: IListViewBaseStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FooterTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FooterTransitionsProperty<Impl: IListViewBaseStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FooterTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListViewBaseStatics2>, base.5, ShowsScrollingPlaceholdersProperty::<Impl, OFFSET>, FooterProperty::<Impl, OFFSET>, FooterTemplateProperty::<Impl, OFFSET>, FooterTransitionsProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseStatics3Impl: Sized {
    fn ReorderModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseStatics3Vtbl {
    pub const fn new<Impl: IListViewBaseStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewBaseStatics3Vtbl {
        unsafe extern "system" fn ReorderModeProperty<Impl: IListViewBaseStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReorderModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListViewBaseStatics3>, base.5, ReorderModeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseStatics4Impl: Sized {
    fn IsMultiSelectCheckBoxEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseStatics4Vtbl {
    pub const fn new<Impl: IListViewBaseStatics4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewBaseStatics4Vtbl {
        unsafe extern "system" fn IsMultiSelectCheckBoxEnabledProperty<Impl: IListViewBaseStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsMultiSelectCheckBoxEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListViewBaseStatics4>, base.5, IsMultiSelectCheckBoxEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewBaseStatics5Impl: Sized {
    fn SingleSelectionFollowsFocusProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewBaseStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewBaseStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewBaseStatics5Vtbl {
    pub const fn new<Impl: IListViewBaseStatics5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewBaseStatics5Vtbl {
        unsafe extern "system" fn SingleSelectionFollowsFocusProperty<Impl: IListViewBaseStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListViewBaseStatics5>, base.5, SingleSelectionFollowsFocusProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewFactoryVtbl {
    pub const fn new<Impl: IListViewFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListViewFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListViewFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewHeaderItemImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewHeaderItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewHeaderItem";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewHeaderItemVtbl {
    pub const fn new<Impl: IListViewHeaderItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewHeaderItemVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListViewHeaderItem>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewHeaderItemFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListViewHeaderItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewHeaderItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewHeaderItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewHeaderItemFactoryVtbl {
    pub const fn new<Impl: IListViewHeaderItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewHeaderItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListViewHeaderItemFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListViewHeaderItemFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewItemImpl: Sized {
    fn TemplateSettings(&self) -> ::windows::core::Result<Primitives::ListViewItemTemplateSettings>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewItem";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewItemVtbl {
    pub const fn new<Impl: IListViewItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewItemVtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IListViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListViewItem>, base.5, TemplateSettings::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewItemFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ListViewItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewItemFactoryVtbl {
    pub const fn new<Impl: IListViewItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IListViewItemFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListViewItemFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewPersistenceHelperImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewPersistenceHelper {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewPersistenceHelper";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewPersistenceHelperVtbl {
    pub const fn new<Impl: IListViewPersistenceHelperImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewPersistenceHelperVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListViewPersistenceHelper>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IListViewPersistenceHelperStaticsImpl: Sized {
    fn GetRelativeScrollPosition(&self, listviewbase: &::core::option::Option<ListViewBase>, itemtokeyhandler: &::core::option::Option<ListViewItemToKeyHandler>) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetRelativeScrollPositionAsync(&self, listviewbase: &::core::option::Option<ListViewBase>, relativescrollposition: &::windows::core::HSTRING, keytoitemhandler: &::core::option::Option<ListViewKeyToItemHandler>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncAction>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IListViewPersistenceHelperStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IListViewPersistenceHelperStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IListViewPersistenceHelperStaticsVtbl {
    pub const fn new<Impl: IListViewPersistenceHelperStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IListViewPersistenceHelperStaticsVtbl {
        unsafe extern "system" fn GetRelativeScrollPosition<Impl: IListViewPersistenceHelperStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, listviewbase: ::windows::core::RawPtr, itemtokeyhandler: ::windows::core::RawPtr, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRelativeScrollPosition(&*(&listviewbase as *const <ListViewBase as ::windows::core::Abi>::Abi as *const <ListViewBase as ::windows::core::DefaultType>::DefaultType), &*(&itemtokeyhandler as *const <ListViewItemToKeyHandler as ::windows::core::Abi>::Abi as *const <ListViewItemToKeyHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRelativeScrollPositionAsync<Impl: IListViewPersistenceHelperStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, listviewbase: ::windows::core::RawPtr, relativescrollposition: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, keytoitemhandler: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRelativeScrollPositionAsync(
                &*(&listviewbase as *const <ListViewBase as ::windows::core::Abi>::Abi as *const <ListViewBase as ::windows::core::DefaultType>::DefaultType),
                &*(&relativescrollposition as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType),
                &*(&keytoitemhandler as *const <ListViewKeyToItemHandler as ::windows::core::Abi>::Abi as *const <ListViewKeyToItemHandler as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IListViewPersistenceHelperStatics>, base.5, GetRelativeScrollPosition::<Impl, OFFSET>, SetRelativeScrollPositionAsync::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaElementImpl: Sized {
    fn PosterSource(&self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetPosterSource(&self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn Source(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetSource(&self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
    fn IsMuted(&self) -> ::windows::core::Result<bool>;
    fn SetIsMuted(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsAudioOnly(&self) -> ::windows::core::Result<bool>;
    fn AutoPlay(&self) -> ::windows::core::Result<bool>;
    fn SetAutoPlay(&self, value: bool) -> ::windows::core::Result<()>;
    fn Volume(&self) -> ::windows::core::Result<f64>;
    fn SetVolume(&self, value: f64) -> ::windows::core::Result<()>;
    fn Balance(&self) -> ::windows::core::Result<f64>;
    fn SetBalance(&self, value: f64) -> ::windows::core::Result<()>;
    fn NaturalVideoHeight(&self) -> ::windows::core::Result<i32>;
    fn NaturalVideoWidth(&self) -> ::windows::core::Result<i32>;
    fn NaturalDuration(&self) -> ::windows::core::Result<super::Duration>;
    fn Position(&self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn SetPosition(&self, value: &super::super::super::Foundation::TimeSpan) -> ::windows::core::Result<()>;
    fn DownloadProgress(&self) -> ::windows::core::Result<f64>;
    fn BufferingProgress(&self) -> ::windows::core::Result<f64>;
    fn DownloadProgressOffset(&self) -> ::windows::core::Result<f64>;
    fn CurrentState(&self) -> ::windows::core::Result<super::Media::MediaElementState>;
    fn Markers(&self) -> ::windows::core::Result<super::Media::TimelineMarkerCollection>;
    fn CanSeek(&self) -> ::windows::core::Result<bool>;
    fn CanPause(&self) -> ::windows::core::Result<bool>;
    fn AudioStreamCount(&self) -> ::windows::core::Result<i32>;
    fn AudioStreamIndex(&self) -> ::windows::core::Result<super::super::super::Foundation::IReference<i32>>;
    fn SetAudioStreamIndex(&self, value: &::core::option::Option<super::super::super::Foundation::IReference<i32>>) -> ::windows::core::Result<()>;
    fn PlaybackRate(&self) -> ::windows::core::Result<f64>;
    fn SetPlaybackRate(&self, value: f64) -> ::windows::core::Result<()>;
    fn IsLooping(&self) -> ::windows::core::Result<bool>;
    fn SetIsLooping(&self, value: bool) -> ::windows::core::Result<()>;
    fn PlayToSource(&self) -> ::windows::core::Result<super::super::super::Media::PlayTo::PlayToSource>;
    fn DefaultPlaybackRate(&self) -> ::windows::core::Result<f64>;
    fn SetDefaultPlaybackRate(&self, value: f64) -> ::windows::core::Result<()>;
    fn AspectRatioWidth(&self) -> ::windows::core::Result<i32>;
    fn AspectRatioHeight(&self) -> ::windows::core::Result<i32>;
    fn RealTimePlayback(&self) -> ::windows::core::Result<bool>;
    fn SetRealTimePlayback(&self, value: bool) -> ::windows::core::Result<()>;
    fn AudioCategory(&self) -> ::windows::core::Result<super::Media::AudioCategory>;
    fn SetAudioCategory(&self, value: super::Media::AudioCategory) -> ::windows::core::Result<()>;
    fn AudioDeviceType(&self) -> ::windows::core::Result<super::Media::AudioDeviceType>;
    fn SetAudioDeviceType(&self, value: super::Media::AudioDeviceType) -> ::windows::core::Result<()>;
    fn ProtectionManager(&self) -> ::windows::core::Result<super::super::super::Media::Protection::MediaProtectionManager>;
    fn SetProtectionManager(&self, value: &::core::option::Option<super::super::super::Media::Protection::MediaProtectionManager>) -> ::windows::core::Result<()>;
    fn Stereo3DVideoPackingMode(&self) -> ::windows::core::Result<super::Media::Stereo3DVideoPackingMode>;
    fn SetStereo3DVideoPackingMode(&self, value: super::Media::Stereo3DVideoPackingMode) -> ::windows::core::Result<()>;
    fn Stereo3DVideoRenderMode(&self) -> ::windows::core::Result<super::Media::Stereo3DVideoRenderMode>;
    fn SetStereo3DVideoRenderMode(&self, value: super::Media::Stereo3DVideoRenderMode) -> ::windows::core::Result<()>;
    fn IsStereo3DVideo(&self) -> ::windows::core::Result<bool>;
    fn MediaOpened(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveMediaOpened(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn MediaEnded(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveMediaEnded(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn MediaFailed(&self, handler: &::core::option::Option<super::ExceptionRoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveMediaFailed(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DownloadProgressChanged(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDownloadProgressChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn BufferingProgressChanged(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveBufferingProgressChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn CurrentStateChanged(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCurrentStateChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn MarkerReached(&self, handler: &::core::option::Option<super::Media::TimelineMarkerRoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveMarkerReached(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn RateChanged(&self, handler: &::core::option::Option<super::Media::RateChangedRoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveRateChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn VolumeChanged(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveVolumeChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SeekCompleted(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSeekCompleted(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Stop(&self) -> ::windows::core::Result<()>;
    fn Play(&self) -> ::windows::core::Result<()>;
    fn Pause(&self) -> ::windows::core::Result<()>;
    fn CanPlayType(&self, r#type: &::windows::core::HSTRING) -> ::windows::core::Result<super::Media::MediaCanPlayResponse>;
    fn SetSource(&self, stream: &::core::option::Option<super::super::super::Storage::Streams::IRandomAccessStream>, mimetype: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn GetAudioStreamLanguage(&self, index: &::core::option::Option<super::super::super::Foundation::IReference<i32>>) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn AddAudioEffect(&self, effectid: &::windows::core::HSTRING, effectoptional: bool, effectconfiguration: &::core::option::Option<super::super::super::Foundation::Collections::IPropertySet>) -> ::windows::core::Result<()>;
    fn AddVideoEffect(&self, effectid: &::windows::core::HSTRING, effectoptional: bool, effectconfiguration: &::core::option::Option<super::super::super::Foundation::Collections::IPropertySet>) -> ::windows::core::Result<()>;
    fn RemoveAllEffects(&self) -> ::windows::core::Result<()>;
    fn ActualStereo3DVideoPackingMode(&self) -> ::windows::core::Result<super::Media::Stereo3DVideoPackingMode>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaElement";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaElementVtbl {
    pub const fn new<Impl: IMediaElementImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaElementVtbl {
        unsafe extern "system" fn PosterSource<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PosterSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPosterSource<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPosterSource(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Source<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsMuted<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsMuted() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsMuted<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsMuted(value).into()
        }
        unsafe extern "system" fn IsAudioOnly<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsAudioOnly() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoPlay<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AutoPlay() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAutoPlay<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAutoPlay(value).into()
        }
        unsafe extern "system" fn Volume<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Volume() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVolume<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVolume(value).into()
        }
        unsafe extern "system" fn Balance<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Balance() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBalance<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBalance(value).into()
        }
        unsafe extern "system" fn NaturalVideoHeight<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NaturalVideoHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NaturalVideoWidth<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NaturalVideoWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NaturalDuration<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Duration) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NaturalDuration() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Position<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Position() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPosition<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPosition(&*(&value as *const <super::super::super::Foundation::TimeSpan as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TimeSpan as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DownloadProgress<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DownloadProgress() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BufferingProgress<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BufferingProgress() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DownloadProgressOffset<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DownloadProgressOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentState<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::MediaElementState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Markers<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Markers() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanSeek<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanSeek() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanPause<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanPause() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioStreamCount<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioStreamCount() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioStreamIndex<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioStreamIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioStreamIndex<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAudioStreamIndex(&*(&value as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaybackRate<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaybackRate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaybackRate<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlaybackRate(value).into()
        }
        unsafe extern "system" fn IsLooping<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsLooping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsLooping<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsLooping(value).into()
        }
        unsafe extern "system" fn PlayToSource<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayToSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultPlaybackRate<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultPlaybackRate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultPlaybackRate<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDefaultPlaybackRate(value).into()
        }
        unsafe extern "system" fn AspectRatioWidth<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AspectRatioWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AspectRatioHeight<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AspectRatioHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RealTimePlayback<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RealTimePlayback() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRealTimePlayback<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetRealTimePlayback(value).into()
        }
        unsafe extern "system" fn AudioCategory<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::AudioCategory) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioCategory() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioCategory<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Media::AudioCategory) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAudioCategory(value).into()
        }
        unsafe extern "system" fn AudioDeviceType<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::AudioDeviceType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioDeviceType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioDeviceType<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Media::AudioDeviceType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAudioDeviceType(value).into()
        }
        unsafe extern "system" fn ProtectionManager<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProtectionManager() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProtectionManager<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetProtectionManager(&*(&value as *const <super::super::super::Media::Protection::MediaProtectionManager as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Protection::MediaProtectionManager as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stereo3DVideoPackingMode<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stereo3DVideoPackingMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stereo3DVideoPackingMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStereo3DVideoPackingMode<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Media::Stereo3DVideoPackingMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetStereo3DVideoPackingMode(value).into()
        }
        unsafe extern "system" fn Stereo3DVideoRenderMode<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stereo3DVideoRenderMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stereo3DVideoRenderMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStereo3DVideoRenderMode<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Media::Stereo3DVideoRenderMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetStereo3DVideoRenderMode(value).into()
        }
        unsafe extern "system" fn IsStereo3DVideo<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsStereo3DVideo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MediaOpened<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MediaOpened(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveMediaOpened<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveMediaOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MediaEnded<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MediaEnded(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveMediaEnded<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveMediaEnded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MediaFailed<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MediaFailed(&*(&handler as *const <super::ExceptionRoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::ExceptionRoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveMediaFailed<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveMediaFailed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DownloadProgressChanged<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DownloadProgressChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDownloadProgressChanged<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveDownloadProgressChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BufferingProgressChanged<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BufferingProgressChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveBufferingProgressChanged<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveBufferingProgressChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CurrentStateChanged<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentStateChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCurrentStateChanged<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveCurrentStateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MarkerReached<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MarkerReached(&*(&handler as *const <super::Media::TimelineMarkerRoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::Media::TimelineMarkerRoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveMarkerReached<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveMarkerReached(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RateChanged<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RateChanged(&*(&handler as *const <super::Media::RateChangedRoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::Media::RateChangedRoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveRateChanged<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveRateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn VolumeChanged<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VolumeChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveVolumeChanged<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveVolumeChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SeekCompleted<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SeekCompleted(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSeekCompleted<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSeekCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stop<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn Play<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Play().into()
        }
        unsafe extern "system" fn Pause<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Pause().into()
        }
        unsafe extern "system" fn CanPlayType<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, r#type: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut super::Media::MediaCanPlayResponse) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanPlayType(&*(&r#type as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, stream: ::windows::core::RawPtr, mimetype: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&stream as *const <super::super::super::Storage::Streams::IRandomAccessStream as ::windows::core::Abi>::Abi as *const <super::super::super::Storage::Streams::IRandomAccessStream as ::windows::core::DefaultType>::DefaultType), &*(&mimetype as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetAudioStreamLanguage<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: ::windows::core::RawPtr, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAudioStreamLanguage(&*(&index as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddAudioEffect<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, effectid: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, effectoptional: bool, effectconfiguration: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).AddAudioEffect(&*(&effectid as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), effectoptional, &*(&effectconfiguration as *const <super::super::super::Foundation::Collections::IPropertySet as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IPropertySet as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AddVideoEffect<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, effectid: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, effectoptional: bool, effectconfiguration: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).AddVideoEffect(&*(&effectid as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), effectoptional, &*(&effectconfiguration as *const <super::super::super::Foundation::Collections::IPropertySet as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IPropertySet as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RemoveAllEffects<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveAllEffects().into()
        }
        unsafe extern "system" fn ActualStereo3DVideoPackingMode<Impl: IMediaElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stereo3DVideoPackingMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ActualStereo3DVideoPackingMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMediaElement>,
            base.5,
            PosterSource::<Impl, OFFSET>,
            SetPosterSource::<Impl, OFFSET>,
            Source::<Impl, OFFSET>,
            SetSource::<Impl, OFFSET>,
            IsMuted::<Impl, OFFSET>,
            SetIsMuted::<Impl, OFFSET>,
            IsAudioOnly::<Impl, OFFSET>,
            AutoPlay::<Impl, OFFSET>,
            SetAutoPlay::<Impl, OFFSET>,
            Volume::<Impl, OFFSET>,
            SetVolume::<Impl, OFFSET>,
            Balance::<Impl, OFFSET>,
            SetBalance::<Impl, OFFSET>,
            NaturalVideoHeight::<Impl, OFFSET>,
            NaturalVideoWidth::<Impl, OFFSET>,
            NaturalDuration::<Impl, OFFSET>,
            Position::<Impl, OFFSET>,
            SetPosition::<Impl, OFFSET>,
            DownloadProgress::<Impl, OFFSET>,
            BufferingProgress::<Impl, OFFSET>,
            DownloadProgressOffset::<Impl, OFFSET>,
            CurrentState::<Impl, OFFSET>,
            Markers::<Impl, OFFSET>,
            CanSeek::<Impl, OFFSET>,
            CanPause::<Impl, OFFSET>,
            AudioStreamCount::<Impl, OFFSET>,
            AudioStreamIndex::<Impl, OFFSET>,
            SetAudioStreamIndex::<Impl, OFFSET>,
            PlaybackRate::<Impl, OFFSET>,
            SetPlaybackRate::<Impl, OFFSET>,
            IsLooping::<Impl, OFFSET>,
            SetIsLooping::<Impl, OFFSET>,
            PlayToSource::<Impl, OFFSET>,
            DefaultPlaybackRate::<Impl, OFFSET>,
            SetDefaultPlaybackRate::<Impl, OFFSET>,
            AspectRatioWidth::<Impl, OFFSET>,
            AspectRatioHeight::<Impl, OFFSET>,
            RealTimePlayback::<Impl, OFFSET>,
            SetRealTimePlayback::<Impl, OFFSET>,
            AudioCategory::<Impl, OFFSET>,
            SetAudioCategory::<Impl, OFFSET>,
            AudioDeviceType::<Impl, OFFSET>,
            SetAudioDeviceType::<Impl, OFFSET>,
            ProtectionManager::<Impl, OFFSET>,
            SetProtectionManager::<Impl, OFFSET>,
            Stereo3DVideoPackingMode::<Impl, OFFSET>,
            SetStereo3DVideoPackingMode::<Impl, OFFSET>,
            Stereo3DVideoRenderMode::<Impl, OFFSET>,
            SetStereo3DVideoRenderMode::<Impl, OFFSET>,
            IsStereo3DVideo::<Impl, OFFSET>,
            MediaOpened::<Impl, OFFSET>,
            RemoveMediaOpened::<Impl, OFFSET>,
            MediaEnded::<Impl, OFFSET>,
            RemoveMediaEnded::<Impl, OFFSET>,
            MediaFailed::<Impl, OFFSET>,
            RemoveMediaFailed::<Impl, OFFSET>,
            DownloadProgressChanged::<Impl, OFFSET>,
            RemoveDownloadProgressChanged::<Impl, OFFSET>,
            BufferingProgressChanged::<Impl, OFFSET>,
            RemoveBufferingProgressChanged::<Impl, OFFSET>,
            CurrentStateChanged::<Impl, OFFSET>,
            RemoveCurrentStateChanged::<Impl, OFFSET>,
            MarkerReached::<Impl, OFFSET>,
            RemoveMarkerReached::<Impl, OFFSET>,
            RateChanged::<Impl, OFFSET>,
            RemoveRateChanged::<Impl, OFFSET>,
            VolumeChanged::<Impl, OFFSET>,
            RemoveVolumeChanged::<Impl, OFFSET>,
            SeekCompleted::<Impl, OFFSET>,
            RemoveSeekCompleted::<Impl, OFFSET>,
            Stop::<Impl, OFFSET>,
            Play::<Impl, OFFSET>,
            Pause::<Impl, OFFSET>,
            CanPlayType::<Impl, OFFSET>,
            SetSource::<Impl, OFFSET>,
            GetAudioStreamLanguage::<Impl, OFFSET>,
            AddAudioEffect::<Impl, OFFSET>,
            AddVideoEffect::<Impl, OFFSET>,
            RemoveAllEffects::<Impl, OFFSET>,
            ActualStereo3DVideoPackingMode::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaElement2Impl: Sized {
    fn AreTransportControlsEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetAreTransportControlsEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn Stretch(&self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
    fn IsFullWindow(&self) -> ::windows::core::Result<bool>;
    fn SetIsFullWindow(&self, value: bool) -> ::windows::core::Result<()>;
    fn SetMediaStreamSource(&self, source: &::core::option::Option<super::super::super::Media::Core::IMediaSource>) -> ::windows::core::Result<()>;
    fn PlayToPreferredSourceUri(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetPlayToPreferredSourceUri(&self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaElement2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaElement2";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaElement2Vtbl {
    pub const fn new<Impl: IMediaElement2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaElement2Vtbl {
        unsafe extern "system" fn AreTransportControlsEnabled<Impl: IMediaElement2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AreTransportControlsEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreTransportControlsEnabled<Impl: IMediaElement2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAreTransportControlsEnabled(value).into()
        }
        unsafe extern "system" fn Stretch<Impl: IMediaElement2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: IMediaElement2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        unsafe extern "system" fn IsFullWindow<Impl: IMediaElement2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFullWindow() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFullWindow<Impl: IMediaElement2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsFullWindow(value).into()
        }
        unsafe extern "system" fn SetMediaStreamSource<Impl: IMediaElement2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMediaStreamSource(&*(&source as *const <super::super::super::Media::Core::IMediaSource as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Core::IMediaSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlayToPreferredSourceUri<Impl: IMediaElement2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayToPreferredSourceUri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlayToPreferredSourceUri<Impl: IMediaElement2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlayToPreferredSourceUri(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaElement2>, base.5, AreTransportControlsEnabled::<Impl, OFFSET>, SetAreTransportControlsEnabled::<Impl, OFFSET>, Stretch::<Impl, OFFSET>, SetStretch::<Impl, OFFSET>, IsFullWindow::<Impl, OFFSET>, SetIsFullWindow::<Impl, OFFSET>, SetMediaStreamSource::<Impl, OFFSET>, PlayToPreferredSourceUri::<Impl, OFFSET>, SetPlayToPreferredSourceUri::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaElement3Impl: Sized {
    fn TransportControls(&self) -> ::windows::core::Result<MediaTransportControls>;
    fn SetTransportControls(&self, value: &::core::option::Option<MediaTransportControls>) -> ::windows::core::Result<()>;
    fn PartialMediaFailureDetected(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<MediaElement, super::Media::PartialMediaFailureDetectedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePartialMediaFailureDetected(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SetPlaybackSource(&self, source: &::core::option::Option<super::super::super::Media::Playback::IMediaPlaybackSource>) -> ::windows::core::Result<()>;
    fn GetAsCastingSource(&self) -> ::windows::core::Result<super::super::super::Media::Casting::CastingSource>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaElement3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaElement3";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaElement3Vtbl {
    pub const fn new<Impl: IMediaElement3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaElement3Vtbl {
        unsafe extern "system" fn TransportControls<Impl: IMediaElement3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TransportControls() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTransportControls<Impl: IMediaElement3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTransportControls(&*(&value as *const <MediaTransportControls as ::windows::core::Abi>::Abi as *const <MediaTransportControls as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PartialMediaFailureDetected<Impl: IMediaElement3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PartialMediaFailureDetected(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<MediaElement, super::Media::PartialMediaFailureDetectedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<MediaElement, super::Media::PartialMediaFailureDetectedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePartialMediaFailureDetected<Impl: IMediaElement3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePartialMediaFailureDetected(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetPlaybackSource<Impl: IMediaElement3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlaybackSource(&*(&source as *const <super::super::super::Media::Playback::IMediaPlaybackSource as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Playback::IMediaPlaybackSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetAsCastingSource<Impl: IMediaElement3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAsCastingSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaElement3>, base.5, TransportControls::<Impl, OFFSET>, SetTransportControls::<Impl, OFFSET>, PartialMediaFailureDetected::<Impl, OFFSET>, RemovePartialMediaFailureDetected::<Impl, OFFSET>, SetPlaybackSource::<Impl, OFFSET>, GetAsCastingSource::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaElementStaticsImpl: Sized {
    fn PosterSourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsMutedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsAudioOnlyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AutoPlayProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VolumeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BalanceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn NaturalVideoHeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn NaturalVideoWidthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn NaturalDurationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PositionProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DownloadProgressProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BufferingProgressProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DownloadProgressOffsetProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CurrentStateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanSeekProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanPauseProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AudioStreamCountProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AudioStreamIndexProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaybackRateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsLoopingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlayToSourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DefaultPlaybackRateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AspectRatioWidthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AspectRatioHeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RealTimePlaybackProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AudioCategoryProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AudioDeviceTypeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ProtectionManagerProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn Stereo3DVideoPackingModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn Stereo3DVideoRenderModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsStereo3DVideoProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ActualStereo3DVideoPackingModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaElementStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaElementStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaElementStaticsVtbl {
    pub const fn new<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaElementStaticsVtbl {
        unsafe extern "system" fn PosterSourceProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PosterSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsMutedProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsMutedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsAudioOnlyProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsAudioOnlyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoPlayProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AutoPlayProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VolumeProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VolumeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BalanceProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BalanceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NaturalVideoHeightProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NaturalVideoHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NaturalVideoWidthProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NaturalVideoWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NaturalDurationProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NaturalDurationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PositionProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PositionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DownloadProgressProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DownloadProgressProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BufferingProgressProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BufferingProgressProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DownloadProgressOffsetProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DownloadProgressOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CurrentStateProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentStateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanSeekProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanSeekProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanPauseProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanPauseProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioStreamCountProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioStreamCountProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioStreamIndexProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioStreamIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaybackRateProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaybackRateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsLoopingProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsLoopingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayToSourceProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayToSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultPlaybackRateProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultPlaybackRateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AspectRatioWidthProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AspectRatioWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AspectRatioHeightProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AspectRatioHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RealTimePlaybackProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RealTimePlaybackProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioCategoryProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioCategoryProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AudioDeviceTypeProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AudioDeviceTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProtectionManagerProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProtectionManagerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stereo3DVideoPackingModeProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stereo3DVideoPackingModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stereo3DVideoRenderModeProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stereo3DVideoRenderModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsStereo3DVideoProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsStereo3DVideoProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ActualStereo3DVideoPackingModeProperty<Impl: IMediaElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ActualStereo3DVideoPackingModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMediaElementStatics>,
            base.5,
            PosterSourceProperty::<Impl, OFFSET>,
            SourceProperty::<Impl, OFFSET>,
            IsMutedProperty::<Impl, OFFSET>,
            IsAudioOnlyProperty::<Impl, OFFSET>,
            AutoPlayProperty::<Impl, OFFSET>,
            VolumeProperty::<Impl, OFFSET>,
            BalanceProperty::<Impl, OFFSET>,
            NaturalVideoHeightProperty::<Impl, OFFSET>,
            NaturalVideoWidthProperty::<Impl, OFFSET>,
            NaturalDurationProperty::<Impl, OFFSET>,
            PositionProperty::<Impl, OFFSET>,
            DownloadProgressProperty::<Impl, OFFSET>,
            BufferingProgressProperty::<Impl, OFFSET>,
            DownloadProgressOffsetProperty::<Impl, OFFSET>,
            CurrentStateProperty::<Impl, OFFSET>,
            CanSeekProperty::<Impl, OFFSET>,
            CanPauseProperty::<Impl, OFFSET>,
            AudioStreamCountProperty::<Impl, OFFSET>,
            AudioStreamIndexProperty::<Impl, OFFSET>,
            PlaybackRateProperty::<Impl, OFFSET>,
            IsLoopingProperty::<Impl, OFFSET>,
            PlayToSourceProperty::<Impl, OFFSET>,
            DefaultPlaybackRateProperty::<Impl, OFFSET>,
            AspectRatioWidthProperty::<Impl, OFFSET>,
            AspectRatioHeightProperty::<Impl, OFFSET>,
            RealTimePlaybackProperty::<Impl, OFFSET>,
            AudioCategoryProperty::<Impl, OFFSET>,
            AudioDeviceTypeProperty::<Impl, OFFSET>,
            ProtectionManagerProperty::<Impl, OFFSET>,
            Stereo3DVideoPackingModeProperty::<Impl, OFFSET>,
            Stereo3DVideoRenderModeProperty::<Impl, OFFSET>,
            IsStereo3DVideoProperty::<Impl, OFFSET>,
            ActualStereo3DVideoPackingModeProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaElementStatics2Impl: Sized {
    fn AreTransportControlsEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFullWindowProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlayToPreferredSourceUriProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaElementStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaElementStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaElementStatics2Vtbl {
    pub const fn new<Impl: IMediaElementStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaElementStatics2Vtbl {
        unsafe extern "system" fn AreTransportControlsEnabledProperty<Impl: IMediaElementStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AreTransportControlsEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchProperty<Impl: IMediaElementStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFullWindowProperty<Impl: IMediaElementStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFullWindowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlayToPreferredSourceUriProperty<Impl: IMediaElementStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlayToPreferredSourceUriProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaElementStatics2>, base.5, AreTransportControlsEnabledProperty::<Impl, OFFSET>, StretchProperty::<Impl, OFFSET>, IsFullWindowProperty::<Impl, OFFSET>, PlayToPreferredSourceUriProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaPlayerElementImpl: Sized {
    fn Source(&self) -> ::windows::core::Result<super::super::super::Media::Playback::IMediaPlaybackSource>;
    fn SetSource(&self, value: &::core::option::Option<super::super::super::Media::Playback::IMediaPlaybackSource>) -> ::windows::core::Result<()>;
    fn TransportControls(&self) -> ::windows::core::Result<MediaTransportControls>;
    fn SetTransportControls(&self, value: &::core::option::Option<MediaTransportControls>) -> ::windows::core::Result<()>;
    fn AreTransportControlsEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetAreTransportControlsEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn PosterSource(&self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetPosterSource(&self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn Stretch(&self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
    fn AutoPlay(&self) -> ::windows::core::Result<bool>;
    fn SetAutoPlay(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsFullWindow(&self) -> ::windows::core::Result<bool>;
    fn SetIsFullWindow(&self, value: bool) -> ::windows::core::Result<()>;
    fn MediaPlayer(&self) -> ::windows::core::Result<super::super::super::Media::Playback::MediaPlayer>;
    fn SetMediaPlayer(&self, mediaplayer: &::core::option::Option<super::super::super::Media::Playback::MediaPlayer>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaPlayerElement {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerElement";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaPlayerElementVtbl {
    pub const fn new<Impl: IMediaPlayerElementImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaPlayerElementVtbl {
        unsafe extern "system" fn Source<Impl: IMediaPlayerElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IMediaPlayerElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::super::super::Media::Playback::IMediaPlaybackSource as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Playback::IMediaPlaybackSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TransportControls<Impl: IMediaPlayerElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TransportControls() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTransportControls<Impl: IMediaPlayerElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTransportControls(&*(&value as *const <MediaTransportControls as ::windows::core::Abi>::Abi as *const <MediaTransportControls as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AreTransportControlsEnabled<Impl: IMediaPlayerElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AreTransportControlsEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreTransportControlsEnabled<Impl: IMediaPlayerElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAreTransportControlsEnabled(value).into()
        }
        unsafe extern "system" fn PosterSource<Impl: IMediaPlayerElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PosterSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPosterSource<Impl: IMediaPlayerElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPosterSource(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stretch<Impl: IMediaPlayerElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: IMediaPlayerElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        unsafe extern "system" fn AutoPlay<Impl: IMediaPlayerElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AutoPlay() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAutoPlay<Impl: IMediaPlayerElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAutoPlay(value).into()
        }
        unsafe extern "system" fn IsFullWindow<Impl: IMediaPlayerElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFullWindow() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFullWindow<Impl: IMediaPlayerElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsFullWindow(value).into()
        }
        unsafe extern "system" fn MediaPlayer<Impl: IMediaPlayerElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MediaPlayer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaPlayer<Impl: IMediaPlayerElementImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mediaplayer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMediaPlayer(&*(&mediaplayer as *const <super::super::super::Media::Playback::MediaPlayer as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Playback::MediaPlayer as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMediaPlayerElement>,
            base.5,
            Source::<Impl, OFFSET>,
            SetSource::<Impl, OFFSET>,
            TransportControls::<Impl, OFFSET>,
            SetTransportControls::<Impl, OFFSET>,
            AreTransportControlsEnabled::<Impl, OFFSET>,
            SetAreTransportControlsEnabled::<Impl, OFFSET>,
            PosterSource::<Impl, OFFSET>,
            SetPosterSource::<Impl, OFFSET>,
            Stretch::<Impl, OFFSET>,
            SetStretch::<Impl, OFFSET>,
            AutoPlay::<Impl, OFFSET>,
            SetAutoPlay::<Impl, OFFSET>,
            IsFullWindow::<Impl, OFFSET>,
            SetIsFullWindow::<Impl, OFFSET>,
            MediaPlayer::<Impl, OFFSET>,
            SetMediaPlayer::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaPlayerElementFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MediaPlayerElement>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaPlayerElementFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerElementFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaPlayerElementFactoryVtbl {
    pub const fn new<Impl: IMediaPlayerElementFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaPlayerElementFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMediaPlayerElementFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaPlayerElementFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaPlayerElementStaticsImpl: Sized {
    fn SourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AreTransportControlsEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PosterSourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AutoPlayProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFullWindowProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MediaPlayerProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaPlayerElementStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerElementStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaPlayerElementStaticsVtbl {
    pub const fn new<Impl: IMediaPlayerElementStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaPlayerElementStaticsVtbl {
        unsafe extern "system" fn SourceProperty<Impl: IMediaPlayerElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AreTransportControlsEnabledProperty<Impl: IMediaPlayerElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AreTransportControlsEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PosterSourceProperty<Impl: IMediaPlayerElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PosterSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchProperty<Impl: IMediaPlayerElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoPlayProperty<Impl: IMediaPlayerElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AutoPlayProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFullWindowProperty<Impl: IMediaPlayerElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFullWindowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MediaPlayerProperty<Impl: IMediaPlayerElementStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MediaPlayerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaPlayerElementStatics>, base.5, SourceProperty::<Impl, OFFSET>, AreTransportControlsEnabledProperty::<Impl, OFFSET>, PosterSourceProperty::<Impl, OFFSET>, StretchProperty::<Impl, OFFSET>, AutoPlayProperty::<Impl, OFFSET>, IsFullWindowProperty::<Impl, OFFSET>, MediaPlayerProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaPlayerPresenterImpl: Sized {
    fn MediaPlayer(&self) -> ::windows::core::Result<super::super::super::Media::Playback::MediaPlayer>;
    fn SetMediaPlayer(&self, value: &::core::option::Option<super::super::super::Media::Playback::MediaPlayer>) -> ::windows::core::Result<()>;
    fn Stretch(&self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
    fn IsFullWindow(&self) -> ::windows::core::Result<bool>;
    fn SetIsFullWindow(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaPlayerPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaPlayerPresenterVtbl {
    pub const fn new<Impl: IMediaPlayerPresenterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaPlayerPresenterVtbl {
        unsafe extern "system" fn MediaPlayer<Impl: IMediaPlayerPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MediaPlayer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaPlayer<Impl: IMediaPlayerPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMediaPlayer(&*(&value as *const <super::super::super::Media::Playback::MediaPlayer as ::windows::core::Abi>::Abi as *const <super::super::super::Media::Playback::MediaPlayer as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stretch<Impl: IMediaPlayerPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: IMediaPlayerPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        unsafe extern "system" fn IsFullWindow<Impl: IMediaPlayerPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFullWindow() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFullWindow<Impl: IMediaPlayerPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsFullWindow(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaPlayerPresenter>, base.5, MediaPlayer::<Impl, OFFSET>, SetMediaPlayer::<Impl, OFFSET>, Stretch::<Impl, OFFSET>, SetStretch::<Impl, OFFSET>, IsFullWindow::<Impl, OFFSET>, SetIsFullWindow::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaPlayerPresenterFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MediaPlayerPresenter>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaPlayerPresenterFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerPresenterFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaPlayerPresenterFactoryVtbl {
    pub const fn new<Impl: IMediaPlayerPresenterFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaPlayerPresenterFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMediaPlayerPresenterFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaPlayerPresenterFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaPlayerPresenterStaticsImpl: Sized {
    fn MediaPlayerProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFullWindowProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaPlayerPresenterStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaPlayerPresenterStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaPlayerPresenterStaticsVtbl {
    pub const fn new<Impl: IMediaPlayerPresenterStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaPlayerPresenterStaticsVtbl {
        unsafe extern "system" fn MediaPlayerProperty<Impl: IMediaPlayerPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MediaPlayerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchProperty<Impl: IMediaPlayerPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFullWindowProperty<Impl: IMediaPlayerPresenterStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFullWindowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaPlayerPresenterStatics>, base.5, MediaPlayerProperty::<Impl, OFFSET>, StretchProperty::<Impl, OFFSET>, IsFullWindowProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsImpl: Sized {
    fn IsFullWindowButtonVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsFullWindowButtonVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsFullWindowEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsFullWindowEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsZoomButtonVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsZoomButtonVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsZoomEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsZoomEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsFastForwardButtonVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsFastForwardButtonVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsFastForwardEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsFastForwardEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsFastRewindButtonVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsFastRewindButtonVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsFastRewindEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsFastRewindEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsStopButtonVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsStopButtonVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsStopEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsStopEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsVolumeButtonVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsVolumeButtonVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsVolumeEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsVolumeEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsPlaybackRateButtonVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsPlaybackRateButtonVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsPlaybackRateEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsPlaybackRateEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsSeekBarVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsSeekBarVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsSeekEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsSeekEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsCompact(&self) -> ::windows::core::Result<bool>;
    fn SetIsCompact(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControls {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControls";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsVtbl {
    pub const fn new<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaTransportControlsVtbl {
        unsafe extern "system" fn IsFullWindowButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFullWindowButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFullWindowButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsFullWindowButtonVisible(value).into()
        }
        unsafe extern "system" fn IsFullWindowEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFullWindowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFullWindowEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsFullWindowEnabled(value).into()
        }
        unsafe extern "system" fn IsZoomButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsZoomButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsZoomButtonVisible(value).into()
        }
        unsafe extern "system" fn IsZoomEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsZoomEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsZoomEnabled(value).into()
        }
        unsafe extern "system" fn IsFastForwardButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFastForwardButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFastForwardButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsFastForwardButtonVisible(value).into()
        }
        unsafe extern "system" fn IsFastForwardEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFastForwardEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFastForwardEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsFastForwardEnabled(value).into()
        }
        unsafe extern "system" fn IsFastRewindButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFastRewindButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFastRewindButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsFastRewindButtonVisible(value).into()
        }
        unsafe extern "system" fn IsFastRewindEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFastRewindEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsFastRewindEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsFastRewindEnabled(value).into()
        }
        unsafe extern "system" fn IsStopButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsStopButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsStopButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsStopButtonVisible(value).into()
        }
        unsafe extern "system" fn IsStopEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsStopEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsStopEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsStopEnabled(value).into()
        }
        unsafe extern "system" fn IsVolumeButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsVolumeButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVolumeButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsVolumeButtonVisible(value).into()
        }
        unsafe extern "system" fn IsVolumeEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsVolumeEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVolumeEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsVolumeEnabled(value).into()
        }
        unsafe extern "system" fn IsPlaybackRateButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPlaybackRateButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPlaybackRateButtonVisible<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsPlaybackRateButtonVisible(value).into()
        }
        unsafe extern "system" fn IsPlaybackRateEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPlaybackRateEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPlaybackRateEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsPlaybackRateEnabled(value).into()
        }
        unsafe extern "system" fn IsSeekBarVisible<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSeekBarVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSeekBarVisible<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsSeekBarVisible(value).into()
        }
        unsafe extern "system" fn IsSeekEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSeekEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSeekEnabled<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsSeekEnabled(value).into()
        }
        unsafe extern "system" fn IsCompact<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCompact() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCompact<Impl: IMediaTransportControlsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsCompact(value).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMediaTransportControls>,
            base.5,
            IsFullWindowButtonVisible::<Impl, OFFSET>,
            SetIsFullWindowButtonVisible::<Impl, OFFSET>,
            IsFullWindowEnabled::<Impl, OFFSET>,
            SetIsFullWindowEnabled::<Impl, OFFSET>,
            IsZoomButtonVisible::<Impl, OFFSET>,
            SetIsZoomButtonVisible::<Impl, OFFSET>,
            IsZoomEnabled::<Impl, OFFSET>,
            SetIsZoomEnabled::<Impl, OFFSET>,
            IsFastForwardButtonVisible::<Impl, OFFSET>,
            SetIsFastForwardButtonVisible::<Impl, OFFSET>,
            IsFastForwardEnabled::<Impl, OFFSET>,
            SetIsFastForwardEnabled::<Impl, OFFSET>,
            IsFastRewindButtonVisible::<Impl, OFFSET>,
            SetIsFastRewindButtonVisible::<Impl, OFFSET>,
            IsFastRewindEnabled::<Impl, OFFSET>,
            SetIsFastRewindEnabled::<Impl, OFFSET>,
            IsStopButtonVisible::<Impl, OFFSET>,
            SetIsStopButtonVisible::<Impl, OFFSET>,
            IsStopEnabled::<Impl, OFFSET>,
            SetIsStopEnabled::<Impl, OFFSET>,
            IsVolumeButtonVisible::<Impl, OFFSET>,
            SetIsVolumeButtonVisible::<Impl, OFFSET>,
            IsVolumeEnabled::<Impl, OFFSET>,
            SetIsVolumeEnabled::<Impl, OFFSET>,
            IsPlaybackRateButtonVisible::<Impl, OFFSET>,
            SetIsPlaybackRateButtonVisible::<Impl, OFFSET>,
            IsPlaybackRateEnabled::<Impl, OFFSET>,
            SetIsPlaybackRateEnabled::<Impl, OFFSET>,
            IsSeekBarVisible::<Impl, OFFSET>,
            SetIsSeekBarVisible::<Impl, OFFSET>,
            IsSeekEnabled::<Impl, OFFSET>,
            SetIsSeekEnabled::<Impl, OFFSET>,
            IsCompact::<Impl, OFFSET>,
            SetIsCompact::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControls2Impl: Sized {
    fn IsSkipForwardButtonVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsSkipForwardButtonVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsSkipForwardEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsSkipForwardEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsSkipBackwardButtonVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsSkipBackwardButtonVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsSkipBackwardEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsSkipBackwardEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsNextTrackButtonVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsNextTrackButtonVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsPreviousTrackButtonVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsPreviousTrackButtonVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn FastPlayFallbackBehaviour(&self) -> ::windows::core::Result<super::Media::FastPlayFallbackBehaviour>;
    fn SetFastPlayFallbackBehaviour(&self, value: super::Media::FastPlayFallbackBehaviour) -> ::windows::core::Result<()>;
    fn ThumbnailRequested(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<MediaTransportControls, super::Media::MediaTransportControlsThumbnailRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveThumbnailRequested(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControls2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControls2";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControls2Vtbl {
    pub const fn new<Impl: IMediaTransportControls2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaTransportControls2Vtbl {
        unsafe extern "system" fn IsSkipForwardButtonVisible<Impl: IMediaTransportControls2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSkipForwardButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSkipForwardButtonVisible<Impl: IMediaTransportControls2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsSkipForwardButtonVisible(value).into()
        }
        unsafe extern "system" fn IsSkipForwardEnabled<Impl: IMediaTransportControls2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSkipForwardEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSkipForwardEnabled<Impl: IMediaTransportControls2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsSkipForwardEnabled(value).into()
        }
        unsafe extern "system" fn IsSkipBackwardButtonVisible<Impl: IMediaTransportControls2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSkipBackwardButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSkipBackwardButtonVisible<Impl: IMediaTransportControls2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsSkipBackwardButtonVisible(value).into()
        }
        unsafe extern "system" fn IsSkipBackwardEnabled<Impl: IMediaTransportControls2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSkipBackwardEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSkipBackwardEnabled<Impl: IMediaTransportControls2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsSkipBackwardEnabled(value).into()
        }
        unsafe extern "system" fn IsNextTrackButtonVisible<Impl: IMediaTransportControls2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsNextTrackButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsNextTrackButtonVisible<Impl: IMediaTransportControls2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsNextTrackButtonVisible(value).into()
        }
        unsafe extern "system" fn IsPreviousTrackButtonVisible<Impl: IMediaTransportControls2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPreviousTrackButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPreviousTrackButtonVisible<Impl: IMediaTransportControls2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsPreviousTrackButtonVisible(value).into()
        }
        unsafe extern "system" fn FastPlayFallbackBehaviour<Impl: IMediaTransportControls2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::FastPlayFallbackBehaviour) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FastPlayFallbackBehaviour() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFastPlayFallbackBehaviour<Impl: IMediaTransportControls2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Media::FastPlayFallbackBehaviour) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFastPlayFallbackBehaviour(value).into()
        }
        unsafe extern "system" fn ThumbnailRequested<Impl: IMediaTransportControls2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ThumbnailRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<MediaTransportControls, super::Media::MediaTransportControlsThumbnailRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<MediaTransportControls, super::Media::MediaTransportControlsThumbnailRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveThumbnailRequested<Impl: IMediaTransportControls2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveThumbnailRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMediaTransportControls2>,
            base.5,
            IsSkipForwardButtonVisible::<Impl, OFFSET>,
            SetIsSkipForwardButtonVisible::<Impl, OFFSET>,
            IsSkipForwardEnabled::<Impl, OFFSET>,
            SetIsSkipForwardEnabled::<Impl, OFFSET>,
            IsSkipBackwardButtonVisible::<Impl, OFFSET>,
            SetIsSkipBackwardButtonVisible::<Impl, OFFSET>,
            IsSkipBackwardEnabled::<Impl, OFFSET>,
            SetIsSkipBackwardEnabled::<Impl, OFFSET>,
            IsNextTrackButtonVisible::<Impl, OFFSET>,
            SetIsNextTrackButtonVisible::<Impl, OFFSET>,
            IsPreviousTrackButtonVisible::<Impl, OFFSET>,
            SetIsPreviousTrackButtonVisible::<Impl, OFFSET>,
            FastPlayFallbackBehaviour::<Impl, OFFSET>,
            SetFastPlayFallbackBehaviour::<Impl, OFFSET>,
            ThumbnailRequested::<Impl, OFFSET>,
            RemoveThumbnailRequested::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControls3Impl: Sized {
    fn ShowAndHideAutomatically(&self) -> ::windows::core::Result<bool>;
    fn SetShowAndHideAutomatically(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsRepeatEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsRepeatEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsRepeatButtonVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsRepeatButtonVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn Show(&self) -> ::windows::core::Result<()>;
    fn Hide(&self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControls3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControls3";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControls3Vtbl {
    pub const fn new<Impl: IMediaTransportControls3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaTransportControls3Vtbl {
        unsafe extern "system" fn ShowAndHideAutomatically<Impl: IMediaTransportControls3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowAndHideAutomatically() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowAndHideAutomatically<Impl: IMediaTransportControls3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetShowAndHideAutomatically(value).into()
        }
        unsafe extern "system" fn IsRepeatEnabled<Impl: IMediaTransportControls3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsRepeatEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsRepeatEnabled<Impl: IMediaTransportControls3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsRepeatEnabled(value).into()
        }
        unsafe extern "system" fn IsRepeatButtonVisible<Impl: IMediaTransportControls3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsRepeatButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsRepeatButtonVisible<Impl: IMediaTransportControls3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsRepeatButtonVisible(value).into()
        }
        unsafe extern "system" fn Show<Impl: IMediaTransportControls3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Show().into()
        }
        unsafe extern "system" fn Hide<Impl: IMediaTransportControls3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Hide().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaTransportControls3>, base.5, ShowAndHideAutomatically::<Impl, OFFSET>, SetShowAndHideAutomatically::<Impl, OFFSET>, IsRepeatEnabled::<Impl, OFFSET>, SetIsRepeatEnabled::<Impl, OFFSET>, IsRepeatButtonVisible::<Impl, OFFSET>, SetIsRepeatButtonVisible::<Impl, OFFSET>, Show::<Impl, OFFSET>, Hide::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControls4Impl: Sized {
    fn IsCompactOverlayButtonVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsCompactOverlayButtonVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsCompactOverlayEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsCompactOverlayEnabled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControls4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControls4";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControls4Vtbl {
    pub const fn new<Impl: IMediaTransportControls4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaTransportControls4Vtbl {
        unsafe extern "system" fn IsCompactOverlayButtonVisible<Impl: IMediaTransportControls4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCompactOverlayButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCompactOverlayButtonVisible<Impl: IMediaTransportControls4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsCompactOverlayButtonVisible(value).into()
        }
        unsafe extern "system" fn IsCompactOverlayEnabled<Impl: IMediaTransportControls4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCompactOverlayEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsCompactOverlayEnabled<Impl: IMediaTransportControls4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsCompactOverlayEnabled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaTransportControls4>, base.5, IsCompactOverlayButtonVisible::<Impl, OFFSET>, SetIsCompactOverlayButtonVisible::<Impl, OFFSET>, IsCompactOverlayEnabled::<Impl, OFFSET>, SetIsCompactOverlayEnabled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MediaTransportControls>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsFactoryVtbl {
    pub const fn new<Impl: IMediaTransportControlsFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaTransportControlsFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMediaTransportControlsFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaTransportControlsFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsHelperImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsHelper {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsHelper";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsHelperVtbl {
    pub const fn new<Impl: IMediaTransportControlsHelperImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaTransportControlsHelperVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaTransportControlsHelper>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsHelperStaticsImpl: Sized {
    fn DropoutOrderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetDropoutOrder(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<super::super::super::Foundation::IReference<i32>>;
    fn SetDropoutOrder(&self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<super::super::super::Foundation::IReference<i32>>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsHelperStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsHelperStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsHelperStaticsVtbl {
    pub const fn new<Impl: IMediaTransportControlsHelperStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaTransportControlsHelperStaticsVtbl {
        unsafe extern "system" fn DropoutOrderProperty<Impl: IMediaTransportControlsHelperStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DropoutOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDropoutOrder<Impl: IMediaTransportControlsHelperStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDropoutOrder(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDropoutOrder<Impl: IMediaTransportControlsHelperStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDropoutOrder(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<i32> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaTransportControlsHelperStatics>, base.5, DropoutOrderProperty::<Impl, OFFSET>, GetDropoutOrder::<Impl, OFFSET>, SetDropoutOrder::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsStaticsImpl: Sized {
    fn IsFullWindowButtonVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFullWindowEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomButtonVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFastForwardButtonVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFastForwardEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFastRewindButtonVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsFastRewindEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsStopButtonVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsStopEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsVolumeButtonVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsVolumeEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPlaybackRateButtonVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPlaybackRateEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSeekBarVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSeekEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCompactProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsStaticsVtbl {
    pub const fn new<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaTransportControlsStaticsVtbl {
        unsafe extern "system" fn IsFullWindowButtonVisibleProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFullWindowButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFullWindowEnabledProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFullWindowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomButtonVisibleProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsZoomButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomEnabledProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsZoomEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFastForwardButtonVisibleProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFastForwardButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFastForwardEnabledProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFastForwardEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFastRewindButtonVisibleProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFastRewindButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFastRewindEnabledProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFastRewindEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsStopButtonVisibleProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsStopButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsStopEnabledProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsStopEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsVolumeButtonVisibleProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsVolumeButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsVolumeEnabledProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsVolumeEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPlaybackRateButtonVisibleProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPlaybackRateButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPlaybackRateEnabledProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPlaybackRateEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSeekBarVisibleProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSeekBarVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSeekEnabledProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSeekEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCompactProperty<Impl: IMediaTransportControlsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCompactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMediaTransportControlsStatics>,
            base.5,
            IsFullWindowButtonVisibleProperty::<Impl, OFFSET>,
            IsFullWindowEnabledProperty::<Impl, OFFSET>,
            IsZoomButtonVisibleProperty::<Impl, OFFSET>,
            IsZoomEnabledProperty::<Impl, OFFSET>,
            IsFastForwardButtonVisibleProperty::<Impl, OFFSET>,
            IsFastForwardEnabledProperty::<Impl, OFFSET>,
            IsFastRewindButtonVisibleProperty::<Impl, OFFSET>,
            IsFastRewindEnabledProperty::<Impl, OFFSET>,
            IsStopButtonVisibleProperty::<Impl, OFFSET>,
            IsStopEnabledProperty::<Impl, OFFSET>,
            IsVolumeButtonVisibleProperty::<Impl, OFFSET>,
            IsVolumeEnabledProperty::<Impl, OFFSET>,
            IsPlaybackRateButtonVisibleProperty::<Impl, OFFSET>,
            IsPlaybackRateEnabledProperty::<Impl, OFFSET>,
            IsSeekBarVisibleProperty::<Impl, OFFSET>,
            IsSeekEnabledProperty::<Impl, OFFSET>,
            IsCompactProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsStatics2Impl: Sized {
    fn IsSkipForwardButtonVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSkipForwardEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSkipBackwardButtonVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSkipBackwardEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsNextTrackButtonVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPreviousTrackButtonVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FastPlayFallbackBehaviourProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsStatics2Vtbl {
    pub const fn new<Impl: IMediaTransportControlsStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaTransportControlsStatics2Vtbl {
        unsafe extern "system" fn IsSkipForwardButtonVisibleProperty<Impl: IMediaTransportControlsStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSkipForwardButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSkipForwardEnabledProperty<Impl: IMediaTransportControlsStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSkipForwardEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSkipBackwardButtonVisibleProperty<Impl: IMediaTransportControlsStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSkipBackwardButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSkipBackwardEnabledProperty<Impl: IMediaTransportControlsStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSkipBackwardEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsNextTrackButtonVisibleProperty<Impl: IMediaTransportControlsStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsNextTrackButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPreviousTrackButtonVisibleProperty<Impl: IMediaTransportControlsStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPreviousTrackButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FastPlayFallbackBehaviourProperty<Impl: IMediaTransportControlsStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FastPlayFallbackBehaviourProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaTransportControlsStatics2>, base.5, IsSkipForwardButtonVisibleProperty::<Impl, OFFSET>, IsSkipForwardEnabledProperty::<Impl, OFFSET>, IsSkipBackwardButtonVisibleProperty::<Impl, OFFSET>, IsSkipBackwardEnabledProperty::<Impl, OFFSET>, IsNextTrackButtonVisibleProperty::<Impl, OFFSET>, IsPreviousTrackButtonVisibleProperty::<Impl, OFFSET>, FastPlayFallbackBehaviourProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsStatics3Impl: Sized {
    fn ShowAndHideAutomaticallyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsRepeatEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsRepeatButtonVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsStatics3Vtbl {
    pub const fn new<Impl: IMediaTransportControlsStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaTransportControlsStatics3Vtbl {
        unsafe extern "system" fn ShowAndHideAutomaticallyProperty<Impl: IMediaTransportControlsStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowAndHideAutomaticallyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRepeatEnabledProperty<Impl: IMediaTransportControlsStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsRepeatEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRepeatButtonVisibleProperty<Impl: IMediaTransportControlsStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsRepeatButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaTransportControlsStatics3>, base.5, ShowAndHideAutomaticallyProperty::<Impl, OFFSET>, IsRepeatEnabledProperty::<Impl, OFFSET>, IsRepeatButtonVisibleProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMediaTransportControlsStatics4Impl: Sized {
    fn IsCompactOverlayButtonVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsCompactOverlayEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMediaTransportControlsStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMediaTransportControlsStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IMediaTransportControlsStatics4Vtbl {
    pub const fn new<Impl: IMediaTransportControlsStatics4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMediaTransportControlsStatics4Vtbl {
        unsafe extern "system" fn IsCompactOverlayButtonVisibleProperty<Impl: IMediaTransportControlsStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCompactOverlayButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCompactOverlayEnabledProperty<Impl: IMediaTransportControlsStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCompactOverlayEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMediaTransportControlsStatics4>, base.5, IsCompactOverlayButtonVisibleProperty::<Impl, OFFSET>, IsCompactOverlayEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarImpl: Sized {
    fn Items(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<MenuBarItem>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBar {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBar";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarVtbl {
    pub const fn new<Impl: IMenuBarImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuBarVtbl {
        unsafe extern "system" fn Items<Impl: IMenuBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuBar>, base.5, Items::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuBar>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarFactoryVtbl {
    pub const fn new<Impl: IMenuBarFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuBarFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuBarFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuBarFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarItemImpl: Sized {
    fn Title(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetTitle(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Items(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<MenuFlyoutItemBase>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarItem";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarItemVtbl {
    pub const fn new<Impl: IMenuBarItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuBarItemVtbl {
        unsafe extern "system" fn Title<Impl: IMenuBarItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Title() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitle<Impl: IMenuBarItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTitle(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Items<Impl: IMenuBarItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuBarItem>, base.5, Title::<Impl, OFFSET>, SetTitle::<Impl, OFFSET>, Items::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarItemFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuBarItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarItemFactoryVtbl {
    pub const fn new<Impl: IMenuBarItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuBarItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuBarItemFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuBarItemFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarItemFlyoutImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarItemFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarItemFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarItemFlyoutVtbl {
    pub const fn new<Impl: IMenuBarItemFlyoutImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuBarItemFlyoutVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuBarItemFlyout>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarItemFlyoutFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuBarItemFlyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarItemFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarItemFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarItemFlyoutFactoryVtbl {
    pub const fn new<Impl: IMenuBarItemFlyoutFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuBarItemFlyoutFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuBarItemFlyoutFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuBarItemFlyoutFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarItemStaticsImpl: Sized {
    fn TitleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarItemStaticsVtbl {
    pub const fn new<Impl: IMenuBarItemStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuBarItemStaticsVtbl {
        unsafe extern "system" fn TitleProperty<Impl: IMenuBarItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsProperty<Impl: IMenuBarItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuBarItemStatics>, base.5, TitleProperty::<Impl, OFFSET>, ItemsProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuBarStaticsImpl: Sized {
    fn ItemsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuBarStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuBarStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuBarStaticsVtbl {
    pub const fn new<Impl: IMenuBarStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuBarStaticsVtbl {
        unsafe extern "system" fn ItemsProperty<Impl: IMenuBarStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuBarStatics>, base.5, ItemsProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutImpl: Sized {
    fn Items(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<MenuFlyoutItemBase>>;
    fn MenuFlyoutPresenterStyle(&self) -> ::windows::core::Result<super::Style>;
    fn SetMenuFlyoutPresenterStyle(&self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutVtbl {
    pub const fn new<Impl: IMenuFlyoutImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutVtbl {
        unsafe extern "system" fn Items<Impl: IMenuFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuFlyoutPresenterStyle<Impl: IMenuFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuFlyoutPresenterStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuFlyoutPresenterStyle<Impl: IMenuFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMenuFlyoutPresenterStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyout>, base.5, Items::<Impl, OFFSET>, MenuFlyoutPresenterStyle::<Impl, OFFSET>, SetMenuFlyoutPresenterStyle::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyout2Impl: Sized {
    fn ShowAt(&self, targetelement: &::core::option::Option<super::UIElement>, point: &super::super::super::Foundation::Point) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyout2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyout2";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyout2Vtbl {
    pub const fn new<Impl: IMenuFlyout2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyout2Vtbl {
        unsafe extern "system" fn ShowAt<Impl: IMenuFlyout2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, targetelement: ::windows::core::RawPtr, point: super::super::super::Foundation::Point) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ShowAt(&*(&targetelement as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&point as *const <super::super::super::Foundation::Point as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Point as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyout2>, base.5, ShowAt::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuFlyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutFactoryVtbl {
    pub const fn new<Impl: IMenuFlyoutFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuFlyoutFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemImpl: Sized {
    fn Text(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Command(&self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetCommand(&self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn CommandParameter(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetCommandParameter(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn Click(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClick(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItem";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemVtbl {
    pub const fn new<Impl: IMenuFlyoutItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutItemVtbl {
        unsafe extern "system" fn Text<Impl: IMenuFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: IMenuFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Command<Impl: IMenuFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Command() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommand<Impl: IMenuFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CommandParameter<Impl: IMenuFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommandParameter<Impl: IMenuFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Click<Impl: IMenuFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Click(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClick<Impl: IMenuFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutItem>, base.5, Text::<Impl, OFFSET>, SetText::<Impl, OFFSET>, Command::<Impl, OFFSET>, SetCommand::<Impl, OFFSET>, CommandParameter::<Impl, OFFSET>, SetCommandParameter::<Impl, OFFSET>, Click::<Impl, OFFSET>, RemoveClick::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItem2Impl: Sized {
    fn Icon(&self) -> ::windows::core::Result<IconElement>;
    fn SetIcon(&self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItem2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItem2";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItem2Vtbl {
    pub const fn new<Impl: IMenuFlyoutItem2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutItem2Vtbl {
        unsafe extern "system" fn Icon<Impl: IMenuFlyoutItem2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Icon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIcon<Impl: IMenuFlyoutItem2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutItem2>, base.5, Icon::<Impl, OFFSET>, SetIcon::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItem3Impl: Sized {
    fn KeyboardAcceleratorTextOverride(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetKeyboardAcceleratorTextOverride(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn TemplateSettings(&self) -> ::windows::core::Result<Primitives::MenuFlyoutItemTemplateSettings>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItem3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItem3";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItem3Vtbl {
    pub const fn new<Impl: IMenuFlyoutItem3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutItem3Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverride<Impl: IMenuFlyoutItem3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverride() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetKeyboardAcceleratorTextOverride<Impl: IMenuFlyoutItem3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetKeyboardAcceleratorTextOverride(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: IMenuFlyoutItem3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutItem3>, base.5, KeyboardAcceleratorTextOverride::<Impl, OFFSET>, SetKeyboardAcceleratorTextOverride::<Impl, OFFSET>, TemplateSettings::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemBaseImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemBase {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemBase";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemBaseVtbl {
    pub const fn new<Impl: IMenuFlyoutItemBaseImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutItemBaseVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutItemBase>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemBaseFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemBaseFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemBaseFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemBaseFactoryVtbl {
    pub const fn new<Impl: IMenuFlyoutItemBaseFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutItemBaseFactoryVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutItemBaseFactory>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuFlyoutItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemFactoryVtbl {
    pub const fn new<Impl: IMenuFlyoutItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuFlyoutItemFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutItemFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemStaticsImpl: Sized {
    fn TextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandParameterProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemStaticsVtbl {
    pub const fn new<Impl: IMenuFlyoutItemStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutItemStaticsVtbl {
        unsafe extern "system" fn TextProperty<Impl: IMenuFlyoutItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandProperty<Impl: IMenuFlyoutItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandParameterProperty<Impl: IMenuFlyoutItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutItemStatics>, base.5, TextProperty::<Impl, OFFSET>, CommandProperty::<Impl, OFFSET>, CommandParameterProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemStatics2Impl: Sized {
    fn IconProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemStatics2Vtbl {
    pub const fn new<Impl: IMenuFlyoutItemStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutItemStatics2Vtbl {
        unsafe extern "system" fn IconProperty<Impl: IMenuFlyoutItemStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutItemStatics2>, base.5, IconProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutItemStatics3Impl: Sized {
    fn KeyboardAcceleratorTextOverrideProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutItemStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutItemStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutItemStatics3Vtbl {
    pub const fn new<Impl: IMenuFlyoutItemStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutItemStatics3Vtbl {
        unsafe extern "system" fn KeyboardAcceleratorTextOverrideProperty<Impl: IMenuFlyoutItemStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeyboardAcceleratorTextOverrideProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutItemStatics3>, base.5, KeyboardAcceleratorTextOverrideProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutPresenterImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutPresenterVtbl {
    pub const fn new<Impl: IMenuFlyoutPresenterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutPresenterVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutPresenter>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutPresenter2Impl: Sized {
    fn TemplateSettings(&self) -> ::windows::core::Result<Primitives::MenuFlyoutPresenterTemplateSettings>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenter2";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutPresenter2Vtbl {
    pub const fn new<Impl: IMenuFlyoutPresenter2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutPresenter2Vtbl {
        unsafe extern "system" fn TemplateSettings<Impl: IMenuFlyoutPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutPresenter2>, base.5, TemplateSettings::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutPresenter3Impl: Sized {
    fn IsDefaultShadowEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsDefaultShadowEnabled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutPresenter3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenter3";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutPresenter3Vtbl {
    pub const fn new<Impl: IMenuFlyoutPresenter3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutPresenter3Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabled<Impl: IMenuFlyoutPresenter3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDefaultShadowEnabled<Impl: IMenuFlyoutPresenter3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsDefaultShadowEnabled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutPresenter3>, base.5, IsDefaultShadowEnabled::<Impl, OFFSET>, SetIsDefaultShadowEnabled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutPresenterFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuFlyoutPresenter>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutPresenterFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenterFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutPresenterFactoryVtbl {
    pub const fn new<Impl: IMenuFlyoutPresenterFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutPresenterFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuFlyoutPresenterFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutPresenterFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutPresenterStatics3Impl: Sized {
    fn IsDefaultShadowEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutPresenterStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutPresenterStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutPresenterStatics3Vtbl {
    pub const fn new<Impl: IMenuFlyoutPresenterStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutPresenterStatics3Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabledProperty<Impl: IMenuFlyoutPresenterStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutPresenterStatics3>, base.5, IsDefaultShadowEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutSeparatorImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutSeparator {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSeparator";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutSeparatorVtbl {
    pub const fn new<Impl: IMenuFlyoutSeparatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutSeparatorVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutSeparator>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutSeparatorFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<MenuFlyoutSeparator>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutSeparatorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSeparatorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutSeparatorFactoryVtbl {
    pub const fn new<Impl: IMenuFlyoutSeparatorFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutSeparatorFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMenuFlyoutSeparatorFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutSeparatorFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutStaticsImpl: Sized {
    fn MenuFlyoutPresenterStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutStaticsVtbl {
    pub const fn new<Impl: IMenuFlyoutStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutStaticsVtbl {
        unsafe extern "system" fn MenuFlyoutPresenterStyleProperty<Impl: IMenuFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuFlyoutPresenterStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutStatics>, base.5, MenuFlyoutPresenterStyleProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutSubItemImpl: Sized {
    fn Items(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<MenuFlyoutItemBase>>;
    fn Text(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutSubItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSubItem";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutSubItemVtbl {
    pub const fn new<Impl: IMenuFlyoutSubItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutSubItemVtbl {
        unsafe extern "system" fn Items<Impl: IMenuFlyoutSubItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Text<Impl: IMenuFlyoutSubItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: IMenuFlyoutSubItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutSubItem>, base.5, Items::<Impl, OFFSET>, Text::<Impl, OFFSET>, SetText::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutSubItem2Impl: Sized {
    fn Icon(&self) -> ::windows::core::Result<IconElement>;
    fn SetIcon(&self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutSubItem2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSubItem2";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutSubItem2Vtbl {
    pub const fn new<Impl: IMenuFlyoutSubItem2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutSubItem2Vtbl {
        unsafe extern "system" fn Icon<Impl: IMenuFlyoutSubItem2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Icon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIcon<Impl: IMenuFlyoutSubItem2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutSubItem2>, base.5, Icon::<Impl, OFFSET>, SetIcon::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutSubItemStaticsImpl: Sized {
    fn TextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutSubItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSubItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutSubItemStaticsVtbl {
    pub const fn new<Impl: IMenuFlyoutSubItemStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutSubItemStaticsVtbl {
        unsafe extern "system" fn TextProperty<Impl: IMenuFlyoutSubItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutSubItemStatics>, base.5, TextProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IMenuFlyoutSubItemStatics2Impl: Sized {
    fn IconProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IMenuFlyoutSubItemStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IMenuFlyoutSubItemStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IMenuFlyoutSubItemStatics2Vtbl {
    pub const fn new<Impl: IMenuFlyoutSubItemStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMenuFlyoutSubItemStatics2Vtbl {
        unsafe extern "system" fn IconProperty<Impl: IMenuFlyoutSubItemStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMenuFlyoutSubItemStatics2>, base.5, IconProperty::<Impl, OFFSET>)
    }
}
pub trait INavigateImpl: Sized {
    fn Navigate(&self, sourcepagetype: &super::Interop::TypeName) -> ::windows::core::Result<bool>;
}
impl ::windows::core::RuntimeName for INavigate {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigate";
}
impl INavigateVtbl {
    pub const fn new<Impl: INavigateImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigateVtbl {
        unsafe extern "system" fn Navigate<Impl: INavigateImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sourcepagetype: ::core::mem::ManuallyDrop<super::Interop::TypeName>, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Navigate(&*(&sourcepagetype as *const <super::Interop::TypeName as ::windows::core::Abi>::Abi as *const <super::Interop::TypeName as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigate>, base.5, Navigate::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewImpl: Sized {
    fn IsPaneOpen(&self) -> ::windows::core::Result<bool>;
    fn SetIsPaneOpen(&self, value: bool) -> ::windows::core::Result<()>;
    fn CompactModeThresholdWidth(&self) -> ::windows::core::Result<f64>;
    fn SetCompactModeThresholdWidth(&self, value: f64) -> ::windows::core::Result<()>;
    fn ExpandedModeThresholdWidth(&self) -> ::windows::core::Result<f64>;
    fn SetExpandedModeThresholdWidth(&self, value: f64) -> ::windows::core::Result<()>;
    fn PaneFooter(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetPaneFooter(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn Header(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn DisplayMode(&self) -> ::windows::core::Result<NavigationViewDisplayMode>;
    fn IsSettingsVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsSettingsVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsPaneToggleButtonVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsPaneToggleButtonVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn AlwaysShowHeader(&self) -> ::windows::core::Result<bool>;
    fn SetAlwaysShowHeader(&self, value: bool) -> ::windows::core::Result<()>;
    fn CompactPaneLength(&self) -> ::windows::core::Result<f64>;
    fn SetCompactPaneLength(&self, value: f64) -> ::windows::core::Result<()>;
    fn OpenPaneLength(&self) -> ::windows::core::Result<f64>;
    fn SetOpenPaneLength(&self, value: f64) -> ::windows::core::Result<()>;
    fn PaneToggleButtonStyle(&self) -> ::windows::core::Result<super::Style>;
    fn SetPaneToggleButtonStyle(&self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn SelectedItem(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetSelectedItem(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn MenuItems(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn MenuItemsSource(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetMenuItemsSource(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SettingsItem(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn AutoSuggestBox(&self) -> ::windows::core::Result<AutoSuggestBox>;
    fn SetAutoSuggestBox(&self, value: &::core::option::Option<AutoSuggestBox>) -> ::windows::core::Result<()>;
    fn MenuItemTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetMenuItemTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn MenuItemTemplateSelector(&self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetMenuItemTemplateSelector(&self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn MenuItemContainerStyle(&self) -> ::windows::core::Result<super::Style>;
    fn SetMenuItemContainerStyle(&self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn MenuItemContainerStyleSelector(&self) -> ::windows::core::Result<StyleSelector>;
    fn SetMenuItemContainerStyleSelector(&self, value: &::core::option::Option<StyleSelector>) -> ::windows::core::Result<()>;
    fn MenuItemFromContainer(&self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn ContainerFromMenuItem(&self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DependencyObject>;
    fn SelectionChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewSelectionChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ItemInvoked(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewItemInvokedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveItemInvoked(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DisplayModeChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewDisplayModeChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDisplayModeChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationView";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewVtbl {
    pub const fn new<Impl: INavigationViewImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewVtbl {
        unsafe extern "system" fn IsPaneOpen<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPaneOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPaneOpen<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsPaneOpen(value).into()
        }
        unsafe extern "system" fn CompactModeThresholdWidth<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompactModeThresholdWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCompactModeThresholdWidth<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCompactModeThresholdWidth(value).into()
        }
        unsafe extern "system" fn ExpandedModeThresholdWidth<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExpandedModeThresholdWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetExpandedModeThresholdWidth<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetExpandedModeThresholdWidth(value).into()
        }
        unsafe extern "system" fn PaneFooter<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneFooter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneFooter<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPaneFooter(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Header<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisplayMode<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSettingsVisible<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSettingsVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSettingsVisible<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsSettingsVisible(value).into()
        }
        unsafe extern "system" fn IsPaneToggleButtonVisible<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPaneToggleButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPaneToggleButtonVisible<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsPaneToggleButtonVisible(value).into()
        }
        unsafe extern "system" fn AlwaysShowHeader<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AlwaysShowHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlwaysShowHeader<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAlwaysShowHeader(value).into()
        }
        unsafe extern "system" fn CompactPaneLength<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompactPaneLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCompactPaneLength<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCompactPaneLength(value).into()
        }
        unsafe extern "system" fn OpenPaneLength<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OpenPaneLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOpenPaneLength<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOpenPaneLength(value).into()
        }
        unsafe extern "system" fn PaneToggleButtonStyle<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneToggleButtonStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneToggleButtonStyle<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPaneToggleButtonStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedItem<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedItem<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedItem(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItems<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemsSource<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuItemsSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuItemsSource<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMenuItemsSource(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SettingsItem<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SettingsItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoSuggestBox<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AutoSuggestBox() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAutoSuggestBox<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAutoSuggestBox(&*(&value as *const <AutoSuggestBox as ::windows::core::Abi>::Abi as *const <AutoSuggestBox as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItemTemplate<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuItemTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuItemTemplate<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMenuItemTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItemTemplateSelector<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuItemTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuItemTemplateSelector<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMenuItemTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItemContainerStyle<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuItemContainerStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuItemContainerStyle<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMenuItemContainerStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItemContainerStyleSelector<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuItemContainerStyleSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMenuItemContainerStyleSelector<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMenuItemContainerStyleSelector(&*(&value as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MenuItemFromContainer<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuItemFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromMenuItem<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContainerFromMenuItem(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionChanged<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewSelectionChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewSelectionChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemInvoked<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemInvoked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewItemInvokedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewItemInvokedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveItemInvoked<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveItemInvoked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisplayModeChanged<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayModeChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewDisplayModeChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewDisplayModeChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDisplayModeChanged<Impl: INavigationViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveDisplayModeChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<INavigationView>,
            base.5,
            IsPaneOpen::<Impl, OFFSET>,
            SetIsPaneOpen::<Impl, OFFSET>,
            CompactModeThresholdWidth::<Impl, OFFSET>,
            SetCompactModeThresholdWidth::<Impl, OFFSET>,
            ExpandedModeThresholdWidth::<Impl, OFFSET>,
            SetExpandedModeThresholdWidth::<Impl, OFFSET>,
            PaneFooter::<Impl, OFFSET>,
            SetPaneFooter::<Impl, OFFSET>,
            Header::<Impl, OFFSET>,
            SetHeader::<Impl, OFFSET>,
            HeaderTemplate::<Impl, OFFSET>,
            SetHeaderTemplate::<Impl, OFFSET>,
            DisplayMode::<Impl, OFFSET>,
            IsSettingsVisible::<Impl, OFFSET>,
            SetIsSettingsVisible::<Impl, OFFSET>,
            IsPaneToggleButtonVisible::<Impl, OFFSET>,
            SetIsPaneToggleButtonVisible::<Impl, OFFSET>,
            AlwaysShowHeader::<Impl, OFFSET>,
            SetAlwaysShowHeader::<Impl, OFFSET>,
            CompactPaneLength::<Impl, OFFSET>,
            SetCompactPaneLength::<Impl, OFFSET>,
            OpenPaneLength::<Impl, OFFSET>,
            SetOpenPaneLength::<Impl, OFFSET>,
            PaneToggleButtonStyle::<Impl, OFFSET>,
            SetPaneToggleButtonStyle::<Impl, OFFSET>,
            SelectedItem::<Impl, OFFSET>,
            SetSelectedItem::<Impl, OFFSET>,
            MenuItems::<Impl, OFFSET>,
            MenuItemsSource::<Impl, OFFSET>,
            SetMenuItemsSource::<Impl, OFFSET>,
            SettingsItem::<Impl, OFFSET>,
            AutoSuggestBox::<Impl, OFFSET>,
            SetAutoSuggestBox::<Impl, OFFSET>,
            MenuItemTemplate::<Impl, OFFSET>,
            SetMenuItemTemplate::<Impl, OFFSET>,
            MenuItemTemplateSelector::<Impl, OFFSET>,
            SetMenuItemTemplateSelector::<Impl, OFFSET>,
            MenuItemContainerStyle::<Impl, OFFSET>,
            SetMenuItemContainerStyle::<Impl, OFFSET>,
            MenuItemContainerStyleSelector::<Impl, OFFSET>,
            SetMenuItemContainerStyleSelector::<Impl, OFFSET>,
            MenuItemFromContainer::<Impl, OFFSET>,
            ContainerFromMenuItem::<Impl, OFFSET>,
            SelectionChanged::<Impl, OFFSET>,
            RemoveSelectionChanged::<Impl, OFFSET>,
            ItemInvoked::<Impl, OFFSET>,
            RemoveItemInvoked::<Impl, OFFSET>,
            DisplayModeChanged::<Impl, OFFSET>,
            RemoveDisplayModeChanged::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationView2Impl: Sized {
    fn IsBackButtonVisible(&self) -> ::windows::core::Result<NavigationViewBackButtonVisible>;
    fn SetIsBackButtonVisible(&self, value: NavigationViewBackButtonVisible) -> ::windows::core::Result<()>;
    fn IsBackEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsBackEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn PaneTitle(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPaneTitle(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn BackRequested(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewBackRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveBackRequested(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneClosed(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneClosed(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneClosing(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewPaneClosingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneClosing(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneOpened(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneOpened(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneOpening(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneOpening(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationView2";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationView2Vtbl {
    pub const fn new<Impl: INavigationView2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationView2Vtbl {
        unsafe extern "system" fn IsBackButtonVisible<Impl: INavigationView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewBackButtonVisible) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsBackButtonVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsBackButtonVisible<Impl: INavigationView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: NavigationViewBackButtonVisible) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsBackButtonVisible(value).into()
        }
        unsafe extern "system" fn IsBackEnabled<Impl: INavigationView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsBackEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsBackEnabled<Impl: INavigationView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsBackEnabled(value).into()
        }
        unsafe extern "system" fn PaneTitle<Impl: INavigationView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneTitle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneTitle<Impl: INavigationView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPaneTitle(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BackRequested<Impl: INavigationView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewBackRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewBackRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveBackRequested<Impl: INavigationView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveBackRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneClosed<Impl: INavigationView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneClosed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneClosed<Impl: INavigationView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePaneClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneClosing<Impl: INavigationView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneClosing(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewPaneClosingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, NavigationViewPaneClosingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneClosing<Impl: INavigationView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePaneClosing(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneOpened<Impl: INavigationView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneOpened(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneOpened<Impl: INavigationView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePaneOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneOpening<Impl: INavigationView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneOpening(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<NavigationView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneOpening<Impl: INavigationView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePaneOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<INavigationView2>,
            base.5,
            IsBackButtonVisible::<Impl, OFFSET>,
            SetIsBackButtonVisible::<Impl, OFFSET>,
            IsBackEnabled::<Impl, OFFSET>,
            SetIsBackEnabled::<Impl, OFFSET>,
            PaneTitle::<Impl, OFFSET>,
            SetPaneTitle::<Impl, OFFSET>,
            BackRequested::<Impl, OFFSET>,
            RemoveBackRequested::<Impl, OFFSET>,
            PaneClosed::<Impl, OFFSET>,
            RemovePaneClosed::<Impl, OFFSET>,
            PaneClosing::<Impl, OFFSET>,
            RemovePaneClosing::<Impl, OFFSET>,
            PaneOpened::<Impl, OFFSET>,
            RemovePaneOpened::<Impl, OFFSET>,
            PaneOpening::<Impl, OFFSET>,
            RemovePaneOpening::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationView3Impl: Sized {
    fn PaneDisplayMode(&self) -> ::windows::core::Result<NavigationViewPaneDisplayMode>;
    fn SetPaneDisplayMode(&self, value: NavigationViewPaneDisplayMode) -> ::windows::core::Result<()>;
    fn PaneHeader(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetPaneHeader(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn PaneCustomContent(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetPaneCustomContent(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn ContentOverlay(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetContentOverlay(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn IsPaneVisible(&self) -> ::windows::core::Result<bool>;
    fn SetIsPaneVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn SelectionFollowsFocus(&self) -> ::windows::core::Result<NavigationViewSelectionFollowsFocus>;
    fn SetSelectionFollowsFocus(&self, value: NavigationViewSelectionFollowsFocus) -> ::windows::core::Result<()>;
    fn TemplateSettings(&self) -> ::windows::core::Result<NavigationViewTemplateSettings>;
    fn ShoulderNavigationEnabled(&self) -> ::windows::core::Result<NavigationViewShoulderNavigationEnabled>;
    fn SetShoulderNavigationEnabled(&self, value: NavigationViewShoulderNavigationEnabled) -> ::windows::core::Result<()>;
    fn OverflowLabelMode(&self) -> ::windows::core::Result<NavigationViewOverflowLabelMode>;
    fn SetOverflowLabelMode(&self, value: NavigationViewOverflowLabelMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationView3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationView3";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationView3Vtbl {
    pub const fn new<Impl: INavigationView3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationView3Vtbl {
        unsafe extern "system" fn PaneDisplayMode<Impl: INavigationView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewPaneDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneDisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneDisplayMode<Impl: INavigationView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: NavigationViewPaneDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPaneDisplayMode(value).into()
        }
        unsafe extern "system" fn PaneHeader<Impl: INavigationView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneHeader<Impl: INavigationView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPaneHeader(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneCustomContent<Impl: INavigationView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneCustomContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneCustomContent<Impl: INavigationView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPaneCustomContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentOverlay<Impl: INavigationView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentOverlay() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentOverlay<Impl: INavigationView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContentOverlay(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsPaneVisible<Impl: INavigationView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPaneVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPaneVisible<Impl: INavigationView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsPaneVisible(value).into()
        }
        unsafe extern "system" fn SelectionFollowsFocus<Impl: INavigationView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewSelectionFollowsFocus) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionFollowsFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFollowsFocus<Impl: INavigationView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: NavigationViewSelectionFollowsFocus) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionFollowsFocus(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: INavigationView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShoulderNavigationEnabled<Impl: INavigationView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewShoulderNavigationEnabled) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShoulderNavigationEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShoulderNavigationEnabled<Impl: INavigationView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: NavigationViewShoulderNavigationEnabled) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetShoulderNavigationEnabled(value).into()
        }
        unsafe extern "system" fn OverflowLabelMode<Impl: INavigationView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewOverflowLabelMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OverflowLabelMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOverflowLabelMode<Impl: INavigationView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: NavigationViewOverflowLabelMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOverflowLabelMode(value).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<INavigationView3>,
            base.5,
            PaneDisplayMode::<Impl, OFFSET>,
            SetPaneDisplayMode::<Impl, OFFSET>,
            PaneHeader::<Impl, OFFSET>,
            SetPaneHeader::<Impl, OFFSET>,
            PaneCustomContent::<Impl, OFFSET>,
            SetPaneCustomContent::<Impl, OFFSET>,
            ContentOverlay::<Impl, OFFSET>,
            SetContentOverlay::<Impl, OFFSET>,
            IsPaneVisible::<Impl, OFFSET>,
            SetIsPaneVisible::<Impl, OFFSET>,
            SelectionFollowsFocus::<Impl, OFFSET>,
            SetSelectionFollowsFocus::<Impl, OFFSET>,
            TemplateSettings::<Impl, OFFSET>,
            ShoulderNavigationEnabled::<Impl, OFFSET>,
            SetShoulderNavigationEnabled::<Impl, OFFSET>,
            OverflowLabelMode::<Impl, OFFSET>,
            SetOverflowLabelMode::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewBackRequestedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewBackRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewBackRequestedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewBackRequestedEventArgsVtbl {
    pub const fn new<Impl: INavigationViewBackRequestedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewBackRequestedEventArgsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewBackRequestedEventArgs>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewDisplayModeChangedEventArgsImpl: Sized {
    fn DisplayMode(&self) -> ::windows::core::Result<NavigationViewDisplayMode>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewDisplayModeChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewDisplayModeChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewDisplayModeChangedEventArgsVtbl {
    pub const fn new<Impl: INavigationViewDisplayModeChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewDisplayModeChangedEventArgsVtbl {
        unsafe extern "system" fn DisplayMode<Impl: INavigationViewDisplayModeChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut NavigationViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewDisplayModeChangedEventArgs>, base.5, DisplayMode::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewFactoryVtbl {
    pub const fn new<Impl: INavigationViewFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemImpl: Sized {
    fn Icon(&self) -> ::windows::core::Result<IconElement>;
    fn SetIcon(&self, value: &::core::option::Option<IconElement>) -> ::windows::core::Result<()>;
    fn CompactPaneLength(&self) -> ::windows::core::Result<f64>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItem";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemVtbl {
    pub const fn new<Impl: INavigationViewItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewItemVtbl {
        unsafe extern "system" fn Icon<Impl: INavigationViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Icon() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIcon<Impl: INavigationViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIcon(&*(&value as *const <IconElement as ::windows::core::Abi>::Abi as *const <IconElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CompactPaneLength<Impl: INavigationViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompactPaneLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewItem>, base.5, Icon::<Impl, OFFSET>, SetIcon::<Impl, OFFSET>, CompactPaneLength::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItem2Impl: Sized {
    fn SelectsOnInvoked(&self) -> ::windows::core::Result<bool>;
    fn SetSelectsOnInvoked(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItem2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItem2";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItem2Vtbl {
    pub const fn new<Impl: INavigationViewItem2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewItem2Vtbl {
        unsafe extern "system" fn SelectsOnInvoked<Impl: INavigationViewItem2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectsOnInvoked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectsOnInvoked<Impl: INavigationViewItem2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectsOnInvoked(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewItem2>, base.5, SelectsOnInvoked::<Impl, OFFSET>, SetSelectsOnInvoked::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemBaseImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemBase {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemBase";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemBaseVtbl {
    pub const fn new<Impl: INavigationViewItemBaseImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewItemBaseVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewItemBase>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemBaseFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemBaseFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemBaseFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemBaseFactoryVtbl {
    pub const fn new<Impl: INavigationViewItemBaseFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewItemBaseFactoryVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewItemBaseFactory>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationViewItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemFactoryVtbl {
    pub const fn new<Impl: INavigationViewItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewItemFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewItemFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemHeaderImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemHeader {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemHeader";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemHeaderVtbl {
    pub const fn new<Impl: INavigationViewItemHeaderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewItemHeaderVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewItemHeader>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemHeaderFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationViewItemHeader>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemHeaderFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemHeaderFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemHeaderFactoryVtbl {
    pub const fn new<Impl: INavigationViewItemHeaderFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewItemHeaderFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewItemHeaderFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewItemHeaderFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemInvokedEventArgsImpl: Sized {
    fn InvokedItem(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn IsSettingsInvoked(&self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemInvokedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemInvokedEventArgsVtbl {
    pub const fn new<Impl: INavigationViewItemInvokedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewItemInvokedEventArgsVtbl {
        unsafe extern "system" fn InvokedItem<Impl: INavigationViewItemInvokedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InvokedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSettingsInvoked<Impl: INavigationViewItemInvokedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSettingsInvoked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewItemInvokedEventArgs>, base.5, InvokedItem::<Impl, OFFSET>, IsSettingsInvoked::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemInvokedEventArgs2Impl: Sized {
    fn InvokedItemContainer(&self) -> ::windows::core::Result<NavigationViewItemBase>;
    fn RecommendedNavigationTransitionInfo(&self) -> ::windows::core::Result<super::Media::Animation::NavigationTransitionInfo>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemInvokedEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemInvokedEventArgs2Vtbl {
    pub const fn new<Impl: INavigationViewItemInvokedEventArgs2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewItemInvokedEventArgs2Vtbl {
        unsafe extern "system" fn InvokedItemContainer<Impl: INavigationViewItemInvokedEventArgs2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InvokedItemContainer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RecommendedNavigationTransitionInfo<Impl: INavigationViewItemInvokedEventArgs2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RecommendedNavigationTransitionInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewItemInvokedEventArgs2>, base.5, InvokedItemContainer::<Impl, OFFSET>, RecommendedNavigationTransitionInfo::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemSeparatorImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemSeparator {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemSeparator";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemSeparatorVtbl {
    pub const fn new<Impl: INavigationViewItemSeparatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewItemSeparatorVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewItemSeparator>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemSeparatorFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationViewItemSeparator>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemSeparatorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemSeparatorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemSeparatorFactoryVtbl {
    pub const fn new<Impl: INavigationViewItemSeparatorFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewItemSeparatorFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewItemSeparatorFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewItemSeparatorFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemStaticsImpl: Sized {
    fn IconProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CompactPaneLengthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemStaticsVtbl {
    pub const fn new<Impl: INavigationViewItemStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewItemStaticsVtbl {
        unsafe extern "system" fn IconProperty<Impl: INavigationViewItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IconProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompactPaneLengthProperty<Impl: INavigationViewItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompactPaneLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewItemStatics>, base.5, IconProperty::<Impl, OFFSET>, CompactPaneLengthProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewItemStatics2Impl: Sized {
    fn SelectsOnInvokedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewItemStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewItemStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewItemStatics2Vtbl {
    pub const fn new<Impl: INavigationViewItemStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewItemStatics2Vtbl {
        unsafe extern "system" fn SelectsOnInvokedProperty<Impl: INavigationViewItemStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectsOnInvokedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewItemStatics2>, base.5, SelectsOnInvokedProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewListImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewList {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewList";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewListVtbl {
    pub const fn new<Impl: INavigationViewListImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewListVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewList>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewListFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationViewList>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewListFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewListFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewListFactoryVtbl {
    pub const fn new<Impl: INavigationViewListFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewListFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewListFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewListFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewPaneClosingEventArgsImpl: Sized {
    fn Cancel(&self) -> ::windows::core::Result<bool>;
    fn SetCancel(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewPaneClosingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewPaneClosingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewPaneClosingEventArgsVtbl {
    pub const fn new<Impl: INavigationViewPaneClosingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewPaneClosingEventArgsVtbl {
        unsafe extern "system" fn Cancel<Impl: INavigationViewPaneClosingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: INavigationViewPaneClosingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewPaneClosingEventArgs>, base.5, Cancel::<Impl, OFFSET>, SetCancel::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewSelectionChangedEventArgsImpl: Sized {
    fn SelectedItem(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn IsSettingsSelected(&self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewSelectionChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewSelectionChangedEventArgsVtbl {
    pub const fn new<Impl: INavigationViewSelectionChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewSelectionChangedEventArgsVtbl {
        unsafe extern "system" fn SelectedItem<Impl: INavigationViewSelectionChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSettingsSelected<Impl: INavigationViewSelectionChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSettingsSelected() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewSelectionChangedEventArgs>, base.5, SelectedItem::<Impl, OFFSET>, IsSettingsSelected::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewSelectionChangedEventArgs2Impl: Sized {
    fn SelectedItemContainer(&self) -> ::windows::core::Result<NavigationViewItemBase>;
    fn RecommendedNavigationTransitionInfo(&self) -> ::windows::core::Result<super::Media::Animation::NavigationTransitionInfo>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewSelectionChangedEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewSelectionChangedEventArgs2Vtbl {
    pub const fn new<Impl: INavigationViewSelectionChangedEventArgs2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewSelectionChangedEventArgs2Vtbl {
        unsafe extern "system" fn SelectedItemContainer<Impl: INavigationViewSelectionChangedEventArgs2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedItemContainer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RecommendedNavigationTransitionInfo<Impl: INavigationViewSelectionChangedEventArgs2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RecommendedNavigationTransitionInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewSelectionChangedEventArgs2>, base.5, SelectedItemContainer::<Impl, OFFSET>, RecommendedNavigationTransitionInfo::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewStaticsImpl: Sized {
    fn IsPaneOpenProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CompactModeThresholdWidthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ExpandedModeThresholdWidthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneFooterProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSettingsVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPaneToggleButtonVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AlwaysShowHeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CompactPaneLengthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OpenPaneLengthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneToggleButtonStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemsSourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedItemProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SettingsItemProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AutoSuggestBoxProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemTemplateSelectorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemContainerStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MenuItemContainerStyleSelectorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewStaticsVtbl {
    pub const fn new<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewStaticsVtbl {
        unsafe extern "system" fn IsPaneOpenProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPaneOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompactModeThresholdWidthProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompactModeThresholdWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExpandedModeThresholdWidthProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExpandedModeThresholdWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneFooterProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneFooterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayModeProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSettingsVisibleProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSettingsVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPaneToggleButtonVisibleProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPaneToggleButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AlwaysShowHeaderProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AlwaysShowHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompactPaneLengthProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompactPaneLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpenPaneLengthProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OpenPaneLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneToggleButtonStyleProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneToggleButtonStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemsProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemsSourceProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuItemsSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedItemProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedItemProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SettingsItemProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SettingsItemProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutoSuggestBoxProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AutoSuggestBoxProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemTemplateProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuItemTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemTemplateSelectorProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuItemTemplateSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemContainerStyleProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuItemContainerStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MenuItemContainerStyleSelectorProperty<Impl: INavigationViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MenuItemContainerStyleSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<INavigationViewStatics>,
            base.5,
            IsPaneOpenProperty::<Impl, OFFSET>,
            CompactModeThresholdWidthProperty::<Impl, OFFSET>,
            ExpandedModeThresholdWidthProperty::<Impl, OFFSET>,
            PaneFooterProperty::<Impl, OFFSET>,
            HeaderProperty::<Impl, OFFSET>,
            HeaderTemplateProperty::<Impl, OFFSET>,
            DisplayModeProperty::<Impl, OFFSET>,
            IsSettingsVisibleProperty::<Impl, OFFSET>,
            IsPaneToggleButtonVisibleProperty::<Impl, OFFSET>,
            AlwaysShowHeaderProperty::<Impl, OFFSET>,
            CompactPaneLengthProperty::<Impl, OFFSET>,
            OpenPaneLengthProperty::<Impl, OFFSET>,
            PaneToggleButtonStyleProperty::<Impl, OFFSET>,
            MenuItemsProperty::<Impl, OFFSET>,
            MenuItemsSourceProperty::<Impl, OFFSET>,
            SelectedItemProperty::<Impl, OFFSET>,
            SettingsItemProperty::<Impl, OFFSET>,
            AutoSuggestBoxProperty::<Impl, OFFSET>,
            MenuItemTemplateProperty::<Impl, OFFSET>,
            MenuItemTemplateSelectorProperty::<Impl, OFFSET>,
            MenuItemContainerStyleProperty::<Impl, OFFSET>,
            MenuItemContainerStyleSelectorProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewStatics2Impl: Sized {
    fn IsBackButtonVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsBackEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneTitleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewStatics2Vtbl {
    pub const fn new<Impl: INavigationViewStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewStatics2Vtbl {
        unsafe extern "system" fn IsBackButtonVisibleProperty<Impl: INavigationViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsBackButtonVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsBackEnabledProperty<Impl: INavigationViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsBackEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneTitleProperty<Impl: INavigationViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneTitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewStatics2>, base.5, IsBackButtonVisibleProperty::<Impl, OFFSET>, IsBackEnabledProperty::<Impl, OFFSET>, PaneTitleProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewStatics3Impl: Sized {
    fn PaneDisplayModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneHeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneCustomContentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentOverlayProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPaneVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionFollowsFocusProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TemplateSettingsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ShoulderNavigationEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OverflowLabelModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewStatics3Vtbl {
    pub const fn new<Impl: INavigationViewStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewStatics3Vtbl {
        unsafe extern "system" fn PaneDisplayModeProperty<Impl: INavigationViewStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneDisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneHeaderProperty<Impl: INavigationViewStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneCustomContentProperty<Impl: INavigationViewStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneCustomContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentOverlayProperty<Impl: INavigationViewStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentOverlayProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPaneVisibleProperty<Impl: INavigationViewStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPaneVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFollowsFocusProperty<Impl: INavigationViewStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionFollowsFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TemplateSettingsProperty<Impl: INavigationViewStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettingsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShoulderNavigationEnabledProperty<Impl: INavigationViewStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShoulderNavigationEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverflowLabelModeProperty<Impl: INavigationViewStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OverflowLabelModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<INavigationViewStatics3>,
            base.5,
            PaneDisplayModeProperty::<Impl, OFFSET>,
            PaneHeaderProperty::<Impl, OFFSET>,
            PaneCustomContentProperty::<Impl, OFFSET>,
            ContentOverlayProperty::<Impl, OFFSET>,
            IsPaneVisibleProperty::<Impl, OFFSET>,
            SelectionFollowsFocusProperty::<Impl, OFFSET>,
            TemplateSettingsProperty::<Impl, OFFSET>,
            ShoulderNavigationEnabledProperty::<Impl, OFFSET>,
            OverflowLabelModeProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewTemplateSettingsImpl: Sized {
    fn TopPadding(&self) -> ::windows::core::Result<f64>;
    fn OverflowButtonVisibility(&self) -> ::windows::core::Result<super::Visibility>;
    fn PaneToggleButtonVisibility(&self) -> ::windows::core::Result<super::Visibility>;
    fn BackButtonVisibility(&self) -> ::windows::core::Result<super::Visibility>;
    fn TopPaneVisibility(&self) -> ::windows::core::Result<super::Visibility>;
    fn LeftPaneVisibility(&self) -> ::windows::core::Result<super::Visibility>;
    fn SingleSelectionFollowsFocus(&self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewTemplateSettings {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewTemplateSettings";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewTemplateSettingsVtbl {
    pub const fn new<Impl: INavigationViewTemplateSettingsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewTemplateSettingsVtbl {
        unsafe extern "system" fn TopPadding<Impl: INavigationViewTemplateSettingsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TopPadding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverflowButtonVisibility<Impl: INavigationViewTemplateSettingsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OverflowButtonVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneToggleButtonVisibility<Impl: INavigationViewTemplateSettingsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneToggleButtonVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackButtonVisibility<Impl: INavigationViewTemplateSettingsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackButtonVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TopPaneVisibility<Impl: INavigationViewTemplateSettingsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TopPaneVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LeftPaneVisibility<Impl: INavigationViewTemplateSettingsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LeftPaneVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SingleSelectionFollowsFocus<Impl: INavigationViewTemplateSettingsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewTemplateSettings>, base.5, TopPadding::<Impl, OFFSET>, OverflowButtonVisibility::<Impl, OFFSET>, PaneToggleButtonVisibility::<Impl, OFFSET>, BackButtonVisibility::<Impl, OFFSET>, TopPaneVisibility::<Impl, OFFSET>, LeftPaneVisibility::<Impl, OFFSET>, SingleSelectionFollowsFocus::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewTemplateSettingsFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<NavigationViewTemplateSettings>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewTemplateSettingsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewTemplateSettingsFactory";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewTemplateSettingsFactoryVtbl {
    pub const fn new<Impl: INavigationViewTemplateSettingsFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewTemplateSettingsFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: INavigationViewTemplateSettingsFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewTemplateSettingsFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INavigationViewTemplateSettingsStaticsImpl: Sized {
    fn TopPaddingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OverflowButtonVisibilityProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneToggleButtonVisibilityProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackButtonVisibilityProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TopPaneVisibilityProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LeftPaneVisibilityProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SingleSelectionFollowsFocusProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INavigationViewTemplateSettingsStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics";
}
#[cfg(feature = "implement_exclusive")]
impl INavigationViewTemplateSettingsStaticsVtbl {
    pub const fn new<Impl: INavigationViewTemplateSettingsStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INavigationViewTemplateSettingsStaticsVtbl {
        unsafe extern "system" fn TopPaddingProperty<Impl: INavigationViewTemplateSettingsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TopPaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverflowButtonVisibilityProperty<Impl: INavigationViewTemplateSettingsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OverflowButtonVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneToggleButtonVisibilityProperty<Impl: INavigationViewTemplateSettingsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneToggleButtonVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackButtonVisibilityProperty<Impl: INavigationViewTemplateSettingsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackButtonVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TopPaneVisibilityProperty<Impl: INavigationViewTemplateSettingsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TopPaneVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LeftPaneVisibilityProperty<Impl: INavigationViewTemplateSettingsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LeftPaneVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SingleSelectionFollowsFocusProperty<Impl: INavigationViewTemplateSettingsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SingleSelectionFollowsFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INavigationViewTemplateSettingsStatics>, base.5, TopPaddingProperty::<Impl, OFFSET>, OverflowButtonVisibilityProperty::<Impl, OFFSET>, PaneToggleButtonVisibilityProperty::<Impl, OFFSET>, BackButtonVisibilityProperty::<Impl, OFFSET>, TopPaneVisibilityProperty::<Impl, OFFSET>, LeftPaneVisibilityProperty::<Impl, OFFSET>, SingleSelectionFollowsFocusProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INotifyEventArgsImpl: Sized {
    fn Value(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INotifyEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INotifyEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl INotifyEventArgsVtbl {
    pub const fn new<Impl: INotifyEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INotifyEventArgsVtbl {
        unsafe extern "system" fn Value<Impl: INotifyEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Value() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INotifyEventArgs>, base.5, Value::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait INotifyEventArgs2Impl: Sized {
    fn CallingUri(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for INotifyEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.INotifyEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl INotifyEventArgs2Vtbl {
    pub const fn new<Impl: INotifyEventArgs2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> INotifyEventArgs2Vtbl {
        unsafe extern "system" fn CallingUri<Impl: INotifyEventArgs2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CallingUri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<INotifyEventArgs2>, base.5, CallingUri::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPageImpl: Sized {
    fn Frame(&self) -> ::windows::core::Result<Frame>;
    fn NavigationCacheMode(&self) -> ::windows::core::Result<super::Navigation::NavigationCacheMode>;
    fn SetNavigationCacheMode(&self, value: super::Navigation::NavigationCacheMode) -> ::windows::core::Result<()>;
    fn TopAppBar(&self) -> ::windows::core::Result<AppBar>;
    fn SetTopAppBar(&self, value: &::core::option::Option<AppBar>) -> ::windows::core::Result<()>;
    fn BottomAppBar(&self) -> ::windows::core::Result<AppBar>;
    fn SetBottomAppBar(&self, value: &::core::option::Option<AppBar>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPage {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPage";
}
#[cfg(feature = "implement_exclusive")]
impl IPageVtbl {
    pub const fn new<Impl: IPageImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPageVtbl {
        unsafe extern "system" fn Frame<Impl: IPageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Frame() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NavigationCacheMode<Impl: IPageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Navigation::NavigationCacheMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NavigationCacheMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetNavigationCacheMode<Impl: IPageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Navigation::NavigationCacheMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetNavigationCacheMode(value).into()
        }
        unsafe extern "system" fn TopAppBar<Impl: IPageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TopAppBar() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTopAppBar<Impl: IPageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTopAppBar(&*(&value as *const <AppBar as ::windows::core::Abi>::Abi as *const <AppBar as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BottomAppBar<Impl: IPageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BottomAppBar() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBottomAppBar<Impl: IPageImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBottomAppBar(&*(&value as *const <AppBar as ::windows::core::Abi>::Abi as *const <AppBar as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPage>, base.5, Frame::<Impl, OFFSET>, NavigationCacheMode::<Impl, OFFSET>, SetNavigationCacheMode::<Impl, OFFSET>, TopAppBar::<Impl, OFFSET>, SetTopAppBar::<Impl, OFFSET>, BottomAppBar::<Impl, OFFSET>, SetBottomAppBar::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPageFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Page>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPageFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPageFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPageFactoryVtbl {
    pub const fn new<Impl: IPageFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPageFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPageFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPageFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPageOverridesImpl: Sized {
    fn OnNavigatedFrom(&self, e: &::core::option::Option<super::Navigation::NavigationEventArgs>) -> ::windows::core::Result<()>;
    fn OnNavigatedTo(&self, e: &::core::option::Option<super::Navigation::NavigationEventArgs>) -> ::windows::core::Result<()>;
    fn OnNavigatingFrom(&self, e: &::core::option::Option<super::Navigation::NavigatingCancelEventArgs>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPageOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPageOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IPageOverridesVtbl {
    pub const fn new<Impl: IPageOverridesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPageOverridesVtbl {
        unsafe extern "system" fn OnNavigatedFrom<Impl: IPageOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnNavigatedFrom(&*(&e as *const <super::Navigation::NavigationEventArgs as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigationEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnNavigatedTo<Impl: IPageOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnNavigatedTo(&*(&e as *const <super::Navigation::NavigationEventArgs as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigationEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnNavigatingFrom<Impl: IPageOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnNavigatingFrom(&*(&e as *const <super::Navigation::NavigatingCancelEventArgs as ::windows::core::Abi>::Abi as *const <super::Navigation::NavigatingCancelEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPageOverrides>, base.5, OnNavigatedFrom::<Impl, OFFSET>, OnNavigatedTo::<Impl, OFFSET>, OnNavigatingFrom::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPageStaticsImpl: Sized {
    fn FrameProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TopAppBarProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BottomAppBarProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPageStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPageStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPageStaticsVtbl {
    pub const fn new<Impl: IPageStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPageStaticsVtbl {
        unsafe extern "system" fn FrameProperty<Impl: IPageStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FrameProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TopAppBarProperty<Impl: IPageStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TopAppBarProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BottomAppBarProperty<Impl: IPageStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BottomAppBarProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPageStatics>, base.5, FrameProperty::<Impl, OFFSET>, TopAppBarProperty::<Impl, OFFSET>, BottomAppBarProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPanelImpl: Sized {
    fn Children(&self) -> ::windows::core::Result<UIElementCollection>;
    fn Background(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn IsItemsHost(&self) -> ::windows::core::Result<bool>;
    fn ChildrenTransitions(&self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetChildrenTransitions(&self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPanel";
}
#[cfg(feature = "implement_exclusive")]
impl IPanelVtbl {
    pub const fn new<Impl: IPanelImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPanelVtbl {
        unsafe extern "system" fn Children<Impl: IPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Children() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Background<Impl: IPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Background() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackground<Impl: IPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsItemsHost<Impl: IPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsItemsHost() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChildrenTransitions<Impl: IPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChildrenTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChildrenTransitions<Impl: IPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetChildrenTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPanel>, base.5, Children::<Impl, OFFSET>, Background::<Impl, OFFSET>, SetBackground::<Impl, OFFSET>, IsItemsHost::<Impl, OFFSET>, ChildrenTransitions::<Impl, OFFSET>, SetChildrenTransitions::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPanel2Impl: Sized {
    fn BackgroundTransition(&self) -> ::windows::core::Result<super::BrushTransition>;
    fn SetBackgroundTransition(&self, value: &::core::option::Option<super::BrushTransition>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPanel2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPanel2";
}
#[cfg(feature = "implement_exclusive")]
impl IPanel2Vtbl {
    pub const fn new<Impl: IPanel2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPanel2Vtbl {
        unsafe extern "system" fn BackgroundTransition<Impl: IPanel2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundTransition() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundTransition<Impl: IPanel2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBackgroundTransition(&*(&value as *const <super::BrushTransition as ::windows::core::Abi>::Abi as *const <super::BrushTransition as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPanel2>, base.5, BackgroundTransition::<Impl, OFFSET>, SetBackgroundTransition::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPanelFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Panel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPanelFactoryVtbl {
    pub const fn new<Impl: IPanelFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPanelFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPanelFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPanelFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPanelStaticsImpl: Sized {
    fn BackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsItemsHostProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ChildrenTransitionsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPanelStaticsVtbl {
    pub const fn new<Impl: IPanelStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPanelStaticsVtbl {
        unsafe extern "system" fn BackgroundProperty<Impl: IPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsItemsHostProperty<Impl: IPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsItemsHostProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChildrenTransitionsProperty<Impl: IPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChildrenTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPanelStatics>, base.5, BackgroundProperty::<Impl, OFFSET>, IsItemsHostProperty::<Impl, OFFSET>, ChildrenTransitionsProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IParallaxViewImpl: Sized {
    fn Child(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetChild(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn HorizontalShift(&self) -> ::windows::core::Result<f64>;
    fn SetHorizontalShift(&self, value: f64) -> ::windows::core::Result<()>;
    fn HorizontalSourceEndOffset(&self) -> ::windows::core::Result<f64>;
    fn SetHorizontalSourceEndOffset(&self, value: f64) -> ::windows::core::Result<()>;
    fn HorizontalSourceOffsetKind(&self) -> ::windows::core::Result<ParallaxSourceOffsetKind>;
    fn SetHorizontalSourceOffsetKind(&self, value: ParallaxSourceOffsetKind) -> ::windows::core::Result<()>;
    fn HorizontalSourceStartOffset(&self) -> ::windows::core::Result<f64>;
    fn SetHorizontalSourceStartOffset(&self, value: f64) -> ::windows::core::Result<()>;
    fn IsHorizontalShiftClamped(&self) -> ::windows::core::Result<bool>;
    fn SetIsHorizontalShiftClamped(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsVerticalShiftClamped(&self) -> ::windows::core::Result<bool>;
    fn SetIsVerticalShiftClamped(&self, value: bool) -> ::windows::core::Result<()>;
    fn MaxHorizontalShiftRatio(&self) -> ::windows::core::Result<f64>;
    fn SetMaxHorizontalShiftRatio(&self, value: f64) -> ::windows::core::Result<()>;
    fn MaxVerticalShiftRatio(&self) -> ::windows::core::Result<f64>;
    fn SetMaxVerticalShiftRatio(&self, value: f64) -> ::windows::core::Result<()>;
    fn Source(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetSource(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn VerticalShift(&self) -> ::windows::core::Result<f64>;
    fn SetVerticalShift(&self, value: f64) -> ::windows::core::Result<()>;
    fn VerticalSourceEndOffset(&self) -> ::windows::core::Result<f64>;
    fn SetVerticalSourceEndOffset(&self, value: f64) -> ::windows::core::Result<()>;
    fn VerticalSourceOffsetKind(&self) -> ::windows::core::Result<ParallaxSourceOffsetKind>;
    fn SetVerticalSourceOffsetKind(&self, value: ParallaxSourceOffsetKind) -> ::windows::core::Result<()>;
    fn VerticalSourceStartOffset(&self) -> ::windows::core::Result<f64>;
    fn SetVerticalSourceStartOffset(&self, value: f64) -> ::windows::core::Result<()>;
    fn RefreshAutomaticHorizontalOffsets(&self) -> ::windows::core::Result<()>;
    fn RefreshAutomaticVerticalOffsets(&self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IParallaxView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IParallaxView";
}
#[cfg(feature = "implement_exclusive")]
impl IParallaxViewVtbl {
    pub const fn new<Impl: IParallaxViewImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IParallaxViewVtbl {
        unsafe extern "system" fn Child<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Child() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChild<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetChild(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HorizontalShift<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalShift() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalShift<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalShift(value).into()
        }
        unsafe extern "system" fn HorizontalSourceEndOffset<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceEndOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalSourceEndOffset<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalSourceEndOffset(value).into()
        }
        unsafe extern "system" fn HorizontalSourceOffsetKind<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ParallaxSourceOffsetKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceOffsetKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalSourceOffsetKind<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ParallaxSourceOffsetKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalSourceOffsetKind(value).into()
        }
        unsafe extern "system" fn HorizontalSourceStartOffset<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceStartOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalSourceStartOffset<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalSourceStartOffset(value).into()
        }
        unsafe extern "system" fn IsHorizontalShiftClamped<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsHorizontalShiftClamped() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHorizontalShiftClamped<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsHorizontalShiftClamped(value).into()
        }
        unsafe extern "system" fn IsVerticalShiftClamped<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsVerticalShiftClamped() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVerticalShiftClamped<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsVerticalShiftClamped(value).into()
        }
        unsafe extern "system" fn MaxHorizontalShiftRatio<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxHorizontalShiftRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxHorizontalShiftRatio<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxHorizontalShiftRatio(value).into()
        }
        unsafe extern "system" fn MaxVerticalShiftRatio<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxVerticalShiftRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxVerticalShiftRatio<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxVerticalShiftRatio(value).into()
        }
        unsafe extern "system" fn Source<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn VerticalShift<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalShift() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalShift<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalShift(value).into()
        }
        unsafe extern "system" fn VerticalSourceEndOffset<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalSourceEndOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalSourceEndOffset<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalSourceEndOffset(value).into()
        }
        unsafe extern "system" fn VerticalSourceOffsetKind<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ParallaxSourceOffsetKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalSourceOffsetKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalSourceOffsetKind<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ParallaxSourceOffsetKind) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalSourceOffsetKind(value).into()
        }
        unsafe extern "system" fn VerticalSourceStartOffset<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalSourceStartOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalSourceStartOffset<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalSourceStartOffset(value).into()
        }
        unsafe extern "system" fn RefreshAutomaticHorizontalOffsets<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RefreshAutomaticHorizontalOffsets().into()
        }
        unsafe extern "system" fn RefreshAutomaticVerticalOffsets<Impl: IParallaxViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RefreshAutomaticVerticalOffsets().into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IParallaxView>,
            base.5,
            Child::<Impl, OFFSET>,
            SetChild::<Impl, OFFSET>,
            HorizontalShift::<Impl, OFFSET>,
            SetHorizontalShift::<Impl, OFFSET>,
            HorizontalSourceEndOffset::<Impl, OFFSET>,
            SetHorizontalSourceEndOffset::<Impl, OFFSET>,
            HorizontalSourceOffsetKind::<Impl, OFFSET>,
            SetHorizontalSourceOffsetKind::<Impl, OFFSET>,
            HorizontalSourceStartOffset::<Impl, OFFSET>,
            SetHorizontalSourceStartOffset::<Impl, OFFSET>,
            IsHorizontalShiftClamped::<Impl, OFFSET>,
            SetIsHorizontalShiftClamped::<Impl, OFFSET>,
            IsVerticalShiftClamped::<Impl, OFFSET>,
            SetIsVerticalShiftClamped::<Impl, OFFSET>,
            MaxHorizontalShiftRatio::<Impl, OFFSET>,
            SetMaxHorizontalShiftRatio::<Impl, OFFSET>,
            MaxVerticalShiftRatio::<Impl, OFFSET>,
            SetMaxVerticalShiftRatio::<Impl, OFFSET>,
            Source::<Impl, OFFSET>,
            SetSource::<Impl, OFFSET>,
            VerticalShift::<Impl, OFFSET>,
            SetVerticalShift::<Impl, OFFSET>,
            VerticalSourceEndOffset::<Impl, OFFSET>,
            SetVerticalSourceEndOffset::<Impl, OFFSET>,
            VerticalSourceOffsetKind::<Impl, OFFSET>,
            SetVerticalSourceOffsetKind::<Impl, OFFSET>,
            VerticalSourceStartOffset::<Impl, OFFSET>,
            SetVerticalSourceStartOffset::<Impl, OFFSET>,
            RefreshAutomaticHorizontalOffsets::<Impl, OFFSET>,
            RefreshAutomaticVerticalOffsets::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IParallaxViewFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ParallaxView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IParallaxViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IParallaxViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IParallaxViewFactoryVtbl {
    pub const fn new<Impl: IParallaxViewFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IParallaxViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IParallaxViewFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IParallaxViewFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IParallaxViewStaticsImpl: Sized {
    fn ChildProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalSourceEndOffsetProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalSourceOffsetKindProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalSourceStartOffsetProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxHorizontalShiftRatioProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalShiftProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHorizontalShiftClampedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsVerticalShiftClampedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalSourceEndOffsetProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalSourceOffsetKindProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalSourceStartOffsetProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxVerticalShiftRatioProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalShiftProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IParallaxViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IParallaxViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IParallaxViewStaticsVtbl {
    pub const fn new<Impl: IParallaxViewStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IParallaxViewStaticsVtbl {
        unsafe extern "system" fn ChildProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChildProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalSourceEndOffsetProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceEndOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalSourceOffsetKindProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceOffsetKindProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalSourceStartOffsetProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalSourceStartOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxHorizontalShiftRatioProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxHorizontalShiftRatioProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalShiftProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalShiftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHorizontalShiftClampedProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsHorizontalShiftClampedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsVerticalShiftClampedProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsVerticalShiftClampedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalSourceEndOffsetProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalSourceEndOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalSourceOffsetKindProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalSourceOffsetKindProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalSourceStartOffsetProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalSourceStartOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxVerticalShiftRatioProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxVerticalShiftRatioProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalShiftProperty<Impl: IParallaxViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalShiftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IParallaxViewStatics>,
            base.5,
            ChildProperty::<Impl, OFFSET>,
            HorizontalSourceEndOffsetProperty::<Impl, OFFSET>,
            HorizontalSourceOffsetKindProperty::<Impl, OFFSET>,
            HorizontalSourceStartOffsetProperty::<Impl, OFFSET>,
            MaxHorizontalShiftRatioProperty::<Impl, OFFSET>,
            HorizontalShiftProperty::<Impl, OFFSET>,
            IsHorizontalShiftClampedProperty::<Impl, OFFSET>,
            IsVerticalShiftClampedProperty::<Impl, OFFSET>,
            SourceProperty::<Impl, OFFSET>,
            VerticalSourceEndOffsetProperty::<Impl, OFFSET>,
            VerticalSourceOffsetKindProperty::<Impl, OFFSET>,
            VerticalSourceStartOffsetProperty::<Impl, OFFSET>,
            MaxVerticalShiftRatioProperty::<Impl, OFFSET>,
            VerticalShiftProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBoxImpl: Sized {
    fn Password(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPassword(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PasswordChar(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPasswordChar(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn IsPasswordRevealButtonEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsPasswordRevealButtonEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn MaxLength(&self) -> ::windows::core::Result<i32>;
    fn SetMaxLength(&self, value: i32) -> ::windows::core::Result<()>;
    fn PasswordChanged(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePasswordChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContextMenuOpening(&self, handler: &::core::option::Option<ContextMenuOpeningEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContextMenuOpening(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectAll(&self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBox";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBoxVtbl {
    pub const fn new<Impl: IPasswordBoxImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPasswordBoxVtbl {
        unsafe extern "system" fn Password<Impl: IPasswordBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Password() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPassword<Impl: IPasswordBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPassword(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PasswordChar<Impl: IPasswordBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PasswordChar() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPasswordChar<Impl: IPasswordBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPasswordChar(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsPasswordRevealButtonEnabled<Impl: IPasswordBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPasswordRevealButtonEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPasswordRevealButtonEnabled<Impl: IPasswordBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsPasswordRevealButtonEnabled(value).into()
        }
        unsafe extern "system" fn MaxLength<Impl: IPasswordBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLength<Impl: IPasswordBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxLength(value).into()
        }
        unsafe extern "system" fn PasswordChanged<Impl: IPasswordBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PasswordChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePasswordChanged<Impl: IPasswordBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePasswordChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContextMenuOpening<Impl: IPasswordBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContextMenuOpening(&*(&handler as *const <ContextMenuOpeningEventHandler as ::windows::core::Abi>::Abi as *const <ContextMenuOpeningEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContextMenuOpening<Impl: IPasswordBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveContextMenuOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: IPasswordBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IPasswordBox>,
            base.5,
            Password::<Impl, OFFSET>,
            SetPassword::<Impl, OFFSET>,
            PasswordChar::<Impl, OFFSET>,
            SetPasswordChar::<Impl, OFFSET>,
            IsPasswordRevealButtonEnabled::<Impl, OFFSET>,
            SetIsPasswordRevealButtonEnabled::<Impl, OFFSET>,
            MaxLength::<Impl, OFFSET>,
            SetMaxLength::<Impl, OFFSET>,
            PasswordChanged::<Impl, OFFSET>,
            RemovePasswordChanged::<Impl, OFFSET>,
            ContextMenuOpening::<Impl, OFFSET>,
            RemoveContextMenuOpening::<Impl, OFFSET>,
            SelectAll::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBox2Impl: Sized {
    fn Header(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn PlaceholderText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectionHighlightColor(&self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColor(&self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn PreventKeyboardDisplayOnProgrammaticFocus(&self) -> ::windows::core::Result<bool>;
    fn SetPreventKeyboardDisplayOnProgrammaticFocus(&self, value: bool) -> ::windows::core::Result<()>;
    fn Paste(&self, handler: &::core::option::Option<TextControlPasteEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaste(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBox2";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBox2Vtbl {
    pub const fn new<Impl: IPasswordBox2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPasswordBox2Vtbl {
        unsafe extern "system" fn Header<Impl: IPasswordBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IPasswordBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IPasswordBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IPasswordBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: IPasswordBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: IPasswordBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionHighlightColor<Impl: IPasswordBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColor<Impl: IPasswordBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocus<Impl: IPasswordBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreventKeyboardDisplayOnProgrammaticFocus<Impl: IPasswordBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPreventKeyboardDisplayOnProgrammaticFocus(value).into()
        }
        unsafe extern "system" fn Paste<Impl: IPasswordBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Paste(&*(&handler as *const <TextControlPasteEventHandler as ::windows::core::Abi>::Abi as *const <TextControlPasteEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaste<Impl: IPasswordBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePaste(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IPasswordBox2>,
            base.5,
            Header::<Impl, OFFSET>,
            SetHeader::<Impl, OFFSET>,
            HeaderTemplate::<Impl, OFFSET>,
            SetHeaderTemplate::<Impl, OFFSET>,
            PlaceholderText::<Impl, OFFSET>,
            SetPlaceholderText::<Impl, OFFSET>,
            SelectionHighlightColor::<Impl, OFFSET>,
            SetSelectionHighlightColor::<Impl, OFFSET>,
            PreventKeyboardDisplayOnProgrammaticFocus::<Impl, OFFSET>,
            SetPreventKeyboardDisplayOnProgrammaticFocus::<Impl, OFFSET>,
            Paste::<Impl, OFFSET>,
            RemovePaste::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBox3Impl: Sized {
    fn PasswordRevealMode(&self) -> ::windows::core::Result<PasswordRevealMode>;
    fn SetPasswordRevealMode(&self, value: PasswordRevealMode) -> ::windows::core::Result<()>;
    fn TextReadingOrder(&self) -> ::windows::core::Result<super::TextReadingOrder>;
    fn SetTextReadingOrder(&self, value: super::TextReadingOrder) -> ::windows::core::Result<()>;
    fn InputScope(&self) -> ::windows::core::Result<super::Input::InputScope>;
    fn SetInputScope(&self, value: &::core::option::Option<super::Input::InputScope>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBox3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBox3";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBox3Vtbl {
    pub const fn new<Impl: IPasswordBox3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPasswordBox3Vtbl {
        unsafe extern "system" fn PasswordRevealMode<Impl: IPasswordBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut PasswordRevealMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PasswordRevealMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPasswordRevealMode<Impl: IPasswordBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: PasswordRevealMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPasswordRevealMode(value).into()
        }
        unsafe extern "system" fn TextReadingOrder<Impl: IPasswordBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextReadingOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextReadingOrder<Impl: IPasswordBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextReadingOrder(value).into()
        }
        unsafe extern "system" fn InputScope<Impl: IPasswordBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InputScope() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputScope<Impl: IPasswordBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetInputScope(&*(&value as *const <super::Input::InputScope as ::windows::core::Abi>::Abi as *const <super::Input::InputScope as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPasswordBox3>, base.5, PasswordRevealMode::<Impl, OFFSET>, SetPasswordRevealMode::<Impl, OFFSET>, TextReadingOrder::<Impl, OFFSET>, SetTextReadingOrder::<Impl, OFFSET>, InputScope::<Impl, OFFSET>, SetInputScope::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBox4Impl: Sized {
    fn PasswordChanging(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<PasswordBox, PasswordBoxPasswordChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePasswordChanging(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBox4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBox4";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBox4Vtbl {
    pub const fn new<Impl: IPasswordBox4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPasswordBox4Vtbl {
        unsafe extern "system" fn PasswordChanging<Impl: IPasswordBox4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PasswordChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<PasswordBox, PasswordBoxPasswordChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<PasswordBox, PasswordBoxPasswordChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePasswordChanging<Impl: IPasswordBox4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePasswordChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPasswordBox4>, base.5, PasswordChanging::<Impl, OFFSET>, RemovePasswordChanging::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBox5Impl: Sized {
    fn CanPasteClipboardContent(&self) -> ::windows::core::Result<bool>;
    fn SelectionFlyout(&self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetSelectionFlyout(&self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn Description(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn PasteFromClipboard(&self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBox5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBox5";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBox5Vtbl {
    pub const fn new<Impl: IPasswordBox5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPasswordBox5Vtbl {
        unsafe extern "system" fn CanPasteClipboardContent<Impl: IPasswordBox5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanPasteClipboardContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFlyout<Impl: IPasswordBox5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFlyout<Impl: IPasswordBox5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Description<Impl: IPasswordBox5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: IPasswordBox5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PasteFromClipboard<Impl: IPasswordBox5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).PasteFromClipboard().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPasswordBox5>, base.5, CanPasteClipboardContent::<Impl, OFFSET>, SelectionFlyout::<Impl, OFFSET>, SetSelectionFlyout::<Impl, OFFSET>, Description::<Impl, OFFSET>, SetDescription::<Impl, OFFSET>, PasteFromClipboard::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBoxPasswordChangingEventArgsImpl: Sized {
    fn IsContentChanging(&self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBoxPasswordChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBoxPasswordChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBoxPasswordChangingEventArgsVtbl {
    pub const fn new<Impl: IPasswordBoxPasswordChangingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPasswordBoxPasswordChangingEventArgsVtbl {
        unsafe extern "system" fn IsContentChanging<Impl: IPasswordBoxPasswordChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsContentChanging() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPasswordBoxPasswordChangingEventArgs>, base.5, IsContentChanging::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBoxStaticsImpl: Sized {
    fn PasswordProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PasswordCharProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPasswordRevealButtonEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxLengthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBoxStaticsVtbl {
    pub const fn new<Impl: IPasswordBoxStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPasswordBoxStaticsVtbl {
        unsafe extern "system" fn PasswordProperty<Impl: IPasswordBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PasswordProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PasswordCharProperty<Impl: IPasswordBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PasswordCharProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPasswordRevealButtonEnabledProperty<Impl: IPasswordBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPasswordRevealButtonEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxLengthProperty<Impl: IPasswordBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPasswordBoxStatics>, base.5, PasswordProperty::<Impl, OFFSET>, PasswordCharProperty::<Impl, OFFSET>, IsPasswordRevealButtonEnabledProperty::<Impl, OFFSET>, MaxLengthProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBoxStatics2Impl: Sized {
    fn HeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionHighlightColorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PreventKeyboardDisplayOnProgrammaticFocusProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBoxStatics2Vtbl {
    pub const fn new<Impl: IPasswordBoxStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPasswordBoxStatics2Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IPasswordBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IPasswordBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: IPasswordBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionHighlightColorProperty<Impl: IPasswordBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocusProperty<Impl: IPasswordBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPasswordBoxStatics2>, base.5, HeaderProperty::<Impl, OFFSET>, HeaderTemplateProperty::<Impl, OFFSET>, PlaceholderTextProperty::<Impl, OFFSET>, SelectionHighlightColorProperty::<Impl, OFFSET>, PreventKeyboardDisplayOnProgrammaticFocusProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBoxStatics3Impl: Sized {
    fn PasswordRevealModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextReadingOrderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InputScopeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBoxStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBoxStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBoxStatics3Vtbl {
    pub const fn new<Impl: IPasswordBoxStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPasswordBoxStatics3Vtbl {
        unsafe extern "system" fn PasswordRevealModeProperty<Impl: IPasswordBoxStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PasswordRevealModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextReadingOrderProperty<Impl: IPasswordBoxStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextReadingOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputScopeProperty<Impl: IPasswordBoxStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InputScopeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPasswordBoxStatics3>, base.5, PasswordRevealModeProperty::<Impl, OFFSET>, TextReadingOrderProperty::<Impl, OFFSET>, InputScopeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPasswordBoxStatics5Impl: Sized {
    fn CanPasteClipboardContentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionFlyoutProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DescriptionProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPasswordBoxStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPasswordBoxStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IPasswordBoxStatics5Vtbl {
    pub const fn new<Impl: IPasswordBoxStatics5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPasswordBoxStatics5Vtbl {
        unsafe extern "system" fn CanPasteClipboardContentProperty<Impl: IPasswordBoxStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanPasteClipboardContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFlyoutProperty<Impl: IPasswordBoxStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DescriptionProperty<Impl: IPasswordBoxStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPasswordBoxStatics5>, base.5, CanPasteClipboardContentProperty::<Impl, OFFSET>, SelectionFlyoutProperty::<Impl, OFFSET>, DescriptionProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPathIconImpl: Sized {
    fn Data(&self) -> ::windows::core::Result<super::Media::Geometry>;
    fn SetData(&self, value: &::core::option::Option<super::Media::Geometry>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPathIcon {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIcon";
}
#[cfg(feature = "implement_exclusive")]
impl IPathIconVtbl {
    pub const fn new<Impl: IPathIconImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPathIconVtbl {
        unsafe extern "system" fn Data<Impl: IPathIconImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Data() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetData<Impl: IPathIconImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetData(&*(&value as *const <super::Media::Geometry as ::windows::core::Abi>::Abi as *const <super::Media::Geometry as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPathIcon>, base.5, Data::<Impl, OFFSET>, SetData::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPathIconFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<PathIcon>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPathIconFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIconFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPathIconFactoryVtbl {
    pub const fn new<Impl: IPathIconFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPathIconFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPathIconFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPathIconFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPathIconSourceImpl: Sized {
    fn Data(&self) -> ::windows::core::Result<super::Media::Geometry>;
    fn SetData(&self, value: &::core::option::Option<super::Media::Geometry>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPathIconSource {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIconSource";
}
#[cfg(feature = "implement_exclusive")]
impl IPathIconSourceVtbl {
    pub const fn new<Impl: IPathIconSourceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPathIconSourceVtbl {
        unsafe extern "system" fn Data<Impl: IPathIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Data() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetData<Impl: IPathIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetData(&*(&value as *const <super::Media::Geometry as ::windows::core::Abi>::Abi as *const <super::Media::Geometry as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPathIconSource>, base.5, Data::<Impl, OFFSET>, SetData::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPathIconSourceFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<PathIconSource>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPathIconSourceFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIconSourceFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPathIconSourceFactoryVtbl {
    pub const fn new<Impl: IPathIconSourceFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPathIconSourceFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPathIconSourceFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPathIconSourceFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPathIconSourceStaticsImpl: Sized {
    fn DataProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPathIconSourceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIconSourceStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPathIconSourceStaticsVtbl {
    pub const fn new<Impl: IPathIconSourceStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPathIconSourceStaticsVtbl {
        unsafe extern "system" fn DataProperty<Impl: IPathIconSourceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DataProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPathIconSourceStatics>, base.5, DataProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPathIconStaticsImpl: Sized {
    fn DataProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPathIconStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPathIconStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPathIconStaticsVtbl {
    pub const fn new<Impl: IPathIconStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPathIconStaticsVtbl {
        unsafe extern "system" fn DataProperty<Impl: IPathIconStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DataProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPathIconStatics>, base.5, DataProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPersonPictureImpl: Sized {
    fn BadgeNumber(&self) -> ::windows::core::Result<i32>;
    fn SetBadgeNumber(&self, value: i32) -> ::windows::core::Result<()>;
    fn BadgeGlyph(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetBadgeGlyph(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn BadgeImageSource(&self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetBadgeImageSource(&self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn BadgeText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetBadgeText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn IsGroup(&self) -> ::windows::core::Result<bool>;
    fn SetIsGroup(&self, value: bool) -> ::windows::core::Result<()>;
    fn Contact(&self) -> ::windows::core::Result<super::super::super::ApplicationModel::Contacts::Contact>;
    fn SetContact(&self, value: &::core::option::Option<super::super::super::ApplicationModel::Contacts::Contact>) -> ::windows::core::Result<()>;
    fn DisplayName(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDisplayName(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Initials(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetInitials(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PreferSmallImage(&self) -> ::windows::core::Result<bool>;
    fn SetPreferSmallImage(&self, value: bool) -> ::windows::core::Result<()>;
    fn ProfilePicture(&self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetProfilePicture(&self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPersonPicture {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPersonPicture";
}
#[cfg(feature = "implement_exclusive")]
impl IPersonPictureVtbl {
    pub const fn new<Impl: IPersonPictureImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPersonPictureVtbl {
        unsafe extern "system" fn BadgeNumber<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BadgeNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBadgeNumber<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBadgeNumber(value).into()
        }
        unsafe extern "system" fn BadgeGlyph<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BadgeGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBadgeGlyph<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBadgeGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BadgeImageSource<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BadgeImageSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBadgeImageSource<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBadgeImageSource(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BadgeText<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BadgeText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBadgeText<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBadgeText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsGroup<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsGroup() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsGroup<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsGroup(value).into()
        }
        unsafe extern "system" fn Contact<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Contact() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContact<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContact(&*(&value as *const <super::super::super::ApplicationModel::Contacts::Contact as ::windows::core::Abi>::Abi as *const <super::super::super::ApplicationModel::Contacts::Contact as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DisplayName<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayName() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayName<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDisplayName(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Initials<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initials() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInitials<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetInitials(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PreferSmallImage<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PreferSmallImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreferSmallImage<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPreferSmallImage(value).into()
        }
        unsafe extern "system" fn ProfilePicture<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProfilePicture() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProfilePicture<Impl: IPersonPictureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetProfilePicture(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IPersonPicture>,
            base.5,
            BadgeNumber::<Impl, OFFSET>,
            SetBadgeNumber::<Impl, OFFSET>,
            BadgeGlyph::<Impl, OFFSET>,
            SetBadgeGlyph::<Impl, OFFSET>,
            BadgeImageSource::<Impl, OFFSET>,
            SetBadgeImageSource::<Impl, OFFSET>,
            BadgeText::<Impl, OFFSET>,
            SetBadgeText::<Impl, OFFSET>,
            IsGroup::<Impl, OFFSET>,
            SetIsGroup::<Impl, OFFSET>,
            Contact::<Impl, OFFSET>,
            SetContact::<Impl, OFFSET>,
            DisplayName::<Impl, OFFSET>,
            SetDisplayName::<Impl, OFFSET>,
            Initials::<Impl, OFFSET>,
            SetInitials::<Impl, OFFSET>,
            PreferSmallImage::<Impl, OFFSET>,
            SetPreferSmallImage::<Impl, OFFSET>,
            ProfilePicture::<Impl, OFFSET>,
            SetProfilePicture::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPersonPictureFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<PersonPicture>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPersonPictureFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPersonPictureFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPersonPictureFactoryVtbl {
    pub const fn new<Impl: IPersonPictureFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPersonPictureFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPersonPictureFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPersonPictureFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPersonPictureStaticsImpl: Sized {
    fn BadgeNumberProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BadgeGlyphProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BadgeImageSourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BadgeTextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsGroupProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContactProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayNameProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InitialsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PreferSmallImageProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ProfilePictureProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPersonPictureStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPersonPictureStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPersonPictureStaticsVtbl {
    pub const fn new<Impl: IPersonPictureStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPersonPictureStaticsVtbl {
        unsafe extern "system" fn BadgeNumberProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BadgeNumberProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BadgeGlyphProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BadgeGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BadgeImageSourceProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BadgeImageSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BadgeTextProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BadgeTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsGroupProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsGroupProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContactProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContactProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayNameProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayNameProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InitialsProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitialsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreferSmallImageProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PreferSmallImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProfilePictureProperty<Impl: IPersonPictureStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProfilePictureProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPersonPictureStatics>, base.5, BadgeNumberProperty::<Impl, OFFSET>, BadgeGlyphProperty::<Impl, OFFSET>, BadgeImageSourceProperty::<Impl, OFFSET>, BadgeTextProperty::<Impl, OFFSET>, IsGroupProperty::<Impl, OFFSET>, ContactProperty::<Impl, OFFSET>, DisplayNameProperty::<Impl, OFFSET>, InitialsProperty::<Impl, OFFSET>, PreferSmallImageProperty::<Impl, OFFSET>, ProfilePictureProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPickerConfirmedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPickerConfirmedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPickerConfirmedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IPickerConfirmedEventArgsVtbl {
    pub const fn new<Impl: IPickerConfirmedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPickerConfirmedEventArgsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPickerConfirmedEventArgs>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPickerFlyoutImpl: Sized {
    fn Content(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetContent(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn ConfirmationButtonsVisible(&self) -> ::windows::core::Result<bool>;
    fn SetConfirmationButtonsVisible(&self, value: bool) -> ::windows::core::Result<()>;
    fn Confirmed(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<PickerFlyout, PickerConfirmedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveConfirmed(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ShowAtAsync(&self, target: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<bool>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPickerFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPickerFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl IPickerFlyoutVtbl {
    pub const fn new<Impl: IPickerFlyoutImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPickerFlyoutVtbl {
        unsafe extern "system" fn Content<Impl: IPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ConfirmationButtonsVisible<Impl: IPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConfirmationButtonsVisible() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetConfirmationButtonsVisible<Impl: IPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetConfirmationButtonsVisible(value).into()
        }
        unsafe extern "system" fn Confirmed<Impl: IPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Confirmed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<PickerFlyout, PickerConfirmedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<PickerFlyout, PickerConfirmedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveConfirmed<Impl: IPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveConfirmed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ShowAtAsync<Impl: IPickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, target: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowAtAsync(&*(&target as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPickerFlyout>, base.5, Content::<Impl, OFFSET>, SetContent::<Impl, OFFSET>, ConfirmationButtonsVisible::<Impl, OFFSET>, SetConfirmationButtonsVisible::<Impl, OFFSET>, Confirmed::<Impl, OFFSET>, RemoveConfirmed::<Impl, OFFSET>, ShowAtAsync::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPickerFlyoutPresenterImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPickerFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPickerFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IPickerFlyoutPresenterVtbl {
    pub const fn new<Impl: IPickerFlyoutPresenterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPickerFlyoutPresenterVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPickerFlyoutPresenter>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPickerFlyoutStaticsImpl: Sized {
    fn ContentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ConfirmationButtonsVisibleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPickerFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPickerFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPickerFlyoutStaticsVtbl {
    pub const fn new<Impl: IPickerFlyoutStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPickerFlyoutStaticsVtbl {
        unsafe extern "system" fn ContentProperty<Impl: IPickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConfirmationButtonsVisibleProperty<Impl: IPickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConfirmationButtonsVisibleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPickerFlyoutStatics>, base.5, ContentProperty::<Impl, OFFSET>, ConfirmationButtonsVisibleProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotImpl: Sized {
    fn Title(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetTitle(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn TitleTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetTitleTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn SelectedIndex(&self) -> ::windows::core::Result<i32>;
    fn SetSelectedIndex(&self, value: i32) -> ::windows::core::Result<()>;
    fn SelectedItem(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetSelectedItem(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn IsLocked(&self) -> ::windows::core::Result<bool>;
    fn SetIsLocked(&self, value: bool) -> ::windows::core::Result<()>;
    fn SelectionChanged(&self, handler: &::core::option::Option<SelectionChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PivotItemLoading(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePivotItemLoading(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PivotItemLoaded(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePivotItemLoaded(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PivotItemUnloading(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePivotItemUnloading(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PivotItemUnloaded(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePivotItemUnloaded(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivot {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivot";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotVtbl {
    pub const fn new<Impl: IPivotImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPivotVtbl {
        unsafe extern "system" fn Title<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Title() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitle<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTitle(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TitleTemplate<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TitleTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitleTemplate<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTitleTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedIndex<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedIndex<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedIndex(value).into()
        }
        unsafe extern "system" fn SelectedItem<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedItem<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedItem(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsLocked<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsLocked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsLocked<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsLocked(value).into()
        }
        unsafe extern "system" fn SelectionChanged<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <SelectionChangedEventHandler as ::windows::core::Abi>::Abi as *const <SelectionChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PivotItemLoading<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PivotItemLoading(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePivotItemLoading<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePivotItemLoading(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PivotItemLoaded<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PivotItemLoaded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePivotItemLoaded<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePivotItemLoaded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PivotItemUnloading<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PivotItemUnloading(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePivotItemUnloading<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePivotItemUnloading(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PivotItemUnloaded<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PivotItemUnloaded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<Pivot, PivotItemEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePivotItemUnloaded<Impl: IPivotImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePivotItemUnloaded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IPivot>,
            base.5,
            Title::<Impl, OFFSET>,
            SetTitle::<Impl, OFFSET>,
            TitleTemplate::<Impl, OFFSET>,
            SetTitleTemplate::<Impl, OFFSET>,
            HeaderTemplate::<Impl, OFFSET>,
            SetHeaderTemplate::<Impl, OFFSET>,
            SelectedIndex::<Impl, OFFSET>,
            SetSelectedIndex::<Impl, OFFSET>,
            SelectedItem::<Impl, OFFSET>,
            SetSelectedItem::<Impl, OFFSET>,
            IsLocked::<Impl, OFFSET>,
            SetIsLocked::<Impl, OFFSET>,
            SelectionChanged::<Impl, OFFSET>,
            RemoveSelectionChanged::<Impl, OFFSET>,
            PivotItemLoading::<Impl, OFFSET>,
            RemovePivotItemLoading::<Impl, OFFSET>,
            PivotItemLoaded::<Impl, OFFSET>,
            RemovePivotItemLoaded::<Impl, OFFSET>,
            PivotItemUnloading::<Impl, OFFSET>,
            RemovePivotItemUnloading::<Impl, OFFSET>,
            PivotItemUnloaded::<Impl, OFFSET>,
            RemovePivotItemUnloaded::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivot2Impl: Sized {
    fn LeftHeader(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetLeftHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn LeftHeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetLeftHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn RightHeader(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetRightHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn RightHeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetRightHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivot2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivot2";
}
#[cfg(feature = "implement_exclusive")]
impl IPivot2Vtbl {
    pub const fn new<Impl: IPivot2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPivot2Vtbl {
        unsafe extern "system" fn LeftHeader<Impl: IPivot2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LeftHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeftHeader<Impl: IPivot2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLeftHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LeftHeaderTemplate<Impl: IPivot2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LeftHeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeftHeaderTemplate<Impl: IPivot2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLeftHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RightHeader<Impl: IPivot2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RightHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRightHeader<Impl: IPivot2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetRightHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RightHeaderTemplate<Impl: IPivot2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RightHeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRightHeaderTemplate<Impl: IPivot2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetRightHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPivot2>, base.5, LeftHeader::<Impl, OFFSET>, SetLeftHeader::<Impl, OFFSET>, LeftHeaderTemplate::<Impl, OFFSET>, SetLeftHeaderTemplate::<Impl, OFFSET>, RightHeader::<Impl, OFFSET>, SetRightHeader::<Impl, OFFSET>, RightHeaderTemplate::<Impl, OFFSET>, SetRightHeaderTemplate::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivot3Impl: Sized {
    fn HeaderFocusVisualPlacement(&self) -> ::windows::core::Result<PivotHeaderFocusVisualPlacement>;
    fn SetHeaderFocusVisualPlacement(&self, value: PivotHeaderFocusVisualPlacement) -> ::windows::core::Result<()>;
    fn IsHeaderItemsCarouselEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsHeaderItemsCarouselEnabled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivot3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivot3";
}
#[cfg(feature = "implement_exclusive")]
impl IPivot3Vtbl {
    pub const fn new<Impl: IPivot3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPivot3Vtbl {
        unsafe extern "system" fn HeaderFocusVisualPlacement<Impl: IPivot3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut PivotHeaderFocusVisualPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderFocusVisualPlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderFocusVisualPlacement<Impl: IPivot3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: PivotHeaderFocusVisualPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderFocusVisualPlacement(value).into()
        }
        unsafe extern "system" fn IsHeaderItemsCarouselEnabled<Impl: IPivot3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsHeaderItemsCarouselEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHeaderItemsCarouselEnabled<Impl: IPivot3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsHeaderItemsCarouselEnabled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPivot3>, base.5, HeaderFocusVisualPlacement::<Impl, OFFSET>, SetHeaderFocusVisualPlacement::<Impl, OFFSET>, IsHeaderItemsCarouselEnabled::<Impl, OFFSET>, SetIsHeaderItemsCarouselEnabled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Pivot>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotFactoryVtbl {
    pub const fn new<Impl: IPivotFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPivotFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPivotFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPivotFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotItemImpl: Sized {
    fn Header(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotItem";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotItemVtbl {
    pub const fn new<Impl: IPivotItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPivotItemVtbl {
        unsafe extern "system" fn Header<Impl: IPivotItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IPivotItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPivotItem>, base.5, Header::<Impl, OFFSET>, SetHeader::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotItemEventArgsImpl: Sized {
    fn Item(&self) -> ::windows::core::Result<PivotItem>;
    fn SetItem(&self, value: &::core::option::Option<PivotItem>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotItemEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotItemEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotItemEventArgsVtbl {
    pub const fn new<Impl: IPivotItemEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPivotItemEventArgsVtbl {
        unsafe extern "system" fn Item<Impl: IPivotItemEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItem<Impl: IPivotItemEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItem(&*(&value as *const <PivotItem as ::windows::core::Abi>::Abi as *const <PivotItem as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPivotItemEventArgs>, base.5, Item::<Impl, OFFSET>, SetItem::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotItemFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<PivotItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotItemFactoryVtbl {
    pub const fn new<Impl: IPivotItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPivotItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPivotItemFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPivotItemFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotItemStaticsImpl: Sized {
    fn HeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotItemStaticsVtbl {
    pub const fn new<Impl: IPivotItemStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPivotItemStaticsVtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IPivotItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPivotItemStatics>, base.5, HeaderProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotStaticsImpl: Sized {
    fn TitleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TitleTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedIndexProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedItemProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsLockedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SlideInAnimationGroupProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetSlideInAnimationGroup(&self, element: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<PivotSlideInAnimationGroup>;
    fn SetSlideInAnimationGroup(&self, element: &::core::option::Option<super::FrameworkElement>, value: PivotSlideInAnimationGroup) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotStaticsVtbl {
    pub const fn new<Impl: IPivotStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPivotStaticsVtbl {
        unsafe extern "system" fn TitleProperty<Impl: IPivotStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TitleTemplateProperty<Impl: IPivotStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TitleTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IPivotStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedIndexProperty<Impl: IPivotStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedIndexProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedItemProperty<Impl: IPivotStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedItemProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsLockedProperty<Impl: IPivotStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsLockedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SlideInAnimationGroupProperty<Impl: IPivotStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SlideInAnimationGroupProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSlideInAnimationGroup<Impl: IPivotStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut PivotSlideInAnimationGroup) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSlideInAnimationGroup(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSlideInAnimationGroup<Impl: IPivotStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: PivotSlideInAnimationGroup) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSlideInAnimationGroup(&*(&element as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPivotStatics>, base.5, TitleProperty::<Impl, OFFSET>, TitleTemplateProperty::<Impl, OFFSET>, HeaderTemplateProperty::<Impl, OFFSET>, SelectedIndexProperty::<Impl, OFFSET>, SelectedItemProperty::<Impl, OFFSET>, IsLockedProperty::<Impl, OFFSET>, SlideInAnimationGroupProperty::<Impl, OFFSET>, GetSlideInAnimationGroup::<Impl, OFFSET>, SetSlideInAnimationGroup::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotStatics2Impl: Sized {
    fn LeftHeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LeftHeaderTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RightHeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RightHeaderTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotStatics2Vtbl {
    pub const fn new<Impl: IPivotStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPivotStatics2Vtbl {
        unsafe extern "system" fn LeftHeaderProperty<Impl: IPivotStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LeftHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LeftHeaderTemplateProperty<Impl: IPivotStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LeftHeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RightHeaderProperty<Impl: IPivotStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RightHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RightHeaderTemplateProperty<Impl: IPivotStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RightHeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPivotStatics2>, base.5, LeftHeaderProperty::<Impl, OFFSET>, LeftHeaderTemplateProperty::<Impl, OFFSET>, RightHeaderProperty::<Impl, OFFSET>, RightHeaderTemplateProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IPivotStatics3Impl: Sized {
    fn HeaderFocusVisualPlacementProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHeaderItemsCarouselEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IPivotStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IPivotStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IPivotStatics3Vtbl {
    pub const fn new<Impl: IPivotStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPivotStatics3Vtbl {
        unsafe extern "system" fn HeaderFocusVisualPlacementProperty<Impl: IPivotStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderFocusVisualPlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHeaderItemsCarouselEnabledProperty<Impl: IPivotStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsHeaderItemsCarouselEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPivotStatics3>, base.5, HeaderFocusVisualPlacementProperty::<Impl, OFFSET>, IsHeaderItemsCarouselEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IProgressBarImpl: Sized {
    fn IsIndeterminate(&self) -> ::windows::core::Result<bool>;
    fn SetIsIndeterminate(&self, value: bool) -> ::windows::core::Result<()>;
    fn ShowError(&self) -> ::windows::core::Result<bool>;
    fn SetShowError(&self, value: bool) -> ::windows::core::Result<()>;
    fn ShowPaused(&self) -> ::windows::core::Result<bool>;
    fn SetShowPaused(&self, value: bool) -> ::windows::core::Result<()>;
    fn TemplateSettings(&self) -> ::windows::core::Result<Primitives::ProgressBarTemplateSettings>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IProgressBar {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IProgressBar";
}
#[cfg(feature = "implement_exclusive")]
impl IProgressBarVtbl {
    pub const fn new<Impl: IProgressBarImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IProgressBarVtbl {
        unsafe extern "system" fn IsIndeterminate<Impl: IProgressBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsIndeterminate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsIndeterminate<Impl: IProgressBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsIndeterminate(value).into()
        }
        unsafe extern "system" fn ShowError<Impl: IProgressBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowError() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowError<Impl: IProgressBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetShowError(value).into()
        }
        unsafe extern "system" fn ShowPaused<Impl: IProgressBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowPaused() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetShowPaused<Impl: IProgressBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetShowPaused(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: IProgressBarImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IProgressBar>, base.5, IsIndeterminate::<Impl, OFFSET>, SetIsIndeterminate::<Impl, OFFSET>, ShowError::<Impl, OFFSET>, SetShowError::<Impl, OFFSET>, ShowPaused::<Impl, OFFSET>, SetShowPaused::<Impl, OFFSET>, TemplateSettings::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IProgressBarFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ProgressBar>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IProgressBarFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IProgressBarFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IProgressBarFactoryVtbl {
    pub const fn new<Impl: IProgressBarFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IProgressBarFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IProgressBarFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IProgressBarFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IProgressBarStaticsImpl: Sized {
    fn IsIndeterminateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ShowErrorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ShowPausedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IProgressBarStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IProgressBarStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IProgressBarStaticsVtbl {
    pub const fn new<Impl: IProgressBarStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IProgressBarStaticsVtbl {
        unsafe extern "system" fn IsIndeterminateProperty<Impl: IProgressBarStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsIndeterminateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShowErrorProperty<Impl: IProgressBarStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowErrorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShowPausedProperty<Impl: IProgressBarStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowPausedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IProgressBarStatics>, base.5, IsIndeterminateProperty::<Impl, OFFSET>, ShowErrorProperty::<Impl, OFFSET>, ShowPausedProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IProgressRingImpl: Sized {
    fn IsActive(&self) -> ::windows::core::Result<bool>;
    fn SetIsActive(&self, value: bool) -> ::windows::core::Result<()>;
    fn TemplateSettings(&self) -> ::windows::core::Result<Primitives::ProgressRingTemplateSettings>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IProgressRing {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IProgressRing";
}
#[cfg(feature = "implement_exclusive")]
impl IProgressRingVtbl {
    pub const fn new<Impl: IProgressRingImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IProgressRingVtbl {
        unsafe extern "system" fn IsActive<Impl: IProgressRingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsActive() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsActive<Impl: IProgressRingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsActive(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: IProgressRingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IProgressRing>, base.5, IsActive::<Impl, OFFSET>, SetIsActive::<Impl, OFFSET>, TemplateSettings::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IProgressRingStaticsImpl: Sized {
    fn IsActiveProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IProgressRingStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IProgressRingStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IProgressRingStaticsVtbl {
    pub const fn new<Impl: IProgressRingStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IProgressRingStaticsVtbl {
        unsafe extern "system" fn IsActiveProperty<Impl: IProgressRingStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsActiveProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IProgressRingStatics>, base.5, IsActiveProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRadioButtonImpl: Sized {
    fn GroupName(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetGroupName(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRadioButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRadioButton";
}
#[cfg(feature = "implement_exclusive")]
impl IRadioButtonVtbl {
    pub const fn new<Impl: IRadioButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRadioButtonVtbl {
        unsafe extern "system" fn GroupName<Impl: IRadioButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GroupName() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGroupName<Impl: IRadioButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetGroupName(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRadioButton>, base.5, GroupName::<Impl, OFFSET>, SetGroupName::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRadioButtonFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RadioButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRadioButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRadioButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRadioButtonFactoryVtbl {
    pub const fn new<Impl: IRadioButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRadioButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRadioButtonFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRadioButtonFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRadioButtonStaticsImpl: Sized {
    fn GroupNameProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRadioButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRadioButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRadioButtonStaticsVtbl {
    pub const fn new<Impl: IRadioButtonStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRadioButtonStaticsVtbl {
        unsafe extern "system" fn GroupNameProperty<Impl: IRadioButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GroupNameProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRadioButtonStatics>, base.5, GroupNameProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingControlImpl: Sized {
    fn Caption(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCaption(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn InitialSetValue(&self) -> ::windows::core::Result<i32>;
    fn SetInitialSetValue(&self, value: i32) -> ::windows::core::Result<()>;
    fn IsClearEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsClearEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsReadOnly(&self) -> ::windows::core::Result<bool>;
    fn SetIsReadOnly(&self, value: bool) -> ::windows::core::Result<()>;
    fn MaxRating(&self) -> ::windows::core::Result<i32>;
    fn SetMaxRating(&self, value: i32) -> ::windows::core::Result<()>;
    fn PlaceholderValue(&self) -> ::windows::core::Result<f64>;
    fn SetPlaceholderValue(&self, value: f64) -> ::windows::core::Result<()>;
    fn ItemInfo(&self) -> ::windows::core::Result<RatingItemInfo>;
    fn SetItemInfo(&self, value: &::core::option::Option<RatingItemInfo>) -> ::windows::core::Result<()>;
    fn Value(&self) -> ::windows::core::Result<f64>;
    fn SetValue(&self, value: f64) -> ::windows::core::Result<()>;
    fn ValueChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RatingControl, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveValueChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingControl";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingControlVtbl {
    pub const fn new<Impl: IRatingControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRatingControlVtbl {
        unsafe extern "system" fn Caption<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Caption() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCaption<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCaption(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn InitialSetValue<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitialSetValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInitialSetValue<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetInitialSetValue(value).into()
        }
        unsafe extern "system" fn IsClearEnabled<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsClearEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsClearEnabled<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsClearEnabled(value).into()
        }
        unsafe extern "system" fn IsReadOnly<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsReadOnly() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsReadOnly<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsReadOnly(value).into()
        }
        unsafe extern "system" fn MaxRating<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxRating() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxRating<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxRating(value).into()
        }
        unsafe extern "system" fn PlaceholderValue<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderValue<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlaceholderValue(value).into()
        }
        unsafe extern "system" fn ItemInfo<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemInfo<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemInfo(&*(&value as *const <RatingItemInfo as ::windows::core::Abi>::Abi as *const <RatingItemInfo as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Value<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Value() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetValue<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetValue(value).into()
        }
        unsafe extern "system" fn ValueChanged<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ValueChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RatingControl, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RatingControl, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveValueChanged<Impl: IRatingControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveValueChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IRatingControl>,
            base.5,
            Caption::<Impl, OFFSET>,
            SetCaption::<Impl, OFFSET>,
            InitialSetValue::<Impl, OFFSET>,
            SetInitialSetValue::<Impl, OFFSET>,
            IsClearEnabled::<Impl, OFFSET>,
            SetIsClearEnabled::<Impl, OFFSET>,
            IsReadOnly::<Impl, OFFSET>,
            SetIsReadOnly::<Impl, OFFSET>,
            MaxRating::<Impl, OFFSET>,
            SetMaxRating::<Impl, OFFSET>,
            PlaceholderValue::<Impl, OFFSET>,
            SetPlaceholderValue::<Impl, OFFSET>,
            ItemInfo::<Impl, OFFSET>,
            SetItemInfo::<Impl, OFFSET>,
            Value::<Impl, OFFSET>,
            SetValue::<Impl, OFFSET>,
            ValueChanged::<Impl, OFFSET>,
            RemoveValueChanged::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingControlFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RatingControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingControlFactoryVtbl {
    pub const fn new<Impl: IRatingControlFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRatingControlFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRatingControlFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRatingControlFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingControlStaticsImpl: Sized {
    fn CaptionProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InitialSetValueProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsClearEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsReadOnlyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxRatingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderValueProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemInfoProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ValueProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingControlStaticsVtbl {
    pub const fn new<Impl: IRatingControlStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRatingControlStaticsVtbl {
        unsafe extern "system" fn CaptionProperty<Impl: IRatingControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CaptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InitialSetValueProperty<Impl: IRatingControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitialSetValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsClearEnabledProperty<Impl: IRatingControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsClearEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsReadOnlyProperty<Impl: IRatingControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsReadOnlyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxRatingProperty<Impl: IRatingControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxRatingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderValueProperty<Impl: IRatingControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemInfoProperty<Impl: IRatingControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemInfoProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ValueProperty<Impl: IRatingControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRatingControlStatics>, base.5, CaptionProperty::<Impl, OFFSET>, InitialSetValueProperty::<Impl, OFFSET>, IsClearEnabledProperty::<Impl, OFFSET>, IsReadOnlyProperty::<Impl, OFFSET>, MaxRatingProperty::<Impl, OFFSET>, PlaceholderValueProperty::<Impl, OFFSET>, ItemInfoProperty::<Impl, OFFSET>, ValueProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemFontInfoImpl: Sized {
    fn DisabledGlyph(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetDisabledGlyph(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Glyph(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetGlyph(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PointerOverGlyph(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPointerOverGlyph(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PointerOverPlaceholderGlyph(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPointerOverPlaceholderGlyph(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PlaceholderGlyph(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderGlyph(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn UnsetGlyph(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetUnsetGlyph(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemFontInfo {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemFontInfo";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemFontInfoVtbl {
    pub const fn new<Impl: IRatingItemFontInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRatingItemFontInfoVtbl {
        unsafe extern "system" fn DisabledGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisabledGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisabledGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDisabledGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Glyph<Impl: IRatingItemFontInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Glyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PointerOverGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PointerOverGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPointerOverGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPointerOverGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PointerOverPlaceholderGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PointerOverPlaceholderGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPointerOverPlaceholderGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPointerOverPlaceholderGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlaceholderGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UnsetGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnsetGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUnsetGlyph<Impl: IRatingItemFontInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetUnsetGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IRatingItemFontInfo>,
            base.5,
            DisabledGlyph::<Impl, OFFSET>,
            SetDisabledGlyph::<Impl, OFFSET>,
            Glyph::<Impl, OFFSET>,
            SetGlyph::<Impl, OFFSET>,
            PointerOverGlyph::<Impl, OFFSET>,
            SetPointerOverGlyph::<Impl, OFFSET>,
            PointerOverPlaceholderGlyph::<Impl, OFFSET>,
            SetPointerOverPlaceholderGlyph::<Impl, OFFSET>,
            PlaceholderGlyph::<Impl, OFFSET>,
            SetPlaceholderGlyph::<Impl, OFFSET>,
            UnsetGlyph::<Impl, OFFSET>,
            SetUnsetGlyph::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemFontInfoFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RatingItemFontInfo>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemFontInfoFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemFontInfoFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemFontInfoFactoryVtbl {
    pub const fn new<Impl: IRatingItemFontInfoFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRatingItemFontInfoFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRatingItemFontInfoFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRatingItemFontInfoFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemFontInfoStaticsImpl: Sized {
    fn DisabledGlyphProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GlyphProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderGlyphProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PointerOverGlyphProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PointerOverPlaceholderGlyphProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn UnsetGlyphProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemFontInfoStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemFontInfoStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemFontInfoStaticsVtbl {
    pub const fn new<Impl: IRatingItemFontInfoStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRatingItemFontInfoStaticsVtbl {
        unsafe extern "system" fn DisabledGlyphProperty<Impl: IRatingItemFontInfoStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisabledGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GlyphProperty<Impl: IRatingItemFontInfoStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderGlyphProperty<Impl: IRatingItemFontInfoStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PointerOverGlyphProperty<Impl: IRatingItemFontInfoStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PointerOverGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PointerOverPlaceholderGlyphProperty<Impl: IRatingItemFontInfoStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PointerOverPlaceholderGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnsetGlyphProperty<Impl: IRatingItemFontInfoStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnsetGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRatingItemFontInfoStatics>, base.5, DisabledGlyphProperty::<Impl, OFFSET>, GlyphProperty::<Impl, OFFSET>, PlaceholderGlyphProperty::<Impl, OFFSET>, PointerOverGlyphProperty::<Impl, OFFSET>, PointerOverPlaceholderGlyphProperty::<Impl, OFFSET>, UnsetGlyphProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemImageInfoImpl: Sized {
    fn DisabledImage(&self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetDisabledImage(&self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn Image(&self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetImage(&self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn PlaceholderImage(&self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetPlaceholderImage(&self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn PointerOverImage(&self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetPointerOverImage(&self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn PointerOverPlaceholderImage(&self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetPointerOverPlaceholderImage(&self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn UnsetImage(&self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetUnsetImage(&self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemImageInfo {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemImageInfo";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemImageInfoVtbl {
    pub const fn new<Impl: IRatingItemImageInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRatingItemImageInfoVtbl {
        unsafe extern "system" fn DisabledImage<Impl: IRatingItemImageInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisabledImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisabledImage<Impl: IRatingItemImageInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDisabledImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Image<Impl: IRatingItemImageInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Image() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetImage<Impl: IRatingItemImageInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderImage<Impl: IRatingItemImageInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderImage<Impl: IRatingItemImageInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlaceholderImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PointerOverImage<Impl: IRatingItemImageInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PointerOverImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPointerOverImage<Impl: IRatingItemImageInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPointerOverImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PointerOverPlaceholderImage<Impl: IRatingItemImageInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PointerOverPlaceholderImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPointerOverPlaceholderImage<Impl: IRatingItemImageInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPointerOverPlaceholderImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UnsetImage<Impl: IRatingItemImageInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnsetImage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUnsetImage<Impl: IRatingItemImageInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetUnsetImage(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IRatingItemImageInfo>,
            base.5,
            DisabledImage::<Impl, OFFSET>,
            SetDisabledImage::<Impl, OFFSET>,
            Image::<Impl, OFFSET>,
            SetImage::<Impl, OFFSET>,
            PlaceholderImage::<Impl, OFFSET>,
            SetPlaceholderImage::<Impl, OFFSET>,
            PointerOverImage::<Impl, OFFSET>,
            SetPointerOverImage::<Impl, OFFSET>,
            PointerOverPlaceholderImage::<Impl, OFFSET>,
            SetPointerOverPlaceholderImage::<Impl, OFFSET>,
            UnsetImage::<Impl, OFFSET>,
            SetUnsetImage::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemImageInfoFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RatingItemImageInfo>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemImageInfoFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemImageInfoFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemImageInfoFactoryVtbl {
    pub const fn new<Impl: IRatingItemImageInfoFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRatingItemImageInfoFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRatingItemImageInfoFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRatingItemImageInfoFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemImageInfoStaticsImpl: Sized {
    fn DisabledImageProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ImageProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderImageProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PointerOverImageProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PointerOverPlaceholderImageProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn UnsetImageProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemImageInfoStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemImageInfoStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemImageInfoStaticsVtbl {
    pub const fn new<Impl: IRatingItemImageInfoStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRatingItemImageInfoStaticsVtbl {
        unsafe extern "system" fn DisabledImageProperty<Impl: IRatingItemImageInfoStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisabledImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ImageProperty<Impl: IRatingItemImageInfoStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderImageProperty<Impl: IRatingItemImageInfoStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PointerOverImageProperty<Impl: IRatingItemImageInfoStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PointerOverImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PointerOverPlaceholderImageProperty<Impl: IRatingItemImageInfoStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PointerOverPlaceholderImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnsetImageProperty<Impl: IRatingItemImageInfoStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnsetImageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRatingItemImageInfoStatics>, base.5, DisabledImageProperty::<Impl, OFFSET>, ImageProperty::<Impl, OFFSET>, PlaceholderImageProperty::<Impl, OFFSET>, PointerOverImageProperty::<Impl, OFFSET>, PointerOverPlaceholderImageProperty::<Impl, OFFSET>, UnsetImageProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemInfoImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemInfo {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemInfo";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemInfoVtbl {
    pub const fn new<Impl: IRatingItemInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRatingItemInfoVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRatingItemInfo>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRatingItemInfoFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RatingItemInfo>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRatingItemInfoFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRatingItemInfoFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRatingItemInfoFactoryVtbl {
    pub const fn new<Impl: IRatingItemInfoFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRatingItemInfoFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRatingItemInfoFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRatingItemInfoFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshContainerImpl: Sized {
    fn Visualizer(&self) -> ::windows::core::Result<RefreshVisualizer>;
    fn SetVisualizer(&self, value: &::core::option::Option<RefreshVisualizer>) -> ::windows::core::Result<()>;
    fn PullDirection(&self) -> ::windows::core::Result<RefreshPullDirection>;
    fn SetPullDirection(&self, value: RefreshPullDirection) -> ::windows::core::Result<()>;
    fn RefreshRequested(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RefreshContainer, RefreshRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveRefreshRequested(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn RequestRefresh(&self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshContainer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshContainer";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshContainerVtbl {
    pub const fn new<Impl: IRefreshContainerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRefreshContainerVtbl {
        unsafe extern "system" fn Visualizer<Impl: IRefreshContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Visualizer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVisualizer<Impl: IRefreshContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVisualizer(&*(&value as *const <RefreshVisualizer as ::windows::core::Abi>::Abi as *const <RefreshVisualizer as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PullDirection<Impl: IRefreshContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut RefreshPullDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PullDirection() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPullDirection<Impl: IRefreshContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: RefreshPullDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPullDirection(value).into()
        }
        unsafe extern "system" fn RefreshRequested<Impl: IRefreshContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RefreshRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RefreshContainer, RefreshRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RefreshContainer, RefreshRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveRefreshRequested<Impl: IRefreshContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveRefreshRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RequestRefresh<Impl: IRefreshContainerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RequestRefresh().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRefreshContainer>, base.5, Visualizer::<Impl, OFFSET>, SetVisualizer::<Impl, OFFSET>, PullDirection::<Impl, OFFSET>, SetPullDirection::<Impl, OFFSET>, RefreshRequested::<Impl, OFFSET>, RemoveRefreshRequested::<Impl, OFFSET>, RequestRefresh::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshContainerFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RefreshContainer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshContainerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshContainerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshContainerFactoryVtbl {
    pub const fn new<Impl: IRefreshContainerFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRefreshContainerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRefreshContainerFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRefreshContainerFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshContainerStaticsImpl: Sized {
    fn VisualizerProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PullDirectionProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshContainerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshContainerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshContainerStaticsVtbl {
    pub const fn new<Impl: IRefreshContainerStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRefreshContainerStaticsVtbl {
        unsafe extern "system" fn VisualizerProperty<Impl: IRefreshContainerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VisualizerProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PullDirectionProperty<Impl: IRefreshContainerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PullDirectionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRefreshContainerStatics>, base.5, VisualizerProperty::<Impl, OFFSET>, PullDirectionProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshInteractionRatioChangedEventArgsImpl: Sized {
    fn InteractionRatio(&self) -> ::windows::core::Result<f64>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshInteractionRatioChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshInteractionRatioChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshInteractionRatioChangedEventArgsVtbl {
    pub const fn new<Impl: IRefreshInteractionRatioChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRefreshInteractionRatioChangedEventArgsVtbl {
        unsafe extern "system" fn InteractionRatio<Impl: IRefreshInteractionRatioChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InteractionRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRefreshInteractionRatioChangedEventArgs>, base.5, InteractionRatio::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshRequestedEventArgsImpl: Sized {
    fn GetDeferral(&self) -> ::windows::core::Result<super::super::super::Foundation::Deferral>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshRequestedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshRequestedEventArgsVtbl {
    pub const fn new<Impl: IRefreshRequestedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRefreshRequestedEventArgsVtbl {
        unsafe extern "system" fn GetDeferral<Impl: IRefreshRequestedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDeferral() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRefreshRequestedEventArgs>, base.5, GetDeferral::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshStateChangedEventArgsImpl: Sized {
    fn OldState(&self) -> ::windows::core::Result<RefreshVisualizerState>;
    fn NewState(&self) -> ::windows::core::Result<RefreshVisualizerState>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshStateChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshStateChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshStateChangedEventArgsVtbl {
    pub const fn new<Impl: IRefreshStateChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRefreshStateChangedEventArgsVtbl {
        unsafe extern "system" fn OldState<Impl: IRefreshStateChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut RefreshVisualizerState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OldState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewState<Impl: IRefreshStateChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut RefreshVisualizerState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NewState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRefreshStateChangedEventArgs>, base.5, OldState::<Impl, OFFSET>, NewState::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshVisualizerImpl: Sized {
    fn RequestRefresh(&self) -> ::windows::core::Result<()>;
    fn Orientation(&self) -> ::windows::core::Result<RefreshVisualizerOrientation>;
    fn SetOrientation(&self, value: RefreshVisualizerOrientation) -> ::windows::core::Result<()>;
    fn Content(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetContent(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn State(&self) -> ::windows::core::Result<RefreshVisualizerState>;
    fn RefreshRequested(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveRefreshRequested(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn RefreshStateChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshStateChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveRefreshStateChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshVisualizer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshVisualizer";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshVisualizerVtbl {
    pub const fn new<Impl: IRefreshVisualizerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRefreshVisualizerVtbl {
        unsafe extern "system" fn RequestRefresh<Impl: IRefreshVisualizerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RequestRefresh().into()
        }
        unsafe extern "system" fn Orientation<Impl: IRefreshVisualizerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut RefreshVisualizerOrientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IRefreshVisualizerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: RefreshVisualizerOrientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn Content<Impl: IRefreshVisualizerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IRefreshVisualizerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn State<Impl: IRefreshVisualizerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut RefreshVisualizerState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).State() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RefreshRequested<Impl: IRefreshVisualizerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RefreshRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveRefreshRequested<Impl: IRefreshVisualizerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveRefreshRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RefreshStateChanged<Impl: IRefreshVisualizerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RefreshStateChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshStateChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RefreshVisualizer, RefreshStateChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveRefreshStateChanged<Impl: IRefreshVisualizerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveRefreshStateChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRefreshVisualizer>, base.5, RequestRefresh::<Impl, OFFSET>, Orientation::<Impl, OFFSET>, SetOrientation::<Impl, OFFSET>, Content::<Impl, OFFSET>, SetContent::<Impl, OFFSET>, State::<Impl, OFFSET>, RefreshRequested::<Impl, OFFSET>, RemoveRefreshRequested::<Impl, OFFSET>, RefreshStateChanged::<Impl, OFFSET>, RemoveRefreshStateChanged::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshVisualizerFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RefreshVisualizer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshVisualizerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshVisualizerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshVisualizerFactoryVtbl {
    pub const fn new<Impl: IRefreshVisualizerFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRefreshVisualizerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRefreshVisualizerFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRefreshVisualizerFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRefreshVisualizerStaticsImpl: Sized {
    fn InfoProviderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRefreshVisualizerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRefreshVisualizerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRefreshVisualizerStaticsVtbl {
    pub const fn new<Impl: IRefreshVisualizerStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRefreshVisualizerStaticsVtbl {
        unsafe extern "system" fn InfoProviderProperty<Impl: IRefreshVisualizerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InfoProviderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IRefreshVisualizerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentProperty<Impl: IRefreshVisualizerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StateProperty<Impl: IRefreshVisualizerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRefreshVisualizerStatics>, base.5, InfoProviderProperty::<Impl, OFFSET>, OrientationProperty::<Impl, OFFSET>, ContentProperty::<Impl, OFFSET>, StateProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRelativePanelImpl: Sized {
    fn BorderBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CornerRadius(&self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
    fn Padding(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRelativePanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRelativePanel";
}
#[cfg(feature = "implement_exclusive")]
impl IRelativePanelVtbl {
    pub const fn new<Impl: IRelativePanelImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRelativePanelVtbl {
        unsafe extern "system" fn BorderBrush<Impl: IRelativePanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IRelativePanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IRelativePanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IRelativePanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IRelativePanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IRelativePanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IRelativePanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IRelativePanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRelativePanel>, base.5, BorderBrush::<Impl, OFFSET>, SetBorderBrush::<Impl, OFFSET>, BorderThickness::<Impl, OFFSET>, SetBorderThickness::<Impl, OFFSET>, CornerRadius::<Impl, OFFSET>, SetCornerRadius::<Impl, OFFSET>, Padding::<Impl, OFFSET>, SetPadding::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRelativePanel2Impl: Sized {
    fn BackgroundSizing(&self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&self, value: BackgroundSizing) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRelativePanel2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRelativePanel2";
}
#[cfg(feature = "implement_exclusive")]
impl IRelativePanel2Vtbl {
    pub const fn new<Impl: IRelativePanel2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRelativePanel2Vtbl {
        unsafe extern "system" fn BackgroundSizing<Impl: IRelativePanel2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IRelativePanel2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRelativePanel2>, base.5, BackgroundSizing::<Impl, OFFSET>, SetBackgroundSizing::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRelativePanelFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RelativePanel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRelativePanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRelativePanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRelativePanelFactoryVtbl {
    pub const fn new<Impl: IRelativePanelFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRelativePanelFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRelativePanelFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRelativePanelFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRelativePanelStaticsImpl: Sized {
    fn LeftOfProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetLeftOf(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetLeftOf(&self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AboveProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAbove(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAbove(&self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn RightOfProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetRightOf(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetRightOf(&self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn BelowProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetBelow(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetBelow(&self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignHorizontalCenterWithProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignHorizontalCenterWith(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignHorizontalCenterWith(&self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignVerticalCenterWithProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignVerticalCenterWith(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignVerticalCenterWith(&self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignLeftWithProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignLeftWith(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignLeftWith(&self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignTopWithProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignTopWith(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignTopWith(&self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignRightWithProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignRightWith(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignRightWith(&self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignBottomWithProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignBottomWith(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetAlignBottomWith(&self, element: &::core::option::Option<super::UIElement>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn AlignLeftWithPanelProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignLeftWithPanel(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignLeftWithPanel(&self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn AlignTopWithPanelProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignTopWithPanel(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignTopWithPanel(&self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn AlignRightWithPanelProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignRightWithPanel(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignRightWithPanel(&self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn AlignBottomWithPanelProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignBottomWithPanel(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignBottomWithPanel(&self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn AlignHorizontalCenterWithPanelProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignHorizontalCenterWithPanel(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignHorizontalCenterWithPanel(&self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn AlignVerticalCenterWithPanelProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetAlignVerticalCenterWithPanel(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<bool>;
    fn SetAlignVerticalCenterWithPanel(&self, element: &::core::option::Option<super::UIElement>, value: bool) -> ::windows::core::Result<()>;
    fn BorderBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRelativePanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRelativePanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRelativePanelStaticsVtbl {
    pub const fn new<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRelativePanelStaticsVtbl {
        unsafe extern "system" fn LeftOfProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LeftOfProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLeftOf<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLeftOf(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeftOf<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLeftOf(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AboveProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AboveProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAbove<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAbove(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAbove<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAbove(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RightOfProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RightOfProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRightOf<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRightOf(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRightOf<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetRightOf(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BelowProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BelowProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBelow<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBelow(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBelow<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBelow(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignHorizontalCenterWithProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AlignHorizontalCenterWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignHorizontalCenterWith<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlignHorizontalCenterWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignHorizontalCenterWith<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAlignHorizontalCenterWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignVerticalCenterWithProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AlignVerticalCenterWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignVerticalCenterWith<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlignVerticalCenterWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignVerticalCenterWith<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAlignVerticalCenterWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignLeftWithProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AlignLeftWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignLeftWith<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlignLeftWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignLeftWith<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAlignLeftWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignTopWithProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AlignTopWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignTopWith<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlignTopWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignTopWith<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAlignTopWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignRightWithProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AlignRightWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignRightWith<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlignRightWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignRightWith<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAlignRightWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignBottomWithProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AlignBottomWithProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignBottomWith<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlignBottomWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignBottomWith<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAlignBottomWith(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AlignLeftWithPanelProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AlignLeftWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignLeftWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlignLeftWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignLeftWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAlignLeftWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn AlignTopWithPanelProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AlignTopWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignTopWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlignTopWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignTopWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAlignTopWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn AlignRightWithPanelProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AlignRightWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignRightWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlignRightWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignRightWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAlignRightWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn AlignBottomWithPanelProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AlignBottomWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignBottomWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlignBottomWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignBottomWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAlignBottomWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn AlignHorizontalCenterWithPanelProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AlignHorizontalCenterWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignHorizontalCenterWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlignHorizontalCenterWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignHorizontalCenterWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAlignHorizontalCenterWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn AlignVerticalCenterWithPanelProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AlignVerticalCenterWithPanelProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlignVerticalCenterWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlignVerticalCenterWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAlignVerticalCenterWithPanel<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAlignVerticalCenterWithPanel(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn BorderBrushProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IRelativePanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IRelativePanelStatics>,
            base.5,
            LeftOfProperty::<Impl, OFFSET>,
            GetLeftOf::<Impl, OFFSET>,
            SetLeftOf::<Impl, OFFSET>,
            AboveProperty::<Impl, OFFSET>,
            GetAbove::<Impl, OFFSET>,
            SetAbove::<Impl, OFFSET>,
            RightOfProperty::<Impl, OFFSET>,
            GetRightOf::<Impl, OFFSET>,
            SetRightOf::<Impl, OFFSET>,
            BelowProperty::<Impl, OFFSET>,
            GetBelow::<Impl, OFFSET>,
            SetBelow::<Impl, OFFSET>,
            AlignHorizontalCenterWithProperty::<Impl, OFFSET>,
            GetAlignHorizontalCenterWith::<Impl, OFFSET>,
            SetAlignHorizontalCenterWith::<Impl, OFFSET>,
            AlignVerticalCenterWithProperty::<Impl, OFFSET>,
            GetAlignVerticalCenterWith::<Impl, OFFSET>,
            SetAlignVerticalCenterWith::<Impl, OFFSET>,
            AlignLeftWithProperty::<Impl, OFFSET>,
            GetAlignLeftWith::<Impl, OFFSET>,
            SetAlignLeftWith::<Impl, OFFSET>,
            AlignTopWithProperty::<Impl, OFFSET>,
            GetAlignTopWith::<Impl, OFFSET>,
            SetAlignTopWith::<Impl, OFFSET>,
            AlignRightWithProperty::<Impl, OFFSET>,
            GetAlignRightWith::<Impl, OFFSET>,
            SetAlignRightWith::<Impl, OFFSET>,
            AlignBottomWithProperty::<Impl, OFFSET>,
            GetAlignBottomWith::<Impl, OFFSET>,
            SetAlignBottomWith::<Impl, OFFSET>,
            AlignLeftWithPanelProperty::<Impl, OFFSET>,
            GetAlignLeftWithPanel::<Impl, OFFSET>,
            SetAlignLeftWithPanel::<Impl, OFFSET>,
            AlignTopWithPanelProperty::<Impl, OFFSET>,
            GetAlignTopWithPanel::<Impl, OFFSET>,
            SetAlignTopWithPanel::<Impl, OFFSET>,
            AlignRightWithPanelProperty::<Impl, OFFSET>,
            GetAlignRightWithPanel::<Impl, OFFSET>,
            SetAlignRightWithPanel::<Impl, OFFSET>,
            AlignBottomWithPanelProperty::<Impl, OFFSET>,
            GetAlignBottomWithPanel::<Impl, OFFSET>,
            SetAlignBottomWithPanel::<Impl, OFFSET>,
            AlignHorizontalCenterWithPanelProperty::<Impl, OFFSET>,
            GetAlignHorizontalCenterWithPanel::<Impl, OFFSET>,
            SetAlignHorizontalCenterWithPanel::<Impl, OFFSET>,
            AlignVerticalCenterWithPanelProperty::<Impl, OFFSET>,
            GetAlignVerticalCenterWithPanel::<Impl, OFFSET>,
            SetAlignVerticalCenterWithPanel::<Impl, OFFSET>,
            BorderBrushProperty::<Impl, OFFSET>,
            BorderThicknessProperty::<Impl, OFFSET>,
            CornerRadiusProperty::<Impl, OFFSET>,
            PaddingProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRelativePanelStatics2Impl: Sized {
    fn BackgroundSizingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRelativePanelStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRelativePanelStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IRelativePanelStatics2Vtbl {
    pub const fn new<Impl: IRelativePanelStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRelativePanelStatics2Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IRelativePanelStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRelativePanelStatics2>, base.5, BackgroundSizingProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxImpl: Sized {
    fn IsReadOnly(&self) -> ::windows::core::Result<bool>;
    fn SetIsReadOnly(&self, value: bool) -> ::windows::core::Result<()>;
    fn AcceptsReturn(&self) -> ::windows::core::Result<bool>;
    fn SetAcceptsReturn(&self, value: bool) -> ::windows::core::Result<()>;
    fn TextAlignment(&self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetTextAlignment(&self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn TextWrapping(&self) -> ::windows::core::Result<super::TextWrapping>;
    fn SetTextWrapping(&self, value: super::TextWrapping) -> ::windows::core::Result<()>;
    fn IsSpellCheckEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsSpellCheckEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsTextPredictionEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsTextPredictionEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn Document(&self) -> ::windows::core::Result<super::super::Text::ITextDocument>;
    fn InputScope(&self) -> ::windows::core::Result<super::Input::InputScope>;
    fn SetInputScope(&self, value: &::core::option::Option<super::Input::InputScope>) -> ::windows::core::Result<()>;
    fn TextChanged(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectionChanged(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContextMenuOpening(&self, handler: &::core::option::Option<ContextMenuOpeningEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContextMenuOpening(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxVtbl {
    pub const fn new<Impl: IRichEditBoxImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBoxVtbl {
        unsafe extern "system" fn IsReadOnly<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsReadOnly() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsReadOnly<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsReadOnly(value).into()
        }
        unsafe extern "system" fn AcceptsReturn<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AcceptsReturn() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAcceptsReturn<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAcceptsReturn(value).into()
        }
        unsafe extern "system" fn TextAlignment<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextAlignment<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextAlignment(value).into()
        }
        unsafe extern "system" fn TextWrapping<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextWrapping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextWrapping<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextWrapping(value).into()
        }
        unsafe extern "system" fn IsSpellCheckEnabled<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSpellCheckEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSpellCheckEnabled<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsSpellCheckEnabled(value).into()
        }
        unsafe extern "system" fn IsTextPredictionEnabled<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextPredictionEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextPredictionEnabled<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsTextPredictionEnabled(value).into()
        }
        unsafe extern "system" fn Document<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Document() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputScope<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InputScope() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputScope<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetInputScope(&*(&value as *const <super::Input::InputScope as ::windows::core::Abi>::Abi as *const <super::Input::InputScope as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextChanged<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextChanged<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveTextChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionChanged<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContextMenuOpening<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContextMenuOpening(&*(&handler as *const <ContextMenuOpeningEventHandler as ::windows::core::Abi>::Abi as *const <ContextMenuOpeningEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContextMenuOpening<Impl: IRichEditBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveContextMenuOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IRichEditBox>,
            base.5,
            IsReadOnly::<Impl, OFFSET>,
            SetIsReadOnly::<Impl, OFFSET>,
            AcceptsReturn::<Impl, OFFSET>,
            SetAcceptsReturn::<Impl, OFFSET>,
            TextAlignment::<Impl, OFFSET>,
            SetTextAlignment::<Impl, OFFSET>,
            TextWrapping::<Impl, OFFSET>,
            SetTextWrapping::<Impl, OFFSET>,
            IsSpellCheckEnabled::<Impl, OFFSET>,
            SetIsSpellCheckEnabled::<Impl, OFFSET>,
            IsTextPredictionEnabled::<Impl, OFFSET>,
            SetIsTextPredictionEnabled::<Impl, OFFSET>,
            Document::<Impl, OFFSET>,
            InputScope::<Impl, OFFSET>,
            SetInputScope::<Impl, OFFSET>,
            TextChanged::<Impl, OFFSET>,
            RemoveTextChanged::<Impl, OFFSET>,
            SelectionChanged::<Impl, OFFSET>,
            RemoveSelectionChanged::<Impl, OFFSET>,
            ContextMenuOpening::<Impl, OFFSET>,
            RemoveContextMenuOpening::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBox2Impl: Sized {
    fn Header(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn PlaceholderText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectionHighlightColor(&self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColor(&self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn PreventKeyboardDisplayOnProgrammaticFocus(&self) -> ::windows::core::Result<bool>;
    fn SetPreventKeyboardDisplayOnProgrammaticFocus(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorFontEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsColorFontEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn Paste(&self, handler: &::core::option::Option<TextControlPasteEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaste(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox2";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBox2Vtbl {
    pub const fn new<Impl: IRichEditBox2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBox2Vtbl {
        unsafe extern "system" fn Header<Impl: IRichEditBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IRichEditBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IRichEditBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IRichEditBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: IRichEditBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: IRichEditBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionHighlightColor<Impl: IRichEditBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColor<Impl: IRichEditBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocus<Impl: IRichEditBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreventKeyboardDisplayOnProgrammaticFocus<Impl: IRichEditBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPreventKeyboardDisplayOnProgrammaticFocus(value).into()
        }
        unsafe extern "system" fn IsColorFontEnabled<Impl: IRichEditBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorFontEnabled<Impl: IRichEditBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsColorFontEnabled(value).into()
        }
        unsafe extern "system" fn Paste<Impl: IRichEditBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Paste(&*(&handler as *const <TextControlPasteEventHandler as ::windows::core::Abi>::Abi as *const <TextControlPasteEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaste<Impl: IRichEditBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePaste(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IRichEditBox2>,
            base.5,
            Header::<Impl, OFFSET>,
            SetHeader::<Impl, OFFSET>,
            HeaderTemplate::<Impl, OFFSET>,
            SetHeaderTemplate::<Impl, OFFSET>,
            PlaceholderText::<Impl, OFFSET>,
            SetPlaceholderText::<Impl, OFFSET>,
            SelectionHighlightColor::<Impl, OFFSET>,
            SetSelectionHighlightColor::<Impl, OFFSET>,
            PreventKeyboardDisplayOnProgrammaticFocus::<Impl, OFFSET>,
            SetPreventKeyboardDisplayOnProgrammaticFocus::<Impl, OFFSET>,
            IsColorFontEnabled::<Impl, OFFSET>,
            SetIsColorFontEnabled::<Impl, OFFSET>,
            Paste::<Impl, OFFSET>,
            RemovePaste::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBox3Impl: Sized {
    fn TextCompositionStarted(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionStartedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionStarted(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextCompositionChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextCompositionEnded(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionEndedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionEnded(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextReadingOrder(&self) -> ::windows::core::Result<super::TextReadingOrder>;
    fn SetTextReadingOrder(&self, value: super::TextReadingOrder) -> ::windows::core::Result<()>;
    fn DesiredCandidateWindowAlignment(&self) -> ::windows::core::Result<CandidateWindowAlignment>;
    fn SetDesiredCandidateWindowAlignment(&self, value: CandidateWindowAlignment) -> ::windows::core::Result<()>;
    fn CandidateWindowBoundsChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, CandidateWindowBoundsChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCandidateWindowBoundsChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextChanging(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxTextChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextChanging(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBox3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox3";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBox3Vtbl {
    pub const fn new<Impl: IRichEditBox3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBox3Vtbl {
        unsafe extern "system" fn TextCompositionStarted<Impl: IRichEditBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextCompositionStarted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionStartedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionStartedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionStarted<Impl: IRichEditBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionStarted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextCompositionChanged<Impl: IRichEditBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextCompositionChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionChanged<Impl: IRichEditBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextCompositionEnded<Impl: IRichEditBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextCompositionEnded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionEndedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextCompositionEndedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionEnded<Impl: IRichEditBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionEnded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextReadingOrder<Impl: IRichEditBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextReadingOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextReadingOrder<Impl: IRichEditBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextReadingOrder(value).into()
        }
        unsafe extern "system" fn DesiredCandidateWindowAlignment<Impl: IRichEditBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut CandidateWindowAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DesiredCandidateWindowAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDesiredCandidateWindowAlignment<Impl: IRichEditBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: CandidateWindowAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDesiredCandidateWindowAlignment(value).into()
        }
        unsafe extern "system" fn CandidateWindowBoundsChanged<Impl: IRichEditBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CandidateWindowBoundsChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, CandidateWindowBoundsChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, CandidateWindowBoundsChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCandidateWindowBoundsChanged<Impl: IRichEditBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveCandidateWindowBoundsChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextChanging<Impl: IRichEditBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxTextChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxTextChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextChanging<Impl: IRichEditBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveTextChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IRichEditBox3>,
            base.5,
            TextCompositionStarted::<Impl, OFFSET>,
            RemoveTextCompositionStarted::<Impl, OFFSET>,
            TextCompositionChanged::<Impl, OFFSET>,
            RemoveTextCompositionChanged::<Impl, OFFSET>,
            TextCompositionEnded::<Impl, OFFSET>,
            RemoveTextCompositionEnded::<Impl, OFFSET>,
            TextReadingOrder::<Impl, OFFSET>,
            SetTextReadingOrder::<Impl, OFFSET>,
            DesiredCandidateWindowAlignment::<Impl, OFFSET>,
            SetDesiredCandidateWindowAlignment::<Impl, OFFSET>,
            CandidateWindowBoundsChanged::<Impl, OFFSET>,
            RemoveCandidateWindowBoundsChanged::<Impl, OFFSET>,
            TextChanging::<Impl, OFFSET>,
            RemoveTextChanging::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBox4Impl: Sized {
    fn GetLinguisticAlternativesAsync(&self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::Foundation::Collections::IVectorView<::windows::core::HSTRING>>>;
    fn ClipboardCopyFormat(&self) -> ::windows::core::Result<RichEditClipboardFormat>;
    fn SetClipboardCopyFormat(&self, value: RichEditClipboardFormat) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBox4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox4";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBox4Vtbl {
    pub const fn new<Impl: IRichEditBox4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBox4Vtbl {
        unsafe extern "system" fn GetLinguisticAlternativesAsync<Impl: IRichEditBox4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLinguisticAlternativesAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClipboardCopyFormat<Impl: IRichEditBox4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut RichEditClipboardFormat) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ClipboardCopyFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClipboardCopyFormat<Impl: IRichEditBox4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: RichEditClipboardFormat) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetClipboardCopyFormat(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichEditBox4>, base.5, GetLinguisticAlternativesAsync::<Impl, OFFSET>, ClipboardCopyFormat::<Impl, OFFSET>, SetClipboardCopyFormat::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBox5Impl: Sized {
    fn SelectionHighlightColorWhenNotFocused(&self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColorWhenNotFocused(&self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn MaxLength(&self) -> ::windows::core::Result<i32>;
    fn SetMaxLength(&self, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBox5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox5";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBox5Vtbl {
    pub const fn new<Impl: IRichEditBox5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBox5Vtbl {
        unsafe extern "system" fn SelectionHighlightColorWhenNotFocused<Impl: IRichEditBox5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorWhenNotFocused() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColorWhenNotFocused<Impl: IRichEditBox5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColorWhenNotFocused(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxLength<Impl: IRichEditBox5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLength<Impl: IRichEditBox5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxLength(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichEditBox5>, base.5, SelectionHighlightColorWhenNotFocused::<Impl, OFFSET>, SetSelectionHighlightColorWhenNotFocused::<Impl, OFFSET>, MaxLength::<Impl, OFFSET>, SetMaxLength::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBox6Impl: Sized {
    fn HorizontalTextAlignment(&self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetHorizontalTextAlignment(&self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn CharacterCasing(&self) -> ::windows::core::Result<CharacterCasing>;
    fn SetCharacterCasing(&self, value: CharacterCasing) -> ::windows::core::Result<()>;
    fn DisabledFormattingAccelerators(&self) -> ::windows::core::Result<DisabledFormattingAccelerators>;
    fn SetDisabledFormattingAccelerators(&self, value: DisabledFormattingAccelerators) -> ::windows::core::Result<()>;
    fn CopyingToClipboard(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCopyingToClipboardEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCopyingToClipboard(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn CuttingToClipboard(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCuttingToClipboardEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCuttingToClipboard(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBox6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox6";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBox6Vtbl {
    pub const fn new<Impl: IRichEditBox6Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBox6Vtbl {
        unsafe extern "system" fn HorizontalTextAlignment<Impl: IRichEditBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalTextAlignment<Impl: IRichEditBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalTextAlignment(value).into()
        }
        unsafe extern "system" fn CharacterCasing<Impl: IRichEditBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut CharacterCasing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CharacterCasing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterCasing<Impl: IRichEditBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: CharacterCasing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCharacterCasing(value).into()
        }
        unsafe extern "system" fn DisabledFormattingAccelerators<Impl: IRichEditBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut DisabledFormattingAccelerators) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisabledFormattingAccelerators() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisabledFormattingAccelerators<Impl: IRichEditBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: DisabledFormattingAccelerators) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDisabledFormattingAccelerators(value).into()
        }
        unsafe extern "system" fn CopyingToClipboard<Impl: IRichEditBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CopyingToClipboard(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCopyingToClipboardEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCopyingToClipboardEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCopyingToClipboard<Impl: IRichEditBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveCopyingToClipboard(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CuttingToClipboard<Impl: IRichEditBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CuttingToClipboard(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCuttingToClipboardEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, TextControlCuttingToClipboardEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCuttingToClipboard<Impl: IRichEditBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveCuttingToClipboard(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IRichEditBox6>,
            base.5,
            HorizontalTextAlignment::<Impl, OFFSET>,
            SetHorizontalTextAlignment::<Impl, OFFSET>,
            CharacterCasing::<Impl, OFFSET>,
            SetCharacterCasing::<Impl, OFFSET>,
            DisabledFormattingAccelerators::<Impl, OFFSET>,
            SetDisabledFormattingAccelerators::<Impl, OFFSET>,
            CopyingToClipboard::<Impl, OFFSET>,
            RemoveCopyingToClipboard::<Impl, OFFSET>,
            CuttingToClipboard::<Impl, OFFSET>,
            RemoveCuttingToClipboard::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBox7Impl: Sized {
    fn ContentLinkForegroundColor(&self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetContentLinkForegroundColor(&self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn ContentLinkBackgroundColor(&self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetContentLinkBackgroundColor(&self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn ContentLinkProviders(&self) -> ::windows::core::Result<super::Documents::ContentLinkProviderCollection>;
    fn SetContentLinkProviders(&self, value: &::core::option::Option<super::Documents::ContentLinkProviderCollection>) -> ::windows::core::Result<()>;
    fn HandwritingView(&self) -> ::windows::core::Result<HandwritingView>;
    fn SetHandwritingView(&self, value: &::core::option::Option<HandwritingView>) -> ::windows::core::Result<()>;
    fn IsHandwritingViewEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsHandwritingViewEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn ContentLinkChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, ContentLinkChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContentLinkChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContentLinkInvoked(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, super::Documents::ContentLinkInvokedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContentLinkInvoked(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBox7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox7";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBox7Vtbl {
    pub const fn new<Impl: IRichEditBox7Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBox7Vtbl {
        unsafe extern "system" fn ContentLinkForegroundColor<Impl: IRichEditBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentLinkForegroundColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentLinkForegroundColor<Impl: IRichEditBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContentLinkForegroundColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentLinkBackgroundColor<Impl: IRichEditBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentLinkBackgroundColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentLinkBackgroundColor<Impl: IRichEditBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContentLinkBackgroundColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentLinkProviders<Impl: IRichEditBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentLinkProviders() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentLinkProviders<Impl: IRichEditBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContentLinkProviders(&*(&value as *const <super::Documents::ContentLinkProviderCollection as ::windows::core::Abi>::Abi as *const <super::Documents::ContentLinkProviderCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HandwritingView<Impl: IRichEditBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HandwritingView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandwritingView<Impl: IRichEditBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHandwritingView(&*(&value as *const <HandwritingView as ::windows::core::Abi>::Abi as *const <HandwritingView as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsHandwritingViewEnabled<Impl: IRichEditBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsHandwritingViewEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHandwritingViewEnabled<Impl: IRichEditBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsHandwritingViewEnabled(value).into()
        }
        unsafe extern "system" fn ContentLinkChanged<Impl: IRichEditBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentLinkChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, ContentLinkChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, ContentLinkChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContentLinkChanged<Impl: IRichEditBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveContentLinkChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentLinkInvoked<Impl: IRichEditBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentLinkInvoked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, super::Documents::ContentLinkInvokedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, super::Documents::ContentLinkInvokedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContentLinkInvoked<Impl: IRichEditBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveContentLinkInvoked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IRichEditBox7>,
            base.5,
            ContentLinkForegroundColor::<Impl, OFFSET>,
            SetContentLinkForegroundColor::<Impl, OFFSET>,
            ContentLinkBackgroundColor::<Impl, OFFSET>,
            SetContentLinkBackgroundColor::<Impl, OFFSET>,
            ContentLinkProviders::<Impl, OFFSET>,
            SetContentLinkProviders::<Impl, OFFSET>,
            HandwritingView::<Impl, OFFSET>,
            SetHandwritingView::<Impl, OFFSET>,
            IsHandwritingViewEnabled::<Impl, OFFSET>,
            SetIsHandwritingViewEnabled::<Impl, OFFSET>,
            ContentLinkChanged::<Impl, OFFSET>,
            RemoveContentLinkChanged::<Impl, OFFSET>,
            ContentLinkInvoked::<Impl, OFFSET>,
            RemoveContentLinkInvoked::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBox8Impl: Sized {
    fn TextDocument(&self) -> ::windows::core::Result<super::super::Text::RichEditTextDocument>;
    fn SelectionFlyout(&self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetSelectionFlyout(&self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn ProofingMenuFlyout(&self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn Description(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectionChanging(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxSelectionChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanging(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBox8 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBox8";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBox8Vtbl {
    pub const fn new<Impl: IRichEditBox8Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBox8Vtbl {
        unsafe extern "system" fn TextDocument<Impl: IRichEditBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextDocument() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFlyout<Impl: IRichEditBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFlyout<Impl: IRichEditBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ProofingMenuFlyout<Impl: IRichEditBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProofingMenuFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Description<Impl: IRichEditBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: IRichEditBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionChanging<Impl: IRichEditBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxSelectionChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichEditBox, RichEditBoxSelectionChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanging<Impl: IRichEditBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichEditBox8>, base.5, TextDocument::<Impl, OFFSET>, SelectionFlyout::<Impl, OFFSET>, SetSelectionFlyout::<Impl, OFFSET>, ProofingMenuFlyout::<Impl, OFFSET>, Description::<Impl, OFFSET>, SetDescription::<Impl, OFFSET>, SelectionChanging::<Impl, OFFSET>, RemoveSelectionChanging::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<RichEditBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxFactoryVtbl {
    pub const fn new<Impl: IRichEditBoxFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBoxFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IRichEditBoxFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichEditBoxFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxSelectionChangingEventArgsImpl: Sized {
    fn SelectionStart(&self) -> ::windows::core::Result<i32>;
    fn SelectionLength(&self) -> ::windows::core::Result<i32>;
    fn Cancel(&self) -> ::windows::core::Result<bool>;
    fn SetCancel(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxSelectionChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxSelectionChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxSelectionChangingEventArgsVtbl {
    pub const fn new<Impl: IRichEditBoxSelectionChangingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBoxSelectionChangingEventArgsVtbl {
        unsafe extern "system" fn SelectionStart<Impl: IRichEditBoxSelectionChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionLength<Impl: IRichEditBoxSelectionChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: IRichEditBoxSelectionChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: IRichEditBoxSelectionChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichEditBoxSelectionChangingEventArgs>, base.5, SelectionStart::<Impl, OFFSET>, SelectionLength::<Impl, OFFSET>, Cancel::<Impl, OFFSET>, SetCancel::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStaticsImpl: Sized {
    fn IsReadOnlyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AcceptsReturnProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextWrappingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSpellCheckEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextPredictionEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InputScopeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStaticsVtbl {
    pub const fn new<Impl: IRichEditBoxStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBoxStaticsVtbl {
        unsafe extern "system" fn IsReadOnlyProperty<Impl: IRichEditBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsReadOnlyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AcceptsReturnProperty<Impl: IRichEditBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AcceptsReturnProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextAlignmentProperty<Impl: IRichEditBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextWrappingProperty<Impl: IRichEditBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextWrappingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSpellCheckEnabledProperty<Impl: IRichEditBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSpellCheckEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextPredictionEnabledProperty<Impl: IRichEditBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextPredictionEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputScopeProperty<Impl: IRichEditBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InputScopeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichEditBoxStatics>, base.5, IsReadOnlyProperty::<Impl, OFFSET>, AcceptsReturnProperty::<Impl, OFFSET>, TextAlignmentProperty::<Impl, OFFSET>, TextWrappingProperty::<Impl, OFFSET>, IsSpellCheckEnabledProperty::<Impl, OFFSET>, IsTextPredictionEnabledProperty::<Impl, OFFSET>, InputScopeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics2Impl: Sized {
    fn HeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionHighlightColorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PreventKeyboardDisplayOnProgrammaticFocusProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorFontEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics2Vtbl {
    pub const fn new<Impl: IRichEditBoxStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBoxStatics2Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: IRichEditBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IRichEditBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: IRichEditBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionHighlightColorProperty<Impl: IRichEditBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocusProperty<Impl: IRichEditBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorFontEnabledProperty<Impl: IRichEditBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichEditBoxStatics2>, base.5, HeaderProperty::<Impl, OFFSET>, HeaderTemplateProperty::<Impl, OFFSET>, PlaceholderTextProperty::<Impl, OFFSET>, SelectionHighlightColorProperty::<Impl, OFFSET>, PreventKeyboardDisplayOnProgrammaticFocusProperty::<Impl, OFFSET>, IsColorFontEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics3Impl: Sized {
    fn DesiredCandidateWindowAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextReadingOrderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics3Vtbl {
    pub const fn new<Impl: IRichEditBoxStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBoxStatics3Vtbl {
        unsafe extern "system" fn DesiredCandidateWindowAlignmentProperty<Impl: IRichEditBoxStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DesiredCandidateWindowAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextReadingOrderProperty<Impl: IRichEditBoxStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextReadingOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichEditBoxStatics3>, base.5, DesiredCandidateWindowAlignmentProperty::<Impl, OFFSET>, TextReadingOrderProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics4Impl: Sized {
    fn ClipboardCopyFormatProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics4Vtbl {
    pub const fn new<Impl: IRichEditBoxStatics4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBoxStatics4Vtbl {
        unsafe extern "system" fn ClipboardCopyFormatProperty<Impl: IRichEditBoxStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ClipboardCopyFormatProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichEditBoxStatics4>, base.5, ClipboardCopyFormatProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics5Impl: Sized {
    fn SelectionHighlightColorWhenNotFocusedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxLengthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics5Vtbl {
    pub const fn new<Impl: IRichEditBoxStatics5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBoxStatics5Vtbl {
        unsafe extern "system" fn SelectionHighlightColorWhenNotFocusedProperty<Impl: IRichEditBoxStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorWhenNotFocusedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxLengthProperty<Impl: IRichEditBoxStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichEditBoxStatics5>, base.5, SelectionHighlightColorWhenNotFocusedProperty::<Impl, OFFSET>, MaxLengthProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics6Impl: Sized {
    fn HorizontalTextAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterCasingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisabledFormattingAcceleratorsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics6";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics6Vtbl {
    pub const fn new<Impl: IRichEditBoxStatics6Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBoxStatics6Vtbl {
        unsafe extern "system" fn HorizontalTextAlignmentProperty<Impl: IRichEditBoxStatics6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterCasingProperty<Impl: IRichEditBoxStatics6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CharacterCasingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisabledFormattingAcceleratorsProperty<Impl: IRichEditBoxStatics6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisabledFormattingAcceleratorsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichEditBoxStatics6>, base.5, HorizontalTextAlignmentProperty::<Impl, OFFSET>, CharacterCasingProperty::<Impl, OFFSET>, DisabledFormattingAcceleratorsProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics7Impl: Sized {
    fn ContentLinkForegroundColorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentLinkBackgroundColorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ContentLinkProvidersProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HandwritingViewProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHandwritingViewEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics7";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics7Vtbl {
    pub const fn new<Impl: IRichEditBoxStatics7Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBoxStatics7Vtbl {
        unsafe extern "system" fn ContentLinkForegroundColorProperty<Impl: IRichEditBoxStatics7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentLinkForegroundColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentLinkBackgroundColorProperty<Impl: IRichEditBoxStatics7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentLinkBackgroundColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentLinkProvidersProperty<Impl: IRichEditBoxStatics7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentLinkProvidersProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HandwritingViewProperty<Impl: IRichEditBoxStatics7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HandwritingViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHandwritingViewEnabledProperty<Impl: IRichEditBoxStatics7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsHandwritingViewEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichEditBoxStatics7>, base.5, ContentLinkForegroundColorProperty::<Impl, OFFSET>, ContentLinkBackgroundColorProperty::<Impl, OFFSET>, ContentLinkProvidersProperty::<Impl, OFFSET>, HandwritingViewProperty::<Impl, OFFSET>, IsHandwritingViewEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxStatics8Impl: Sized {
    fn SelectionFlyoutProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ProofingMenuFlyoutProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DescriptionProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxStatics8 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxStatics8";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxStatics8Vtbl {
    pub const fn new<Impl: IRichEditBoxStatics8Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBoxStatics8Vtbl {
        unsafe extern "system" fn SelectionFlyoutProperty<Impl: IRichEditBoxStatics8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProofingMenuFlyoutProperty<Impl: IRichEditBoxStatics8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProofingMenuFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DescriptionProperty<Impl: IRichEditBoxStatics8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichEditBoxStatics8>, base.5, SelectionFlyoutProperty::<Impl, OFFSET>, ProofingMenuFlyoutProperty::<Impl, OFFSET>, DescriptionProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxTextChangingEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxTextChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxTextChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxTextChangingEventArgsVtbl {
    pub const fn new<Impl: IRichEditBoxTextChangingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBoxTextChangingEventArgsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichEditBoxTextChangingEventArgs>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichEditBoxTextChangingEventArgs2Impl: Sized {
    fn IsContentChanging(&self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichEditBoxTextChangingEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichEditBoxTextChangingEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl IRichEditBoxTextChangingEventArgs2Vtbl {
    pub const fn new<Impl: IRichEditBoxTextChangingEventArgs2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichEditBoxTextChangingEventArgs2Vtbl {
        unsafe extern "system" fn IsContentChanging<Impl: IRichEditBoxTextChangingEventArgs2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsContentChanging() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichEditBoxTextChangingEventArgs2>, base.5, IsContentChanging::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockImpl: Sized {
    fn FontSize(&self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FontStretch(&self) -> ::windows::core::Result<super::super::Text::FontStretch>;
    fn SetFontStretch(&self, value: super::super::Text::FontStretch) -> ::windows::core::Result<()>;
    fn Foreground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TextWrapping(&self) -> ::windows::core::Result<super::TextWrapping>;
    fn SetTextWrapping(&self, value: super::TextWrapping) -> ::windows::core::Result<()>;
    fn TextTrimming(&self) -> ::windows::core::Result<super::TextTrimming>;
    fn SetTextTrimming(&self, value: super::TextTrimming) -> ::windows::core::Result<()>;
    fn TextAlignment(&self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetTextAlignment(&self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn Blocks(&self) -> ::windows::core::Result<super::Documents::BlockCollection>;
    fn Padding(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn LineHeight(&self) -> ::windows::core::Result<f64>;
    fn SetLineHeight(&self, value: f64) -> ::windows::core::Result<()>;
    fn LineStackingStrategy(&self) -> ::windows::core::Result<super::LineStackingStrategy>;
    fn SetLineStackingStrategy(&self, value: super::LineStackingStrategy) -> ::windows::core::Result<()>;
    fn CharacterSpacing(&self) -> ::windows::core::Result<i32>;
    fn SetCharacterSpacing(&self, value: i32) -> ::windows::core::Result<()>;
    fn OverflowContentTarget(&self) -> ::windows::core::Result<RichTextBlockOverflow>;
    fn SetOverflowContentTarget(&self, value: &::core::option::Option<RichTextBlockOverflow>) -> ::windows::core::Result<()>;
    fn IsTextSelectionEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsTextSelectionEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn HasOverflowContent(&self) -> ::windows::core::Result<bool>;
    fn SelectedText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn ContentStart(&self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn ContentEnd(&self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn SelectionStart(&self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn SelectionEnd(&self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn BaselineOffset(&self) -> ::windows::core::Result<f64>;
    fn SelectionChanged(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContextMenuOpening(&self, handler: &::core::option::Option<ContextMenuOpeningEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContextMenuOpening(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectAll(&self) -> ::windows::core::Result<()>;
    fn Select(&self, start: &::core::option::Option<super::Documents::TextPointer>, end: &::core::option::Option<super::Documents::TextPointer>) -> ::windows::core::Result<()>;
    fn GetPositionFromPoint(&self, point: &super::super::super::Foundation::Point) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn Focus(&self, value: super::FocusState) -> ::windows::core::Result<bool>;
    fn TextIndent(&self) -> ::windows::core::Result<f64>;
    fn SetTextIndent(&self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlock {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockVtbl {
    pub const fn new<Impl: IRichTextBlockImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlockVtbl {
        unsafe extern "system" fn FontSize<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        unsafe extern "system" fn FontStretch<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStretch<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontStretch(value).into()
        }
        unsafe extern "system" fn Foreground<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextWrapping<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextWrapping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextWrapping<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextWrapping(value).into()
        }
        unsafe extern "system" fn TextTrimming<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextTrimming) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextTrimming() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextTrimming<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextTrimming) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextTrimming(value).into()
        }
        unsafe extern "system" fn TextAlignment<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextAlignment<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextAlignment(value).into()
        }
        unsafe extern "system" fn Blocks<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Blocks() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Padding<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LineHeight<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LineHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineHeight<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLineHeight(value).into()
        }
        unsafe extern "system" fn LineStackingStrategy<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategy() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineStackingStrategy<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLineStackingStrategy(value).into()
        }
        unsafe extern "system" fn CharacterSpacing<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CharacterSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterSpacing<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCharacterSpacing(value).into()
        }
        unsafe extern "system" fn OverflowContentTarget<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OverflowContentTarget() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOverflowContentTarget<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOverflowContentTarget(&*(&value as *const <RichTextBlockOverflow as ::windows::core::Abi>::Abi as *const <RichTextBlockOverflow as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsTextSelectionEnabled<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextSelectionEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextSelectionEnabled<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsTextSelectionEnabled(value).into()
        }
        unsafe extern "system" fn HasOverflowContent<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HasOverflowContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedText<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentStart<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentEnd<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionStart<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionEnd<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BaselineOffset<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BaselineOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionChanged<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContextMenuOpening<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContextMenuOpening(&*(&handler as *const <ContextMenuOpeningEventHandler as ::windows::core::Abi>::Abi as *const <ContextMenuOpeningEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContextMenuOpening<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveContextMenuOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        unsafe extern "system" fn Select<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, start: ::windows::core::RawPtr, end: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Select(&*(&start as *const <super::Documents::TextPointer as ::windows::core::Abi>::Abi as *const <super::Documents::TextPointer as ::windows::core::DefaultType>::DefaultType), &*(&end as *const <super::Documents::TextPointer as ::windows::core::Abi>::Abi as *const <super::Documents::TextPointer as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetPositionFromPoint<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, point: super::super::super::Foundation::Point, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPositionFromPoint(&*(&point as *const <super::super::super::Foundation::Point as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Point as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Focus<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::FocusState, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Focus(value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextIndent<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextIndent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextIndent<Impl: IRichTextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextIndent(value).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IRichTextBlock>,
            base.5,
            FontSize::<Impl, OFFSET>,
            SetFontSize::<Impl, OFFSET>,
            FontFamily::<Impl, OFFSET>,
            SetFontFamily::<Impl, OFFSET>,
            FontWeight::<Impl, OFFSET>,
            SetFontWeight::<Impl, OFFSET>,
            FontStyle::<Impl, OFFSET>,
            SetFontStyle::<Impl, OFFSET>,
            FontStretch::<Impl, OFFSET>,
            SetFontStretch::<Impl, OFFSET>,
            Foreground::<Impl, OFFSET>,
            SetForeground::<Impl, OFFSET>,
            TextWrapping::<Impl, OFFSET>,
            SetTextWrapping::<Impl, OFFSET>,
            TextTrimming::<Impl, OFFSET>,
            SetTextTrimming::<Impl, OFFSET>,
            TextAlignment::<Impl, OFFSET>,
            SetTextAlignment::<Impl, OFFSET>,
            Blocks::<Impl, OFFSET>,
            Padding::<Impl, OFFSET>,
            SetPadding::<Impl, OFFSET>,
            LineHeight::<Impl, OFFSET>,
            SetLineHeight::<Impl, OFFSET>,
            LineStackingStrategy::<Impl, OFFSET>,
            SetLineStackingStrategy::<Impl, OFFSET>,
            CharacterSpacing::<Impl, OFFSET>,
            SetCharacterSpacing::<Impl, OFFSET>,
            OverflowContentTarget::<Impl, OFFSET>,
            SetOverflowContentTarget::<Impl, OFFSET>,
            IsTextSelectionEnabled::<Impl, OFFSET>,
            SetIsTextSelectionEnabled::<Impl, OFFSET>,
            HasOverflowContent::<Impl, OFFSET>,
            SelectedText::<Impl, OFFSET>,
            ContentStart::<Impl, OFFSET>,
            ContentEnd::<Impl, OFFSET>,
            SelectionStart::<Impl, OFFSET>,
            SelectionEnd::<Impl, OFFSET>,
            BaselineOffset::<Impl, OFFSET>,
            SelectionChanged::<Impl, OFFSET>,
            RemoveSelectionChanged::<Impl, OFFSET>,
            ContextMenuOpening::<Impl, OFFSET>,
            RemoveContextMenuOpening::<Impl, OFFSET>,
            SelectAll::<Impl, OFFSET>,
            Select::<Impl, OFFSET>,
            GetPositionFromPoint::<Impl, OFFSET>,
            Focus::<Impl, OFFSET>,
            TextIndent::<Impl, OFFSET>,
            SetTextIndent::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlock2Impl: Sized {
    fn MaxLines(&self) -> ::windows::core::Result<i32>;
    fn SetMaxLines(&self, value: i32) -> ::windows::core::Result<()>;
    fn TextLineBounds(&self) -> ::windows::core::Result<super::TextLineBounds>;
    fn SetTextLineBounds(&self, value: super::TextLineBounds) -> ::windows::core::Result<()>;
    fn SelectionHighlightColor(&self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColor(&self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn OpticalMarginAlignment(&self) -> ::windows::core::Result<super::OpticalMarginAlignment>;
    fn SetOpticalMarginAlignment(&self, value: super::OpticalMarginAlignment) -> ::windows::core::Result<()>;
    fn IsColorFontEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsColorFontEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn TextReadingOrder(&self) -> ::windows::core::Result<super::TextReadingOrder>;
    fn SetTextReadingOrder(&self, value: super::TextReadingOrder) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlock2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock2";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlock2Vtbl {
    pub const fn new<Impl: IRichTextBlock2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlock2Vtbl {
        unsafe extern "system" fn MaxLines<Impl: IRichTextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxLines() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLines<Impl: IRichTextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxLines(value).into()
        }
        unsafe extern "system" fn TextLineBounds<Impl: IRichTextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextLineBounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextLineBounds<Impl: IRichTextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextLineBounds(value).into()
        }
        unsafe extern "system" fn SelectionHighlightColor<Impl: IRichTextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColor<Impl: IRichTextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OpticalMarginAlignment<Impl: IRichTextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOpticalMarginAlignment<Impl: IRichTextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOpticalMarginAlignment(value).into()
        }
        unsafe extern "system" fn IsColorFontEnabled<Impl: IRichTextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorFontEnabled<Impl: IRichTextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsColorFontEnabled(value).into()
        }
        unsafe extern "system" fn TextReadingOrder<Impl: IRichTextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextReadingOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextReadingOrder<Impl: IRichTextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextReadingOrder(value).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IRichTextBlock2>,
            base.5,
            MaxLines::<Impl, OFFSET>,
            SetMaxLines::<Impl, OFFSET>,
            TextLineBounds::<Impl, OFFSET>,
            SetTextLineBounds::<Impl, OFFSET>,
            SelectionHighlightColor::<Impl, OFFSET>,
            SetSelectionHighlightColor::<Impl, OFFSET>,
            OpticalMarginAlignment::<Impl, OFFSET>,
            SetOpticalMarginAlignment::<Impl, OFFSET>,
            IsColorFontEnabled::<Impl, OFFSET>,
            SetIsColorFontEnabled::<Impl, OFFSET>,
            TextReadingOrder::<Impl, OFFSET>,
            SetTextReadingOrder::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlock3Impl: Sized {
    fn IsTextScaleFactorEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlock3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock3";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlock3Vtbl {
    pub const fn new<Impl: IRichTextBlock3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlock3Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: IRichTextBlock3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: IRichTextBlock3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichTextBlock3>, base.5, IsTextScaleFactorEnabled::<Impl, OFFSET>, SetIsTextScaleFactorEnabled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlock4Impl: Sized {
    fn TextDecorations(&self) -> ::windows::core::Result<super::super::Text::TextDecorations>;
    fn SetTextDecorations(&self, value: super::super::Text::TextDecorations) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlock4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock4";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlock4Vtbl {
    pub const fn new<Impl: IRichTextBlock4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlock4Vtbl {
        unsafe extern "system" fn TextDecorations<Impl: IRichTextBlock4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::TextDecorations) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextDecorations() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextDecorations<Impl: IRichTextBlock4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::TextDecorations) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextDecorations(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichTextBlock4>, base.5, TextDecorations::<Impl, OFFSET>, SetTextDecorations::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlock5Impl: Sized {
    fn IsTextTrimmed(&self) -> ::windows::core::Result<bool>;
    fn HorizontalTextAlignment(&self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetHorizontalTextAlignment(&self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn TextHighlighters(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::Documents::TextHighlighter>>;
    fn IsTextTrimmedChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichTextBlock, IsTextTrimmedChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsTextTrimmedChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlock5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock5";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlock5Vtbl {
    pub const fn new<Impl: IRichTextBlock5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlock5Vtbl {
        unsafe extern "system" fn IsTextTrimmed<Impl: IRichTextBlock5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmed() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalTextAlignment<Impl: IRichTextBlock5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalTextAlignment<Impl: IRichTextBlock5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalTextAlignment(value).into()
        }
        unsafe extern "system" fn TextHighlighters<Impl: IRichTextBlock5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextHighlighters() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextTrimmedChanged<Impl: IRichTextBlock5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichTextBlock, IsTextTrimmedChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichTextBlock, IsTextTrimmedChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsTextTrimmedChanged<Impl: IRichTextBlock5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveIsTextTrimmedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichTextBlock5>, base.5, IsTextTrimmed::<Impl, OFFSET>, HorizontalTextAlignment::<Impl, OFFSET>, SetHorizontalTextAlignment::<Impl, OFFSET>, TextHighlighters::<Impl, OFFSET>, IsTextTrimmedChanged::<Impl, OFFSET>, RemoveIsTextTrimmedChanged::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlock6Impl: Sized {
    fn SelectionFlyout(&self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetSelectionFlyout(&self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn CopySelectionToClipboard(&self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlock6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlock6";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlock6Vtbl {
    pub const fn new<Impl: IRichTextBlock6Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlock6Vtbl {
        unsafe extern "system" fn SelectionFlyout<Impl: IRichTextBlock6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFlyout<Impl: IRichTextBlock6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CopySelectionToClipboard<Impl: IRichTextBlock6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).CopySelectionToClipboard().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichTextBlock6>, base.5, SelectionFlyout::<Impl, OFFSET>, SetSelectionFlyout::<Impl, OFFSET>, CopySelectionToClipboard::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockOverflowImpl: Sized {
    fn OverflowContentTarget(&self) -> ::windows::core::Result<RichTextBlockOverflow>;
    fn SetOverflowContentTarget(&self, value: &::core::option::Option<RichTextBlockOverflow>) -> ::windows::core::Result<()>;
    fn Padding(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn ContentSource(&self) -> ::windows::core::Result<RichTextBlock>;
    fn HasOverflowContent(&self) -> ::windows::core::Result<bool>;
    fn ContentStart(&self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn ContentEnd(&self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn BaselineOffset(&self) -> ::windows::core::Result<f64>;
    fn GetPositionFromPoint(&self, point: &super::super::super::Foundation::Point) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn Focus(&self, value: super::FocusState) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockOverflow {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflow";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockOverflowVtbl {
    pub const fn new<Impl: IRichTextBlockOverflowImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlockOverflowVtbl {
        unsafe extern "system" fn OverflowContentTarget<Impl: IRichTextBlockOverflowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OverflowContentTarget() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOverflowContentTarget<Impl: IRichTextBlockOverflowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOverflowContentTarget(&*(&value as *const <RichTextBlockOverflow as ::windows::core::Abi>::Abi as *const <RichTextBlockOverflow as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IRichTextBlockOverflowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IRichTextBlockOverflowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentSource<Impl: IRichTextBlockOverflowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasOverflowContent<Impl: IRichTextBlockOverflowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HasOverflowContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentStart<Impl: IRichTextBlockOverflowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentEnd<Impl: IRichTextBlockOverflowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BaselineOffset<Impl: IRichTextBlockOverflowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BaselineOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPositionFromPoint<Impl: IRichTextBlockOverflowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, point: super::super::super::Foundation::Point, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPositionFromPoint(&*(&point as *const <super::super::super::Foundation::Point as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Point as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Focus<Impl: IRichTextBlockOverflowImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::FocusState, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Focus(value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichTextBlockOverflow>, base.5, OverflowContentTarget::<Impl, OFFSET>, SetOverflowContentTarget::<Impl, OFFSET>, Padding::<Impl, OFFSET>, SetPadding::<Impl, OFFSET>, ContentSource::<Impl, OFFSET>, HasOverflowContent::<Impl, OFFSET>, ContentStart::<Impl, OFFSET>, ContentEnd::<Impl, OFFSET>, BaselineOffset::<Impl, OFFSET>, GetPositionFromPoint::<Impl, OFFSET>, Focus::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockOverflow2Impl: Sized {
    fn MaxLines(&self) -> ::windows::core::Result<i32>;
    fn SetMaxLines(&self, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockOverflow2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflow2";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockOverflow2Vtbl {
    pub const fn new<Impl: IRichTextBlockOverflow2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlockOverflow2Vtbl {
        unsafe extern "system" fn MaxLines<Impl: IRichTextBlockOverflow2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxLines() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLines<Impl: IRichTextBlockOverflow2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxLines(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichTextBlockOverflow2>, base.5, MaxLines::<Impl, OFFSET>, SetMaxLines::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockOverflow3Impl: Sized {
    fn IsTextTrimmed(&self) -> ::windows::core::Result<bool>;
    fn IsTextTrimmedChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<RichTextBlockOverflow, IsTextTrimmedChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsTextTrimmedChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockOverflow3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflow3";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockOverflow3Vtbl {
    pub const fn new<Impl: IRichTextBlockOverflow3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlockOverflow3Vtbl {
        unsafe extern "system" fn IsTextTrimmed<Impl: IRichTextBlockOverflow3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmed() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextTrimmedChanged<Impl: IRichTextBlockOverflow3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<RichTextBlockOverflow, IsTextTrimmedChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<RichTextBlockOverflow, IsTextTrimmedChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsTextTrimmedChanged<Impl: IRichTextBlockOverflow3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveIsTextTrimmedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichTextBlockOverflow3>, base.5, IsTextTrimmed::<Impl, OFFSET>, IsTextTrimmedChanged::<Impl, OFFSET>, RemoveIsTextTrimmedChanged::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockOverflowStaticsImpl: Sized {
    fn OverflowContentTargetProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HasOverflowContentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockOverflowStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflowStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockOverflowStaticsVtbl {
    pub const fn new<Impl: IRichTextBlockOverflowStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlockOverflowStaticsVtbl {
        unsafe extern "system" fn OverflowContentTargetProperty<Impl: IRichTextBlockOverflowStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OverflowContentTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IRichTextBlockOverflowStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasOverflowContentProperty<Impl: IRichTextBlockOverflowStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HasOverflowContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichTextBlockOverflowStatics>, base.5, OverflowContentTargetProperty::<Impl, OFFSET>, PaddingProperty::<Impl, OFFSET>, HasOverflowContentProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockOverflowStatics2Impl: Sized {
    fn MaxLinesProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockOverflowStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflowStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockOverflowStatics2Vtbl {
    pub const fn new<Impl: IRichTextBlockOverflowStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlockOverflowStatics2Vtbl {
        unsafe extern "system" fn MaxLinesProperty<Impl: IRichTextBlockOverflowStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxLinesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichTextBlockOverflowStatics2>, base.5, MaxLinesProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockOverflowStatics3Impl: Sized {
    fn IsTextTrimmedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockOverflowStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockOverflowStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockOverflowStatics3Vtbl {
    pub const fn new<Impl: IRichTextBlockOverflowStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlockOverflowStatics3Vtbl {
        unsafe extern "system" fn IsTextTrimmedProperty<Impl: IRichTextBlockOverflowStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichTextBlockOverflowStatics3>, base.5, IsTextTrimmedProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStaticsImpl: Sized {
    fn FontSizeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStretchProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextWrappingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextTrimmingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineHeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineStackingStrategyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterSpacingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OverflowContentTargetProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextSelectionEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HasOverflowContentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedTextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextIndentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStaticsVtbl {
    pub const fn new<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlockStaticsVtbl {
        unsafe extern "system" fn FontSizeProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStretchProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForegroundProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextWrappingProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextWrappingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextTrimmingProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextTrimmingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextAlignmentProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineHeightProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LineHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineStackingStrategyProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterSpacingProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CharacterSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OverflowContentTargetProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OverflowContentTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextSelectionEnabledProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextSelectionEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasOverflowContentProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HasOverflowContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedTextProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextIndentProperty<Impl: IRichTextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextIndentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IRichTextBlockStatics>,
            base.5,
            FontSizeProperty::<Impl, OFFSET>,
            FontFamilyProperty::<Impl, OFFSET>,
            FontWeightProperty::<Impl, OFFSET>,
            FontStyleProperty::<Impl, OFFSET>,
            FontStretchProperty::<Impl, OFFSET>,
            ForegroundProperty::<Impl, OFFSET>,
            TextWrappingProperty::<Impl, OFFSET>,
            TextTrimmingProperty::<Impl, OFFSET>,
            TextAlignmentProperty::<Impl, OFFSET>,
            PaddingProperty::<Impl, OFFSET>,
            LineHeightProperty::<Impl, OFFSET>,
            LineStackingStrategyProperty::<Impl, OFFSET>,
            CharacterSpacingProperty::<Impl, OFFSET>,
            OverflowContentTargetProperty::<Impl, OFFSET>,
            IsTextSelectionEnabledProperty::<Impl, OFFSET>,
            HasOverflowContentProperty::<Impl, OFFSET>,
            SelectedTextProperty::<Impl, OFFSET>,
            TextIndentProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStatics2Impl: Sized {
    fn MaxLinesProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextLineBoundsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionHighlightColorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OpticalMarginAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorFontEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextReadingOrderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStatics2Vtbl {
    pub const fn new<Impl: IRichTextBlockStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlockStatics2Vtbl {
        unsafe extern "system" fn MaxLinesProperty<Impl: IRichTextBlockStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxLinesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextLineBoundsProperty<Impl: IRichTextBlockStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextLineBoundsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionHighlightColorProperty<Impl: IRichTextBlockStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpticalMarginAlignmentProperty<Impl: IRichTextBlockStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorFontEnabledProperty<Impl: IRichTextBlockStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextReadingOrderProperty<Impl: IRichTextBlockStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextReadingOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichTextBlockStatics2>, base.5, MaxLinesProperty::<Impl, OFFSET>, TextLineBoundsProperty::<Impl, OFFSET>, SelectionHighlightColorProperty::<Impl, OFFSET>, OpticalMarginAlignmentProperty::<Impl, OFFSET>, IsColorFontEnabledProperty::<Impl, OFFSET>, TextReadingOrderProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStatics3Impl: Sized {
    fn IsTextScaleFactorEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStatics3Vtbl {
    pub const fn new<Impl: IRichTextBlockStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlockStatics3Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: IRichTextBlockStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichTextBlockStatics3>, base.5, IsTextScaleFactorEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStatics4Impl: Sized {
    fn TextDecorationsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStatics4Vtbl {
    pub const fn new<Impl: IRichTextBlockStatics4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlockStatics4Vtbl {
        unsafe extern "system" fn TextDecorationsProperty<Impl: IRichTextBlockStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextDecorationsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichTextBlockStatics4>, base.5, TextDecorationsProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStatics5Impl: Sized {
    fn IsTextTrimmedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalTextAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStatics5Vtbl {
    pub const fn new<Impl: IRichTextBlockStatics5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlockStatics5Vtbl {
        unsafe extern "system" fn IsTextTrimmedProperty<Impl: IRichTextBlockStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalTextAlignmentProperty<Impl: IRichTextBlockStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichTextBlockStatics5>, base.5, IsTextTrimmedProperty::<Impl, OFFSET>, HorizontalTextAlignmentProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRichTextBlockStatics6Impl: Sized {
    fn SelectionFlyoutProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRichTextBlockStatics6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRichTextBlockStatics6";
}
#[cfg(feature = "implement_exclusive")]
impl IRichTextBlockStatics6Vtbl {
    pub const fn new<Impl: IRichTextBlockStatics6Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRichTextBlockStatics6Vtbl {
        unsafe extern "system" fn SelectionFlyoutProperty<Impl: IRichTextBlockStatics6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRichTextBlockStatics6>, base.5, SelectionFlyoutProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRowDefinitionImpl: Sized {
    fn Height(&self) -> ::windows::core::Result<super::GridLength>;
    fn SetHeight(&self, value: &super::GridLength) -> ::windows::core::Result<()>;
    fn MaxHeight(&self) -> ::windows::core::Result<f64>;
    fn SetMaxHeight(&self, value: f64) -> ::windows::core::Result<()>;
    fn MinHeight(&self) -> ::windows::core::Result<f64>;
    fn SetMinHeight(&self, value: f64) -> ::windows::core::Result<()>;
    fn ActualHeight(&self) -> ::windows::core::Result<f64>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRowDefinition {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRowDefinition";
}
#[cfg(feature = "implement_exclusive")]
impl IRowDefinitionVtbl {
    pub const fn new<Impl: IRowDefinitionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRowDefinitionVtbl {
        unsafe extern "system" fn Height<Impl: IRowDefinitionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Height() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeight<Impl: IRowDefinitionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeight(&*(&value as *const <super::GridLength as ::windows::core::Abi>::Abi as *const <super::GridLength as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxHeight<Impl: IRowDefinitionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxHeight<Impl: IRowDefinitionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxHeight(value).into()
        }
        unsafe extern "system" fn MinHeight<Impl: IRowDefinitionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinHeight<Impl: IRowDefinitionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMinHeight(value).into()
        }
        unsafe extern "system" fn ActualHeight<Impl: IRowDefinitionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ActualHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRowDefinition>, base.5, Height::<Impl, OFFSET>, SetHeight::<Impl, OFFSET>, MaxHeight::<Impl, OFFSET>, SetMaxHeight::<Impl, OFFSET>, MinHeight::<Impl, OFFSET>, SetMinHeight::<Impl, OFFSET>, ActualHeight::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IRowDefinitionStaticsImpl: Sized {
    fn HeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxHeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinHeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IRowDefinitionStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IRowDefinitionStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IRowDefinitionStaticsVtbl {
    pub const fn new<Impl: IRowDefinitionStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IRowDefinitionStaticsVtbl {
        unsafe extern "system" fn HeightProperty<Impl: IRowDefinitionStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxHeightProperty<Impl: IRowDefinitionStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinHeightProperty<Impl: IRowDefinitionStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IRowDefinitionStatics>, base.5, HeightProperty::<Impl, OFFSET>, MaxHeightProperty::<Impl, OFFSET>, MinHeightProperty::<Impl, OFFSET>)
    }
}
pub trait IScrollAnchorProviderImpl: Sized {
    fn CurrentAnchor(&self) -> ::windows::core::Result<super::UIElement>;
    fn RegisterAnchorCandidate(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn UnregisterAnchorCandidate(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for IScrollAnchorProvider {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollAnchorProvider";
}
impl IScrollAnchorProviderVtbl {
    pub const fn new<Impl: IScrollAnchorProviderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IScrollAnchorProviderVtbl {
        unsafe extern "system" fn CurrentAnchor<Impl: IScrollAnchorProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CurrentAnchor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterAnchorCandidate<Impl: IScrollAnchorProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RegisterAnchorCandidate(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UnregisterAnchorCandidate<Impl: IScrollAnchorProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).UnregisterAnchorCandidate(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IScrollAnchorProvider>, base.5, CurrentAnchor::<Impl, OFFSET>, RegisterAnchorCandidate::<Impl, OFFSET>, UnregisterAnchorCandidate::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollContentPresenterImpl: Sized {
    fn CanVerticallyScroll(&self) -> ::windows::core::Result<bool>;
    fn SetCanVerticallyScroll(&self, value: bool) -> ::windows::core::Result<()>;
    fn CanHorizontallyScroll(&self) -> ::windows::core::Result<bool>;
    fn SetCanHorizontallyScroll(&self, value: bool) -> ::windows::core::Result<()>;
    fn ExtentWidth(&self) -> ::windows::core::Result<f64>;
    fn ExtentHeight(&self) -> ::windows::core::Result<f64>;
    fn ViewportWidth(&self) -> ::windows::core::Result<f64>;
    fn ViewportHeight(&self) -> ::windows::core::Result<f64>;
    fn HorizontalOffset(&self) -> ::windows::core::Result<f64>;
    fn VerticalOffset(&self) -> ::windows::core::Result<f64>;
    fn ScrollOwner(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetScrollOwner(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn LineUp(&self) -> ::windows::core::Result<()>;
    fn LineDown(&self) -> ::windows::core::Result<()>;
    fn LineLeft(&self) -> ::windows::core::Result<()>;
    fn LineRight(&self) -> ::windows::core::Result<()>;
    fn PageUp(&self) -> ::windows::core::Result<()>;
    fn PageDown(&self) -> ::windows::core::Result<()>;
    fn PageLeft(&self) -> ::windows::core::Result<()>;
    fn PageRight(&self) -> ::windows::core::Result<()>;
    fn MouseWheelUp(&self) -> ::windows::core::Result<()>;
    fn MouseWheelDown(&self) -> ::windows::core::Result<()>;
    fn MouseWheelLeft(&self) -> ::windows::core::Result<()>;
    fn MouseWheelRight(&self) -> ::windows::core::Result<()>;
    fn SetHorizontalOffset(&self, offset: f64) -> ::windows::core::Result<()>;
    fn SetVerticalOffset(&self, offset: f64) -> ::windows::core::Result<()>;
    fn MakeVisible(&self, visual: &::core::option::Option<super::UIElement>, rectangle: &super::super::super::Foundation::Rect) -> ::windows::core::Result<super::super::super::Foundation::Rect>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollContentPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollContentPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollContentPresenterVtbl {
    pub const fn new<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IScrollContentPresenterVtbl {
        unsafe extern "system" fn CanVerticallyScroll<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanVerticallyScroll() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanVerticallyScroll<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCanVerticallyScroll(value).into()
        }
        unsafe extern "system" fn CanHorizontallyScroll<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanHorizontallyScroll() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanHorizontallyScroll<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCanHorizontallyScroll(value).into()
        }
        unsafe extern "system" fn ExtentWidth<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExtentWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExtentHeight<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExtentHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportWidth<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ViewportWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportHeight<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ViewportHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalOffset<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalOffset<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollOwner<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ScrollOwner() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetScrollOwner<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetScrollOwner(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LineUp<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).LineUp().into()
        }
        unsafe extern "system" fn LineDown<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).LineDown().into()
        }
        unsafe extern "system" fn LineLeft<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).LineLeft().into()
        }
        unsafe extern "system" fn LineRight<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).LineRight().into()
        }
        unsafe extern "system" fn PageUp<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).PageUp().into()
        }
        unsafe extern "system" fn PageDown<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).PageDown().into()
        }
        unsafe extern "system" fn PageLeft<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).PageLeft().into()
        }
        unsafe extern "system" fn PageRight<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).PageRight().into()
        }
        unsafe extern "system" fn MouseWheelUp<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).MouseWheelUp().into()
        }
        unsafe extern "system" fn MouseWheelDown<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).MouseWheelDown().into()
        }
        unsafe extern "system" fn MouseWheelLeft<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).MouseWheelLeft().into()
        }
        unsafe extern "system" fn MouseWheelRight<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).MouseWheelRight().into()
        }
        unsafe extern "system" fn SetHorizontalOffset<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalOffset(offset).into()
        }
        unsafe extern "system" fn SetVerticalOffset<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalOffset(offset).into()
        }
        unsafe extern "system" fn MakeVisible<Impl: IScrollContentPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, visual: ::windows::core::RawPtr, rectangle: super::super::super::Foundation::Rect, result__: *mut super::super::super::Foundation::Rect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MakeVisible(&*(&visual as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), &*(&rectangle as *const <super::super::super::Foundation::Rect as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Rect as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IScrollContentPresenter>,
            base.5,
            CanVerticallyScroll::<Impl, OFFSET>,
            SetCanVerticallyScroll::<Impl, OFFSET>,
            CanHorizontallyScroll::<Impl, OFFSET>,
            SetCanHorizontallyScroll::<Impl, OFFSET>,
            ExtentWidth::<Impl, OFFSET>,
            ExtentHeight::<Impl, OFFSET>,
            ViewportWidth::<Impl, OFFSET>,
            ViewportHeight::<Impl, OFFSET>,
            HorizontalOffset::<Impl, OFFSET>,
            VerticalOffset::<Impl, OFFSET>,
            ScrollOwner::<Impl, OFFSET>,
            SetScrollOwner::<Impl, OFFSET>,
            LineUp::<Impl, OFFSET>,
            LineDown::<Impl, OFFSET>,
            LineLeft::<Impl, OFFSET>,
            LineRight::<Impl, OFFSET>,
            PageUp::<Impl, OFFSET>,
            PageDown::<Impl, OFFSET>,
            PageLeft::<Impl, OFFSET>,
            PageRight::<Impl, OFFSET>,
            MouseWheelUp::<Impl, OFFSET>,
            MouseWheelDown::<Impl, OFFSET>,
            MouseWheelLeft::<Impl, OFFSET>,
            MouseWheelRight::<Impl, OFFSET>,
            SetHorizontalOffset::<Impl, OFFSET>,
            SetVerticalOffset::<Impl, OFFSET>,
            MakeVisible::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollContentPresenter2Impl: Sized {
    fn CanContentRenderOutsideBounds(&self) -> ::windows::core::Result<bool>;
    fn SetCanContentRenderOutsideBounds(&self, value: bool) -> ::windows::core::Result<()>;
    fn SizesContentToTemplatedParent(&self) -> ::windows::core::Result<bool>;
    fn SetSizesContentToTemplatedParent(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollContentPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollContentPresenter2";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollContentPresenter2Vtbl {
    pub const fn new<Impl: IScrollContentPresenter2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IScrollContentPresenter2Vtbl {
        unsafe extern "system" fn CanContentRenderOutsideBounds<Impl: IScrollContentPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanContentRenderOutsideBounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanContentRenderOutsideBounds<Impl: IScrollContentPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCanContentRenderOutsideBounds(value).into()
        }
        unsafe extern "system" fn SizesContentToTemplatedParent<Impl: IScrollContentPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SizesContentToTemplatedParent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSizesContentToTemplatedParent<Impl: IScrollContentPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSizesContentToTemplatedParent(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IScrollContentPresenter2>, base.5, CanContentRenderOutsideBounds::<Impl, OFFSET>, SetCanContentRenderOutsideBounds::<Impl, OFFSET>, SizesContentToTemplatedParent::<Impl, OFFSET>, SetSizesContentToTemplatedParent::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollContentPresenterStatics2Impl: Sized {
    fn CanContentRenderOutsideBoundsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SizesContentToTemplatedParentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollContentPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollContentPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollContentPresenterStatics2Vtbl {
    pub const fn new<Impl: IScrollContentPresenterStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IScrollContentPresenterStatics2Vtbl {
        unsafe extern "system" fn CanContentRenderOutsideBoundsProperty<Impl: IScrollContentPresenterStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanContentRenderOutsideBoundsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SizesContentToTemplatedParentProperty<Impl: IScrollContentPresenterStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SizesContentToTemplatedParentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IScrollContentPresenterStatics2>, base.5, CanContentRenderOutsideBoundsProperty::<Impl, OFFSET>, SizesContentToTemplatedParentProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerImpl: Sized {
    fn HorizontalScrollBarVisibility(&self) -> ::windows::core::Result<ScrollBarVisibility>;
    fn SetHorizontalScrollBarVisibility(&self, value: ScrollBarVisibility) -> ::windows::core::Result<()>;
    fn VerticalScrollBarVisibility(&self) -> ::windows::core::Result<ScrollBarVisibility>;
    fn SetVerticalScrollBarVisibility(&self, value: ScrollBarVisibility) -> ::windows::core::Result<()>;
    fn IsHorizontalRailEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsHorizontalRailEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsVerticalRailEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsVerticalRailEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsHorizontalScrollChainingEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsHorizontalScrollChainingEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsVerticalScrollChainingEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsVerticalScrollChainingEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsZoomChainingEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsZoomChainingEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsScrollInertiaEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsScrollInertiaEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsZoomInertiaEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsZoomInertiaEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn HorizontalScrollMode(&self) -> ::windows::core::Result<ScrollMode>;
    fn SetHorizontalScrollMode(&self, value: ScrollMode) -> ::windows::core::Result<()>;
    fn VerticalScrollMode(&self) -> ::windows::core::Result<ScrollMode>;
    fn SetVerticalScrollMode(&self, value: ScrollMode) -> ::windows::core::Result<()>;
    fn ZoomMode(&self) -> ::windows::core::Result<ZoomMode>;
    fn SetZoomMode(&self, value: ZoomMode) -> ::windows::core::Result<()>;
    fn HorizontalSnapPointsAlignment(&self) -> ::windows::core::Result<Primitives::SnapPointsAlignment>;
    fn SetHorizontalSnapPointsAlignment(&self, value: Primitives::SnapPointsAlignment) -> ::windows::core::Result<()>;
    fn VerticalSnapPointsAlignment(&self) -> ::windows::core::Result<Primitives::SnapPointsAlignment>;
    fn SetVerticalSnapPointsAlignment(&self, value: Primitives::SnapPointsAlignment) -> ::windows::core::Result<()>;
    fn HorizontalSnapPointsType(&self) -> ::windows::core::Result<SnapPointsType>;
    fn SetHorizontalSnapPointsType(&self, value: SnapPointsType) -> ::windows::core::Result<()>;
    fn VerticalSnapPointsType(&self) -> ::windows::core::Result<SnapPointsType>;
    fn SetVerticalSnapPointsType(&self, value: SnapPointsType) -> ::windows::core::Result<()>;
    fn ZoomSnapPointsType(&self) -> ::windows::core::Result<SnapPointsType>;
    fn SetZoomSnapPointsType(&self, value: SnapPointsType) -> ::windows::core::Result<()>;
    fn HorizontalOffset(&self) -> ::windows::core::Result<f64>;
    fn ViewportWidth(&self) -> ::windows::core::Result<f64>;
    fn ScrollableWidth(&self) -> ::windows::core::Result<f64>;
    fn ComputedHorizontalScrollBarVisibility(&self) -> ::windows::core::Result<super::Visibility>;
    fn ExtentWidth(&self) -> ::windows::core::Result<f64>;
    fn VerticalOffset(&self) -> ::windows::core::Result<f64>;
    fn ViewportHeight(&self) -> ::windows::core::Result<f64>;
    fn ScrollableHeight(&self) -> ::windows::core::Result<f64>;
    fn ComputedVerticalScrollBarVisibility(&self) -> ::windows::core::Result<super::Visibility>;
    fn ExtentHeight(&self) -> ::windows::core::Result<f64>;
    fn MinZoomFactor(&self) -> ::windows::core::Result<f32>;
    fn SetMinZoomFactor(&self, value: f32) -> ::windows::core::Result<()>;
    fn MaxZoomFactor(&self) -> ::windows::core::Result<f32>;
    fn SetMaxZoomFactor(&self, value: f32) -> ::windows::core::Result<()>;
    fn ZoomFactor(&self) -> ::windows::core::Result<f32>;
    fn ZoomSnapPoints(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<f32>>;
    fn ViewChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<ScrollViewerViewChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveViewChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ScrollToHorizontalOffset(&self, offset: f64) -> ::windows::core::Result<()>;
    fn ScrollToVerticalOffset(&self, offset: f64) -> ::windows::core::Result<()>;
    fn ZoomToFactor(&self, factor: f32) -> ::windows::core::Result<()>;
    fn InvalidateScrollInfo(&self) -> ::windows::core::Result<()>;
    fn IsDeferredScrollingEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsDeferredScrollingEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn BringIntoViewOnFocusChange(&self) -> ::windows::core::Result<bool>;
    fn SetBringIntoViewOnFocusChange(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewer";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerVtbl {
    pub const fn new<Impl: IScrollViewerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IScrollViewerVtbl {
        unsafe extern "system" fn HorizontalScrollBarVisibility<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalScrollBarVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalScrollBarVisibility<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalScrollBarVisibility(value).into()
        }
        unsafe extern "system" fn VerticalScrollBarVisibility<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalScrollBarVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalScrollBarVisibility<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalScrollBarVisibility(value).into()
        }
        unsafe extern "system" fn IsHorizontalRailEnabled<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsHorizontalRailEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHorizontalRailEnabled<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsHorizontalRailEnabled(value).into()
        }
        unsafe extern "system" fn IsVerticalRailEnabled<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsVerticalRailEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVerticalRailEnabled<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsVerticalRailEnabled(value).into()
        }
        unsafe extern "system" fn IsHorizontalScrollChainingEnabled<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsHorizontalScrollChainingEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHorizontalScrollChainingEnabled<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsHorizontalScrollChainingEnabled(value).into()
        }
        unsafe extern "system" fn IsVerticalScrollChainingEnabled<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsVerticalScrollChainingEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVerticalScrollChainingEnabled<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsVerticalScrollChainingEnabled(value).into()
        }
        unsafe extern "system" fn IsZoomChainingEnabled<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsZoomChainingEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomChainingEnabled<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsZoomChainingEnabled(value).into()
        }
        unsafe extern "system" fn IsScrollInertiaEnabled<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsScrollInertiaEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsScrollInertiaEnabled<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsScrollInertiaEnabled(value).into()
        }
        unsafe extern "system" fn IsZoomInertiaEnabled<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsZoomInertiaEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomInertiaEnabled<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsZoomInertiaEnabled(value).into()
        }
        unsafe extern "system" fn HorizontalScrollMode<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalScrollMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalScrollMode<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalScrollMode(value).into()
        }
        unsafe extern "system" fn VerticalScrollMode<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalScrollMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalScrollMode<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalScrollMode(value).into()
        }
        unsafe extern "system" fn ZoomMode<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ZoomMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ZoomMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZoomMode<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ZoomMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetZoomMode(value).into()
        }
        unsafe extern "system" fn HorizontalSnapPointsAlignment<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::SnapPointsAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalSnapPointsAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalSnapPointsAlignment<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Primitives::SnapPointsAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalSnapPointsAlignment(value).into()
        }
        unsafe extern "system" fn VerticalSnapPointsAlignment<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::SnapPointsAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalSnapPointsAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalSnapPointsAlignment<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Primitives::SnapPointsAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalSnapPointsAlignment(value).into()
        }
        unsafe extern "system" fn HorizontalSnapPointsType<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalSnapPointsType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalSnapPointsType<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalSnapPointsType(value).into()
        }
        unsafe extern "system" fn VerticalSnapPointsType<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalSnapPointsType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalSnapPointsType<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalSnapPointsType(value).into()
        }
        unsafe extern "system" fn ZoomSnapPointsType<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ZoomSnapPointsType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZoomSnapPointsType<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: SnapPointsType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetZoomSnapPointsType(value).into()
        }
        unsafe extern "system" fn HorizontalOffset<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportWidth<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ViewportWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollableWidth<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ScrollableWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ComputedHorizontalScrollBarVisibility<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ComputedHorizontalScrollBarVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExtentWidth<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExtentWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalOffset<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportHeight<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ViewportHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollableHeight<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ScrollableHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ComputedVerticalScrollBarVisibility<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ComputedVerticalScrollBarVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExtentHeight<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExtentHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinZoomFactor<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinZoomFactor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinZoomFactor<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMinZoomFactor(value).into()
        }
        unsafe extern "system" fn MaxZoomFactor<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxZoomFactor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxZoomFactor<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxZoomFactor(value).into()
        }
        unsafe extern "system" fn ZoomFactor<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ZoomFactor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomSnapPoints<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ZoomSnapPoints() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewChanged<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ViewChanged(&*(&handler as *const <super::super::super::Foundation::EventHandler<ScrollViewerViewChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<ScrollViewerViewChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveViewChanged<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveViewChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ScrollToHorizontalOffset<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ScrollToHorizontalOffset(offset).into()
        }
        unsafe extern "system" fn ScrollToVerticalOffset<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ScrollToVerticalOffset(offset).into()
        }
        unsafe extern "system" fn ZoomToFactor<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, factor: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ZoomToFactor(factor).into()
        }
        unsafe extern "system" fn InvalidateScrollInfo<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).InvalidateScrollInfo().into()
        }
        unsafe extern "system" fn IsDeferredScrollingEnabled<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDeferredScrollingEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDeferredScrollingEnabled<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsDeferredScrollingEnabled(value).into()
        }
        unsafe extern "system" fn BringIntoViewOnFocusChange<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BringIntoViewOnFocusChange() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBringIntoViewOnFocusChange<Impl: IScrollViewerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBringIntoViewOnFocusChange(value).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IScrollViewer>,
            base.5,
            HorizontalScrollBarVisibility::<Impl, OFFSET>,
            SetHorizontalScrollBarVisibility::<Impl, OFFSET>,
            VerticalScrollBarVisibility::<Impl, OFFSET>,
            SetVerticalScrollBarVisibility::<Impl, OFFSET>,
            IsHorizontalRailEnabled::<Impl, OFFSET>,
            SetIsHorizontalRailEnabled::<Impl, OFFSET>,
            IsVerticalRailEnabled::<Impl, OFFSET>,
            SetIsVerticalRailEnabled::<Impl, OFFSET>,
            IsHorizontalScrollChainingEnabled::<Impl, OFFSET>,
            SetIsHorizontalScrollChainingEnabled::<Impl, OFFSET>,
            IsVerticalScrollChainingEnabled::<Impl, OFFSET>,
            SetIsVerticalScrollChainingEnabled::<Impl, OFFSET>,
            IsZoomChainingEnabled::<Impl, OFFSET>,
            SetIsZoomChainingEnabled::<Impl, OFFSET>,
            IsScrollInertiaEnabled::<Impl, OFFSET>,
            SetIsScrollInertiaEnabled::<Impl, OFFSET>,
            IsZoomInertiaEnabled::<Impl, OFFSET>,
            SetIsZoomInertiaEnabled::<Impl, OFFSET>,
            HorizontalScrollMode::<Impl, OFFSET>,
            SetHorizontalScrollMode::<Impl, OFFSET>,
            VerticalScrollMode::<Impl, OFFSET>,
            SetVerticalScrollMode::<Impl, OFFSET>,
            ZoomMode::<Impl, OFFSET>,
            SetZoomMode::<Impl, OFFSET>,
            HorizontalSnapPointsAlignment::<Impl, OFFSET>,
            SetHorizontalSnapPointsAlignment::<Impl, OFFSET>,
            VerticalSnapPointsAlignment::<Impl, OFFSET>,
            SetVerticalSnapPointsAlignment::<Impl, OFFSET>,
            HorizontalSnapPointsType::<Impl, OFFSET>,
            SetHorizontalSnapPointsType::<Impl, OFFSET>,
            VerticalSnapPointsType::<Impl, OFFSET>,
            SetVerticalSnapPointsType::<Impl, OFFSET>,
            ZoomSnapPointsType::<Impl, OFFSET>,
            SetZoomSnapPointsType::<Impl, OFFSET>,
            HorizontalOffset::<Impl, OFFSET>,
            ViewportWidth::<Impl, OFFSET>,
            ScrollableWidth::<Impl, OFFSET>,
            ComputedHorizontalScrollBarVisibility::<Impl, OFFSET>,
            ExtentWidth::<Impl, OFFSET>,
            VerticalOffset::<Impl, OFFSET>,
            ViewportHeight::<Impl, OFFSET>,
            ScrollableHeight::<Impl, OFFSET>,
            ComputedVerticalScrollBarVisibility::<Impl, OFFSET>,
            ExtentHeight::<Impl, OFFSET>,
            MinZoomFactor::<Impl, OFFSET>,
            SetMinZoomFactor::<Impl, OFFSET>,
            MaxZoomFactor::<Impl, OFFSET>,
            SetMaxZoomFactor::<Impl, OFFSET>,
            ZoomFactor::<Impl, OFFSET>,
            ZoomSnapPoints::<Impl, OFFSET>,
            ViewChanged::<Impl, OFFSET>,
            RemoveViewChanged::<Impl, OFFSET>,
            ScrollToHorizontalOffset::<Impl, OFFSET>,
            ScrollToVerticalOffset::<Impl, OFFSET>,
            ZoomToFactor::<Impl, OFFSET>,
            InvalidateScrollInfo::<Impl, OFFSET>,
            IsDeferredScrollingEnabled::<Impl, OFFSET>,
            SetIsDeferredScrollingEnabled::<Impl, OFFSET>,
            BringIntoViewOnFocusChange::<Impl, OFFSET>,
            SetBringIntoViewOnFocusChange::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewer2Impl: Sized {
    fn TopLeftHeader(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetTopLeftHeader(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn LeftHeader(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetLeftHeader(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn TopHeader(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetTopHeader(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn ViewChanging(&self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<ScrollViewerViewChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveViewChanging(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ChangeView(&self, horizontaloffset: &::core::option::Option<super::super::super::Foundation::IReference<f64>>, verticaloffset: &::core::option::Option<super::super::super::Foundation::IReference<f64>>, zoomfactor: &::core::option::Option<super::super::super::Foundation::IReference<f32>>) -> ::windows::core::Result<bool>;
    fn ChangeViewWithOptionalAnimation(&self, horizontaloffset: &::core::option::Option<super::super::super::Foundation::IReference<f64>>, verticaloffset: &::core::option::Option<super::super::super::Foundation::IReference<f64>>, zoomfactor: &::core::option::Option<super::super::super::Foundation::IReference<f32>>, disableanimation: bool) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewer2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewer2";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewer2Vtbl {
    pub const fn new<Impl: IScrollViewer2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IScrollViewer2Vtbl {
        unsafe extern "system" fn TopLeftHeader<Impl: IScrollViewer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TopLeftHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTopLeftHeader<Impl: IScrollViewer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTopLeftHeader(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LeftHeader<Impl: IScrollViewer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LeftHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeftHeader<Impl: IScrollViewer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLeftHeader(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TopHeader<Impl: IScrollViewer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TopHeader() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTopHeader<Impl: IScrollViewer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTopHeader(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ViewChanging<Impl: IScrollViewer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ViewChanging(&*(&handler as *const <super::super::super::Foundation::EventHandler<ScrollViewerViewChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<ScrollViewerViewChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveViewChanging<Impl: IScrollViewer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveViewChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ChangeView<Impl: IScrollViewer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, horizontaloffset: ::windows::core::RawPtr, verticaloffset: ::windows::core::RawPtr, zoomfactor: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChangeView(
                &*(&horizontaloffset as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::DefaultType>::DefaultType),
                &*(&verticaloffset as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::DefaultType>::DefaultType),
                &*(&zoomfactor as *const <super::super::super::Foundation::IReference<f32> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f32> as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChangeViewWithOptionalAnimation<Impl: IScrollViewer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, horizontaloffset: ::windows::core::RawPtr, verticaloffset: ::windows::core::RawPtr, zoomfactor: ::windows::core::RawPtr, disableanimation: bool, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChangeViewWithOptionalAnimation(
                &*(&horizontaloffset as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::DefaultType>::DefaultType),
                &*(&verticaloffset as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f64> as ::windows::core::DefaultType>::DefaultType),
                &*(&zoomfactor as *const <super::super::super::Foundation::IReference<f32> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<f32> as ::windows::core::DefaultType>::DefaultType),
                disableanimation,
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IScrollViewer2>, base.5, TopLeftHeader::<Impl, OFFSET>, SetTopLeftHeader::<Impl, OFFSET>, LeftHeader::<Impl, OFFSET>, SetLeftHeader::<Impl, OFFSET>, TopHeader::<Impl, OFFSET>, SetTopHeader::<Impl, OFFSET>, ViewChanging::<Impl, OFFSET>, RemoveViewChanging::<Impl, OFFSET>, ChangeView::<Impl, OFFSET>, ChangeViewWithOptionalAnimation::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewer3Impl: Sized {
    fn DirectManipulationStarted(&self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDirectManipulationStarted(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DirectManipulationCompleted(&self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDirectManipulationCompleted(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewer3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewer3";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewer3Vtbl {
    pub const fn new<Impl: IScrollViewer3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IScrollViewer3Vtbl {
        unsafe extern "system" fn DirectManipulationStarted<Impl: IScrollViewer3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DirectManipulationStarted(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDirectManipulationStarted<Impl: IScrollViewer3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveDirectManipulationStarted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DirectManipulationCompleted<Impl: IScrollViewer3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DirectManipulationCompleted(&*(&handler as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDirectManipulationCompleted<Impl: IScrollViewer3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveDirectManipulationCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IScrollViewer3>, base.5, DirectManipulationStarted::<Impl, OFFSET>, RemoveDirectManipulationStarted::<Impl, OFFSET>, DirectManipulationCompleted::<Impl, OFFSET>, RemoveDirectManipulationCompleted::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewer4Impl: Sized {
    fn ReduceViewportForCoreInputViewOcclusions(&self) -> ::windows::core::Result<bool>;
    fn SetReduceViewportForCoreInputViewOcclusions(&self, value: bool) -> ::windows::core::Result<()>;
    fn HorizontalAnchorRatio(&self) -> ::windows::core::Result<f64>;
    fn SetHorizontalAnchorRatio(&self, value: f64) -> ::windows::core::Result<()>;
    fn VerticalAnchorRatio(&self) -> ::windows::core::Result<f64>;
    fn SetVerticalAnchorRatio(&self, value: f64) -> ::windows::core::Result<()>;
    fn CanContentRenderOutsideBounds(&self) -> ::windows::core::Result<bool>;
    fn SetCanContentRenderOutsideBounds(&self, value: bool) -> ::windows::core::Result<()>;
    fn AnchorRequested(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ScrollViewer, AnchorRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveAnchorRequested(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewer4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewer4";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewer4Vtbl {
    pub const fn new<Impl: IScrollViewer4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IScrollViewer4Vtbl {
        unsafe extern "system" fn ReduceViewportForCoreInputViewOcclusions<Impl: IScrollViewer4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReduceViewportForCoreInputViewOcclusions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetReduceViewportForCoreInputViewOcclusions<Impl: IScrollViewer4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetReduceViewportForCoreInputViewOcclusions(value).into()
        }
        unsafe extern "system" fn HorizontalAnchorRatio<Impl: IScrollViewer4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalAnchorRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalAnchorRatio<Impl: IScrollViewer4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalAnchorRatio(value).into()
        }
        unsafe extern "system" fn VerticalAnchorRatio<Impl: IScrollViewer4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalAnchorRatio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalAnchorRatio<Impl: IScrollViewer4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalAnchorRatio(value).into()
        }
        unsafe extern "system" fn CanContentRenderOutsideBounds<Impl: IScrollViewer4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanContentRenderOutsideBounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanContentRenderOutsideBounds<Impl: IScrollViewer4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCanContentRenderOutsideBounds(value).into()
        }
        unsafe extern "system" fn AnchorRequested<Impl: IScrollViewer4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AnchorRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ScrollViewer, AnchorRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ScrollViewer, AnchorRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveAnchorRequested<Impl: IScrollViewer4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveAnchorRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IScrollViewer4>,
            base.5,
            ReduceViewportForCoreInputViewOcclusions::<Impl, OFFSET>,
            SetReduceViewportForCoreInputViewOcclusions::<Impl, OFFSET>,
            HorizontalAnchorRatio::<Impl, OFFSET>,
            SetHorizontalAnchorRatio::<Impl, OFFSET>,
            VerticalAnchorRatio::<Impl, OFFSET>,
            SetVerticalAnchorRatio::<Impl, OFFSET>,
            CanContentRenderOutsideBounds::<Impl, OFFSET>,
            SetCanContentRenderOutsideBounds::<Impl, OFFSET>,
            AnchorRequested::<Impl, OFFSET>,
            RemoveAnchorRequested::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerStaticsImpl: Sized {
    fn HorizontalSnapPointsAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalSnapPointsAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalSnapPointsTypeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalSnapPointsTypeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ZoomSnapPointsTypeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalOffsetProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ViewportWidthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ScrollableWidthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ComputedHorizontalScrollBarVisibilityProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ExtentWidthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalOffsetProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ViewportHeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ScrollableHeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ComputedVerticalScrollBarVisibilityProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ExtentHeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinZoomFactorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxZoomFactorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ZoomFactorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ZoomSnapPointsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalScrollBarVisibilityProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetHorizontalScrollBarVisibility(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ScrollBarVisibility>;
    fn SetHorizontalScrollBarVisibility(&self, element: &::core::option::Option<super::DependencyObject>, horizontalscrollbarvisibility: ScrollBarVisibility) -> ::windows::core::Result<()>;
    fn VerticalScrollBarVisibilityProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetVerticalScrollBarVisibility(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ScrollBarVisibility>;
    fn SetVerticalScrollBarVisibility(&self, element: &::core::option::Option<super::DependencyObject>, verticalscrollbarvisibility: ScrollBarVisibility) -> ::windows::core::Result<()>;
    fn IsHorizontalRailEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsHorizontalRailEnabled(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsHorizontalRailEnabled(&self, element: &::core::option::Option<super::DependencyObject>, ishorizontalrailenabled: bool) -> ::windows::core::Result<()>;
    fn IsVerticalRailEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsVerticalRailEnabled(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsVerticalRailEnabled(&self, element: &::core::option::Option<super::DependencyObject>, isverticalrailenabled: bool) -> ::windows::core::Result<()>;
    fn IsHorizontalScrollChainingEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsHorizontalScrollChainingEnabled(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsHorizontalScrollChainingEnabled(&self, element: &::core::option::Option<super::DependencyObject>, ishorizontalscrollchainingenabled: bool) -> ::windows::core::Result<()>;
    fn IsVerticalScrollChainingEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsVerticalScrollChainingEnabled(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsVerticalScrollChainingEnabled(&self, element: &::core::option::Option<super::DependencyObject>, isverticalscrollchainingenabled: bool) -> ::windows::core::Result<()>;
    fn IsZoomChainingEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsZoomChainingEnabled(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsZoomChainingEnabled(&self, element: &::core::option::Option<super::DependencyObject>, iszoomchainingenabled: bool) -> ::windows::core::Result<()>;
    fn IsScrollInertiaEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsScrollInertiaEnabled(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsScrollInertiaEnabled(&self, element: &::core::option::Option<super::DependencyObject>, isscrollinertiaenabled: bool) -> ::windows::core::Result<()>;
    fn IsZoomInertiaEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsZoomInertiaEnabled(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsZoomInertiaEnabled(&self, element: &::core::option::Option<super::DependencyObject>, iszoominertiaenabled: bool) -> ::windows::core::Result<()>;
    fn HorizontalScrollModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetHorizontalScrollMode(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ScrollMode>;
    fn SetHorizontalScrollMode(&self, element: &::core::option::Option<super::DependencyObject>, horizontalscrollmode: ScrollMode) -> ::windows::core::Result<()>;
    fn VerticalScrollModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetVerticalScrollMode(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ScrollMode>;
    fn SetVerticalScrollMode(&self, element: &::core::option::Option<super::DependencyObject>, verticalscrollmode: ScrollMode) -> ::windows::core::Result<()>;
    fn ZoomModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetZoomMode(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<ZoomMode>;
    fn SetZoomMode(&self, element: &::core::option::Option<super::DependencyObject>, zoommode: ZoomMode) -> ::windows::core::Result<()>;
    fn IsDeferredScrollingEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsDeferredScrollingEnabled(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetIsDeferredScrollingEnabled(&self, element: &::core::option::Option<super::DependencyObject>, isdeferredscrollingenabled: bool) -> ::windows::core::Result<()>;
    fn BringIntoViewOnFocusChangeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetBringIntoViewOnFocusChange(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetBringIntoViewOnFocusChange(&self, element: &::core::option::Option<super::DependencyObject>, bringintoviewonfocuschange: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerStaticsVtbl {
    pub const fn new<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IScrollViewerStaticsVtbl {
        unsafe extern "system" fn HorizontalSnapPointsAlignmentProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalSnapPointsAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalSnapPointsAlignmentProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalSnapPointsAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalSnapPointsTypeProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalSnapPointsTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalSnapPointsTypeProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalSnapPointsTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomSnapPointsTypeProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ZoomSnapPointsTypeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalOffsetProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportWidthProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ViewportWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollableWidthProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ScrollableWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ComputedHorizontalScrollBarVisibilityProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ComputedHorizontalScrollBarVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExtentWidthProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExtentWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalOffsetProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ViewportHeightProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ViewportHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ScrollableHeightProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ScrollableHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ComputedVerticalScrollBarVisibilityProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ComputedVerticalScrollBarVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExtentHeightProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExtentHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinZoomFactorProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinZoomFactorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxZoomFactorProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxZoomFactorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomFactorProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ZoomFactorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomSnapPointsProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ZoomSnapPointsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalScrollBarVisibilityProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalScrollBarVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetHorizontalScrollBarVisibility<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetHorizontalScrollBarVisibility(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalScrollBarVisibility<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, horizontalscrollbarvisibility: ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalScrollBarVisibility(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), horizontalscrollbarvisibility).into()
        }
        unsafe extern "system" fn VerticalScrollBarVisibilityProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalScrollBarVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVerticalScrollBarVisibility<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVerticalScrollBarVisibility(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalScrollBarVisibility<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, verticalscrollbarvisibility: ScrollBarVisibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalScrollBarVisibility(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), verticalscrollbarvisibility).into()
        }
        unsafe extern "system" fn IsHorizontalRailEnabledProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsHorizontalRailEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsHorizontalRailEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIsHorizontalRailEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHorizontalRailEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, ishorizontalrailenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsHorizontalRailEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), ishorizontalrailenabled).into()
        }
        unsafe extern "system" fn IsVerticalRailEnabledProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsVerticalRailEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsVerticalRailEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIsVerticalRailEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVerticalRailEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, isverticalrailenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsVerticalRailEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), isverticalrailenabled).into()
        }
        unsafe extern "system" fn IsHorizontalScrollChainingEnabledProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsHorizontalScrollChainingEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsHorizontalScrollChainingEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIsHorizontalScrollChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHorizontalScrollChainingEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, ishorizontalscrollchainingenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsHorizontalScrollChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), ishorizontalscrollchainingenabled).into()
        }
        unsafe extern "system" fn IsVerticalScrollChainingEnabledProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsVerticalScrollChainingEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsVerticalScrollChainingEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIsVerticalScrollChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsVerticalScrollChainingEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, isverticalscrollchainingenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsVerticalScrollChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), isverticalscrollchainingenabled).into()
        }
        unsafe extern "system" fn IsZoomChainingEnabledProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsZoomChainingEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsZoomChainingEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIsZoomChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomChainingEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, iszoomchainingenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsZoomChainingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), iszoomchainingenabled).into()
        }
        unsafe extern "system" fn IsScrollInertiaEnabledProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsScrollInertiaEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsScrollInertiaEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIsScrollInertiaEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsScrollInertiaEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, isscrollinertiaenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsScrollInertiaEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), isscrollinertiaenabled).into()
        }
        unsafe extern "system" fn IsZoomInertiaEnabledProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsZoomInertiaEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsZoomInertiaEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIsZoomInertiaEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomInertiaEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, iszoominertiaenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsZoomInertiaEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), iszoominertiaenabled).into()
        }
        unsafe extern "system" fn HorizontalScrollModeProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalScrollModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetHorizontalScrollMode<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetHorizontalScrollMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalScrollMode<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, horizontalscrollmode: ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalScrollMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), horizontalscrollmode).into()
        }
        unsafe extern "system" fn VerticalScrollModeProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalScrollModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVerticalScrollMode<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVerticalScrollMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalScrollMode<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, verticalscrollmode: ScrollMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalScrollMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), verticalscrollmode).into()
        }
        unsafe extern "system" fn ZoomModeProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ZoomModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetZoomMode<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ZoomMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetZoomMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZoomMode<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, zoommode: ZoomMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetZoomMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), zoommode).into()
        }
        unsafe extern "system" fn IsDeferredScrollingEnabledProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDeferredScrollingEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsDeferredScrollingEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIsDeferredScrollingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDeferredScrollingEnabled<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, isdeferredscrollingenabled: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsDeferredScrollingEnabled(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), isdeferredscrollingenabled).into()
        }
        unsafe extern "system" fn BringIntoViewOnFocusChangeProperty<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BringIntoViewOnFocusChangeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBringIntoViewOnFocusChange<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBringIntoViewOnFocusChange(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBringIntoViewOnFocusChange<Impl: IScrollViewerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, bringintoviewonfocuschange: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBringIntoViewOnFocusChange(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), bringintoviewonfocuschange).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IScrollViewerStatics>,
            base.5,
            HorizontalSnapPointsAlignmentProperty::<Impl, OFFSET>,
            VerticalSnapPointsAlignmentProperty::<Impl, OFFSET>,
            HorizontalSnapPointsTypeProperty::<Impl, OFFSET>,
            VerticalSnapPointsTypeProperty::<Impl, OFFSET>,
            ZoomSnapPointsTypeProperty::<Impl, OFFSET>,
            HorizontalOffsetProperty::<Impl, OFFSET>,
            ViewportWidthProperty::<Impl, OFFSET>,
            ScrollableWidthProperty::<Impl, OFFSET>,
            ComputedHorizontalScrollBarVisibilityProperty::<Impl, OFFSET>,
            ExtentWidthProperty::<Impl, OFFSET>,
            VerticalOffsetProperty::<Impl, OFFSET>,
            ViewportHeightProperty::<Impl, OFFSET>,
            ScrollableHeightProperty::<Impl, OFFSET>,
            ComputedVerticalScrollBarVisibilityProperty::<Impl, OFFSET>,
            ExtentHeightProperty::<Impl, OFFSET>,
            MinZoomFactorProperty::<Impl, OFFSET>,
            MaxZoomFactorProperty::<Impl, OFFSET>,
            ZoomFactorProperty::<Impl, OFFSET>,
            ZoomSnapPointsProperty::<Impl, OFFSET>,
            HorizontalScrollBarVisibilityProperty::<Impl, OFFSET>,
            GetHorizontalScrollBarVisibility::<Impl, OFFSET>,
            SetHorizontalScrollBarVisibility::<Impl, OFFSET>,
            VerticalScrollBarVisibilityProperty::<Impl, OFFSET>,
            GetVerticalScrollBarVisibility::<Impl, OFFSET>,
            SetVerticalScrollBarVisibility::<Impl, OFFSET>,
            IsHorizontalRailEnabledProperty::<Impl, OFFSET>,
            GetIsHorizontalRailEnabled::<Impl, OFFSET>,
            SetIsHorizontalRailEnabled::<Impl, OFFSET>,
            IsVerticalRailEnabledProperty::<Impl, OFFSET>,
            GetIsVerticalRailEnabled::<Impl, OFFSET>,
            SetIsVerticalRailEnabled::<Impl, OFFSET>,
            IsHorizontalScrollChainingEnabledProperty::<Impl, OFFSET>,
            GetIsHorizontalScrollChainingEnabled::<Impl, OFFSET>,
            SetIsHorizontalScrollChainingEnabled::<Impl, OFFSET>,
            IsVerticalScrollChainingEnabledProperty::<Impl, OFFSET>,
            GetIsVerticalScrollChainingEnabled::<Impl, OFFSET>,
            SetIsVerticalScrollChainingEnabled::<Impl, OFFSET>,
            IsZoomChainingEnabledProperty::<Impl, OFFSET>,
            GetIsZoomChainingEnabled::<Impl, OFFSET>,
            SetIsZoomChainingEnabled::<Impl, OFFSET>,
            IsScrollInertiaEnabledProperty::<Impl, OFFSET>,
            GetIsScrollInertiaEnabled::<Impl, OFFSET>,
            SetIsScrollInertiaEnabled::<Impl, OFFSET>,
            IsZoomInertiaEnabledProperty::<Impl, OFFSET>,
            GetIsZoomInertiaEnabled::<Impl, OFFSET>,
            SetIsZoomInertiaEnabled::<Impl, OFFSET>,
            HorizontalScrollModeProperty::<Impl, OFFSET>,
            GetHorizontalScrollMode::<Impl, OFFSET>,
            SetHorizontalScrollMode::<Impl, OFFSET>,
            VerticalScrollModeProperty::<Impl, OFFSET>,
            GetVerticalScrollMode::<Impl, OFFSET>,
            SetVerticalScrollMode::<Impl, OFFSET>,
            ZoomModeProperty::<Impl, OFFSET>,
            GetZoomMode::<Impl, OFFSET>,
            SetZoomMode::<Impl, OFFSET>,
            IsDeferredScrollingEnabledProperty::<Impl, OFFSET>,
            GetIsDeferredScrollingEnabled::<Impl, OFFSET>,
            SetIsDeferredScrollingEnabled::<Impl, OFFSET>,
            BringIntoViewOnFocusChangeProperty::<Impl, OFFSET>,
            GetBringIntoViewOnFocusChange::<Impl, OFFSET>,
            SetBringIntoViewOnFocusChange::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerStatics2Impl: Sized {
    fn TopLeftHeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LeftHeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TopHeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerStatics2Vtbl {
    pub const fn new<Impl: IScrollViewerStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IScrollViewerStatics2Vtbl {
        unsafe extern "system" fn TopLeftHeaderProperty<Impl: IScrollViewerStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TopLeftHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LeftHeaderProperty<Impl: IScrollViewerStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LeftHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TopHeaderProperty<Impl: IScrollViewerStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TopHeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IScrollViewerStatics2>, base.5, TopLeftHeaderProperty::<Impl, OFFSET>, LeftHeaderProperty::<Impl, OFFSET>, TopHeaderProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerStatics4Impl: Sized {
    fn ReduceViewportForCoreInputViewOcclusionsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalAnchorRatioProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalAnchorRatioProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanContentRenderOutsideBoundsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetCanContentRenderOutsideBounds(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
    fn SetCanContentRenderOutsideBounds(&self, element: &::core::option::Option<super::DependencyObject>, cancontentrenderoutsidebounds: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerStatics4Vtbl {
    pub const fn new<Impl: IScrollViewerStatics4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IScrollViewerStatics4Vtbl {
        unsafe extern "system" fn ReduceViewportForCoreInputViewOcclusionsProperty<Impl: IScrollViewerStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReduceViewportForCoreInputViewOcclusionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalAnchorRatioProperty<Impl: IScrollViewerStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalAnchorRatioProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalAnchorRatioProperty<Impl: IScrollViewerStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalAnchorRatioProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanContentRenderOutsideBoundsProperty<Impl: IScrollViewerStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanContentRenderOutsideBoundsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCanContentRenderOutsideBounds<Impl: IScrollViewerStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCanContentRenderOutsideBounds(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanContentRenderOutsideBounds<Impl: IScrollViewerStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, cancontentrenderoutsidebounds: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCanContentRenderOutsideBounds(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), cancontentrenderoutsidebounds).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IScrollViewerStatics4>, base.5, ReduceViewportForCoreInputViewOcclusionsProperty::<Impl, OFFSET>, HorizontalAnchorRatioProperty::<Impl, OFFSET>, VerticalAnchorRatioProperty::<Impl, OFFSET>, CanContentRenderOutsideBoundsProperty::<Impl, OFFSET>, GetCanContentRenderOutsideBounds::<Impl, OFFSET>, SetCanContentRenderOutsideBounds::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerViewImpl: Sized {
    fn HorizontalOffset(&self) -> ::windows::core::Result<f64>;
    fn VerticalOffset(&self) -> ::windows::core::Result<f64>;
    fn ZoomFactor(&self) -> ::windows::core::Result<f32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerView";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerViewVtbl {
    pub const fn new<Impl: IScrollViewerViewImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IScrollViewerViewVtbl {
        unsafe extern "system" fn HorizontalOffset<Impl: IScrollViewerViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalOffset<Impl: IScrollViewerViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomFactor<Impl: IScrollViewerViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ZoomFactor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IScrollViewerView>, base.5, HorizontalOffset::<Impl, OFFSET>, VerticalOffset::<Impl, OFFSET>, ZoomFactor::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerViewChangedEventArgsImpl: Sized {
    fn IsIntermediate(&self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerViewChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerViewChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerViewChangedEventArgsVtbl {
    pub const fn new<Impl: IScrollViewerViewChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IScrollViewerViewChangedEventArgsVtbl {
        unsafe extern "system" fn IsIntermediate<Impl: IScrollViewerViewChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsIntermediate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IScrollViewerViewChangedEventArgs>, base.5, IsIntermediate::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IScrollViewerViewChangingEventArgsImpl: Sized {
    fn NextView(&self) -> ::windows::core::Result<ScrollViewerView>;
    fn FinalView(&self) -> ::windows::core::Result<ScrollViewerView>;
    fn IsInertial(&self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IScrollViewerViewChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IScrollViewerViewChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IScrollViewerViewChangingEventArgsVtbl {
    pub const fn new<Impl: IScrollViewerViewChangingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IScrollViewerViewChangingEventArgsVtbl {
        unsafe extern "system" fn NextView<Impl: IScrollViewerViewChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NextView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FinalView<Impl: IScrollViewerViewChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FinalView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsInertial<Impl: IScrollViewerViewChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsInertial() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IScrollViewerViewChangingEventArgs>, base.5, NextView::<Impl, OFFSET>, FinalView::<Impl, OFFSET>, IsInertial::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISearchBoxImpl: Sized {
    fn SearchHistoryEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetSearchHistoryEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn SearchHistoryContext(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSearchHistoryContext(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn PlaceholderText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn QueryText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetQueryText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn FocusOnKeyboardInput(&self) -> ::windows::core::Result<bool>;
    fn SetFocusOnKeyboardInput(&self, value: bool) -> ::windows::core::Result<()>;
    fn ChooseSuggestionOnEnter(&self) -> ::windows::core::Result<bool>;
    fn SetChooseSuggestionOnEnter(&self, value: bool) -> ::windows::core::Result<()>;
    fn QueryChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQueryChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveQueryChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SuggestionsRequested(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxSuggestionsRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSuggestionsRequested(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn QuerySubmitted(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQuerySubmittedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveQuerySubmitted(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ResultSuggestionChosen(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxResultSuggestionChosenEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveResultSuggestionChosen(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PrepareForFocusOnKeyboardInput(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SearchBox, super::RoutedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePrepareForFocusOnKeyboardInput(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SetLocalContentSuggestionSettings(&self, settings: &::core::option::Option<super::super::super::ApplicationModel::Search::LocalContentSuggestionSettings>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISearchBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBox";
}
#[cfg(feature = "implement_exclusive")]
impl ISearchBoxVtbl {
    pub const fn new<Impl: ISearchBoxImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISearchBoxVtbl {
        unsafe extern "system" fn SearchHistoryEnabled<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SearchHistoryEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSearchHistoryEnabled<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSearchHistoryEnabled(value).into()
        }
        unsafe extern "system" fn SearchHistoryContext<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SearchHistoryContext() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSearchHistoryContext<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSearchHistoryContext(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn QueryText<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetQueryText<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetQueryText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FocusOnKeyboardInput<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FocusOnKeyboardInput() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFocusOnKeyboardInput<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFocusOnKeyboardInput(value).into()
        }
        unsafe extern "system" fn ChooseSuggestionOnEnter<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChooseSuggestionOnEnter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChooseSuggestionOnEnter<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetChooseSuggestionOnEnter(value).into()
        }
        unsafe extern "system" fn QueryChanged<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQueryChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQueryChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveQueryChanged<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveQueryChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SuggestionsRequested<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SuggestionsRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxSuggestionsRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxSuggestionsRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSuggestionsRequested<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSuggestionsRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn QuerySubmitted<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QuerySubmitted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQuerySubmittedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxQuerySubmittedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveQuerySubmitted<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveQuerySubmitted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ResultSuggestionChosen<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ResultSuggestionChosen(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxResultSuggestionChosenEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, SearchBoxResultSuggestionChosenEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveResultSuggestionChosen<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveResultSuggestionChosen(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PrepareForFocusOnKeyboardInput<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PrepareForFocusOnKeyboardInput(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, super::RoutedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SearchBox, super::RoutedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePrepareForFocusOnKeyboardInput<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePrepareForFocusOnKeyboardInput(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SetLocalContentSuggestionSettings<Impl: ISearchBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, settings: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLocalContentSuggestionSettings(&*(&settings as *const <super::super::super::ApplicationModel::Search::LocalContentSuggestionSettings as ::windows::core::Abi>::Abi as *const <super::super::super::ApplicationModel::Search::LocalContentSuggestionSettings as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ISearchBox>,
            base.5,
            SearchHistoryEnabled::<Impl, OFFSET>,
            SetSearchHistoryEnabled::<Impl, OFFSET>,
            SearchHistoryContext::<Impl, OFFSET>,
            SetSearchHistoryContext::<Impl, OFFSET>,
            PlaceholderText::<Impl, OFFSET>,
            SetPlaceholderText::<Impl, OFFSET>,
            QueryText::<Impl, OFFSET>,
            SetQueryText::<Impl, OFFSET>,
            FocusOnKeyboardInput::<Impl, OFFSET>,
            SetFocusOnKeyboardInput::<Impl, OFFSET>,
            ChooseSuggestionOnEnter::<Impl, OFFSET>,
            SetChooseSuggestionOnEnter::<Impl, OFFSET>,
            QueryChanged::<Impl, OFFSET>,
            RemoveQueryChanged::<Impl, OFFSET>,
            SuggestionsRequested::<Impl, OFFSET>,
            RemoveSuggestionsRequested::<Impl, OFFSET>,
            QuerySubmitted::<Impl, OFFSET>,
            RemoveQuerySubmitted::<Impl, OFFSET>,
            ResultSuggestionChosen::<Impl, OFFSET>,
            RemoveResultSuggestionChosen::<Impl, OFFSET>,
            PrepareForFocusOnKeyboardInput::<Impl, OFFSET>,
            RemovePrepareForFocusOnKeyboardInput::<Impl, OFFSET>,
            SetLocalContentSuggestionSettings::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISearchBoxFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SearchBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISearchBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISearchBoxFactoryVtbl {
    pub const fn new<Impl: ISearchBoxFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISearchBoxFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISearchBoxFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISearchBoxFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISearchBoxQueryChangedEventArgsImpl: Sized {
    fn QueryText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Language(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn LinguisticDetails(&self) -> ::windows::core::Result<super::super::super::ApplicationModel::Search::SearchQueryLinguisticDetails>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISearchBoxQueryChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxQueryChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISearchBoxQueryChangedEventArgsVtbl {
    pub const fn new<Impl: ISearchBoxQueryChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISearchBoxQueryChangedEventArgsVtbl {
        unsafe extern "system" fn QueryText<Impl: ISearchBoxQueryChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Language<Impl: ISearchBoxQueryChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Language() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LinguisticDetails<Impl: ISearchBoxQueryChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LinguisticDetails() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISearchBoxQueryChangedEventArgs>, base.5, QueryText::<Impl, OFFSET>, Language::<Impl, OFFSET>, LinguisticDetails::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISearchBoxQuerySubmittedEventArgsImpl: Sized {
    fn QueryText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Language(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn LinguisticDetails(&self) -> ::windows::core::Result<super::super::super::ApplicationModel::Search::SearchQueryLinguisticDetails>;
    fn KeyModifiers(&self) -> ::windows::core::Result<super::super::super::System::VirtualKeyModifiers>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISearchBoxQuerySubmittedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxQuerySubmittedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISearchBoxQuerySubmittedEventArgsVtbl {
    pub const fn new<Impl: ISearchBoxQuerySubmittedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISearchBoxQuerySubmittedEventArgsVtbl {
        unsafe extern "system" fn QueryText<Impl: ISearchBoxQuerySubmittedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Language<Impl: ISearchBoxQuerySubmittedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Language() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LinguisticDetails<Impl: ISearchBoxQuerySubmittedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LinguisticDetails() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeyModifiers<Impl: ISearchBoxQuerySubmittedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::System::VirtualKeyModifiers) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeyModifiers() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISearchBoxQuerySubmittedEventArgs>, base.5, QueryText::<Impl, OFFSET>, Language::<Impl, OFFSET>, LinguisticDetails::<Impl, OFFSET>, KeyModifiers::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISearchBoxResultSuggestionChosenEventArgsImpl: Sized {
    fn Tag(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn KeyModifiers(&self) -> ::windows::core::Result<super::super::super::System::VirtualKeyModifiers>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISearchBoxResultSuggestionChosenEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxResultSuggestionChosenEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISearchBoxResultSuggestionChosenEventArgsVtbl {
    pub const fn new<Impl: ISearchBoxResultSuggestionChosenEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISearchBoxResultSuggestionChosenEventArgsVtbl {
        unsafe extern "system" fn Tag<Impl: ISearchBoxResultSuggestionChosenEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Tag() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeyModifiers<Impl: ISearchBoxResultSuggestionChosenEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::System::VirtualKeyModifiers) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeyModifiers() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISearchBoxResultSuggestionChosenEventArgs>, base.5, Tag::<Impl, OFFSET>, KeyModifiers::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISearchBoxStaticsImpl: Sized {
    fn SearchHistoryEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SearchHistoryContextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn QueryTextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FocusOnKeyboardInputProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ChooseSuggestionOnEnterProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISearchBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISearchBoxStaticsVtbl {
    pub const fn new<Impl: ISearchBoxStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISearchBoxStaticsVtbl {
        unsafe extern "system" fn SearchHistoryEnabledProperty<Impl: ISearchBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SearchHistoryEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SearchHistoryContextProperty<Impl: ISearchBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SearchHistoryContextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: ISearchBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryTextProperty<Impl: ISearchBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FocusOnKeyboardInputProperty<Impl: ISearchBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FocusOnKeyboardInputProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ChooseSuggestionOnEnterProperty<Impl: ISearchBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ChooseSuggestionOnEnterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISearchBoxStatics>, base.5, SearchHistoryEnabledProperty::<Impl, OFFSET>, SearchHistoryContextProperty::<Impl, OFFSET>, PlaceholderTextProperty::<Impl, OFFSET>, QueryTextProperty::<Impl, OFFSET>, FocusOnKeyboardInputProperty::<Impl, OFFSET>, ChooseSuggestionOnEnterProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISearchBoxSuggestionsRequestedEventArgsImpl: Sized {
    fn QueryText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Language(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn LinguisticDetails(&self) -> ::windows::core::Result<super::super::super::ApplicationModel::Search::SearchQueryLinguisticDetails>;
    fn Request(&self) -> ::windows::core::Result<super::super::super::ApplicationModel::Search::SearchSuggestionsRequest>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISearchBoxSuggestionsRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISearchBoxSuggestionsRequestedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISearchBoxSuggestionsRequestedEventArgsVtbl {
    pub const fn new<Impl: ISearchBoxSuggestionsRequestedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISearchBoxSuggestionsRequestedEventArgsVtbl {
        unsafe extern "system" fn QueryText<Impl: ISearchBoxSuggestionsRequestedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Language<Impl: ISearchBoxSuggestionsRequestedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Language() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LinguisticDetails<Impl: ISearchBoxSuggestionsRequestedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LinguisticDetails() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Request<Impl: ISearchBoxSuggestionsRequestedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Request() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISearchBoxSuggestionsRequestedEventArgs>, base.5, QueryText::<Impl, OFFSET>, Language::<Impl, OFFSET>, LinguisticDetails::<Impl, OFFSET>, Request::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISectionsInViewChangedEventArgsImpl: Sized {
    fn AddedSections(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<HubSection>>;
    fn RemovedSections(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<HubSection>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISectionsInViewChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISectionsInViewChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISectionsInViewChangedEventArgsVtbl {
    pub const fn new<Impl: ISectionsInViewChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISectionsInViewChangedEventArgsVtbl {
        unsafe extern "system" fn AddedSections<Impl: ISectionsInViewChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddedSections() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovedSections<Impl: ISectionsInViewChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemovedSections() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISectionsInViewChangedEventArgs>, base.5, AddedSections::<Impl, OFFSET>, RemovedSections::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISectionsInViewChangedEventArgsFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISectionsInViewChangedEventArgsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISectionsInViewChangedEventArgsFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISectionsInViewChangedEventArgsFactoryVtbl {
    pub const fn new<Impl: ISectionsInViewChangedEventArgsFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISectionsInViewChangedEventArgsFactoryVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISectionsInViewChangedEventArgsFactory>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISelectionChangedEventArgsImpl: Sized {
    fn AddedItems(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
    fn RemovedItems(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISelectionChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISelectionChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISelectionChangedEventArgsVtbl {
    pub const fn new<Impl: ISelectionChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISelectionChangedEventArgsVtbl {
        unsafe extern "system" fn AddedItems<Impl: ISelectionChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovedItems<Impl: ISelectionChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemovedItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISelectionChangedEventArgs>, base.5, AddedItems::<Impl, OFFSET>, RemovedItems::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISelectionChangedEventArgsFactoryImpl: Sized {
    fn CreateInstanceWithRemovedItemsAndAddedItems(&self, removeditems: &::core::option::Option<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>, addeditems: &::core::option::Option<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SelectionChangedEventArgs>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISelectionChangedEventArgsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISelectionChangedEventArgsFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISelectionChangedEventArgsFactoryVtbl {
    pub const fn new<Impl: ISelectionChangedEventArgsFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISelectionChangedEventArgsFactoryVtbl {
        unsafe extern "system" fn CreateInstanceWithRemovedItemsAndAddedItems<Impl: ISelectionChangedEventArgsFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, removeditems: ::windows::core::RawPtr, addeditems: ::windows::core::RawPtr, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstanceWithRemovedItemsAndAddedItems(
                &*(&removeditems as *const <super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType),
                &*(&addeditems as *const <super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType),
                &*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&innerinterface),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISelectionChangedEventArgsFactory>, base.5, CreateInstanceWithRemovedItemsAndAddedItems::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISemanticZoomImpl: Sized {
    fn ZoomedInView(&self) -> ::windows::core::Result<ISemanticZoomInformation>;
    fn SetZoomedInView(&self, value: &::core::option::Option<ISemanticZoomInformation>) -> ::windows::core::Result<()>;
    fn ZoomedOutView(&self) -> ::windows::core::Result<ISemanticZoomInformation>;
    fn SetZoomedOutView(&self, value: &::core::option::Option<ISemanticZoomInformation>) -> ::windows::core::Result<()>;
    fn IsZoomedInViewActive(&self) -> ::windows::core::Result<bool>;
    fn SetIsZoomedInViewActive(&self, value: bool) -> ::windows::core::Result<()>;
    fn CanChangeViews(&self) -> ::windows::core::Result<bool>;
    fn SetCanChangeViews(&self, value: bool) -> ::windows::core::Result<()>;
    fn ViewChangeStarted(&self, handler: &::core::option::Option<SemanticZoomViewChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveViewChangeStarted(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ViewChangeCompleted(&self, handler: &::core::option::Option<SemanticZoomViewChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveViewChangeCompleted(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ToggleActiveView(&self) -> ::windows::core::Result<()>;
    fn IsZoomOutButtonEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsZoomOutButtonEnabled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISemanticZoom {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISemanticZoom";
}
#[cfg(feature = "implement_exclusive")]
impl ISemanticZoomVtbl {
    pub const fn new<Impl: ISemanticZoomImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISemanticZoomVtbl {
        unsafe extern "system" fn ZoomedInView<Impl: ISemanticZoomImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ZoomedInView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZoomedInView<Impl: ISemanticZoomImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetZoomedInView(&*(&value as *const <ISemanticZoomInformation as ::windows::core::Abi>::Abi as *const <ISemanticZoomInformation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ZoomedOutView<Impl: ISemanticZoomImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ZoomedOutView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetZoomedOutView<Impl: ISemanticZoomImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetZoomedOutView(&*(&value as *const <ISemanticZoomInformation as ::windows::core::Abi>::Abi as *const <ISemanticZoomInformation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsZoomedInViewActive<Impl: ISemanticZoomImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsZoomedInViewActive() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomedInViewActive<Impl: ISemanticZoomImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsZoomedInViewActive(value).into()
        }
        unsafe extern "system" fn CanChangeViews<Impl: ISemanticZoomImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanChangeViews() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanChangeViews<Impl: ISemanticZoomImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCanChangeViews(value).into()
        }
        unsafe extern "system" fn ViewChangeStarted<Impl: ISemanticZoomImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ViewChangeStarted(&*(&handler as *const <SemanticZoomViewChangedEventHandler as ::windows::core::Abi>::Abi as *const <SemanticZoomViewChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveViewChangeStarted<Impl: ISemanticZoomImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveViewChangeStarted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ViewChangeCompleted<Impl: ISemanticZoomImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ViewChangeCompleted(&*(&handler as *const <SemanticZoomViewChangedEventHandler as ::windows::core::Abi>::Abi as *const <SemanticZoomViewChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveViewChangeCompleted<Impl: ISemanticZoomImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveViewChangeCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ToggleActiveView<Impl: ISemanticZoomImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ToggleActiveView().into()
        }
        unsafe extern "system" fn IsZoomOutButtonEnabled<Impl: ISemanticZoomImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsZoomOutButtonEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomOutButtonEnabled<Impl: ISemanticZoomImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsZoomOutButtonEnabled(value).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ISemanticZoom>,
            base.5,
            ZoomedInView::<Impl, OFFSET>,
            SetZoomedInView::<Impl, OFFSET>,
            ZoomedOutView::<Impl, OFFSET>,
            SetZoomedOutView::<Impl, OFFSET>,
            IsZoomedInViewActive::<Impl, OFFSET>,
            SetIsZoomedInViewActive::<Impl, OFFSET>,
            CanChangeViews::<Impl, OFFSET>,
            SetCanChangeViews::<Impl, OFFSET>,
            ViewChangeStarted::<Impl, OFFSET>,
            RemoveViewChangeStarted::<Impl, OFFSET>,
            ViewChangeCompleted::<Impl, OFFSET>,
            RemoveViewChangeCompleted::<Impl, OFFSET>,
            ToggleActiveView::<Impl, OFFSET>,
            IsZoomOutButtonEnabled::<Impl, OFFSET>,
            SetIsZoomOutButtonEnabled::<Impl, OFFSET>,
        )
    }
}
pub trait ISemanticZoomInformationImpl: Sized {
    fn SemanticZoomOwner(&self) -> ::windows::core::Result<SemanticZoom>;
    fn SetSemanticZoomOwner(&self, value: &::core::option::Option<SemanticZoom>) -> ::windows::core::Result<()>;
    fn IsActiveView(&self) -> ::windows::core::Result<bool>;
    fn SetIsActiveView(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsZoomedInView(&self) -> ::windows::core::Result<bool>;
    fn SetIsZoomedInView(&self, value: bool) -> ::windows::core::Result<()>;
    fn InitializeViewChange(&self) -> ::windows::core::Result<()>;
    fn CompleteViewChange(&self) -> ::windows::core::Result<()>;
    fn MakeVisible(&self, item: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
    fn StartViewChangeFrom(&self, source: &::core::option::Option<SemanticZoomLocation>, destination: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
    fn StartViewChangeTo(&self, source: &::core::option::Option<SemanticZoomLocation>, destination: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
    fn CompleteViewChangeFrom(&self, source: &::core::option::Option<SemanticZoomLocation>, destination: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
    fn CompleteViewChangeTo(&self, source: &::core::option::Option<SemanticZoomLocation>, destination: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ISemanticZoomInformation {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISemanticZoomInformation";
}
impl ISemanticZoomInformationVtbl {
    pub const fn new<Impl: ISemanticZoomInformationImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISemanticZoomInformationVtbl {
        unsafe extern "system" fn SemanticZoomOwner<Impl: ISemanticZoomInformationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SemanticZoomOwner() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSemanticZoomOwner<Impl: ISemanticZoomInformationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSemanticZoomOwner(&*(&value as *const <SemanticZoom as ::windows::core::Abi>::Abi as *const <SemanticZoom as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsActiveView<Impl: ISemanticZoomInformationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsActiveView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsActiveView<Impl: ISemanticZoomInformationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsActiveView(value).into()
        }
        unsafe extern "system" fn IsZoomedInView<Impl: ISemanticZoomInformationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsZoomedInView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsZoomedInView<Impl: ISemanticZoomInformationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsZoomedInView(value).into()
        }
        unsafe extern "system" fn InitializeViewChange<Impl: ISemanticZoomInformationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).InitializeViewChange().into()
        }
        unsafe extern "system" fn CompleteViewChange<Impl: ISemanticZoomInformationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).CompleteViewChange().into()
        }
        unsafe extern "system" fn MakeVisible<Impl: ISemanticZoomInformationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, item: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).MakeVisible(&*(&item as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn StartViewChangeFrom<Impl: ISemanticZoomInformationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr, destination: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).StartViewChangeFrom(&*(&source as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType), &*(&destination as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn StartViewChangeTo<Impl: ISemanticZoomInformationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr, destination: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).StartViewChangeTo(&*(&source as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType), &*(&destination as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CompleteViewChangeFrom<Impl: ISemanticZoomInformationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr, destination: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).CompleteViewChangeFrom(&*(&source as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType), &*(&destination as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CompleteViewChangeTo<Impl: ISemanticZoomInformationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr, destination: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).CompleteViewChangeTo(&*(&source as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType), &*(&destination as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ISemanticZoomInformation>,
            base.5,
            SemanticZoomOwner::<Impl, OFFSET>,
            SetSemanticZoomOwner::<Impl, OFFSET>,
            IsActiveView::<Impl, OFFSET>,
            SetIsActiveView::<Impl, OFFSET>,
            IsZoomedInView::<Impl, OFFSET>,
            SetIsZoomedInView::<Impl, OFFSET>,
            InitializeViewChange::<Impl, OFFSET>,
            CompleteViewChange::<Impl, OFFSET>,
            MakeVisible::<Impl, OFFSET>,
            StartViewChangeFrom::<Impl, OFFSET>,
            StartViewChangeTo::<Impl, OFFSET>,
            CompleteViewChangeFrom::<Impl, OFFSET>,
            CompleteViewChangeTo::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISemanticZoomLocationImpl: Sized {
    fn Item(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetItem(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn Bounds(&self) -> ::windows::core::Result<super::super::super::Foundation::Rect>;
    fn SetBounds(&self, value: &super::super::super::Foundation::Rect) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISemanticZoomLocation {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISemanticZoomLocation";
}
#[cfg(feature = "implement_exclusive")]
impl ISemanticZoomLocationVtbl {
    pub const fn new<Impl: ISemanticZoomLocationImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISemanticZoomLocationVtbl {
        unsafe extern "system" fn Item<Impl: ISemanticZoomLocationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItem<Impl: ISemanticZoomLocationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItem(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Bounds<Impl: ISemanticZoomLocationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::Rect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Bounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBounds<Impl: ISemanticZoomLocationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::Rect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBounds(&*(&value as *const <super::super::super::Foundation::Rect as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Rect as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISemanticZoomLocation>, base.5, Item::<Impl, OFFSET>, SetItem::<Impl, OFFSET>, Bounds::<Impl, OFFSET>, SetBounds::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISemanticZoomStaticsImpl: Sized {
    fn ZoomedInViewProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ZoomedOutViewProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomedInViewActiveProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanChangeViewsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsZoomOutButtonEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISemanticZoomStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISemanticZoomStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISemanticZoomStaticsVtbl {
    pub const fn new<Impl: ISemanticZoomStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISemanticZoomStaticsVtbl {
        unsafe extern "system" fn ZoomedInViewProperty<Impl: ISemanticZoomStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ZoomedInViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ZoomedOutViewProperty<Impl: ISemanticZoomStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ZoomedOutViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomedInViewActiveProperty<Impl: ISemanticZoomStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsZoomedInViewActiveProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanChangeViewsProperty<Impl: ISemanticZoomStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanChangeViewsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsZoomOutButtonEnabledProperty<Impl: ISemanticZoomStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsZoomOutButtonEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISemanticZoomStatics>, base.5, ZoomedInViewProperty::<Impl, OFFSET>, ZoomedOutViewProperty::<Impl, OFFSET>, IsZoomedInViewActiveProperty::<Impl, OFFSET>, CanChangeViewsProperty::<Impl, OFFSET>, IsZoomOutButtonEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISemanticZoomViewChangedEventArgsImpl: Sized {
    fn IsSourceZoomedInView(&self) -> ::windows::core::Result<bool>;
    fn SetIsSourceZoomedInView(&self, value: bool) -> ::windows::core::Result<()>;
    fn SourceItem(&self) -> ::windows::core::Result<SemanticZoomLocation>;
    fn SetSourceItem(&self, value: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
    fn DestinationItem(&self) -> ::windows::core::Result<SemanticZoomLocation>;
    fn SetDestinationItem(&self, value: &::core::option::Option<SemanticZoomLocation>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISemanticZoomViewChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISemanticZoomViewChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISemanticZoomViewChangedEventArgsVtbl {
    pub const fn new<Impl: ISemanticZoomViewChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISemanticZoomViewChangedEventArgsVtbl {
        unsafe extern "system" fn IsSourceZoomedInView<Impl: ISemanticZoomViewChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSourceZoomedInView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSourceZoomedInView<Impl: ISemanticZoomViewChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsSourceZoomedInView(value).into()
        }
        unsafe extern "system" fn SourceItem<Impl: ISemanticZoomViewChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceItem<Impl: ISemanticZoomViewChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSourceItem(&*(&value as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DestinationItem<Impl: ISemanticZoomViewChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DestinationItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDestinationItem<Impl: ISemanticZoomViewChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDestinationItem(&*(&value as *const <SemanticZoomLocation as ::windows::core::Abi>::Abi as *const <SemanticZoomLocation as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISemanticZoomViewChangedEventArgs>, base.5, IsSourceZoomedInView::<Impl, OFFSET>, SetIsSourceZoomedInView::<Impl, OFFSET>, SourceItem::<Impl, OFFSET>, SetSourceItem::<Impl, OFFSET>, DestinationItem::<Impl, OFFSET>, SetDestinationItem::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISettingsFlyoutImpl: Sized {
    fn Title(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetTitle(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn HeaderBackground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetHeaderBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn HeaderForeground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetHeaderForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn IconSource(&self) -> ::windows::core::Result<super::Media::ImageSource>;
    fn SetIconSource(&self, value: &::core::option::Option<super::Media::ImageSource>) -> ::windows::core::Result<()>;
    fn TemplateSettings(&self) -> ::windows::core::Result<Primitives::SettingsFlyoutTemplateSettings>;
    fn BackClick(&self, handler: &::core::option::Option<BackClickEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveBackClick(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Show(&self) -> ::windows::core::Result<()>;
    fn ShowIndependent(&self) -> ::windows::core::Result<()>;
    fn Hide(&self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISettingsFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISettingsFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl ISettingsFlyoutVtbl {
    pub const fn new<Impl: ISettingsFlyoutImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISettingsFlyoutVtbl {
        unsafe extern "system" fn Title<Impl: ISettingsFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Title() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTitle<Impl: ISettingsFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTitle(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderBackground<Impl: ISettingsFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderBackground<Impl: ISettingsFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderForeground<Impl: ISettingsFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderForeground<Impl: ISettingsFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IconSource<Impl: ISettingsFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IconSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIconSource<Impl: ISettingsFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIconSource(&*(&value as *const <super::Media::ImageSource as ::windows::core::Abi>::Abi as *const <super::Media::ImageSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: ISettingsFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackClick<Impl: ISettingsFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackClick(&*(&handler as *const <BackClickEventHandler as ::windows::core::Abi>::Abi as *const <BackClickEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveBackClick<Impl: ISettingsFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveBackClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Show<Impl: ISettingsFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Show().into()
        }
        unsafe extern "system" fn ShowIndependent<Impl: ISettingsFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ShowIndependent().into()
        }
        unsafe extern "system" fn Hide<Impl: ISettingsFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Hide().into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ISettingsFlyout>,
            base.5,
            Title::<Impl, OFFSET>,
            SetTitle::<Impl, OFFSET>,
            HeaderBackground::<Impl, OFFSET>,
            SetHeaderBackground::<Impl, OFFSET>,
            HeaderForeground::<Impl, OFFSET>,
            SetHeaderForeground::<Impl, OFFSET>,
            IconSource::<Impl, OFFSET>,
            SetIconSource::<Impl, OFFSET>,
            TemplateSettings::<Impl, OFFSET>,
            BackClick::<Impl, OFFSET>,
            RemoveBackClick::<Impl, OFFSET>,
            Show::<Impl, OFFSET>,
            ShowIndependent::<Impl, OFFSET>,
            Hide::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISettingsFlyoutFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SettingsFlyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISettingsFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISettingsFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISettingsFlyoutFactoryVtbl {
    pub const fn new<Impl: ISettingsFlyoutFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISettingsFlyoutFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISettingsFlyoutFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISettingsFlyoutFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISettingsFlyoutStaticsImpl: Sized {
    fn TitleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderBackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IconSourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISettingsFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISettingsFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISettingsFlyoutStaticsVtbl {
    pub const fn new<Impl: ISettingsFlyoutStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISettingsFlyoutStaticsVtbl {
        unsafe extern "system" fn TitleProperty<Impl: ISettingsFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderBackgroundProperty<Impl: ISettingsFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderForegroundProperty<Impl: ISettingsFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IconSourceProperty<Impl: ISettingsFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IconSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISettingsFlyoutStatics>, base.5, TitleProperty::<Impl, OFFSET>, HeaderBackgroundProperty::<Impl, OFFSET>, HeaderForegroundProperty::<Impl, OFFSET>, IconSourceProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISliderImpl: Sized {
    fn IntermediateValue(&self) -> ::windows::core::Result<f64>;
    fn SetIntermediateValue(&self, value: f64) -> ::windows::core::Result<()>;
    fn StepFrequency(&self) -> ::windows::core::Result<f64>;
    fn SetStepFrequency(&self, value: f64) -> ::windows::core::Result<()>;
    fn SnapsTo(&self) -> ::windows::core::Result<Primitives::SliderSnapsTo>;
    fn SetSnapsTo(&self, value: Primitives::SliderSnapsTo) -> ::windows::core::Result<()>;
    fn TickFrequency(&self) -> ::windows::core::Result<f64>;
    fn SetTickFrequency(&self, value: f64) -> ::windows::core::Result<()>;
    fn TickPlacement(&self) -> ::windows::core::Result<Primitives::TickPlacement>;
    fn SetTickPlacement(&self, value: Primitives::TickPlacement) -> ::windows::core::Result<()>;
    fn Orientation(&self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&self, value: Orientation) -> ::windows::core::Result<()>;
    fn IsDirectionReversed(&self) -> ::windows::core::Result<bool>;
    fn SetIsDirectionReversed(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsThumbToolTipEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsThumbToolTipEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn ThumbToolTipValueConverter(&self) -> ::windows::core::Result<super::Data::IValueConverter>;
    fn SetThumbToolTipValueConverter(&self, value: &::core::option::Option<super::Data::IValueConverter>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISlider {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISlider";
}
#[cfg(feature = "implement_exclusive")]
impl ISliderVtbl {
    pub const fn new<Impl: ISliderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISliderVtbl {
        unsafe extern "system" fn IntermediateValue<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IntermediateValue() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIntermediateValue<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIntermediateValue(value).into()
        }
        unsafe extern "system" fn StepFrequency<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StepFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStepFrequency<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetStepFrequency(value).into()
        }
        unsafe extern "system" fn SnapsTo<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::SliderSnapsTo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SnapsTo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSnapsTo<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Primitives::SliderSnapsTo) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSnapsTo(value).into()
        }
        unsafe extern "system" fn TickFrequency<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TickFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTickFrequency<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTickFrequency(value).into()
        }
        unsafe extern "system" fn TickPlacement<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::TickPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TickPlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTickPlacement<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Primitives::TickPlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTickPlacement(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn IsDirectionReversed<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDirectionReversed() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDirectionReversed<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsDirectionReversed(value).into()
        }
        unsafe extern "system" fn IsThumbToolTipEnabled<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsThumbToolTipEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsThumbToolTipEnabled<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsThumbToolTipEnabled(value).into()
        }
        unsafe extern "system" fn ThumbToolTipValueConverter<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ThumbToolTipValueConverter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetThumbToolTipValueConverter<Impl: ISliderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetThumbToolTipValueConverter(&*(&value as *const <super::Data::IValueConverter as ::windows::core::Abi>::Abi as *const <super::Data::IValueConverter as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ISlider>,
            base.5,
            IntermediateValue::<Impl, OFFSET>,
            SetIntermediateValue::<Impl, OFFSET>,
            StepFrequency::<Impl, OFFSET>,
            SetStepFrequency::<Impl, OFFSET>,
            SnapsTo::<Impl, OFFSET>,
            SetSnapsTo::<Impl, OFFSET>,
            TickFrequency::<Impl, OFFSET>,
            SetTickFrequency::<Impl, OFFSET>,
            TickPlacement::<Impl, OFFSET>,
            SetTickPlacement::<Impl, OFFSET>,
            Orientation::<Impl, OFFSET>,
            SetOrientation::<Impl, OFFSET>,
            IsDirectionReversed::<Impl, OFFSET>,
            SetIsDirectionReversed::<Impl, OFFSET>,
            IsThumbToolTipEnabled::<Impl, OFFSET>,
            SetIsThumbToolTipEnabled::<Impl, OFFSET>,
            ThumbToolTipValueConverter::<Impl, OFFSET>,
            SetThumbToolTipValueConverter::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISlider2Impl: Sized {
    fn Header(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISlider2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISlider2";
}
#[cfg(feature = "implement_exclusive")]
impl ISlider2Vtbl {
    pub const fn new<Impl: ISlider2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISlider2Vtbl {
        unsafe extern "system" fn Header<Impl: ISlider2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: ISlider2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: ISlider2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: ISlider2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISlider2>, base.5, Header::<Impl, OFFSET>, SetHeader::<Impl, OFFSET>, HeaderTemplate::<Impl, OFFSET>, SetHeaderTemplate::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISliderFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<Slider>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISliderFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISliderFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISliderFactoryVtbl {
    pub const fn new<Impl: ISliderFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISliderFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISliderFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISliderFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISliderStaticsImpl: Sized {
    fn IntermediateValueProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StepFrequencyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SnapsToProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TickFrequencyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TickPlacementProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsDirectionReversedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsThumbToolTipEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ThumbToolTipValueConverterProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISliderStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISliderStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISliderStaticsVtbl {
    pub const fn new<Impl: ISliderStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISliderStaticsVtbl {
        unsafe extern "system" fn IntermediateValueProperty<Impl: ISliderStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IntermediateValueProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StepFrequencyProperty<Impl: ISliderStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StepFrequencyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SnapsToProperty<Impl: ISliderStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SnapsToProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TickFrequencyProperty<Impl: ISliderStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TickFrequencyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TickPlacementProperty<Impl: ISliderStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TickPlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: ISliderStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsDirectionReversedProperty<Impl: ISliderStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDirectionReversedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsThumbToolTipEnabledProperty<Impl: ISliderStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsThumbToolTipEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ThumbToolTipValueConverterProperty<Impl: ISliderStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ThumbToolTipValueConverterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISliderStatics>, base.5, IntermediateValueProperty::<Impl, OFFSET>, StepFrequencyProperty::<Impl, OFFSET>, SnapsToProperty::<Impl, OFFSET>, TickFrequencyProperty::<Impl, OFFSET>, TickPlacementProperty::<Impl, OFFSET>, OrientationProperty::<Impl, OFFSET>, IsDirectionReversedProperty::<Impl, OFFSET>, IsThumbToolTipEnabledProperty::<Impl, OFFSET>, ThumbToolTipValueConverterProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISliderStatics2Impl: Sized {
    fn HeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISliderStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISliderStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ISliderStatics2Vtbl {
    pub const fn new<Impl: ISliderStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISliderStatics2Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: ISliderStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: ISliderStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISliderStatics2>, base.5, HeaderProperty::<Impl, OFFSET>, HeaderTemplateProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitButtonImpl: Sized {
    fn Flyout(&self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetFlyout(&self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn Command(&self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetCommand(&self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn CommandParameter(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetCommandParameter(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn Click(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SplitButton, SplitButtonClickEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClick(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButton";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitButtonVtbl {
    pub const fn new<Impl: ISplitButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISplitButtonVtbl {
        unsafe extern "system" fn Flyout<Impl: ISplitButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Flyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFlyout<Impl: ISplitButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Command<Impl: ISplitButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Command() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommand<Impl: ISplitButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CommandParameter<Impl: ISplitButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommandParameter<Impl: ISplitButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Click<Impl: ISplitButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Click(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SplitButton, SplitButtonClickEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SplitButton, SplitButtonClickEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClick<Impl: ISplitButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveClick(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISplitButton>, base.5, Flyout::<Impl, OFFSET>, SetFlyout::<Impl, OFFSET>, Command::<Impl, OFFSET>, SetCommand::<Impl, OFFSET>, CommandParameter::<Impl, OFFSET>, SetCommandParameter::<Impl, OFFSET>, Click::<Impl, OFFSET>, RemoveClick::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitButtonAutomationPeerImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitButtonAutomationPeer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButtonAutomationPeer";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitButtonAutomationPeerVtbl {
    pub const fn new<Impl: ISplitButtonAutomationPeerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISplitButtonAutomationPeerVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISplitButtonAutomationPeer>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitButtonAutomationPeerFactoryImpl: Sized {
    fn CreateInstance(&self, owner: &::core::option::Option<SplitButton>, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SplitButtonAutomationPeer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitButtonAutomationPeerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButtonAutomationPeerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitButtonAutomationPeerFactoryVtbl {
    pub const fn new<Impl: ISplitButtonAutomationPeerFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISplitButtonAutomationPeerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISplitButtonAutomationPeerFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, owner: ::windows::core::RawPtr, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&owner as *const <SplitButton as ::windows::core::Abi>::Abi as *const <SplitButton as ::windows::core::DefaultType>::DefaultType), &*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISplitButtonAutomationPeerFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitButtonClickEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitButtonClickEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButtonClickEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitButtonClickEventArgsVtbl {
    pub const fn new<Impl: ISplitButtonClickEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISplitButtonClickEventArgsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISplitButtonClickEventArgs>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitButtonFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SplitButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitButtonFactoryVtbl {
    pub const fn new<Impl: ISplitButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISplitButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISplitButtonFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISplitButtonFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitButtonStaticsImpl: Sized {
    fn FlyoutProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandParameterProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitButtonStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitButtonStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitButtonStaticsVtbl {
    pub const fn new<Impl: ISplitButtonStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISplitButtonStaticsVtbl {
        unsafe extern "system" fn FlyoutProperty<Impl: ISplitButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandProperty<Impl: ISplitButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandParameterProperty<Impl: ISplitButtonStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISplitButtonStatics>, base.5, FlyoutProperty::<Impl, OFFSET>, CommandProperty::<Impl, OFFSET>, CommandParameterProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitViewImpl: Sized {
    fn Content(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetContent(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn Pane(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetPane(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn IsPaneOpen(&self) -> ::windows::core::Result<bool>;
    fn SetIsPaneOpen(&self, value: bool) -> ::windows::core::Result<()>;
    fn OpenPaneLength(&self) -> ::windows::core::Result<f64>;
    fn SetOpenPaneLength(&self, value: f64) -> ::windows::core::Result<()>;
    fn CompactPaneLength(&self) -> ::windows::core::Result<f64>;
    fn SetCompactPaneLength(&self, value: f64) -> ::windows::core::Result<()>;
    fn PanePlacement(&self) -> ::windows::core::Result<SplitViewPanePlacement>;
    fn SetPanePlacement(&self, value: SplitViewPanePlacement) -> ::windows::core::Result<()>;
    fn DisplayMode(&self) -> ::windows::core::Result<SplitViewDisplayMode>;
    fn SetDisplayMode(&self, value: SplitViewDisplayMode) -> ::windows::core::Result<()>;
    fn TemplateSettings(&self) -> ::windows::core::Result<Primitives::SplitViewTemplateSettings>;
    fn PaneBackground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetPaneBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn PaneClosing(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SplitView, SplitViewPaneClosingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneClosing(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneClosed(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneClosed(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitView";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitViewVtbl {
    pub const fn new<Impl: ISplitViewImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISplitViewVtbl {
        unsafe extern "system" fn Content<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Pane<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pane() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPane<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPane(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsPaneOpen<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPaneOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsPaneOpen<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsPaneOpen(value).into()
        }
        unsafe extern "system" fn OpenPaneLength<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OpenPaneLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOpenPaneLength<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOpenPaneLength(value).into()
        }
        unsafe extern "system" fn CompactPaneLength<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompactPaneLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCompactPaneLength<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCompactPaneLength(value).into()
        }
        unsafe extern "system" fn PanePlacement<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut SplitViewPanePlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PanePlacement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPanePlacement<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: SplitViewPanePlacement) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPanePlacement(value).into()
        }
        unsafe extern "system" fn DisplayMode<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut SplitViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayMode<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: SplitViewDisplayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDisplayMode(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneBackground<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneBackground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPaneBackground<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPaneBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneClosing<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneClosing(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SplitView, SplitViewPaneClosingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SplitView, SplitViewPaneClosingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneClosing<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePaneClosing(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneClosed<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneClosed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneClosed<Impl: ISplitViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePaneClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ISplitView>,
            base.5,
            Content::<Impl, OFFSET>,
            SetContent::<Impl, OFFSET>,
            Pane::<Impl, OFFSET>,
            SetPane::<Impl, OFFSET>,
            IsPaneOpen::<Impl, OFFSET>,
            SetIsPaneOpen::<Impl, OFFSET>,
            OpenPaneLength::<Impl, OFFSET>,
            SetOpenPaneLength::<Impl, OFFSET>,
            CompactPaneLength::<Impl, OFFSET>,
            SetCompactPaneLength::<Impl, OFFSET>,
            PanePlacement::<Impl, OFFSET>,
            SetPanePlacement::<Impl, OFFSET>,
            DisplayMode::<Impl, OFFSET>,
            SetDisplayMode::<Impl, OFFSET>,
            TemplateSettings::<Impl, OFFSET>,
            PaneBackground::<Impl, OFFSET>,
            SetPaneBackground::<Impl, OFFSET>,
            PaneClosing::<Impl, OFFSET>,
            RemovePaneClosing::<Impl, OFFSET>,
            PaneClosed::<Impl, OFFSET>,
            RemovePaneClosed::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitView2Impl: Sized {
    fn LightDismissOverlayMode(&self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitView2";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitView2Vtbl {
    pub const fn new<Impl: ISplitView2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISplitView2Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: ISplitView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: ISplitView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISplitView2>, base.5, LightDismissOverlayMode::<Impl, OFFSET>, SetLightDismissOverlayMode::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitView3Impl: Sized {
    fn PaneOpening(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneOpening(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PaneOpened(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaneOpened(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitView3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitView3";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitView3Vtbl {
    pub const fn new<Impl: ISplitView3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISplitView3Vtbl {
        unsafe extern "system" fn PaneOpening<Impl: ISplitView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneOpening(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneOpening<Impl: ISplitView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePaneOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PaneOpened<Impl: ISplitView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneOpened(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SplitView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaneOpened<Impl: ISplitView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePaneOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISplitView3>, base.5, PaneOpening::<Impl, OFFSET>, RemovePaneOpening::<Impl, OFFSET>, PaneOpened::<Impl, OFFSET>, RemovePaneOpened::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitViewFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SplitView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitViewFactoryVtbl {
    pub const fn new<Impl: ISplitViewFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISplitViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISplitViewFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISplitViewFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitViewPaneClosingEventArgsImpl: Sized {
    fn Cancel(&self) -> ::windows::core::Result<bool>;
    fn SetCancel(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitViewPaneClosingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitViewPaneClosingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitViewPaneClosingEventArgsVtbl {
    pub const fn new<Impl: ISplitViewPaneClosingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISplitViewPaneClosingEventArgsVtbl {
        unsafe extern "system" fn Cancel<Impl: ISplitViewPaneClosingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: ISplitViewPaneClosingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISplitViewPaneClosingEventArgs>, base.5, Cancel::<Impl, OFFSET>, SetCancel::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitViewStaticsImpl: Sized {
    fn ContentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsPaneOpenProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OpenPaneLengthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CompactPaneLengthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PanePlacementProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DisplayModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TemplateSettingsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaneBackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitViewStaticsVtbl {
    pub const fn new<Impl: ISplitViewStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISplitViewStaticsVtbl {
        unsafe extern "system" fn ContentProperty<Impl: ISplitViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneProperty<Impl: ISplitViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPaneOpenProperty<Impl: ISplitViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPaneOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpenPaneLengthProperty<Impl: ISplitViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OpenPaneLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompactPaneLengthProperty<Impl: ISplitViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompactPaneLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PanePlacementProperty<Impl: ISplitViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PanePlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisplayModeProperty<Impl: ISplitViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisplayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TemplateSettingsProperty<Impl: ISplitViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettingsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaneBackgroundProperty<Impl: ISplitViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaneBackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISplitViewStatics>, base.5, ContentProperty::<Impl, OFFSET>, PaneProperty::<Impl, OFFSET>, IsPaneOpenProperty::<Impl, OFFSET>, OpenPaneLengthProperty::<Impl, OFFSET>, CompactPaneLengthProperty::<Impl, OFFSET>, PanePlacementProperty::<Impl, OFFSET>, DisplayModeProperty::<Impl, OFFSET>, TemplateSettingsProperty::<Impl, OFFSET>, PaneBackgroundProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISplitViewStatics2Impl: Sized {
    fn LightDismissOverlayModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISplitViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISplitViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ISplitViewStatics2Vtbl {
    pub const fn new<Impl: ISplitViewStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISplitViewStatics2Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: ISplitViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISplitViewStatics2>, base.5, LightDismissOverlayModeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanelImpl: Sized {
    fn AreScrollSnapPointsRegular(&self) -> ::windows::core::Result<bool>;
    fn SetAreScrollSnapPointsRegular(&self, value: bool) -> ::windows::core::Result<()>;
    fn Orientation(&self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&self, value: Orientation) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanel";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanelVtbl {
    pub const fn new<Impl: IStackPanelImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStackPanelVtbl {
        unsafe extern "system" fn AreScrollSnapPointsRegular<Impl: IStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AreScrollSnapPointsRegular() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreScrollSnapPointsRegular<Impl: IStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAreScrollSnapPointsRegular(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: IStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStackPanel>, base.5, AreScrollSnapPointsRegular::<Impl, OFFSET>, SetAreScrollSnapPointsRegular::<Impl, OFFSET>, Orientation::<Impl, OFFSET>, SetOrientation::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanel2Impl: Sized {
    fn BorderBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBorderBrush(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn BorderThickness(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetBorderThickness(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn CornerRadius(&self) -> ::windows::core::Result<super::CornerRadius>;
    fn SetCornerRadius(&self, value: &super::CornerRadius) -> ::windows::core::Result<()>;
    fn Padding(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanel2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanel2";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanel2Vtbl {
    pub const fn new<Impl: IStackPanel2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStackPanel2Vtbl {
        unsafe extern "system" fn BorderBrush<Impl: IStackPanel2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderBrush<Impl: IStackPanel2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBorderBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BorderThickness<Impl: IStackPanel2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderThickness() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderThickness<Impl: IStackPanel2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBorderThickness(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CornerRadius<Impl: IStackPanel2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CornerRadius() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCornerRadius<Impl: IStackPanel2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::CornerRadius) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCornerRadius(&*(&value as *const <super::CornerRadius as ::windows::core::Abi>::Abi as *const <super::CornerRadius as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Padding<Impl: IStackPanel2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: IStackPanel2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStackPanel2>, base.5, BorderBrush::<Impl, OFFSET>, SetBorderBrush::<Impl, OFFSET>, BorderThickness::<Impl, OFFSET>, SetBorderThickness::<Impl, OFFSET>, CornerRadius::<Impl, OFFSET>, SetCornerRadius::<Impl, OFFSET>, Padding::<Impl, OFFSET>, SetPadding::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanel4Impl: Sized {
    fn Spacing(&self) -> ::windows::core::Result<f64>;
    fn SetSpacing(&self, value: f64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanel4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanel4";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanel4Vtbl {
    pub const fn new<Impl: IStackPanel4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStackPanel4Vtbl {
        unsafe extern "system" fn Spacing<Impl: IStackPanel4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Spacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSpacing<Impl: IStackPanel4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSpacing(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStackPanel4>, base.5, Spacing::<Impl, OFFSET>, SetSpacing::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanel5Impl: Sized {
    fn BackgroundSizing(&self) -> ::windows::core::Result<BackgroundSizing>;
    fn SetBackgroundSizing(&self, value: BackgroundSizing) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanel5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanel5";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanel5Vtbl {
    pub const fn new<Impl: IStackPanel5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStackPanel5Vtbl {
        unsafe extern "system" fn BackgroundSizing<Impl: IStackPanel5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundSizing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundSizing<Impl: IStackPanel5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: BackgroundSizing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBackgroundSizing(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStackPanel5>, base.5, BackgroundSizing::<Impl, OFFSET>, SetBackgroundSizing::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanelFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<StackPanel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanelFactoryVtbl {
    pub const fn new<Impl: IStackPanelFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStackPanelFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IStackPanelFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStackPanelFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanelStaticsImpl: Sized {
    fn AreScrollSnapPointsRegularProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanelStaticsVtbl {
    pub const fn new<Impl: IStackPanelStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStackPanelStaticsVtbl {
        unsafe extern "system" fn AreScrollSnapPointsRegularProperty<Impl: IStackPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AreScrollSnapPointsRegularProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IStackPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStackPanelStatics>, base.5, AreScrollSnapPointsRegularProperty::<Impl, OFFSET>, OrientationProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanelStatics2Impl: Sized {
    fn BorderBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BorderThicknessProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CornerRadiusProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanelStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanelStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanelStatics2Vtbl {
    pub const fn new<Impl: IStackPanelStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStackPanelStatics2Vtbl {
        unsafe extern "system" fn BorderBrushProperty<Impl: IStackPanelStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BorderThicknessProperty<Impl: IStackPanelStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BorderThicknessProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CornerRadiusProperty<Impl: IStackPanelStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CornerRadiusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: IStackPanelStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStackPanelStatics2>, base.5, BorderBrushProperty::<Impl, OFFSET>, BorderThicknessProperty::<Impl, OFFSET>, CornerRadiusProperty::<Impl, OFFSET>, PaddingProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanelStatics4Impl: Sized {
    fn SpacingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanelStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanelStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanelStatics4Vtbl {
    pub const fn new<Impl: IStackPanelStatics4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStackPanelStatics4Vtbl {
        unsafe extern "system" fn SpacingProperty<Impl: IStackPanelStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStackPanelStatics4>, base.5, SpacingProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStackPanelStatics5Impl: Sized {
    fn BackgroundSizingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStackPanelStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStackPanelStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IStackPanelStatics5Vtbl {
    pub const fn new<Impl: IStackPanelStatics5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStackPanelStatics5Vtbl {
        unsafe extern "system" fn BackgroundSizingProperty<Impl: IStackPanelStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundSizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStackPanelStatics5>, base.5, BackgroundSizingProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStyleSelectorImpl: Sized {
    fn SelectStyle(&self, item: &::core::option::Option<::windows::core::IInspectable>, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::Style>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStyleSelector {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStyleSelector";
}
#[cfg(feature = "implement_exclusive")]
impl IStyleSelectorVtbl {
    pub const fn new<Impl: IStyleSelectorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStyleSelectorVtbl {
        unsafe extern "system" fn SelectStyle<Impl: IStyleSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectStyle(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStyleSelector>, base.5, SelectStyle::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStyleSelectorFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<StyleSelector>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStyleSelectorFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStyleSelectorFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IStyleSelectorFactoryVtbl {
    pub const fn new<Impl: IStyleSelectorFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStyleSelectorFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IStyleSelectorFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStyleSelectorFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IStyleSelectorOverridesImpl: Sized {
    fn SelectStyleCore(&self, item: &::core::option::Option<::windows::core::IInspectable>, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::Style>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IStyleSelectorOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IStyleSelectorOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IStyleSelectorOverridesVtbl {
    pub const fn new<Impl: IStyleSelectorOverridesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IStyleSelectorOverridesVtbl {
        unsafe extern "system" fn SelectStyleCore<Impl: IStyleSelectorOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectStyleCore(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IStyleSelectorOverrides>, base.5, SelectStyleCore::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwapChainBackgroundPanelImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwapChainBackgroundPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainBackgroundPanel";
}
#[cfg(feature = "implement_exclusive")]
impl ISwapChainBackgroundPanelVtbl {
    pub const fn new<Impl: ISwapChainBackgroundPanelImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISwapChainBackgroundPanelVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISwapChainBackgroundPanel>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwapChainBackgroundPanel2Impl: Sized {
    fn CreateCoreIndependentInputSource(&self, devicetypes: super::super::Core::CoreInputDeviceTypes) -> ::windows::core::Result<super::super::Core::CoreIndependentInputSource>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwapChainBackgroundPanel2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainBackgroundPanel2";
}
#[cfg(feature = "implement_exclusive")]
impl ISwapChainBackgroundPanel2Vtbl {
    pub const fn new<Impl: ISwapChainBackgroundPanel2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISwapChainBackgroundPanel2Vtbl {
        unsafe extern "system" fn CreateCoreIndependentInputSource<Impl: ISwapChainBackgroundPanel2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, devicetypes: super::super::Core::CoreInputDeviceTypes, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateCoreIndependentInputSource(devicetypes) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISwapChainBackgroundPanel2>, base.5, CreateCoreIndependentInputSource::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwapChainBackgroundPanelFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SwapChainBackgroundPanel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwapChainBackgroundPanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainBackgroundPanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISwapChainBackgroundPanelFactoryVtbl {
    pub const fn new<Impl: ISwapChainBackgroundPanelFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISwapChainBackgroundPanelFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISwapChainBackgroundPanelFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISwapChainBackgroundPanelFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwapChainPanelImpl: Sized {
    fn CompositionScaleX(&self) -> ::windows::core::Result<f32>;
    fn CompositionScaleY(&self) -> ::windows::core::Result<f32>;
    fn CompositionScaleChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SwapChainPanel, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCompositionScaleChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn CreateCoreIndependentInputSource(&self, devicetypes: super::super::Core::CoreInputDeviceTypes) -> ::windows::core::Result<super::super::Core::CoreIndependentInputSource>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwapChainPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainPanel";
}
#[cfg(feature = "implement_exclusive")]
impl ISwapChainPanelVtbl {
    pub const fn new<Impl: ISwapChainPanelImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISwapChainPanelVtbl {
        unsafe extern "system" fn CompositionScaleX<Impl: ISwapChainPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompositionScaleX() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompositionScaleY<Impl: ISwapChainPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompositionScaleY() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompositionScaleChanged<Impl: ISwapChainPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompositionScaleChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SwapChainPanel, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SwapChainPanel, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCompositionScaleChanged<Impl: ISwapChainPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveCompositionScaleChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CreateCoreIndependentInputSource<Impl: ISwapChainPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, devicetypes: super::super::Core::CoreInputDeviceTypes, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateCoreIndependentInputSource(devicetypes) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISwapChainPanel>, base.5, CompositionScaleX::<Impl, OFFSET>, CompositionScaleY::<Impl, OFFSET>, CompositionScaleChanged::<Impl, OFFSET>, RemoveCompositionScaleChanged::<Impl, OFFSET>, CreateCoreIndependentInputSource::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwapChainPanelFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SwapChainPanel>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwapChainPanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainPanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISwapChainPanelFactoryVtbl {
    pub const fn new<Impl: ISwapChainPanelFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISwapChainPanelFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISwapChainPanelFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISwapChainPanelFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwapChainPanelStaticsImpl: Sized {
    fn CompositionScaleXProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CompositionScaleYProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwapChainPanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwapChainPanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISwapChainPanelStaticsVtbl {
    pub const fn new<Impl: ISwapChainPanelStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISwapChainPanelStaticsVtbl {
        unsafe extern "system" fn CompositionScaleXProperty<Impl: ISwapChainPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompositionScaleXProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompositionScaleYProperty<Impl: ISwapChainPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompositionScaleYProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISwapChainPanelStatics>, base.5, CompositionScaleXProperty::<Impl, OFFSET>, CompositionScaleYProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeControlImpl: Sized {
    fn LeftItems(&self) -> ::windows::core::Result<SwipeItems>;
    fn SetLeftItems(&self, value: &::core::option::Option<SwipeItems>) -> ::windows::core::Result<()>;
    fn RightItems(&self) -> ::windows::core::Result<SwipeItems>;
    fn SetRightItems(&self, value: &::core::option::Option<SwipeItems>) -> ::windows::core::Result<()>;
    fn TopItems(&self) -> ::windows::core::Result<SwipeItems>;
    fn SetTopItems(&self, value: &::core::option::Option<SwipeItems>) -> ::windows::core::Result<()>;
    fn BottomItems(&self) -> ::windows::core::Result<SwipeItems>;
    fn SetBottomItems(&self, value: &::core::option::Option<SwipeItems>) -> ::windows::core::Result<()>;
    fn Close(&self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeControl";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeControlVtbl {
    pub const fn new<Impl: ISwipeControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISwipeControlVtbl {
        unsafe extern "system" fn LeftItems<Impl: ISwipeControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LeftItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLeftItems<Impl: ISwipeControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLeftItems(&*(&value as *const <SwipeItems as ::windows::core::Abi>::Abi as *const <SwipeItems as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RightItems<Impl: ISwipeControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RightItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRightItems<Impl: ISwipeControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetRightItems(&*(&value as *const <SwipeItems as ::windows::core::Abi>::Abi as *const <SwipeItems as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TopItems<Impl: ISwipeControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TopItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTopItems<Impl: ISwipeControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTopItems(&*(&value as *const <SwipeItems as ::windows::core::Abi>::Abi as *const <SwipeItems as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BottomItems<Impl: ISwipeControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BottomItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBottomItems<Impl: ISwipeControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBottomItems(&*(&value as *const <SwipeItems as ::windows::core::Abi>::Abi as *const <SwipeItems as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Close<Impl: ISwipeControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Close().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISwipeControl>, base.5, LeftItems::<Impl, OFFSET>, SetLeftItems::<Impl, OFFSET>, RightItems::<Impl, OFFSET>, SetRightItems::<Impl, OFFSET>, TopItems::<Impl, OFFSET>, SetTopItems::<Impl, OFFSET>, BottomItems::<Impl, OFFSET>, SetBottomItems::<Impl, OFFSET>, Close::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeControlFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SwipeControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeControlFactoryVtbl {
    pub const fn new<Impl: ISwipeControlFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISwipeControlFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISwipeControlFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISwipeControlFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeControlStaticsImpl: Sized {
    fn LeftItemsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RightItemsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TopItemsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BottomItemsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeControlStaticsVtbl {
    pub const fn new<Impl: ISwipeControlStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISwipeControlStaticsVtbl {
        unsafe extern "system" fn LeftItemsProperty<Impl: ISwipeControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LeftItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RightItemsProperty<Impl: ISwipeControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RightItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TopItemsProperty<Impl: ISwipeControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TopItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BottomItemsProperty<Impl: ISwipeControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BottomItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISwipeControlStatics>, base.5, LeftItemsProperty::<Impl, OFFSET>, RightItemsProperty::<Impl, OFFSET>, TopItemsProperty::<Impl, OFFSET>, BottomItemsProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemImpl: Sized {
    fn Text(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn IconSource(&self) -> ::windows::core::Result<IconSource>;
    fn SetIconSource(&self, value: &::core::option::Option<IconSource>) -> ::windows::core::Result<()>;
    fn Background(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetBackground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn Foreground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn Command(&self) -> ::windows::core::Result<super::Input::ICommand>;
    fn SetCommand(&self, value: &::core::option::Option<super::Input::ICommand>) -> ::windows::core::Result<()>;
    fn CommandParameter(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetCommandParameter(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn BehaviorOnInvoked(&self) -> ::windows::core::Result<SwipeBehaviorOnInvoked>;
    fn SetBehaviorOnInvoked(&self, value: SwipeBehaviorOnInvoked) -> ::windows::core::Result<()>;
    fn Invoked(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<SwipeItem, SwipeItemInvokedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveInvoked(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItem";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemVtbl {
    pub const fn new<Impl: ISwipeItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISwipeItemVtbl {
        unsafe extern "system" fn Text<Impl: ISwipeItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: ISwipeItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IconSource<Impl: ISwipeItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IconSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIconSource<Impl: ISwipeItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIconSource(&*(&value as *const <IconSource as ::windows::core::Abi>::Abi as *const <IconSource as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Background<Impl: ISwipeItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Background() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackground<Impl: ISwipeItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBackground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Foreground<Impl: ISwipeItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: ISwipeItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Command<Impl: ISwipeItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Command() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommand<Impl: ISwipeItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCommand(&*(&value as *const <super::Input::ICommand as ::windows::core::Abi>::Abi as *const <super::Input::ICommand as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CommandParameter<Impl: ISwipeItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CommandParameter() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCommandParameter<Impl: ISwipeItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCommandParameter(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BehaviorOnInvoked<Impl: ISwipeItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut SwipeBehaviorOnInvoked) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BehaviorOnInvoked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBehaviorOnInvoked<Impl: ISwipeItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: SwipeBehaviorOnInvoked) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetBehaviorOnInvoked(value).into()
        }
        unsafe extern "system" fn Invoked<Impl: ISwipeItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Invoked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<SwipeItem, SwipeItemInvokedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<SwipeItem, SwipeItemInvokedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveInvoked<Impl: ISwipeItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveInvoked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ISwipeItem>,
            base.5,
            Text::<Impl, OFFSET>,
            SetText::<Impl, OFFSET>,
            IconSource::<Impl, OFFSET>,
            SetIconSource::<Impl, OFFSET>,
            Background::<Impl, OFFSET>,
            SetBackground::<Impl, OFFSET>,
            Foreground::<Impl, OFFSET>,
            SetForeground::<Impl, OFFSET>,
            Command::<Impl, OFFSET>,
            SetCommand::<Impl, OFFSET>,
            CommandParameter::<Impl, OFFSET>,
            SetCommandParameter::<Impl, OFFSET>,
            BehaviorOnInvoked::<Impl, OFFSET>,
            SetBehaviorOnInvoked::<Impl, OFFSET>,
            Invoked::<Impl, OFFSET>,
            RemoveInvoked::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SwipeItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemFactoryVtbl {
    pub const fn new<Impl: ISwipeItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISwipeItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISwipeItemFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISwipeItemFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemInvokedEventArgsImpl: Sized {
    fn SwipeControl(&self) -> ::windows::core::Result<SwipeControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItemInvokedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItemInvokedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemInvokedEventArgsVtbl {
    pub const fn new<Impl: ISwipeItemInvokedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISwipeItemInvokedEventArgsVtbl {
        unsafe extern "system" fn SwipeControl<Impl: ISwipeItemInvokedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SwipeControl() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISwipeItemInvokedEventArgs>, base.5, SwipeControl::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemStaticsImpl: Sized {
    fn IconSourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BackgroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CommandParameterProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn BehaviorOnInvokedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemStaticsVtbl {
    pub const fn new<Impl: ISwipeItemStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISwipeItemStaticsVtbl {
        unsafe extern "system" fn IconSourceProperty<Impl: ISwipeItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IconSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextProperty<Impl: ISwipeItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BackgroundProperty<Impl: ISwipeItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BackgroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForegroundProperty<Impl: ISwipeItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandProperty<Impl: ISwipeItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CommandProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommandParameterProperty<Impl: ISwipeItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CommandParameterProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BehaviorOnInvokedProperty<Impl: ISwipeItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BehaviorOnInvokedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISwipeItemStatics>, base.5, IconSourceProperty::<Impl, OFFSET>, TextProperty::<Impl, OFFSET>, BackgroundProperty::<Impl, OFFSET>, ForegroundProperty::<Impl, OFFSET>, CommandProperty::<Impl, OFFSET>, CommandParameterProperty::<Impl, OFFSET>, BehaviorOnInvokedProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemsImpl: Sized {
    fn Mode(&self) -> ::windows::core::Result<SwipeMode>;
    fn SetMode(&self, value: SwipeMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItems {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItems";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemsVtbl {
    pub const fn new<Impl: ISwipeItemsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISwipeItemsVtbl {
        unsafe extern "system" fn Mode<Impl: ISwipeItemsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut SwipeMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Mode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMode<Impl: ISwipeItemsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: SwipeMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMode(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISwipeItems>, base.5, Mode::<Impl, OFFSET>, SetMode::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemsFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SwipeItems>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItemsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItemsFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemsFactoryVtbl {
    pub const fn new<Impl: ISwipeItemsFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISwipeItemsFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISwipeItemsFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISwipeItemsFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISwipeItemsStaticsImpl: Sized {
    fn ModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISwipeItemsStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISwipeItemsStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISwipeItemsStaticsVtbl {
    pub const fn new<Impl: ISwipeItemsStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISwipeItemsStaticsVtbl {
        unsafe extern "system" fn ModeProperty<Impl: ISwipeItemsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISwipeItemsStatics>, base.5, ModeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIconImpl: Sized {
    fn Symbol(&self) -> ::windows::core::Result<Symbol>;
    fn SetSymbol(&self, value: Symbol) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIcon {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIcon";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIconVtbl {
    pub const fn new<Impl: ISymbolIconImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISymbolIconVtbl {
        unsafe extern "system" fn Symbol<Impl: ISymbolIconImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Symbol) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Symbol() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSymbol<Impl: ISymbolIconImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Symbol) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSymbol(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISymbolIcon>, base.5, Symbol::<Impl, OFFSET>, SetSymbol::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIconFactoryImpl: Sized {
    fn CreateInstanceWithSymbol(&self, symbol: Symbol) -> ::windows::core::Result<SymbolIcon>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIconFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIconFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIconFactoryVtbl {
    pub const fn new<Impl: ISymbolIconFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISymbolIconFactoryVtbl {
        unsafe extern "system" fn CreateInstanceWithSymbol<Impl: ISymbolIconFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, symbol: Symbol, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstanceWithSymbol(symbol) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISymbolIconFactory>, base.5, CreateInstanceWithSymbol::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIconSourceImpl: Sized {
    fn Symbol(&self) -> ::windows::core::Result<Symbol>;
    fn SetSymbol(&self, value: Symbol) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIconSource {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIconSource";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIconSourceVtbl {
    pub const fn new<Impl: ISymbolIconSourceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISymbolIconSourceVtbl {
        unsafe extern "system" fn Symbol<Impl: ISymbolIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Symbol) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Symbol() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSymbol<Impl: ISymbolIconSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Symbol) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSymbol(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISymbolIconSource>, base.5, Symbol::<Impl, OFFSET>, SetSymbol::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIconSourceFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<SymbolIconSource>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIconSourceFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIconSourceFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIconSourceFactoryVtbl {
    pub const fn new<Impl: ISymbolIconSourceFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISymbolIconSourceFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ISymbolIconSourceFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISymbolIconSourceFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIconSourceStaticsImpl: Sized {
    fn SymbolProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIconSourceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIconSourceStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIconSourceStaticsVtbl {
    pub const fn new<Impl: ISymbolIconSourceStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISymbolIconSourceStaticsVtbl {
        unsafe extern "system" fn SymbolProperty<Impl: ISymbolIconSourceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SymbolProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISymbolIconSourceStatics>, base.5, SymbolProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ISymbolIconStaticsImpl: Sized {
    fn SymbolProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ISymbolIconStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ISymbolIconStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ISymbolIconStaticsVtbl {
    pub const fn new<Impl: ISymbolIconStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ISymbolIconStaticsVtbl {
        unsafe extern "system" fn SymbolProperty<Impl: ISymbolIconStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SymbolProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ISymbolIconStatics>, base.5, SymbolProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockImpl: Sized {
    fn FontSize(&self) -> ::windows::core::Result<f64>;
    fn SetFontSize(&self, value: f64) -> ::windows::core::Result<()>;
    fn FontFamily(&self) -> ::windows::core::Result<super::Media::FontFamily>;
    fn SetFontFamily(&self, value: &::core::option::Option<super::Media::FontFamily>) -> ::windows::core::Result<()>;
    fn FontWeight(&self) -> ::windows::core::Result<super::super::Text::FontWeight>;
    fn SetFontWeight(&self, value: &super::super::Text::FontWeight) -> ::windows::core::Result<()>;
    fn FontStyle(&self) -> ::windows::core::Result<super::super::Text::FontStyle>;
    fn SetFontStyle(&self, value: super::super::Text::FontStyle) -> ::windows::core::Result<()>;
    fn FontStretch(&self) -> ::windows::core::Result<super::super::Text::FontStretch>;
    fn SetFontStretch(&self, value: super::super::Text::FontStretch) -> ::windows::core::Result<()>;
    fn CharacterSpacing(&self) -> ::windows::core::Result<i32>;
    fn SetCharacterSpacing(&self, value: i32) -> ::windows::core::Result<()>;
    fn Foreground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn TextWrapping(&self) -> ::windows::core::Result<super::TextWrapping>;
    fn SetTextWrapping(&self, value: super::TextWrapping) -> ::windows::core::Result<()>;
    fn TextTrimming(&self) -> ::windows::core::Result<super::TextTrimming>;
    fn SetTextTrimming(&self, value: super::TextTrimming) -> ::windows::core::Result<()>;
    fn TextAlignment(&self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetTextAlignment(&self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn Text(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Inlines(&self) -> ::windows::core::Result<super::Documents::InlineCollection>;
    fn Padding(&self) -> ::windows::core::Result<super::Thickness>;
    fn SetPadding(&self, value: &super::Thickness) -> ::windows::core::Result<()>;
    fn LineHeight(&self) -> ::windows::core::Result<f64>;
    fn SetLineHeight(&self, value: f64) -> ::windows::core::Result<()>;
    fn LineStackingStrategy(&self) -> ::windows::core::Result<super::LineStackingStrategy>;
    fn SetLineStackingStrategy(&self, value: super::LineStackingStrategy) -> ::windows::core::Result<()>;
    fn IsTextSelectionEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsTextSelectionEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn SelectedText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn ContentStart(&self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn ContentEnd(&self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn SelectionStart(&self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn SelectionEnd(&self) -> ::windows::core::Result<super::Documents::TextPointer>;
    fn BaselineOffset(&self) -> ::windows::core::Result<f64>;
    fn SelectionChanged(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContextMenuOpening(&self, handler: &::core::option::Option<ContextMenuOpeningEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContextMenuOpening(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectAll(&self) -> ::windows::core::Result<()>;
    fn Select(&self, start: &::core::option::Option<super::Documents::TextPointer>, end: &::core::option::Option<super::Documents::TextPointer>) -> ::windows::core::Result<()>;
    fn Focus(&self, value: super::FocusState) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlock {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockVtbl {
    pub const fn new<Impl: ITextBlockImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBlockVtbl {
        unsafe extern "system" fn FontSize<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontSize<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontSize(value).into()
        }
        unsafe extern "system" fn FontFamily<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontFamily<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontFamily(&*(&value as *const <super::Media::FontFamily as ::windows::core::Abi>::Abi as *const <super::Media::FontFamily as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontWeight<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontWeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontWeight<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontWeight) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontWeight(&*(&value as *const <super::super::Text::FontWeight as ::windows::core::Abi>::Abi as *const <super::super::Text::FontWeight as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FontStyle<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStyle<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStyle) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontStyle(value).into()
        }
        unsafe extern "system" fn FontStretch<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFontStretch<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::FontStretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetFontStretch(value).into()
        }
        unsafe extern "system" fn CharacterSpacing<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CharacterSpacing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterSpacing<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCharacterSpacing(value).into()
        }
        unsafe extern "system" fn Foreground<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Foreground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetForeground<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextWrapping<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextWrapping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextWrapping<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextWrapping(value).into()
        }
        unsafe extern "system" fn TextTrimming<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextTrimming) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextTrimming() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextTrimming<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextTrimming) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextTrimming(value).into()
        }
        unsafe extern "system" fn TextAlignment<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextAlignment<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextAlignment(value).into()
        }
        unsafe extern "system" fn Text<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Inlines<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Inlines() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Padding<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Padding() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPadding<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPadding(&*(&value as *const <super::Thickness as ::windows::core::Abi>::Abi as *const <super::Thickness as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LineHeight<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LineHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineHeight<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLineHeight(value).into()
        }
        unsafe extern "system" fn LineStackingStrategy<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategy() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLineStackingStrategy<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::LineStackingStrategy) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLineStackingStrategy(value).into()
        }
        unsafe extern "system" fn IsTextSelectionEnabled<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextSelectionEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextSelectionEnabled<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsTextSelectionEnabled(value).into()
        }
        unsafe extern "system" fn SelectedText<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentStart<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContentEnd<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionStart<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionEnd<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BaselineOffset<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BaselineOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionChanged<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContextMenuOpening<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContextMenuOpening(&*(&handler as *const <ContextMenuOpeningEventHandler as ::windows::core::Abi>::Abi as *const <ContextMenuOpeningEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContextMenuOpening<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveContextMenuOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        unsafe extern "system" fn Select<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, start: ::windows::core::RawPtr, end: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Select(&*(&start as *const <super::Documents::TextPointer as ::windows::core::Abi>::Abi as *const <super::Documents::TextPointer as ::windows::core::DefaultType>::DefaultType), &*(&end as *const <super::Documents::TextPointer as ::windows::core::Abi>::Abi as *const <super::Documents::TextPointer as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Focus<Impl: ITextBlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::FocusState, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Focus(value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ITextBlock>,
            base.5,
            FontSize::<Impl, OFFSET>,
            SetFontSize::<Impl, OFFSET>,
            FontFamily::<Impl, OFFSET>,
            SetFontFamily::<Impl, OFFSET>,
            FontWeight::<Impl, OFFSET>,
            SetFontWeight::<Impl, OFFSET>,
            FontStyle::<Impl, OFFSET>,
            SetFontStyle::<Impl, OFFSET>,
            FontStretch::<Impl, OFFSET>,
            SetFontStretch::<Impl, OFFSET>,
            CharacterSpacing::<Impl, OFFSET>,
            SetCharacterSpacing::<Impl, OFFSET>,
            Foreground::<Impl, OFFSET>,
            SetForeground::<Impl, OFFSET>,
            TextWrapping::<Impl, OFFSET>,
            SetTextWrapping::<Impl, OFFSET>,
            TextTrimming::<Impl, OFFSET>,
            SetTextTrimming::<Impl, OFFSET>,
            TextAlignment::<Impl, OFFSET>,
            SetTextAlignment::<Impl, OFFSET>,
            Text::<Impl, OFFSET>,
            SetText::<Impl, OFFSET>,
            Inlines::<Impl, OFFSET>,
            Padding::<Impl, OFFSET>,
            SetPadding::<Impl, OFFSET>,
            LineHeight::<Impl, OFFSET>,
            SetLineHeight::<Impl, OFFSET>,
            LineStackingStrategy::<Impl, OFFSET>,
            SetLineStackingStrategy::<Impl, OFFSET>,
            IsTextSelectionEnabled::<Impl, OFFSET>,
            SetIsTextSelectionEnabled::<Impl, OFFSET>,
            SelectedText::<Impl, OFFSET>,
            ContentStart::<Impl, OFFSET>,
            ContentEnd::<Impl, OFFSET>,
            SelectionStart::<Impl, OFFSET>,
            SelectionEnd::<Impl, OFFSET>,
            BaselineOffset::<Impl, OFFSET>,
            SelectionChanged::<Impl, OFFSET>,
            RemoveSelectionChanged::<Impl, OFFSET>,
            ContextMenuOpening::<Impl, OFFSET>,
            RemoveContextMenuOpening::<Impl, OFFSET>,
            SelectAll::<Impl, OFFSET>,
            Select::<Impl, OFFSET>,
            Focus::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlock2Impl: Sized {
    fn SelectionHighlightColor(&self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColor(&self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn MaxLines(&self) -> ::windows::core::Result<i32>;
    fn SetMaxLines(&self, value: i32) -> ::windows::core::Result<()>;
    fn TextLineBounds(&self) -> ::windows::core::Result<super::TextLineBounds>;
    fn SetTextLineBounds(&self, value: super::TextLineBounds) -> ::windows::core::Result<()>;
    fn OpticalMarginAlignment(&self) -> ::windows::core::Result<super::OpticalMarginAlignment>;
    fn SetOpticalMarginAlignment(&self, value: super::OpticalMarginAlignment) -> ::windows::core::Result<()>;
    fn IsColorFontEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsColorFontEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn TextReadingOrder(&self) -> ::windows::core::Result<super::TextReadingOrder>;
    fn SetTextReadingOrder(&self, value: super::TextReadingOrder) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlock2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock2";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlock2Vtbl {
    pub const fn new<Impl: ITextBlock2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBlock2Vtbl {
        unsafe extern "system" fn SelectionHighlightColor<Impl: ITextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColor<Impl: ITextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MaxLines<Impl: ITextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxLines() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLines<Impl: ITextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxLines(value).into()
        }
        unsafe extern "system" fn TextLineBounds<Impl: ITextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextLineBounds() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextLineBounds<Impl: ITextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextLineBounds) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextLineBounds(value).into()
        }
        unsafe extern "system" fn OpticalMarginAlignment<Impl: ITextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOpticalMarginAlignment<Impl: ITextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::OpticalMarginAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOpticalMarginAlignment(value).into()
        }
        unsafe extern "system" fn IsColorFontEnabled<Impl: ITextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorFontEnabled<Impl: ITextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsColorFontEnabled(value).into()
        }
        unsafe extern "system" fn TextReadingOrder<Impl: ITextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextReadingOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextReadingOrder<Impl: ITextBlock2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextReadingOrder(value).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ITextBlock2>,
            base.5,
            SelectionHighlightColor::<Impl, OFFSET>,
            SetSelectionHighlightColor::<Impl, OFFSET>,
            MaxLines::<Impl, OFFSET>,
            SetMaxLines::<Impl, OFFSET>,
            TextLineBounds::<Impl, OFFSET>,
            SetTextLineBounds::<Impl, OFFSET>,
            OpticalMarginAlignment::<Impl, OFFSET>,
            SetOpticalMarginAlignment::<Impl, OFFSET>,
            IsColorFontEnabled::<Impl, OFFSET>,
            SetIsColorFontEnabled::<Impl, OFFSET>,
            TextReadingOrder::<Impl, OFFSET>,
            SetTextReadingOrder::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlock3Impl: Sized {
    fn IsTextScaleFactorEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsTextScaleFactorEnabled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlock3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock3";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlock3Vtbl {
    pub const fn new<Impl: ITextBlock3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBlock3Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabled<Impl: ITextBlock3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextScaleFactorEnabled<Impl: ITextBlock3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsTextScaleFactorEnabled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBlock3>, base.5, IsTextScaleFactorEnabled::<Impl, OFFSET>, SetIsTextScaleFactorEnabled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlock4Impl: Sized {
    fn GetAlphaMask(&self) -> ::windows::core::Result<super::super::Composition::CompositionBrush>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlock4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock4";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlock4Vtbl {
    pub const fn new<Impl: ITextBlock4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBlock4Vtbl {
        unsafe extern "system" fn GetAlphaMask<Impl: ITextBlock4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlphaMask() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBlock4>, base.5, GetAlphaMask::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlock5Impl: Sized {
    fn TextDecorations(&self) -> ::windows::core::Result<super::super::Text::TextDecorations>;
    fn SetTextDecorations(&self, value: super::super::Text::TextDecorations) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlock5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock5";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlock5Vtbl {
    pub const fn new<Impl: ITextBlock5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBlock5Vtbl {
        unsafe extern "system" fn TextDecorations<Impl: ITextBlock5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Text::TextDecorations) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextDecorations() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextDecorations<Impl: ITextBlock5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Text::TextDecorations) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextDecorations(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBlock5>, base.5, TextDecorations::<Impl, OFFSET>, SetTextDecorations::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlock6Impl: Sized {
    fn IsTextTrimmed(&self) -> ::windows::core::Result<bool>;
    fn HorizontalTextAlignment(&self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetHorizontalTextAlignment(&self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn TextHighlighters(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::Documents::TextHighlighter>>;
    fn IsTextTrimmedChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBlock, IsTextTrimmedChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsTextTrimmedChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlock6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock6";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlock6Vtbl {
    pub const fn new<Impl: ITextBlock6Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBlock6Vtbl {
        unsafe extern "system" fn IsTextTrimmed<Impl: ITextBlock6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmed() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalTextAlignment<Impl: ITextBlock6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalTextAlignment<Impl: ITextBlock6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalTextAlignment(value).into()
        }
        unsafe extern "system" fn TextHighlighters<Impl: ITextBlock6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextHighlighters() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextTrimmedChanged<Impl: ITextBlock6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBlock, IsTextTrimmedChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBlock, IsTextTrimmedChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsTextTrimmedChanged<Impl: ITextBlock6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveIsTextTrimmedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBlock6>, base.5, IsTextTrimmed::<Impl, OFFSET>, HorizontalTextAlignment::<Impl, OFFSET>, SetHorizontalTextAlignment::<Impl, OFFSET>, TextHighlighters::<Impl, OFFSET>, IsTextTrimmedChanged::<Impl, OFFSET>, RemoveIsTextTrimmedChanged::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlock7Impl: Sized {
    fn SelectionFlyout(&self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetSelectionFlyout(&self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn CopySelectionToClipboard(&self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlock7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlock7";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlock7Vtbl {
    pub const fn new<Impl: ITextBlock7Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBlock7Vtbl {
        unsafe extern "system" fn SelectionFlyout<Impl: ITextBlock7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFlyout<Impl: ITextBlock7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CopySelectionToClipboard<Impl: ITextBlock7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).CopySelectionToClipboard().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBlock7>, base.5, SelectionFlyout::<Impl, OFFSET>, SetSelectionFlyout::<Impl, OFFSET>, CopySelectionToClipboard::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStaticsImpl: Sized {
    fn FontSizeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontFamilyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontWeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn FontStretchProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterSpacingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextWrappingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextTrimmingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PaddingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineHeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn LineStackingStrategyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextSelectionEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectedTextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStaticsVtbl {
    pub const fn new<Impl: ITextBlockStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBlockStaticsVtbl {
        unsafe extern "system" fn FontSizeProperty<Impl: ITextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontFamilyProperty<Impl: ITextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontFamilyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontWeightProperty<Impl: ITextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontWeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStyleProperty<Impl: ITextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FontStretchProperty<Impl: ITextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FontStretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterSpacingProperty<Impl: ITextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CharacterSpacingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ForegroundProperty<Impl: ITextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextWrappingProperty<Impl: ITextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextWrappingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextTrimmingProperty<Impl: ITextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextTrimmingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextAlignmentProperty<Impl: ITextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextProperty<Impl: ITextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PaddingProperty<Impl: ITextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PaddingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineHeightProperty<Impl: ITextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LineHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LineStackingStrategyProperty<Impl: ITextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LineStackingStrategyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextSelectionEnabledProperty<Impl: ITextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextSelectionEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectedTextProperty<Impl: ITextBlockStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ITextBlockStatics>,
            base.5,
            FontSizeProperty::<Impl, OFFSET>,
            FontFamilyProperty::<Impl, OFFSET>,
            FontWeightProperty::<Impl, OFFSET>,
            FontStyleProperty::<Impl, OFFSET>,
            FontStretchProperty::<Impl, OFFSET>,
            CharacterSpacingProperty::<Impl, OFFSET>,
            ForegroundProperty::<Impl, OFFSET>,
            TextWrappingProperty::<Impl, OFFSET>,
            TextTrimmingProperty::<Impl, OFFSET>,
            TextAlignmentProperty::<Impl, OFFSET>,
            TextProperty::<Impl, OFFSET>,
            PaddingProperty::<Impl, OFFSET>,
            LineHeightProperty::<Impl, OFFSET>,
            LineStackingStrategyProperty::<Impl, OFFSET>,
            IsTextSelectionEnabledProperty::<Impl, OFFSET>,
            SelectedTextProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStatics2Impl: Sized {
    fn SelectionHighlightColorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxLinesProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextLineBoundsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OpticalMarginAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorFontEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextReadingOrderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStatics2Vtbl {
    pub const fn new<Impl: ITextBlockStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBlockStatics2Vtbl {
        unsafe extern "system" fn SelectionHighlightColorProperty<Impl: ITextBlockStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxLinesProperty<Impl: ITextBlockStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxLinesProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextLineBoundsProperty<Impl: ITextBlockStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextLineBoundsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpticalMarginAlignmentProperty<Impl: ITextBlockStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OpticalMarginAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorFontEnabledProperty<Impl: ITextBlockStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextReadingOrderProperty<Impl: ITextBlockStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextReadingOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBlockStatics2>, base.5, SelectionHighlightColorProperty::<Impl, OFFSET>, MaxLinesProperty::<Impl, OFFSET>, TextLineBoundsProperty::<Impl, OFFSET>, OpticalMarginAlignmentProperty::<Impl, OFFSET>, IsColorFontEnabledProperty::<Impl, OFFSET>, TextReadingOrderProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStatics3Impl: Sized {
    fn IsTextScaleFactorEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStatics3Vtbl {
    pub const fn new<Impl: ITextBlockStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBlockStatics3Vtbl {
        unsafe extern "system" fn IsTextScaleFactorEnabledProperty<Impl: ITextBlockStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextScaleFactorEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBlockStatics3>, base.5, IsTextScaleFactorEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStatics5Impl: Sized {
    fn TextDecorationsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStatics5Vtbl {
    pub const fn new<Impl: ITextBlockStatics5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBlockStatics5Vtbl {
        unsafe extern "system" fn TextDecorationsProperty<Impl: ITextBlockStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextDecorationsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBlockStatics5>, base.5, TextDecorationsProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStatics6Impl: Sized {
    fn IsTextTrimmedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalTextAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics6";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStatics6Vtbl {
    pub const fn new<Impl: ITextBlockStatics6Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBlockStatics6Vtbl {
        unsafe extern "system" fn IsTextTrimmedProperty<Impl: ITextBlockStatics6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextTrimmedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalTextAlignmentProperty<Impl: ITextBlockStatics6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBlockStatics6>, base.5, IsTextTrimmedProperty::<Impl, OFFSET>, HorizontalTextAlignmentProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBlockStatics7Impl: Sized {
    fn SelectionFlyoutProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBlockStatics7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBlockStatics7";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBlockStatics7Vtbl {
    pub const fn new<Impl: ITextBlockStatics7Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBlockStatics7Vtbl {
        unsafe extern "system" fn SelectionFlyoutProperty<Impl: ITextBlockStatics7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBlockStatics7>, base.5, SelectionFlyoutProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxImpl: Sized {
    fn Text(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectedText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSelectedText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectionLength(&self) -> ::windows::core::Result<i32>;
    fn SetSelectionLength(&self, value: i32) -> ::windows::core::Result<()>;
    fn SelectionStart(&self) -> ::windows::core::Result<i32>;
    fn SetSelectionStart(&self, value: i32) -> ::windows::core::Result<()>;
    fn MaxLength(&self) -> ::windows::core::Result<i32>;
    fn SetMaxLength(&self, value: i32) -> ::windows::core::Result<()>;
    fn IsReadOnly(&self) -> ::windows::core::Result<bool>;
    fn SetIsReadOnly(&self, value: bool) -> ::windows::core::Result<()>;
    fn AcceptsReturn(&self) -> ::windows::core::Result<bool>;
    fn SetAcceptsReturn(&self, value: bool) -> ::windows::core::Result<()>;
    fn TextAlignment(&self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetTextAlignment(&self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn TextWrapping(&self) -> ::windows::core::Result<super::TextWrapping>;
    fn SetTextWrapping(&self, value: super::TextWrapping) -> ::windows::core::Result<()>;
    fn IsSpellCheckEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsSpellCheckEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsTextPredictionEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsTextPredictionEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn InputScope(&self) -> ::windows::core::Result<super::Input::InputScope>;
    fn SetInputScope(&self, value: &::core::option::Option<super::Input::InputScope>) -> ::windows::core::Result<()>;
    fn TextChanged(&self, handler: &::core::option::Option<TextChangedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn SelectionChanged(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContextMenuOpening(&self, handler: &::core::option::Option<ContextMenuOpeningEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContextMenuOpening(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Select(&self, start: i32, length: i32) -> ::windows::core::Result<()>;
    fn SelectAll(&self) -> ::windows::core::Result<()>;
    fn GetRectFromCharacterIndex(&self, charindex: i32, trailingedge: bool) -> ::windows::core::Result<super::super::super::Foundation::Rect>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxVtbl {
    pub const fn new<Impl: ITextBoxImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBoxVtbl {
        unsafe extern "system" fn Text<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Text() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetText<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedText<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedText<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionLength<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionLength<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionLength(value).into()
        }
        unsafe extern "system" fn SelectionStart<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionStart<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionStart(value).into()
        }
        unsafe extern "system" fn MaxLength<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaxLength<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaxLength(value).into()
        }
        unsafe extern "system" fn IsReadOnly<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsReadOnly() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsReadOnly<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsReadOnly(value).into()
        }
        unsafe extern "system" fn AcceptsReturn<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AcceptsReturn() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAcceptsReturn<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAcceptsReturn(value).into()
        }
        unsafe extern "system" fn TextAlignment<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextAlignment<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextAlignment(value).into()
        }
        unsafe extern "system" fn TextWrapping<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextWrapping() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextWrapping<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextWrapping) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextWrapping(value).into()
        }
        unsafe extern "system" fn IsSpellCheckEnabled<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSpellCheckEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsSpellCheckEnabled<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsSpellCheckEnabled(value).into()
        }
        unsafe extern "system" fn IsTextPredictionEnabled<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextPredictionEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsTextPredictionEnabled<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsTextPredictionEnabled(value).into()
        }
        unsafe extern "system" fn InputScope<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InputScope() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputScope<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetInputScope(&*(&value as *const <super::Input::InputScope as ::windows::core::Abi>::Abi as *const <super::Input::InputScope as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextChanged<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextChanged(&*(&handler as *const <TextChangedEventHandler as ::windows::core::Abi>::Abi as *const <TextChangedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextChanged<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveTextChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionChanged<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionChanged(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanged<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContextMenuOpening<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContextMenuOpening(&*(&handler as *const <ContextMenuOpeningEventHandler as ::windows::core::Abi>::Abi as *const <ContextMenuOpeningEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContextMenuOpening<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveContextMenuOpening(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Select<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, start: i32, length: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Select(start, length).into()
        }
        unsafe extern "system" fn SelectAll<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        unsafe extern "system" fn GetRectFromCharacterIndex<Impl: ITextBoxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, charindex: i32, trailingedge: bool, result__: *mut super::super::super::Foundation::Rect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRectFromCharacterIndex(charindex, trailingedge) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ITextBox>,
            base.5,
            Text::<Impl, OFFSET>,
            SetText::<Impl, OFFSET>,
            SelectedText::<Impl, OFFSET>,
            SetSelectedText::<Impl, OFFSET>,
            SelectionLength::<Impl, OFFSET>,
            SetSelectionLength::<Impl, OFFSET>,
            SelectionStart::<Impl, OFFSET>,
            SetSelectionStart::<Impl, OFFSET>,
            MaxLength::<Impl, OFFSET>,
            SetMaxLength::<Impl, OFFSET>,
            IsReadOnly::<Impl, OFFSET>,
            SetIsReadOnly::<Impl, OFFSET>,
            AcceptsReturn::<Impl, OFFSET>,
            SetAcceptsReturn::<Impl, OFFSET>,
            TextAlignment::<Impl, OFFSET>,
            SetTextAlignment::<Impl, OFFSET>,
            TextWrapping::<Impl, OFFSET>,
            SetTextWrapping::<Impl, OFFSET>,
            IsSpellCheckEnabled::<Impl, OFFSET>,
            SetIsSpellCheckEnabled::<Impl, OFFSET>,
            IsTextPredictionEnabled::<Impl, OFFSET>,
            SetIsTextPredictionEnabled::<Impl, OFFSET>,
            InputScope::<Impl, OFFSET>,
            SetInputScope::<Impl, OFFSET>,
            TextChanged::<Impl, OFFSET>,
            RemoveTextChanged::<Impl, OFFSET>,
            SelectionChanged::<Impl, OFFSET>,
            RemoveSelectionChanged::<Impl, OFFSET>,
            ContextMenuOpening::<Impl, OFFSET>,
            RemoveContextMenuOpening::<Impl, OFFSET>,
            Select::<Impl, OFFSET>,
            SelectAll::<Impl, OFFSET>,
            GetRectFromCharacterIndex::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBox2Impl: Sized {
    fn Header(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn PlaceholderText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetPlaceholderText(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn SelectionHighlightColor(&self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColor(&self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
    fn PreventKeyboardDisplayOnProgrammaticFocus(&self) -> ::windows::core::Result<bool>;
    fn SetPreventKeyboardDisplayOnProgrammaticFocus(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsColorFontEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsColorFontEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn Paste(&self, handler: &::core::option::Option<TextControlPasteEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePaste(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBox2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox2";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBox2Vtbl {
    pub const fn new<Impl: ITextBox2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBox2Vtbl {
        unsafe extern "system" fn Header<Impl: ITextBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: ITextBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: ITextBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: ITextBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PlaceholderText<Impl: ITextBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderText<Impl: ITextBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlaceholderText(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionHighlightColor<Impl: ITextBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColor<Impl: ITextBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColor(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocus<Impl: ITextBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreventKeyboardDisplayOnProgrammaticFocus<Impl: ITextBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPreventKeyboardDisplayOnProgrammaticFocus(value).into()
        }
        unsafe extern "system" fn IsColorFontEnabled<Impl: ITextBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsColorFontEnabled<Impl: ITextBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsColorFontEnabled(value).into()
        }
        unsafe extern "system" fn Paste<Impl: ITextBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Paste(&*(&handler as *const <TextControlPasteEventHandler as ::windows::core::Abi>::Abi as *const <TextControlPasteEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePaste<Impl: ITextBox2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePaste(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ITextBox2>,
            base.5,
            Header::<Impl, OFFSET>,
            SetHeader::<Impl, OFFSET>,
            HeaderTemplate::<Impl, OFFSET>,
            SetHeaderTemplate::<Impl, OFFSET>,
            PlaceholderText::<Impl, OFFSET>,
            SetPlaceholderText::<Impl, OFFSET>,
            SelectionHighlightColor::<Impl, OFFSET>,
            SetSelectionHighlightColor::<Impl, OFFSET>,
            PreventKeyboardDisplayOnProgrammaticFocus::<Impl, OFFSET>,
            SetPreventKeyboardDisplayOnProgrammaticFocus::<Impl, OFFSET>,
            IsColorFontEnabled::<Impl, OFFSET>,
            SetIsColorFontEnabled::<Impl, OFFSET>,
            Paste::<Impl, OFFSET>,
            RemovePaste::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBox3Impl: Sized {
    fn TextCompositionStarted(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionStartedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionStarted(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextCompositionChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextCompositionEnded(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionEndedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextCompositionEnded(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextReadingOrder(&self) -> ::windows::core::Result<super::TextReadingOrder>;
    fn SetTextReadingOrder(&self, value: super::TextReadingOrder) -> ::windows::core::Result<()>;
    fn DesiredCandidateWindowAlignment(&self) -> ::windows::core::Result<CandidateWindowAlignment>;
    fn SetDesiredCandidateWindowAlignment(&self, value: CandidateWindowAlignment) -> ::windows::core::Result<()>;
    fn CandidateWindowBoundsChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, CandidateWindowBoundsChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCandidateWindowBoundsChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn TextChanging(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxTextChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTextChanging(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBox3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox3";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBox3Vtbl {
    pub const fn new<Impl: ITextBox3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBox3Vtbl {
        unsafe extern "system" fn TextCompositionStarted<Impl: ITextBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextCompositionStarted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionStartedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionStartedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionStarted<Impl: ITextBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionStarted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextCompositionChanged<Impl: ITextBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextCompositionChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionChanged<Impl: ITextBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextCompositionEnded<Impl: ITextBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextCompositionEnded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionEndedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextCompositionEndedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextCompositionEnded<Impl: ITextBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveTextCompositionEnded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextReadingOrder<Impl: ITextBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextReadingOrder() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTextReadingOrder<Impl: ITextBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextReadingOrder) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTextReadingOrder(value).into()
        }
        unsafe extern "system" fn DesiredCandidateWindowAlignment<Impl: ITextBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut CandidateWindowAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DesiredCandidateWindowAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDesiredCandidateWindowAlignment<Impl: ITextBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: CandidateWindowAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDesiredCandidateWindowAlignment(value).into()
        }
        unsafe extern "system" fn CandidateWindowBoundsChanged<Impl: ITextBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CandidateWindowBoundsChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, CandidateWindowBoundsChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, CandidateWindowBoundsChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCandidateWindowBoundsChanged<Impl: ITextBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveCandidateWindowBoundsChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TextChanging<Impl: ITextBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxTextChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxTextChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTextChanging<Impl: ITextBox3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveTextChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ITextBox3>,
            base.5,
            TextCompositionStarted::<Impl, OFFSET>,
            RemoveTextCompositionStarted::<Impl, OFFSET>,
            TextCompositionChanged::<Impl, OFFSET>,
            RemoveTextCompositionChanged::<Impl, OFFSET>,
            TextCompositionEnded::<Impl, OFFSET>,
            RemoveTextCompositionEnded::<Impl, OFFSET>,
            TextReadingOrder::<Impl, OFFSET>,
            SetTextReadingOrder::<Impl, OFFSET>,
            DesiredCandidateWindowAlignment::<Impl, OFFSET>,
            SetDesiredCandidateWindowAlignment::<Impl, OFFSET>,
            CandidateWindowBoundsChanged::<Impl, OFFSET>,
            RemoveCandidateWindowBoundsChanged::<Impl, OFFSET>,
            TextChanging::<Impl, OFFSET>,
            RemoveTextChanging::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBox4Impl: Sized {
    fn GetLinguisticAlternativesAsync(&self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::Foundation::Collections::IVectorView<::windows::core::HSTRING>>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBox4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox4";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBox4Vtbl {
    pub const fn new<Impl: ITextBox4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBox4Vtbl {
        unsafe extern "system" fn GetLinguisticAlternativesAsync<Impl: ITextBox4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLinguisticAlternativesAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBox4>, base.5, GetLinguisticAlternativesAsync::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBox5Impl: Sized {
    fn SelectionHighlightColorWhenNotFocused(&self) -> ::windows::core::Result<super::Media::SolidColorBrush>;
    fn SetSelectionHighlightColorWhenNotFocused(&self, value: &::core::option::Option<super::Media::SolidColorBrush>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBox5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox5";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBox5Vtbl {
    pub const fn new<Impl: ITextBox5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBox5Vtbl {
        unsafe extern "system" fn SelectionHighlightColorWhenNotFocused<Impl: ITextBox5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorWhenNotFocused() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionHighlightColorWhenNotFocused<Impl: ITextBox5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionHighlightColorWhenNotFocused(&*(&value as *const <super::Media::SolidColorBrush as ::windows::core::Abi>::Abi as *const <super::Media::SolidColorBrush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBox5>, base.5, SelectionHighlightColorWhenNotFocused::<Impl, OFFSET>, SetSelectionHighlightColorWhenNotFocused::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBox6Impl: Sized {
    fn HorizontalTextAlignment(&self) -> ::windows::core::Result<super::TextAlignment>;
    fn SetHorizontalTextAlignment(&self, value: super::TextAlignment) -> ::windows::core::Result<()>;
    fn CharacterCasing(&self) -> ::windows::core::Result<CharacterCasing>;
    fn SetCharacterCasing(&self, value: CharacterCasing) -> ::windows::core::Result<()>;
    fn PlaceholderForeground(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetPlaceholderForeground(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn CopyingToClipboard(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCopyingToClipboardEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCopyingToClipboard(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn CuttingToClipboard(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCuttingToClipboardEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCuttingToClipboard(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn BeforeTextChanging(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxBeforeTextChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveBeforeTextChanging(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBox6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox6";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBox6Vtbl {
    pub const fn new<Impl: ITextBox6Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBox6Vtbl {
        unsafe extern "system" fn HorizontalTextAlignment<Impl: ITextBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalTextAlignment<Impl: ITextBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::TextAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalTextAlignment(value).into()
        }
        unsafe extern "system" fn CharacterCasing<Impl: ITextBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut CharacterCasing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CharacterCasing() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCharacterCasing<Impl: ITextBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: CharacterCasing) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCharacterCasing(value).into()
        }
        unsafe extern "system" fn PlaceholderForeground<Impl: ITextBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderForeground() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaceholderForeground<Impl: ITextBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlaceholderForeground(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CopyingToClipboard<Impl: ITextBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CopyingToClipboard(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCopyingToClipboardEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCopyingToClipboardEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCopyingToClipboard<Impl: ITextBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveCopyingToClipboard(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CuttingToClipboard<Impl: ITextBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CuttingToClipboard(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCuttingToClipboardEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextControlCuttingToClipboardEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCuttingToClipboard<Impl: ITextBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveCuttingToClipboard(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BeforeTextChanging<Impl: ITextBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeforeTextChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxBeforeTextChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxBeforeTextChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveBeforeTextChanging<Impl: ITextBox6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveBeforeTextChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ITextBox6>,
            base.5,
            HorizontalTextAlignment::<Impl, OFFSET>,
            SetHorizontalTextAlignment::<Impl, OFFSET>,
            CharacterCasing::<Impl, OFFSET>,
            SetCharacterCasing::<Impl, OFFSET>,
            PlaceholderForeground::<Impl, OFFSET>,
            SetPlaceholderForeground::<Impl, OFFSET>,
            CopyingToClipboard::<Impl, OFFSET>,
            RemoveCopyingToClipboard::<Impl, OFFSET>,
            CuttingToClipboard::<Impl, OFFSET>,
            RemoveCuttingToClipboard::<Impl, OFFSET>,
            BeforeTextChanging::<Impl, OFFSET>,
            RemoveBeforeTextChanging::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBox7Impl: Sized {
    fn HandwritingView(&self) -> ::windows::core::Result<HandwritingView>;
    fn SetHandwritingView(&self, value: &::core::option::Option<HandwritingView>) -> ::windows::core::Result<()>;
    fn IsHandwritingViewEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsHandwritingViewEnabled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBox7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox7";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBox7Vtbl {
    pub const fn new<Impl: ITextBox7Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBox7Vtbl {
        unsafe extern "system" fn HandwritingView<Impl: ITextBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HandwritingView() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandwritingView<Impl: ITextBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHandwritingView(&*(&value as *const <HandwritingView as ::windows::core::Abi>::Abi as *const <HandwritingView as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn IsHandwritingViewEnabled<Impl: ITextBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsHandwritingViewEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsHandwritingViewEnabled<Impl: ITextBox7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsHandwritingViewEnabled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBox7>, base.5, HandwritingView::<Impl, OFFSET>, SetHandwritingView::<Impl, OFFSET>, IsHandwritingViewEnabled::<Impl, OFFSET>, SetIsHandwritingViewEnabled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBox8Impl: Sized {
    fn CanPasteClipboardContent(&self) -> ::windows::core::Result<bool>;
    fn CanUndo(&self) -> ::windows::core::Result<bool>;
    fn CanRedo(&self) -> ::windows::core::Result<bool>;
    fn SelectionFlyout(&self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn SetSelectionFlyout(&self, value: &::core::option::Option<Primitives::FlyoutBase>) -> ::windows::core::Result<()>;
    fn ProofingMenuFlyout(&self) -> ::windows::core::Result<Primitives::FlyoutBase>;
    fn Description(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetDescription(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn SelectionChanging(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxSelectionChangingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectionChanging(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Undo(&self) -> ::windows::core::Result<()>;
    fn Redo(&self) -> ::windows::core::Result<()>;
    fn PasteFromClipboard(&self) -> ::windows::core::Result<()>;
    fn CopySelectionToClipboard(&self) -> ::windows::core::Result<()>;
    fn CutSelectionToClipboard(&self) -> ::windows::core::Result<()>;
    fn ClearUndoRedoHistory(&self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBox8 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBox8";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBox8Vtbl {
    pub const fn new<Impl: ITextBox8Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBox8Vtbl {
        unsafe extern "system" fn CanPasteClipboardContent<Impl: ITextBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanPasteClipboardContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanUndo<Impl: ITextBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanUndo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanRedo<Impl: ITextBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanRedo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFlyout<Impl: ITextBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionFlyout<Impl: ITextBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionFlyout(&*(&value as *const <Primitives::FlyoutBase as ::windows::core::Abi>::Abi as *const <Primitives::FlyoutBase as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ProofingMenuFlyout<Impl: ITextBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProofingMenuFlyout() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Description<Impl: ITextBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Description() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: ITextBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDescription(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectionChanging<Impl: ITextBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionChanging(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxSelectionChangingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TextBox, TextBoxSelectionChangingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectionChanging<Impl: ITextBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSelectionChanging(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Undo<Impl: ITextBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Undo().into()
        }
        unsafe extern "system" fn Redo<Impl: ITextBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Redo().into()
        }
        unsafe extern "system" fn PasteFromClipboard<Impl: ITextBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).PasteFromClipboard().into()
        }
        unsafe extern "system" fn CopySelectionToClipboard<Impl: ITextBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).CopySelectionToClipboard().into()
        }
        unsafe extern "system" fn CutSelectionToClipboard<Impl: ITextBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).CutSelectionToClipboard().into()
        }
        unsafe extern "system" fn ClearUndoRedoHistory<Impl: ITextBox8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ClearUndoRedoHistory().into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ITextBox8>,
            base.5,
            CanPasteClipboardContent::<Impl, OFFSET>,
            CanUndo::<Impl, OFFSET>,
            CanRedo::<Impl, OFFSET>,
            SelectionFlyout::<Impl, OFFSET>,
            SetSelectionFlyout::<Impl, OFFSET>,
            ProofingMenuFlyout::<Impl, OFFSET>,
            Description::<Impl, OFFSET>,
            SetDescription::<Impl, OFFSET>,
            SelectionChanging::<Impl, OFFSET>,
            RemoveSelectionChanging::<Impl, OFFSET>,
            Undo::<Impl, OFFSET>,
            Redo::<Impl, OFFSET>,
            PasteFromClipboard::<Impl, OFFSET>,
            CopySelectionToClipboard::<Impl, OFFSET>,
            CutSelectionToClipboard::<Impl, OFFSET>,
            ClearUndoRedoHistory::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxBeforeTextChangingEventArgsImpl: Sized {
    fn NewText(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Cancel(&self) -> ::windows::core::Result<bool>;
    fn SetCancel(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxBeforeTextChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxBeforeTextChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxBeforeTextChangingEventArgsVtbl {
    pub const fn new<Impl: ITextBoxBeforeTextChangingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBoxBeforeTextChangingEventArgsVtbl {
        unsafe extern "system" fn NewText<Impl: ITextBoxBeforeTextChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NewText() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: ITextBoxBeforeTextChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: ITextBoxBeforeTextChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBoxBeforeTextChangingEventArgs>, base.5, NewText::<Impl, OFFSET>, Cancel::<Impl, OFFSET>, SetCancel::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TextBox>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxFactoryVtbl {
    pub const fn new<Impl: ITextBoxFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBoxFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITextBoxFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBoxFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxSelectionChangingEventArgsImpl: Sized {
    fn SelectionStart(&self) -> ::windows::core::Result<i32>;
    fn SelectionLength(&self) -> ::windows::core::Result<i32>;
    fn Cancel(&self) -> ::windows::core::Result<bool>;
    fn SetCancel(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxSelectionChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxSelectionChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxSelectionChangingEventArgsVtbl {
    pub const fn new<Impl: ITextBoxSelectionChangingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBoxSelectionChangingEventArgsVtbl {
        unsafe extern "system" fn SelectionStart<Impl: ITextBoxSelectionChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionLength<Impl: ITextBoxSelectionChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: ITextBoxSelectionChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: ITextBoxSelectionChangingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBoxSelectionChangingEventArgs>, base.5, SelectionStart::<Impl, OFFSET>, SelectionLength::<Impl, OFFSET>, Cancel::<Impl, OFFSET>, SetCancel::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStaticsImpl: Sized {
    fn TextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaxLengthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsReadOnlyProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AcceptsReturnProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextWrappingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsSpellCheckEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsTextPredictionEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn InputScopeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStaticsVtbl {
    pub const fn new<Impl: ITextBoxStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBoxStaticsVtbl {
        unsafe extern "system" fn TextProperty<Impl: ITextBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaxLengthProperty<Impl: ITextBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaxLengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsReadOnlyProperty<Impl: ITextBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsReadOnlyProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AcceptsReturnProperty<Impl: ITextBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AcceptsReturnProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextAlignmentProperty<Impl: ITextBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextWrappingProperty<Impl: ITextBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextWrappingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSpellCheckEnabledProperty<Impl: ITextBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSpellCheckEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextPredictionEnabledProperty<Impl: ITextBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextPredictionEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InputScopeProperty<Impl: ITextBoxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InputScopeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBoxStatics>, base.5, TextProperty::<Impl, OFFSET>, MaxLengthProperty::<Impl, OFFSET>, IsReadOnlyProperty::<Impl, OFFSET>, AcceptsReturnProperty::<Impl, OFFSET>, TextAlignmentProperty::<Impl, OFFSET>, TextWrappingProperty::<Impl, OFFSET>, IsSpellCheckEnabledProperty::<Impl, OFFSET>, IsTextPredictionEnabledProperty::<Impl, OFFSET>, InputScopeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics2Impl: Sized {
    fn HeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderTextProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionHighlightColorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PreventKeyboardDisplayOnProgrammaticFocusProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsColorFontEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics2Vtbl {
    pub const fn new<Impl: ITextBoxStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBoxStatics2Vtbl {
        unsafe extern "system" fn HeaderProperty<Impl: ITextBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: ITextBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderTextProperty<Impl: ITextBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderTextProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionHighlightColorProperty<Impl: ITextBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PreventKeyboardDisplayOnProgrammaticFocusProperty<Impl: ITextBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PreventKeyboardDisplayOnProgrammaticFocusProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsColorFontEnabledProperty<Impl: ITextBoxStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsColorFontEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBoxStatics2>, base.5, HeaderProperty::<Impl, OFFSET>, HeaderTemplateProperty::<Impl, OFFSET>, PlaceholderTextProperty::<Impl, OFFSET>, SelectionHighlightColorProperty::<Impl, OFFSET>, PreventKeyboardDisplayOnProgrammaticFocusProperty::<Impl, OFFSET>, IsColorFontEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics3Impl: Sized {
    fn DesiredCandidateWindowAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TextReadingOrderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics3Vtbl {
    pub const fn new<Impl: ITextBoxStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBoxStatics3Vtbl {
        unsafe extern "system" fn DesiredCandidateWindowAlignmentProperty<Impl: ITextBoxStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DesiredCandidateWindowAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TextReadingOrderProperty<Impl: ITextBoxStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TextReadingOrderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBoxStatics3>, base.5, DesiredCandidateWindowAlignmentProperty::<Impl, OFFSET>, TextReadingOrderProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics5Impl: Sized {
    fn SelectionHighlightColorWhenNotFocusedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics5Vtbl {
    pub const fn new<Impl: ITextBoxStatics5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBoxStatics5Vtbl {
        unsafe extern "system" fn SelectionHighlightColorWhenNotFocusedProperty<Impl: ITextBoxStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionHighlightColorWhenNotFocusedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBoxStatics5>, base.5, SelectionHighlightColorWhenNotFocusedProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics6Impl: Sized {
    fn HorizontalTextAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CharacterCasingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlaceholderForegroundProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics6";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics6Vtbl {
    pub const fn new<Impl: ITextBoxStatics6Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBoxStatics6Vtbl {
        unsafe extern "system" fn HorizontalTextAlignmentProperty<Impl: ITextBoxStatics6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalTextAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CharacterCasingProperty<Impl: ITextBoxStatics6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CharacterCasingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceholderForegroundProperty<Impl: ITextBoxStatics6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceholderForegroundProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBoxStatics6>, base.5, HorizontalTextAlignmentProperty::<Impl, OFFSET>, CharacterCasingProperty::<Impl, OFFSET>, PlaceholderForegroundProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics7Impl: Sized {
    fn HandwritingViewProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsHandwritingViewEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics7";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics7Vtbl {
    pub const fn new<Impl: ITextBoxStatics7Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBoxStatics7Vtbl {
        unsafe extern "system" fn HandwritingViewProperty<Impl: ITextBoxStatics7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HandwritingViewProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsHandwritingViewEnabledProperty<Impl: ITextBoxStatics7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsHandwritingViewEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBoxStatics7>, base.5, HandwritingViewProperty::<Impl, OFFSET>, IsHandwritingViewEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxStatics8Impl: Sized {
    fn CanPasteClipboardContentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanUndoProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanRedoProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn SelectionFlyoutProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ProofingMenuFlyoutProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DescriptionProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxStatics8 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxStatics8";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxStatics8Vtbl {
    pub const fn new<Impl: ITextBoxStatics8Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBoxStatics8Vtbl {
        unsafe extern "system" fn CanPasteClipboardContentProperty<Impl: ITextBoxStatics8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanPasteClipboardContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanUndoProperty<Impl: ITextBoxStatics8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanUndoProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanRedoProperty<Impl: ITextBoxStatics8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanRedoProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionFlyoutProperty<Impl: ITextBoxStatics8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProofingMenuFlyoutProperty<Impl: ITextBoxStatics8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProofingMenuFlyoutProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DescriptionProperty<Impl: ITextBoxStatics8Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DescriptionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBoxStatics8>, base.5, CanPasteClipboardContentProperty::<Impl, OFFSET>, CanUndoProperty::<Impl, OFFSET>, CanRedoProperty::<Impl, OFFSET>, SelectionFlyoutProperty::<Impl, OFFSET>, ProofingMenuFlyoutProperty::<Impl, OFFSET>, DescriptionProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxTextChangingEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxTextChangingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxTextChangingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxTextChangingEventArgsVtbl {
    pub const fn new<Impl: ITextBoxTextChangingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBoxTextChangingEventArgsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBoxTextChangingEventArgs>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextBoxTextChangingEventArgs2Impl: Sized {
    fn IsContentChanging(&self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextBoxTextChangingEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextBoxTextChangingEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl ITextBoxTextChangingEventArgs2Vtbl {
    pub const fn new<Impl: ITextBoxTextChangingEventArgs2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextBoxTextChangingEventArgs2Vtbl {
        unsafe extern "system" fn IsContentChanging<Impl: ITextBoxTextChangingEventArgs2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsContentChanging() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextBoxTextChangingEventArgs2>, base.5, IsContentChanging::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextChangedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextChangedEventArgsVtbl {
    pub const fn new<Impl: ITextChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextChangedEventArgsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextChangedEventArgs>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextCommandBarFlyoutImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextCommandBarFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextCommandBarFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl ITextCommandBarFlyoutVtbl {
    pub const fn new<Impl: ITextCommandBarFlyoutImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextCommandBarFlyoutVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextCommandBarFlyout>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextCommandBarFlyoutFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TextCommandBarFlyout>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextCommandBarFlyoutFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextCommandBarFlyoutFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITextCommandBarFlyoutFactoryVtbl {
    pub const fn new<Impl: ITextCommandBarFlyoutFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextCommandBarFlyoutFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITextCommandBarFlyoutFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextCommandBarFlyoutFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextCompositionChangedEventArgsImpl: Sized {
    fn StartIndex(&self) -> ::windows::core::Result<i32>;
    fn Length(&self) -> ::windows::core::Result<i32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextCompositionChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextCompositionChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextCompositionChangedEventArgsVtbl {
    pub const fn new<Impl: ITextCompositionChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextCompositionChangedEventArgsVtbl {
        unsafe extern "system" fn StartIndex<Impl: ITextCompositionChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StartIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Length<Impl: ITextCompositionChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Length() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextCompositionChangedEventArgs>, base.5, StartIndex::<Impl, OFFSET>, Length::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextCompositionEndedEventArgsImpl: Sized {
    fn StartIndex(&self) -> ::windows::core::Result<i32>;
    fn Length(&self) -> ::windows::core::Result<i32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextCompositionEndedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextCompositionEndedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextCompositionEndedEventArgsVtbl {
    pub const fn new<Impl: ITextCompositionEndedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextCompositionEndedEventArgsVtbl {
        unsafe extern "system" fn StartIndex<Impl: ITextCompositionEndedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StartIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Length<Impl: ITextCompositionEndedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Length() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextCompositionEndedEventArgs>, base.5, StartIndex::<Impl, OFFSET>, Length::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextCompositionStartedEventArgsImpl: Sized {
    fn StartIndex(&self) -> ::windows::core::Result<i32>;
    fn Length(&self) -> ::windows::core::Result<i32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextCompositionStartedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextCompositionStartedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextCompositionStartedEventArgsVtbl {
    pub const fn new<Impl: ITextCompositionStartedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextCompositionStartedEventArgsVtbl {
        unsafe extern "system" fn StartIndex<Impl: ITextCompositionStartedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StartIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Length<Impl: ITextCompositionStartedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Length() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextCompositionStartedEventArgs>, base.5, StartIndex::<Impl, OFFSET>, Length::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextControlCopyingToClipboardEventArgsImpl: Sized {
    fn Handled(&self) -> ::windows::core::Result<bool>;
    fn SetHandled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextControlCopyingToClipboardEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextControlCopyingToClipboardEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextControlCopyingToClipboardEventArgsVtbl {
    pub const fn new<Impl: ITextControlCopyingToClipboardEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextControlCopyingToClipboardEventArgsVtbl {
        unsafe extern "system" fn Handled<Impl: ITextControlCopyingToClipboardEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: ITextControlCopyingToClipboardEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextControlCopyingToClipboardEventArgs>, base.5, Handled::<Impl, OFFSET>, SetHandled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextControlCuttingToClipboardEventArgsImpl: Sized {
    fn Handled(&self) -> ::windows::core::Result<bool>;
    fn SetHandled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextControlCuttingToClipboardEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextControlCuttingToClipboardEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextControlCuttingToClipboardEventArgsVtbl {
    pub const fn new<Impl: ITextControlCuttingToClipboardEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextControlCuttingToClipboardEventArgsVtbl {
        unsafe extern "system" fn Handled<Impl: ITextControlCuttingToClipboardEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: ITextControlCuttingToClipboardEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextControlCuttingToClipboardEventArgs>, base.5, Handled::<Impl, OFFSET>, SetHandled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITextControlPasteEventArgsImpl: Sized {
    fn Handled(&self) -> ::windows::core::Result<bool>;
    fn SetHandled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITextControlPasteEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITextControlPasteEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITextControlPasteEventArgsVtbl {
    pub const fn new<Impl: ITextControlPasteEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITextControlPasteEventArgsVtbl {
        unsafe extern "system" fn Handled<Impl: ITextControlPasteEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: ITextControlPasteEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITextControlPasteEventArgs>, base.5, Handled::<Impl, OFFSET>, SetHandled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickedEventArgsImpl: Sized {
    fn OldTime(&self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn NewTime(&self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickedEventArgsVtbl {
    pub const fn new<Impl: ITimePickedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITimePickedEventArgsVtbl {
        unsafe extern "system" fn OldTime<Impl: ITimePickedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OldTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewTime<Impl: ITimePickedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NewTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITimePickedEventArgs>, base.5, OldTime::<Impl, OFFSET>, NewTime::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerImpl: Sized {
    fn Header(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ClockIdentifier(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetClockIdentifier(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn MinuteIncrement(&self) -> ::windows::core::Result<i32>;
    fn SetMinuteIncrement(&self, value: i32) -> ::windows::core::Result<()>;
    fn Time(&self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn SetTime(&self, value: &super::super::super::Foundation::TimeSpan) -> ::windows::core::Result<()>;
    fn TimeChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::EventHandler<TimePickerValueChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTimeChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePicker {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePicker";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerVtbl {
    pub const fn new<Impl: ITimePickerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITimePickerVtbl {
        unsafe extern "system" fn Header<Impl: ITimePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: ITimePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: ITimePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: ITimePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ClockIdentifier<Impl: ITimePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ClockIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClockIdentifier<Impl: ITimePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetClockIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinuteIncrement<Impl: ITimePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinuteIncrement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinuteIncrement<Impl: ITimePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMinuteIncrement(value).into()
        }
        unsafe extern "system" fn Time<Impl: ITimePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Time() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTime<Impl: ITimePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTime(&*(&value as *const <super::super::super::Foundation::TimeSpan as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TimeSpan as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TimeChanged<Impl: ITimePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TimeChanged(&*(&handler as *const <super::super::super::Foundation::EventHandler<TimePickerValueChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventHandler<TimePickerValueChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTimeChanged<Impl: ITimePickerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveTimeChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITimePicker>, base.5, Header::<Impl, OFFSET>, SetHeader::<Impl, OFFSET>, HeaderTemplate::<Impl, OFFSET>, SetHeaderTemplate::<Impl, OFFSET>, ClockIdentifier::<Impl, OFFSET>, SetClockIdentifier::<Impl, OFFSET>, MinuteIncrement::<Impl, OFFSET>, SetMinuteIncrement::<Impl, OFFSET>, Time::<Impl, OFFSET>, SetTime::<Impl, OFFSET>, TimeChanged::<Impl, OFFSET>, RemoveTimeChanged::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePicker2Impl: Sized {
    fn LightDismissOverlayMode(&self) -> ::windows::core::Result<LightDismissOverlayMode>;
    fn SetLightDismissOverlayMode(&self, value: LightDismissOverlayMode) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePicker2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePicker2";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePicker2Vtbl {
    pub const fn new<Impl: ITimePicker2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITimePicker2Vtbl {
        unsafe extern "system" fn LightDismissOverlayMode<Impl: ITimePicker2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLightDismissOverlayMode<Impl: ITimePicker2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: LightDismissOverlayMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetLightDismissOverlayMode(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITimePicker2>, base.5, LightDismissOverlayMode::<Impl, OFFSET>, SetLightDismissOverlayMode::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePicker3Impl: Sized {
    fn SelectedTime(&self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan>>;
    fn SetSelectedTime(&self, value: &::core::option::Option<super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan>>) -> ::windows::core::Result<()>;
    fn SelectedTimeChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TimePicker, TimePickerSelectedValueChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSelectedTimeChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePicker3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePicker3";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePicker3Vtbl {
    pub const fn new<Impl: ITimePicker3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITimePicker3Vtbl {
        unsafe extern "system" fn SelectedTime<Impl: ITimePicker3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedTime<Impl: ITimePicker3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectedTime(&*(&value as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectedTimeChanged<Impl: ITimePicker3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedTimeChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TimePicker, TimePickerSelectedValueChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TimePicker, TimePickerSelectedValueChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSelectedTimeChanged<Impl: ITimePicker3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSelectedTimeChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITimePicker3>, base.5, SelectedTime::<Impl, OFFSET>, SetSelectedTime::<Impl, OFFSET>, SelectedTimeChanged::<Impl, OFFSET>, RemoveSelectedTimeChanged::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TimePicker>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerFactoryVtbl {
    pub const fn new<Impl: ITimePickerFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITimePickerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITimePickerFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITimePickerFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerFlyoutImpl: Sized {
    fn ClockIdentifier(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetClockIdentifier(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Time(&self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn SetTime(&self, value: &super::super::super::Foundation::TimeSpan) -> ::windows::core::Result<()>;
    fn MinuteIncrement(&self) -> ::windows::core::Result<i32>;
    fn SetMinuteIncrement(&self, value: i32) -> ::windows::core::Result<()>;
    fn TimePicked(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TimePickerFlyout, TimePickedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveTimePicked(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ShowAtAsync(&self, target: &::core::option::Option<super::FrameworkElement>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan>>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerFlyout {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFlyout";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerFlyoutVtbl {
    pub const fn new<Impl: ITimePickerFlyoutImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITimePickerFlyoutVtbl {
        unsafe extern "system" fn ClockIdentifier<Impl: ITimePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ClockIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClockIdentifier<Impl: ITimePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetClockIdentifier(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Time<Impl: ITimePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Time() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTime<Impl: ITimePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTime(&*(&value as *const <super::super::super::Foundation::TimeSpan as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TimeSpan as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn MinuteIncrement<Impl: ITimePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinuteIncrement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinuteIncrement<Impl: ITimePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMinuteIncrement(value).into()
        }
        unsafe extern "system" fn TimePicked<Impl: ITimePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TimePicked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TimePickerFlyout, TimePickedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TimePickerFlyout, TimePickedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTimePicked<Impl: ITimePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveTimePicked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ShowAtAsync<Impl: ITimePickerFlyoutImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, target: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShowAtAsync(&*(&target as *const <super::FrameworkElement as ::windows::core::Abi>::Abi as *const <super::FrameworkElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITimePickerFlyout>, base.5, ClockIdentifier::<Impl, OFFSET>, SetClockIdentifier::<Impl, OFFSET>, Time::<Impl, OFFSET>, SetTime::<Impl, OFFSET>, MinuteIncrement::<Impl, OFFSET>, SetMinuteIncrement::<Impl, OFFSET>, TimePicked::<Impl, OFFSET>, RemoveTimePicked::<Impl, OFFSET>, ShowAtAsync::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerFlyoutPresenterImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerFlyoutPresenter {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenter";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerFlyoutPresenterVtbl {
    pub const fn new<Impl: ITimePickerFlyoutPresenterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITimePickerFlyoutPresenterVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITimePickerFlyoutPresenter>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerFlyoutPresenter2Impl: Sized {
    fn IsDefaultShadowEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsDefaultShadowEnabled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerFlyoutPresenter2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenter2";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerFlyoutPresenter2Vtbl {
    pub const fn new<Impl: ITimePickerFlyoutPresenter2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITimePickerFlyoutPresenter2Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabled<Impl: ITimePickerFlyoutPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsDefaultShadowEnabled<Impl: ITimePickerFlyoutPresenter2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsDefaultShadowEnabled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITimePickerFlyoutPresenter2>, base.5, IsDefaultShadowEnabled::<Impl, OFFSET>, SetIsDefaultShadowEnabled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerFlyoutPresenterStatics2Impl: Sized {
    fn IsDefaultShadowEnabledProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerFlyoutPresenterStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenterStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerFlyoutPresenterStatics2Vtbl {
    pub const fn new<Impl: ITimePickerFlyoutPresenterStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITimePickerFlyoutPresenterStatics2Vtbl {
        unsafe extern "system" fn IsDefaultShadowEnabledProperty<Impl: ITimePickerFlyoutPresenterStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDefaultShadowEnabledProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITimePickerFlyoutPresenterStatics2>, base.5, IsDefaultShadowEnabledProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerFlyoutStaticsImpl: Sized {
    fn ClockIdentifierProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TimeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinuteIncrementProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerFlyoutStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerFlyoutStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerFlyoutStaticsVtbl {
    pub const fn new<Impl: ITimePickerFlyoutStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITimePickerFlyoutStaticsVtbl {
        unsafe extern "system" fn ClockIdentifierProperty<Impl: ITimePickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ClockIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TimeProperty<Impl: ITimePickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TimeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinuteIncrementProperty<Impl: ITimePickerFlyoutStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinuteIncrementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITimePickerFlyoutStatics>, base.5, ClockIdentifierProperty::<Impl, OFFSET>, TimeProperty::<Impl, OFFSET>, MinuteIncrementProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerSelectedValueChangedEventArgsImpl: Sized {
    fn OldTime(&self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan>>;
    fn NewTime(&self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::TimeSpan>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerSelectedValueChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerSelectedValueChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerSelectedValueChangedEventArgsVtbl {
    pub const fn new<Impl: ITimePickerSelectedValueChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITimePickerSelectedValueChangedEventArgsVtbl {
        unsafe extern "system" fn OldTime<Impl: ITimePickerSelectedValueChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OldTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewTime<Impl: ITimePickerSelectedValueChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NewTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITimePickerSelectedValueChangedEventArgs>, base.5, OldTime::<Impl, OFFSET>, NewTime::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerStaticsImpl: Sized {
    fn HeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ClockIdentifierProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinuteIncrementProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TimeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerStaticsVtbl {
    pub const fn new<Impl: ITimePickerStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITimePickerStaticsVtbl {
        unsafe extern "system" fn HeaderProperty<Impl: ITimePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: ITimePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClockIdentifierProperty<Impl: ITimePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ClockIdentifierProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinuteIncrementProperty<Impl: ITimePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinuteIncrementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TimeProperty<Impl: ITimePickerStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TimeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITimePickerStatics>, base.5, HeaderProperty::<Impl, OFFSET>, HeaderTemplateProperty::<Impl, OFFSET>, ClockIdentifierProperty::<Impl, OFFSET>, MinuteIncrementProperty::<Impl, OFFSET>, TimeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerStatics2Impl: Sized {
    fn LightDismissOverlayModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerStatics2Vtbl {
    pub const fn new<Impl: ITimePickerStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITimePickerStatics2Vtbl {
        unsafe extern "system" fn LightDismissOverlayModeProperty<Impl: ITimePickerStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LightDismissOverlayModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITimePickerStatics2>, base.5, LightDismissOverlayModeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerStatics3Impl: Sized {
    fn SelectedTimeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerStatics3Vtbl {
    pub const fn new<Impl: ITimePickerStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITimePickerStatics3Vtbl {
        unsafe extern "system" fn SelectedTimeProperty<Impl: ITimePickerStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedTimeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITimePickerStatics3>, base.5, SelectedTimeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITimePickerValueChangedEventArgsImpl: Sized {
    fn OldTime(&self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn NewTime(&self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITimePickerValueChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITimePickerValueChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITimePickerValueChangedEventArgsVtbl {
    pub const fn new<Impl: ITimePickerValueChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITimePickerValueChangedEventArgsVtbl {
        unsafe extern "system" fn OldTime<Impl: ITimePickerValueChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OldTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NewTime<Impl: ITimePickerValueChangedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NewTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITimePickerValueChangedEventArgs>, base.5, OldTime::<Impl, OFFSET>, NewTime::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleMenuFlyoutItemImpl: Sized {
    fn IsChecked(&self) -> ::windows::core::Result<bool>;
    fn SetIsChecked(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleMenuFlyoutItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleMenuFlyoutItem";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleMenuFlyoutItemVtbl {
    pub const fn new<Impl: IToggleMenuFlyoutItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToggleMenuFlyoutItemVtbl {
        unsafe extern "system" fn IsChecked<Impl: IToggleMenuFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsChecked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsChecked<Impl: IToggleMenuFlyoutItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsChecked(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IToggleMenuFlyoutItem>, base.5, IsChecked::<Impl, OFFSET>, SetIsChecked::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleMenuFlyoutItemFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ToggleMenuFlyoutItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleMenuFlyoutItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleMenuFlyoutItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleMenuFlyoutItemFactoryVtbl {
    pub const fn new<Impl: IToggleMenuFlyoutItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToggleMenuFlyoutItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IToggleMenuFlyoutItemFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IToggleMenuFlyoutItemFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleMenuFlyoutItemStaticsImpl: Sized {
    fn IsCheckedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleMenuFlyoutItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleMenuFlyoutItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleMenuFlyoutItemStaticsVtbl {
    pub const fn new<Impl: IToggleMenuFlyoutItemStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToggleMenuFlyoutItemStaticsVtbl {
        unsafe extern "system" fn IsCheckedProperty<Impl: IToggleMenuFlyoutItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCheckedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IToggleMenuFlyoutItemStatics>, base.5, IsCheckedProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSplitButtonImpl: Sized {
    fn IsChecked(&self) -> ::windows::core::Result<bool>;
    fn SetIsChecked(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsCheckedChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<ToggleSplitButton, ToggleSplitButtonIsCheckedChangedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveIsCheckedChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSplitButton {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSplitButton";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSplitButtonVtbl {
    pub const fn new<Impl: IToggleSplitButtonImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToggleSplitButtonVtbl {
        unsafe extern "system" fn IsChecked<Impl: IToggleSplitButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsChecked() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsChecked<Impl: IToggleSplitButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsChecked(value).into()
        }
        unsafe extern "system" fn IsCheckedChanged<Impl: IToggleSplitButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCheckedChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<ToggleSplitButton, ToggleSplitButtonIsCheckedChangedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<ToggleSplitButton, ToggleSplitButtonIsCheckedChangedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveIsCheckedChanged<Impl: IToggleSplitButtonImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveIsCheckedChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IToggleSplitButton>, base.5, IsChecked::<Impl, OFFSET>, SetIsChecked::<Impl, OFFSET>, IsCheckedChanged::<Impl, OFFSET>, RemoveIsCheckedChanged::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSplitButtonAutomationPeerImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSplitButtonAutomationPeer {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSplitButtonAutomationPeer";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSplitButtonAutomationPeerVtbl {
    pub const fn new<Impl: IToggleSplitButtonAutomationPeerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToggleSplitButtonAutomationPeerVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IToggleSplitButtonAutomationPeer>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSplitButtonAutomationPeerFactoryImpl: Sized {
    fn CreateInstance(&self, owner: &::core::option::Option<ToggleSplitButton>, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ToggleSplitButtonAutomationPeer>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSplitButtonAutomationPeerFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSplitButtonAutomationPeerFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSplitButtonAutomationPeerFactoryVtbl {
    pub const fn new<Impl: IToggleSplitButtonAutomationPeerFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToggleSplitButtonAutomationPeerFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IToggleSplitButtonAutomationPeerFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, owner: ::windows::core::RawPtr, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&owner as *const <ToggleSplitButton as ::windows::core::Abi>::Abi as *const <ToggleSplitButton as ::windows::core::DefaultType>::DefaultType), &*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IToggleSplitButtonAutomationPeerFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSplitButtonFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ToggleSplitButton>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSplitButtonFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSplitButtonFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSplitButtonFactoryVtbl {
    pub const fn new<Impl: IToggleSplitButtonFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToggleSplitButtonFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IToggleSplitButtonFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IToggleSplitButtonFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSplitButtonIsCheckedChangedEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSplitButtonIsCheckedChangedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSplitButtonIsCheckedChangedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSplitButtonIsCheckedChangedEventArgsVtbl {
    pub const fn new<Impl: IToggleSplitButtonIsCheckedChangedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToggleSplitButtonIsCheckedChangedEventArgsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IToggleSplitButtonIsCheckedChangedEventArgs>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSwitchImpl: Sized {
    fn IsOn(&self) -> ::windows::core::Result<bool>;
    fn SetIsOn(&self, value: bool) -> ::windows::core::Result<()>;
    fn Header(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHeader(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn HeaderTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetHeaderTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn OnContent(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetOnContent(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnContentTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetOnContentTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn OffContent(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetOffContent(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OffContentTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetOffContentTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn TemplateSettings(&self) -> ::windows::core::Result<Primitives::ToggleSwitchTemplateSettings>;
    fn Toggled(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveToggled(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSwitch {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSwitch";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSwitchVtbl {
    pub const fn new<Impl: IToggleSwitchImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToggleSwitchVtbl {
        unsafe extern "system" fn IsOn<Impl: IToggleSwitchImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsOn() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsOn<Impl: IToggleSwitchImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsOn(value).into()
        }
        unsafe extern "system" fn Header<Impl: IToggleSwitchImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Header() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeader<Impl: IToggleSwitchImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeader(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn HeaderTemplate<Impl: IToggleSwitchImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHeaderTemplate<Impl: IToggleSwitchImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHeaderTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnContent<Impl: IToggleSwitchImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOnContent<Impl: IToggleSwitchImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOnContent(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnContentTemplate<Impl: IToggleSwitchImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnContentTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOnContentTemplate<Impl: IToggleSwitchImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOnContentTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OffContent<Impl: IToggleSwitchImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OffContent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOffContent<Impl: IToggleSwitchImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOffContent(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OffContentTemplate<Impl: IToggleSwitchImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OffContentTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOffContentTemplate<Impl: IToggleSwitchImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOffContentTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: IToggleSwitchImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Toggled<Impl: IToggleSwitchImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Toggled(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveToggled<Impl: IToggleSwitchImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveToggled(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IToggleSwitch>,
            base.5,
            IsOn::<Impl, OFFSET>,
            SetIsOn::<Impl, OFFSET>,
            Header::<Impl, OFFSET>,
            SetHeader::<Impl, OFFSET>,
            HeaderTemplate::<Impl, OFFSET>,
            SetHeaderTemplate::<Impl, OFFSET>,
            OnContent::<Impl, OFFSET>,
            SetOnContent::<Impl, OFFSET>,
            OnContentTemplate::<Impl, OFFSET>,
            SetOnContentTemplate::<Impl, OFFSET>,
            OffContent::<Impl, OFFSET>,
            SetOffContent::<Impl, OFFSET>,
            OffContentTemplate::<Impl, OFFSET>,
            SetOffContentTemplate::<Impl, OFFSET>,
            TemplateSettings::<Impl, OFFSET>,
            Toggled::<Impl, OFFSET>,
            RemoveToggled::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSwitchOverridesImpl: Sized {
    fn OnToggled(&self) -> ::windows::core::Result<()>;
    fn OnOnContentChanged(&self, oldcontent: &::core::option::Option<::windows::core::IInspectable>, newcontent: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnOffContentChanged(&self, oldcontent: &::core::option::Option<::windows::core::IInspectable>, newcontent: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn OnHeaderChanged(&self, oldcontent: &::core::option::Option<::windows::core::IInspectable>, newcontent: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSwitchOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSwitchOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSwitchOverridesVtbl {
    pub const fn new<Impl: IToggleSwitchOverridesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToggleSwitchOverridesVtbl {
        unsafe extern "system" fn OnToggled<Impl: IToggleSwitchOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnToggled().into()
        }
        unsafe extern "system" fn OnOnContentChanged<Impl: IToggleSwitchOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, oldcontent: *mut ::core::ffi::c_void, newcontent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnOnContentChanged(&*(&oldcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&newcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnOffContentChanged<Impl: IToggleSwitchOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, oldcontent: *mut ::core::ffi::c_void, newcontent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnOffContentChanged(&*(&oldcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&newcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnHeaderChanged<Impl: IToggleSwitchOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, oldcontent: *mut ::core::ffi::c_void, newcontent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnHeaderChanged(&*(&oldcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&newcontent as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IToggleSwitchOverrides>, base.5, OnToggled::<Impl, OFFSET>, OnOnContentChanged::<Impl, OFFSET>, OnOffContentChanged::<Impl, OFFSET>, OnHeaderChanged::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToggleSwitchStaticsImpl: Sized {
    fn IsOnProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HeaderTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OnContentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OnContentTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OffContentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OffContentTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToggleSwitchStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToggleSwitchStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IToggleSwitchStaticsVtbl {
    pub const fn new<Impl: IToggleSwitchStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToggleSwitchStaticsVtbl {
        unsafe extern "system" fn IsOnProperty<Impl: IToggleSwitchStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsOnProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderProperty<Impl: IToggleSwitchStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HeaderTemplateProperty<Impl: IToggleSwitchStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HeaderTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnContentProperty<Impl: IToggleSwitchStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnContentTemplateProperty<Impl: IToggleSwitchStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnContentTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OffContentProperty<Impl: IToggleSwitchStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OffContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OffContentTemplateProperty<Impl: IToggleSwitchStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OffContentTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IToggleSwitchStatics>, base.5, IsOnProperty::<Impl, OFFSET>, HeaderProperty::<Impl, OFFSET>, HeaderTemplateProperty::<Impl, OFFSET>, OnContentProperty::<Impl, OFFSET>, OnContentTemplateProperty::<Impl, OFFSET>, OffContentProperty::<Impl, OFFSET>, OffContentTemplateProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToolTipImpl: Sized {
    fn HorizontalOffset(&self) -> ::windows::core::Result<f64>;
    fn SetHorizontalOffset(&self, value: f64) -> ::windows::core::Result<()>;
    fn IsOpen(&self) -> ::windows::core::Result<bool>;
    fn SetIsOpen(&self, value: bool) -> ::windows::core::Result<()>;
    fn Placement(&self) -> ::windows::core::Result<Primitives::PlacementMode>;
    fn SetPlacement(&self, value: Primitives::PlacementMode) -> ::windows::core::Result<()>;
    fn PlacementTarget(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetPlacementTarget(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn VerticalOffset(&self) -> ::windows::core::Result<f64>;
    fn SetVerticalOffset(&self, value: f64) -> ::windows::core::Result<()>;
    fn TemplateSettings(&self) -> ::windows::core::Result<Primitives::ToolTipTemplateSettings>;
    fn Closed(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveClosed(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Opened(&self, handler: &::core::option::Option<super::RoutedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveOpened(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToolTip {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTip";
}
#[cfg(feature = "implement_exclusive")]
impl IToolTipVtbl {
    pub const fn new<Impl: IToolTipImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToolTipVtbl {
        unsafe extern "system" fn HorizontalOffset<Impl: IToolTipImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalOffset<Impl: IToolTipImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalOffset(value).into()
        }
        unsafe extern "system" fn IsOpen<Impl: IToolTipImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsOpen() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsOpen<Impl: IToolTipImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsOpen(value).into()
        }
        unsafe extern "system" fn Placement<Impl: IToolTipImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Primitives::PlacementMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Placement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacement<Impl: IToolTipImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Primitives::PlacementMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlacement(value).into()
        }
        unsafe extern "system" fn PlacementTarget<Impl: IToolTipImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlacementTarget() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacementTarget<Impl: IToolTipImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlacementTarget(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn VerticalOffset<Impl: IToolTipImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalOffset<Impl: IToolTipImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalOffset(value).into()
        }
        unsafe extern "system" fn TemplateSettings<Impl: IToolTipImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Closed<Impl: IToolTipImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Closed(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClosed<Impl: IToolTipImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveClosed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Opened<Impl: IToolTipImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Opened(&*(&handler as *const <super::RoutedEventHandler as ::windows::core::Abi>::Abi as *const <super::RoutedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveOpened<Impl: IToolTipImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveOpened(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IToolTip>,
            base.5,
            HorizontalOffset::<Impl, OFFSET>,
            SetHorizontalOffset::<Impl, OFFSET>,
            IsOpen::<Impl, OFFSET>,
            SetIsOpen::<Impl, OFFSET>,
            Placement::<Impl, OFFSET>,
            SetPlacement::<Impl, OFFSET>,
            PlacementTarget::<Impl, OFFSET>,
            SetPlacementTarget::<Impl, OFFSET>,
            VerticalOffset::<Impl, OFFSET>,
            SetVerticalOffset::<Impl, OFFSET>,
            TemplateSettings::<Impl, OFFSET>,
            Closed::<Impl, OFFSET>,
            RemoveClosed::<Impl, OFFSET>,
            Opened::<Impl, OFFSET>,
            RemoveOpened::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToolTip2Impl: Sized {
    fn PlacementRect(&self) -> ::windows::core::Result<super::super::super::Foundation::IReference<super::super::super::Foundation::Rect>>;
    fn SetPlacementRect(&self, value: &::core::option::Option<super::super::super::Foundation::IReference<super::super::super::Foundation::Rect>>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToolTip2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTip2";
}
#[cfg(feature = "implement_exclusive")]
impl IToolTip2Vtbl {
    pub const fn new<Impl: IToolTip2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToolTip2Vtbl {
        unsafe extern "system" fn PlacementRect<Impl: IToolTip2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlacementRect() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacementRect<Impl: IToolTip2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlacementRect(&*(&value as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::Rect> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::IReference<super::super::super::Foundation::Rect> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IToolTip2>, base.5, PlacementRect::<Impl, OFFSET>, SetPlacementRect::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToolTipFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<ToolTip>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToolTipFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTipFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IToolTipFactoryVtbl {
    pub const fn new<Impl: IToolTipFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToolTipFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IToolTipFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IToolTipFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToolTipServiceImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToolTipService {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTipService";
}
#[cfg(feature = "implement_exclusive")]
impl IToolTipServiceVtbl {
    pub const fn new<Impl: IToolTipServiceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToolTipServiceVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IToolTipService>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToolTipServiceStaticsImpl: Sized {
    fn PlacementProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetPlacement(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<Primitives::PlacementMode>;
    fn SetPlacement(&self, element: &::core::option::Option<super::DependencyObject>, value: Primitives::PlacementMode) -> ::windows::core::Result<()>;
    fn PlacementTargetProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetPlacementTarget(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<super::UIElement>;
    fn SetPlacementTarget(&self, element: &::core::option::Option<super::DependencyObject>, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn ToolTipProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetToolTip(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetToolTip(&self, element: &::core::option::Option<super::DependencyObject>, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToolTipServiceStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTipServiceStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IToolTipServiceStaticsVtbl {
    pub const fn new<Impl: IToolTipServiceStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToolTipServiceStaticsVtbl {
        unsafe extern "system" fn PlacementProperty<Impl: IToolTipServiceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPlacement<Impl: IToolTipServiceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut Primitives::PlacementMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPlacement(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacement<Impl: IToolTipServiceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: Primitives::PlacementMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlacement(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn PlacementTargetProperty<Impl: IToolTipServiceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlacementTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPlacementTarget<Impl: IToolTipServiceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPlacementTarget(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlacementTarget<Impl: IToolTipServiceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPlacementTarget(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ToolTipProperty<Impl: IToolTipServiceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ToolTipProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetToolTip<Impl: IToolTipServiceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetToolTip(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetToolTip<Impl: IToolTipServiceStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetToolTip(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IToolTipServiceStatics>, base.5, PlacementProperty::<Impl, OFFSET>, GetPlacement::<Impl, OFFSET>, SetPlacement::<Impl, OFFSET>, PlacementTargetProperty::<Impl, OFFSET>, GetPlacementTarget::<Impl, OFFSET>, SetPlacementTarget::<Impl, OFFSET>, ToolTipProperty::<Impl, OFFSET>, GetToolTip::<Impl, OFFSET>, SetToolTip::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToolTipStaticsImpl: Sized {
    fn HorizontalOffsetProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsOpenProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlacementProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PlacementTargetProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalOffsetProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToolTipStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTipStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IToolTipStaticsVtbl {
    pub const fn new<Impl: IToolTipStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToolTipStaticsVtbl {
        unsafe extern "system" fn HorizontalOffsetProperty<Impl: IToolTipStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsOpenProperty<Impl: IToolTipStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsOpenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlacementProperty<Impl: IToolTipStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlacementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlacementTargetProperty<Impl: IToolTipStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlacementTargetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalOffsetProperty<Impl: IToolTipStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalOffsetProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IToolTipStatics>, base.5, HorizontalOffsetProperty::<Impl, OFFSET>, IsOpenProperty::<Impl, OFFSET>, PlacementProperty::<Impl, OFFSET>, PlacementTargetProperty::<Impl, OFFSET>, VerticalOffsetProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IToolTipStatics2Impl: Sized {
    fn PlacementRectProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IToolTipStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IToolTipStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IToolTipStatics2Vtbl {
    pub const fn new<Impl: IToolTipStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IToolTipStatics2Vtbl {
        unsafe extern "system" fn PlacementRectProperty<Impl: IToolTipStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlacementRectProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IToolTipStatics2>, base.5, PlacementRectProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewImpl: Sized {
    fn RootNodes(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<TreeViewNode>>;
    fn SelectionMode(&self) -> ::windows::core::Result<TreeViewSelectionMode>;
    fn SetSelectionMode(&self, value: TreeViewSelectionMode) -> ::windows::core::Result<()>;
    fn SelectedNodes(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<TreeViewNode>>;
    fn Expand(&self, value: &::core::option::Option<TreeViewNode>) -> ::windows::core::Result<()>;
    fn Collapse(&self, value: &::core::option::Option<TreeViewNode>) -> ::windows::core::Result<()>;
    fn SelectAll(&self) -> ::windows::core::Result<()>;
    fn ItemInvoked(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewItemInvokedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveItemInvoked(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Expanding(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewExpandingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveExpanding(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn Collapsed(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewCollapsedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCollapsed(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeView";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewVtbl {
    pub const fn new<Impl: ITreeViewImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewVtbl {
        unsafe extern "system" fn RootNodes<Impl: ITreeViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RootNodes() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectionMode<Impl: ITreeViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut TreeViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectionMode<Impl: ITreeViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: TreeViewSelectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSelectionMode(value).into()
        }
        unsafe extern "system" fn SelectedNodes<Impl: ITreeViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectedNodes() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Expand<Impl: ITreeViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Expand(&*(&value as *const <TreeViewNode as ::windows::core::Abi>::Abi as *const <TreeViewNode as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Collapse<Impl: ITreeViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Collapse(&*(&value as *const <TreeViewNode as ::windows::core::Abi>::Abi as *const <TreeViewNode as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn SelectAll<Impl: ITreeViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SelectAll().into()
        }
        unsafe extern "system" fn ItemInvoked<Impl: ITreeViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemInvoked(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewItemInvokedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewItemInvokedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveItemInvoked<Impl: ITreeViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveItemInvoked(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Expanding<Impl: ITreeViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Expanding(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewExpandingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewExpandingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveExpanding<Impl: ITreeViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveExpanding(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Collapsed<Impl: ITreeViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Collapsed(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewCollapsedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewCollapsedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCollapsed<Impl: ITreeViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveCollapsed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeView>, base.5, RootNodes::<Impl, OFFSET>, SelectionMode::<Impl, OFFSET>, SetSelectionMode::<Impl, OFFSET>, SelectedNodes::<Impl, OFFSET>, Expand::<Impl, OFFSET>, Collapse::<Impl, OFFSET>, SelectAll::<Impl, OFFSET>, ItemInvoked::<Impl, OFFSET>, RemoveItemInvoked::<Impl, OFFSET>, Expanding::<Impl, OFFSET>, RemoveExpanding::<Impl, OFFSET>, Collapsed::<Impl, OFFSET>, RemoveCollapsed::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeView2Impl: Sized {
    fn NodeFromContainer(&self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<TreeViewNode>;
    fn ContainerFromNode(&self, node: &::core::option::Option<TreeViewNode>) -> ::windows::core::Result<super::DependencyObject>;
    fn ItemFromContainer(&self, container: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn ContainerFromItem(&self, item: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<super::DependencyObject>;
    fn CanDragItems(&self) -> ::windows::core::Result<bool>;
    fn SetCanDragItems(&self, value: bool) -> ::windows::core::Result<()>;
    fn CanReorderItems(&self) -> ::windows::core::Result<bool>;
    fn SetCanReorderItems(&self, value: bool) -> ::windows::core::Result<()>;
    fn ItemTemplate(&self) -> ::windows::core::Result<super::DataTemplate>;
    fn SetItemTemplate(&self, value: &::core::option::Option<super::DataTemplate>) -> ::windows::core::Result<()>;
    fn ItemTemplateSelector(&self) -> ::windows::core::Result<DataTemplateSelector>;
    fn SetItemTemplateSelector(&self, value: &::core::option::Option<DataTemplateSelector>) -> ::windows::core::Result<()>;
    fn ItemContainerStyle(&self) -> ::windows::core::Result<super::Style>;
    fn SetItemContainerStyle(&self, value: &::core::option::Option<super::Style>) -> ::windows::core::Result<()>;
    fn ItemContainerStyleSelector(&self) -> ::windows::core::Result<StyleSelector>;
    fn SetItemContainerStyleSelector(&self, value: &::core::option::Option<StyleSelector>) -> ::windows::core::Result<()>;
    fn ItemContainerTransitions(&self) -> ::windows::core::Result<super::Media::Animation::TransitionCollection>;
    fn SetItemContainerTransitions(&self, value: &::core::option::Option<super::Media::Animation::TransitionCollection>) -> ::windows::core::Result<()>;
    fn ItemsSource(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetItemsSource(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn DragItemsStarting(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsStartingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDragItemsStarting(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DragItemsCompleted(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsCompletedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDragItemsCompleted(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeView2";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeView2Vtbl {
    pub const fn new<Impl: ITreeView2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeView2Vtbl {
        unsafe extern "system" fn NodeFromContainer<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NodeFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromNode<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, node: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContainerFromNode(&*(&node as *const <TreeViewNode as ::windows::core::Abi>::Abi as *const <TreeViewNode as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemFromContainer<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, container: ::windows::core::RawPtr, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemFromContainer(&*(&container as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainerFromItem<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, item: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContainerFromItem(&*(&item as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanDragItems<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanDragItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanDragItems<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCanDragItems(value).into()
        }
        unsafe extern "system" fn CanReorderItems<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanReorderItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCanReorderItems<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCanReorderItems(value).into()
        }
        unsafe extern "system" fn ItemTemplate<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemTemplate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemTemplate<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemTemplate(&*(&value as *const <super::DataTemplate as ::windows::core::Abi>::Abi as *const <super::DataTemplate as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemTemplateSelector<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemTemplateSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemTemplateSelector<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemTemplateSelector(&*(&value as *const <DataTemplateSelector as ::windows::core::Abi>::Abi as *const <DataTemplateSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerStyle<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerStyle<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemContainerStyle(&*(&value as *const <super::Style as ::windows::core::Abi>::Abi as *const <super::Style as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerStyleSelector<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleSelector() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerStyleSelector<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemContainerStyleSelector(&*(&value as *const <StyleSelector as ::windows::core::Abi>::Abi as *const <StyleSelector as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemContainerTransitions<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemContainerTransitions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemContainerTransitions<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemContainerTransitions(&*(&value as *const <super::Media::Animation::TransitionCollection as ::windows::core::Abi>::Abi as *const <super::Media::Animation::TransitionCollection as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ItemsSource<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemsSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsSource<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemsSource(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DragItemsStarting<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DragItemsStarting(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsStartingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsStartingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDragItemsStarting<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveDragItemsStarting(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DragItemsCompleted<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DragItemsCompleted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsCompletedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TreeView, TreeViewDragItemsCompletedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDragItemsCompleted<Impl: ITreeView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveDragItemsCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ITreeView2>,
            base.5,
            NodeFromContainer::<Impl, OFFSET>,
            ContainerFromNode::<Impl, OFFSET>,
            ItemFromContainer::<Impl, OFFSET>,
            ContainerFromItem::<Impl, OFFSET>,
            CanDragItems::<Impl, OFFSET>,
            SetCanDragItems::<Impl, OFFSET>,
            CanReorderItems::<Impl, OFFSET>,
            SetCanReorderItems::<Impl, OFFSET>,
            ItemTemplate::<Impl, OFFSET>,
            SetItemTemplate::<Impl, OFFSET>,
            ItemTemplateSelector::<Impl, OFFSET>,
            SetItemTemplateSelector::<Impl, OFFSET>,
            ItemContainerStyle::<Impl, OFFSET>,
            SetItemContainerStyle::<Impl, OFFSET>,
            ItemContainerStyleSelector::<Impl, OFFSET>,
            SetItemContainerStyleSelector::<Impl, OFFSET>,
            ItemContainerTransitions::<Impl, OFFSET>,
            SetItemContainerTransitions::<Impl, OFFSET>,
            ItemsSource::<Impl, OFFSET>,
            SetItemsSource::<Impl, OFFSET>,
            DragItemsStarting::<Impl, OFFSET>,
            RemoveDragItemsStarting::<Impl, OFFSET>,
            DragItemsCompleted::<Impl, OFFSET>,
            RemoveDragItemsCompleted::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewCollapsedEventArgsImpl: Sized {
    fn Node(&self) -> ::windows::core::Result<TreeViewNode>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewCollapsedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewCollapsedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewCollapsedEventArgsVtbl {
    pub const fn new<Impl: ITreeViewCollapsedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewCollapsedEventArgsVtbl {
        unsafe extern "system" fn Node<Impl: ITreeViewCollapsedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Node() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewCollapsedEventArgs>, base.5, Node::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewCollapsedEventArgs2Impl: Sized {
    fn Item(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewCollapsedEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewCollapsedEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewCollapsedEventArgs2Vtbl {
    pub const fn new<Impl: ITreeViewCollapsedEventArgs2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewCollapsedEventArgs2Vtbl {
        unsafe extern "system" fn Item<Impl: ITreeViewCollapsedEventArgs2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewCollapsedEventArgs2>, base.5, Item::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewDragItemsCompletedEventArgsImpl: Sized {
    fn DropResult(&self) -> ::windows::core::Result<super::super::super::ApplicationModel::DataTransfer::DataPackageOperation>;
    fn Items(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVectorView<::windows::core::IInspectable>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewDragItemsCompletedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewDragItemsCompletedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewDragItemsCompletedEventArgsVtbl {
    pub const fn new<Impl: ITreeViewDragItemsCompletedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewDragItemsCompletedEventArgsVtbl {
        unsafe extern "system" fn DropResult<Impl: ITreeViewDragItemsCompletedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::ApplicationModel::DataTransfer::DataPackageOperation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DropResult() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Items<Impl: ITreeViewDragItemsCompletedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewDragItemsCompletedEventArgs>, base.5, DropResult::<Impl, OFFSET>, Items::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewDragItemsStartingEventArgsImpl: Sized {
    fn Cancel(&self) -> ::windows::core::Result<bool>;
    fn SetCancel(&self, value: bool) -> ::windows::core::Result<()>;
    fn Data(&self) -> ::windows::core::Result<super::super::super::ApplicationModel::DataTransfer::DataPackage>;
    fn Items(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<::windows::core::IInspectable>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewDragItemsStartingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewDragItemsStartingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewDragItemsStartingEventArgsVtbl {
    pub const fn new<Impl: ITreeViewDragItemsStartingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewDragItemsStartingEventArgsVtbl {
        unsafe extern "system" fn Cancel<Impl: ITreeViewDragItemsStartingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: ITreeViewDragItemsStartingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        unsafe extern "system" fn Data<Impl: ITreeViewDragItemsStartingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Data() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Items<Impl: ITreeViewDragItemsStartingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Items() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewDragItemsStartingEventArgs>, base.5, Cancel::<Impl, OFFSET>, SetCancel::<Impl, OFFSET>, Data::<Impl, OFFSET>, Items::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewExpandingEventArgsImpl: Sized {
    fn Node(&self) -> ::windows::core::Result<TreeViewNode>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewExpandingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewExpandingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewExpandingEventArgsVtbl {
    pub const fn new<Impl: ITreeViewExpandingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewExpandingEventArgsVtbl {
        unsafe extern "system" fn Node<Impl: ITreeViewExpandingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Node() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewExpandingEventArgs>, base.5, Node::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewExpandingEventArgs2Impl: Sized {
    fn Item(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewExpandingEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewExpandingEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewExpandingEventArgs2Vtbl {
    pub const fn new<Impl: ITreeViewExpandingEventArgs2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewExpandingEventArgs2Vtbl {
        unsafe extern "system" fn Item<Impl: ITreeViewExpandingEventArgs2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Item() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewExpandingEventArgs2>, base.5, Item::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TreeView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewFactoryVtbl {
    pub const fn new<Impl: ITreeViewFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITreeViewFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemImpl: Sized {
    fn GlyphOpacity(&self) -> ::windows::core::Result<f64>;
    fn SetGlyphOpacity(&self, value: f64) -> ::windows::core::Result<()>;
    fn GlyphBrush(&self) -> ::windows::core::Result<super::Media::Brush>;
    fn SetGlyphBrush(&self, value: &::core::option::Option<super::Media::Brush>) -> ::windows::core::Result<()>;
    fn ExpandedGlyph(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetExpandedGlyph(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn CollapsedGlyph(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetCollapsedGlyph(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn GlyphSize(&self) -> ::windows::core::Result<f64>;
    fn SetGlyphSize(&self, value: f64) -> ::windows::core::Result<()>;
    fn IsExpanded(&self) -> ::windows::core::Result<bool>;
    fn SetIsExpanded(&self, value: bool) -> ::windows::core::Result<()>;
    fn TreeViewItemTemplateSettings(&self) -> ::windows::core::Result<TreeViewItemTemplateSettings>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItem {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItem";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemVtbl {
    pub const fn new<Impl: ITreeViewItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewItemVtbl {
        unsafe extern "system" fn GlyphOpacity<Impl: ITreeViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GlyphOpacity() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyphOpacity<Impl: ITreeViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetGlyphOpacity(value).into()
        }
        unsafe extern "system" fn GlyphBrush<Impl: ITreeViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GlyphBrush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyphBrush<Impl: ITreeViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetGlyphBrush(&*(&value as *const <super::Media::Brush as ::windows::core::Abi>::Abi as *const <super::Media::Brush as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ExpandedGlyph<Impl: ITreeViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExpandedGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetExpandedGlyph<Impl: ITreeViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetExpandedGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn CollapsedGlyph<Impl: ITreeViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CollapsedGlyph() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCollapsedGlyph<Impl: ITreeViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCollapsedGlyph(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GlyphSize<Impl: ITreeViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GlyphSize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGlyphSize<Impl: ITreeViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetGlyphSize(value).into()
        }
        unsafe extern "system" fn IsExpanded<Impl: ITreeViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsExpanded() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsExpanded<Impl: ITreeViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsExpanded(value).into()
        }
        unsafe extern "system" fn TreeViewItemTemplateSettings<Impl: ITreeViewItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TreeViewItemTemplateSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ITreeViewItem>,
            base.5,
            GlyphOpacity::<Impl, OFFSET>,
            SetGlyphOpacity::<Impl, OFFSET>,
            GlyphBrush::<Impl, OFFSET>,
            SetGlyphBrush::<Impl, OFFSET>,
            ExpandedGlyph::<Impl, OFFSET>,
            SetExpandedGlyph::<Impl, OFFSET>,
            CollapsedGlyph::<Impl, OFFSET>,
            SetCollapsedGlyph::<Impl, OFFSET>,
            GlyphSize::<Impl, OFFSET>,
            SetGlyphSize::<Impl, OFFSET>,
            IsExpanded::<Impl, OFFSET>,
            SetIsExpanded::<Impl, OFFSET>,
            TreeViewItemTemplateSettings::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItem2Impl: Sized {
    fn HasUnrealizedChildren(&self) -> ::windows::core::Result<bool>;
    fn SetHasUnrealizedChildren(&self, value: bool) -> ::windows::core::Result<()>;
    fn ItemsSource(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetItemsSource(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItem2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItem2";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItem2Vtbl {
    pub const fn new<Impl: ITreeViewItem2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewItem2Vtbl {
        unsafe extern "system" fn HasUnrealizedChildren<Impl: ITreeViewItem2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HasUnrealizedChildren() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHasUnrealizedChildren<Impl: ITreeViewItem2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHasUnrealizedChildren(value).into()
        }
        unsafe extern "system" fn ItemsSource<Impl: ITreeViewItem2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemsSource() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemsSource<Impl: ITreeViewItem2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemsSource(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewItem2>, base.5, HasUnrealizedChildren::<Impl, OFFSET>, SetHasUnrealizedChildren::<Impl, OFFSET>, ItemsSource::<Impl, OFFSET>, SetItemsSource::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TreeViewItem>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemFactoryVtbl {
    pub const fn new<Impl: ITreeViewItemFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewItemFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITreeViewItemFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewItemFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemInvokedEventArgsImpl: Sized {
    fn InvokedItem(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetHandled(&self, value: bool) -> ::windows::core::Result<()>;
    fn Handled(&self) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemInvokedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemInvokedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemInvokedEventArgsVtbl {
    pub const fn new<Impl: ITreeViewItemInvokedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewItemInvokedEventArgsVtbl {
        unsafe extern "system" fn InvokedItem<Impl: ITreeViewItemInvokedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InvokedItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: ITreeViewItemInvokedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        unsafe extern "system" fn Handled<Impl: ITreeViewItemInvokedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewItemInvokedEventArgs>, base.5, InvokedItem::<Impl, OFFSET>, SetHandled::<Impl, OFFSET>, Handled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemStaticsImpl: Sized {
    fn GlyphOpacityProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GlyphBrushProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ExpandedGlyphProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CollapsedGlyphProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GlyphSizeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsExpandedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TreeViewItemTemplateSettingsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemStaticsVtbl {
    pub const fn new<Impl: ITreeViewItemStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewItemStaticsVtbl {
        unsafe extern "system" fn GlyphOpacityProperty<Impl: ITreeViewItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GlyphOpacityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GlyphBrushProperty<Impl: ITreeViewItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GlyphBrushProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExpandedGlyphProperty<Impl: ITreeViewItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExpandedGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CollapsedGlyphProperty<Impl: ITreeViewItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CollapsedGlyphProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GlyphSizeProperty<Impl: ITreeViewItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GlyphSizeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExpandedProperty<Impl: ITreeViewItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsExpandedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TreeViewItemTemplateSettingsProperty<Impl: ITreeViewItemStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TreeViewItemTemplateSettingsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewItemStatics>, base.5, GlyphOpacityProperty::<Impl, OFFSET>, GlyphBrushProperty::<Impl, OFFSET>, ExpandedGlyphProperty::<Impl, OFFSET>, CollapsedGlyphProperty::<Impl, OFFSET>, GlyphSizeProperty::<Impl, OFFSET>, IsExpandedProperty::<Impl, OFFSET>, TreeViewItemTemplateSettingsProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemStatics2Impl: Sized {
    fn HasUnrealizedChildrenProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemsSourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemStatics2Vtbl {
    pub const fn new<Impl: ITreeViewItemStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewItemStatics2Vtbl {
        unsafe extern "system" fn HasUnrealizedChildrenProperty<Impl: ITreeViewItemStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HasUnrealizedChildrenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsSourceProperty<Impl: ITreeViewItemStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemsSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewItemStatics2>, base.5, HasUnrealizedChildrenProperty::<Impl, OFFSET>, ItemsSourceProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemTemplateSettingsImpl: Sized {
    fn ExpandedGlyphVisibility(&self) -> ::windows::core::Result<super::Visibility>;
    fn CollapsedGlyphVisibility(&self) -> ::windows::core::Result<super::Visibility>;
    fn Indentation(&self) -> ::windows::core::Result<super::Thickness>;
    fn DragItemsCount(&self) -> ::windows::core::Result<i32>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemTemplateSettings {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettings";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemTemplateSettingsVtbl {
    pub const fn new<Impl: ITreeViewItemTemplateSettingsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewItemTemplateSettingsVtbl {
        unsafe extern "system" fn ExpandedGlyphVisibility<Impl: ITreeViewItemTemplateSettingsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExpandedGlyphVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CollapsedGlyphVisibility<Impl: ITreeViewItemTemplateSettingsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Visibility) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CollapsedGlyphVisibility() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Indentation<Impl: ITreeViewItemTemplateSettingsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Thickness) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Indentation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DragItemsCount<Impl: ITreeViewItemTemplateSettingsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DragItemsCount() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewItemTemplateSettings>, base.5, ExpandedGlyphVisibility::<Impl, OFFSET>, CollapsedGlyphVisibility::<Impl, OFFSET>, Indentation::<Impl, OFFSET>, DragItemsCount::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemTemplateSettingsFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TreeViewItemTemplateSettings>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemTemplateSettingsFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettingsFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemTemplateSettingsFactoryVtbl {
    pub const fn new<Impl: ITreeViewItemTemplateSettingsFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewItemTemplateSettingsFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITreeViewItemTemplateSettingsFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewItemTemplateSettingsFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewItemTemplateSettingsStaticsImpl: Sized {
    fn ExpandedGlyphVisibilityProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CollapsedGlyphVisibilityProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IndentationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DragItemsCountProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewItemTemplateSettingsStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettingsStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewItemTemplateSettingsStaticsVtbl {
    pub const fn new<Impl: ITreeViewItemTemplateSettingsStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewItemTemplateSettingsStaticsVtbl {
        unsafe extern "system" fn ExpandedGlyphVisibilityProperty<Impl: ITreeViewItemTemplateSettingsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExpandedGlyphVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CollapsedGlyphVisibilityProperty<Impl: ITreeViewItemTemplateSettingsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CollapsedGlyphVisibilityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IndentationProperty<Impl: ITreeViewItemTemplateSettingsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IndentationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DragItemsCountProperty<Impl: ITreeViewItemTemplateSettingsStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DragItemsCountProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewItemTemplateSettingsStatics>, base.5, ExpandedGlyphVisibilityProperty::<Impl, OFFSET>, CollapsedGlyphVisibilityProperty::<Impl, OFFSET>, IndentationProperty::<Impl, OFFSET>, DragItemsCountProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewListImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewList {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewList";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewListVtbl {
    pub const fn new<Impl: ITreeViewListImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewListVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewList>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewListFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TreeViewList>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewListFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewListFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewListFactoryVtbl {
    pub const fn new<Impl: ITreeViewListFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewListFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITreeViewListFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewListFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewNodeImpl: Sized {
    fn Content(&self) -> ::windows::core::Result<::windows::core::IInspectable>;
    fn SetContent(&self, value: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn Parent(&self) -> ::windows::core::Result<TreeViewNode>;
    fn IsExpanded(&self) -> ::windows::core::Result<bool>;
    fn SetIsExpanded(&self, value: bool) -> ::windows::core::Result<()>;
    fn HasChildren(&self) -> ::windows::core::Result<bool>;
    fn Depth(&self) -> ::windows::core::Result<i32>;
    fn HasUnrealizedChildren(&self) -> ::windows::core::Result<bool>;
    fn SetHasUnrealizedChildren(&self, value: bool) -> ::windows::core::Result<()>;
    fn Children(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<TreeViewNode>>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewNode {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewNode";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewNodeVtbl {
    pub const fn new<Impl: ITreeViewNodeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewNodeVtbl {
        unsafe extern "system" fn Content<Impl: ITreeViewNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: ITreeViewNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Parent<Impl: ITreeViewNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Parent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExpanded<Impl: ITreeViewNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsExpanded() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsExpanded<Impl: ITreeViewNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsExpanded(value).into()
        }
        unsafe extern "system" fn HasChildren<Impl: ITreeViewNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HasChildren() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Depth<Impl: ITreeViewNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Depth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasUnrealizedChildren<Impl: ITreeViewNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HasUnrealizedChildren() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHasUnrealizedChildren<Impl: ITreeViewNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHasUnrealizedChildren(value).into()
        }
        unsafe extern "system" fn Children<Impl: ITreeViewNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Children() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewNode>, base.5, Content::<Impl, OFFSET>, SetContent::<Impl, OFFSET>, Parent::<Impl, OFFSET>, IsExpanded::<Impl, OFFSET>, SetIsExpanded::<Impl, OFFSET>, HasChildren::<Impl, OFFSET>, Depth::<Impl, OFFSET>, HasUnrealizedChildren::<Impl, OFFSET>, SetHasUnrealizedChildren::<Impl, OFFSET>, Children::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewNodeFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TreeViewNode>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewNodeFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewNodeFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewNodeFactoryVtbl {
    pub const fn new<Impl: ITreeViewNodeFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewNodeFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITreeViewNodeFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewNodeFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewNodeStaticsImpl: Sized {
    fn ContentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DepthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn IsExpandedProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HasChildrenProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewNodeStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewNodeStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewNodeStaticsVtbl {
    pub const fn new<Impl: ITreeViewNodeStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewNodeStaticsVtbl {
        unsafe extern "system" fn ContentProperty<Impl: ITreeViewNodeStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DepthProperty<Impl: ITreeViewNodeStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DepthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExpandedProperty<Impl: ITreeViewNodeStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsExpandedProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasChildrenProperty<Impl: ITreeViewNodeStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HasChildrenProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewNodeStatics>, base.5, ContentProperty::<Impl, OFFSET>, DepthProperty::<Impl, OFFSET>, IsExpandedProperty::<Impl, OFFSET>, HasChildrenProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewStaticsImpl: Sized {
    fn SelectionModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewStaticsVtbl {
    pub const fn new<Impl: ITreeViewStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewStaticsVtbl {
        unsafe extern "system" fn SelectionModeProperty<Impl: ITreeViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectionModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewStatics>, base.5, SelectionModeProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITreeViewStatics2Impl: Sized {
    fn CanDragItemsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanReorderItemsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemTemplateProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemTemplateSelectorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerStyleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerStyleSelectorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemContainerTransitionsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemsSourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITreeViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITreeViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl ITreeViewStatics2Vtbl {
    pub const fn new<Impl: ITreeViewStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITreeViewStatics2Vtbl {
        unsafe extern "system" fn CanDragItemsProperty<Impl: ITreeViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanDragItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanReorderItemsProperty<Impl: ITreeViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanReorderItemsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplateProperty<Impl: ITreeViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemTemplateProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemTemplateSelectorProperty<Impl: ITreeViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemTemplateSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerStyleProperty<Impl: ITreeViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerStyleSelectorProperty<Impl: ITreeViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemContainerStyleSelectorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemContainerTransitionsProperty<Impl: ITreeViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemContainerTransitionsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemsSourceProperty<Impl: ITreeViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemsSourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITreeViewStatics2>, base.5, CanDragItemsProperty::<Impl, OFFSET>, CanReorderItemsProperty::<Impl, OFFSET>, ItemTemplateProperty::<Impl, OFFSET>, ItemTemplateSelectorProperty::<Impl, OFFSET>, ItemContainerStyleProperty::<Impl, OFFSET>, ItemContainerStyleSelectorProperty::<Impl, OFFSET>, ItemContainerTransitionsProperty::<Impl, OFFSET>, ItemsSourceProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITwoPaneViewImpl: Sized {
    fn Pane1(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetPane1(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn Pane2(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetPane2(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn Pane1Length(&self) -> ::windows::core::Result<super::GridLength>;
    fn SetPane1Length(&self, value: &super::GridLength) -> ::windows::core::Result<()>;
    fn Pane2Length(&self) -> ::windows::core::Result<super::GridLength>;
    fn SetPane2Length(&self, value: &super::GridLength) -> ::windows::core::Result<()>;
    fn PanePriority(&self) -> ::windows::core::Result<TwoPaneViewPriority>;
    fn SetPanePriority(&self, value: TwoPaneViewPriority) -> ::windows::core::Result<()>;
    fn Mode(&self) -> ::windows::core::Result<TwoPaneViewMode>;
    fn WideModeConfiguration(&self) -> ::windows::core::Result<TwoPaneViewWideModeConfiguration>;
    fn SetWideModeConfiguration(&self, value: TwoPaneViewWideModeConfiguration) -> ::windows::core::Result<()>;
    fn TallModeConfiguration(&self) -> ::windows::core::Result<TwoPaneViewTallModeConfiguration>;
    fn SetTallModeConfiguration(&self, value: TwoPaneViewTallModeConfiguration) -> ::windows::core::Result<()>;
    fn MinWideModeWidth(&self) -> ::windows::core::Result<f64>;
    fn SetMinWideModeWidth(&self, value: f64) -> ::windows::core::Result<()>;
    fn MinTallModeHeight(&self) -> ::windows::core::Result<f64>;
    fn SetMinTallModeHeight(&self, value: f64) -> ::windows::core::Result<()>;
    fn ModeChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<TwoPaneView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveModeChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITwoPaneView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITwoPaneView";
}
#[cfg(feature = "implement_exclusive")]
impl ITwoPaneViewVtbl {
    pub const fn new<Impl: ITwoPaneViewImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITwoPaneViewVtbl {
        unsafe extern "system" fn Pane1<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pane1() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPane1<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPane1(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Pane2<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pane2() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPane2<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPane2(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Pane1Length<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pane1Length() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPane1Length<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPane1Length(&*(&value as *const <super::GridLength as ::windows::core::Abi>::Abi as *const <super::GridLength as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Pane2Length<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pane2Length() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPane2Length<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::GridLength) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPane2Length(&*(&value as *const <super::GridLength as ::windows::core::Abi>::Abi as *const <super::GridLength as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PanePriority<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut TwoPaneViewPriority) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PanePriority() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPanePriority<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: TwoPaneViewPriority) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPanePriority(value).into()
        }
        unsafe extern "system" fn Mode<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut TwoPaneViewMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Mode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WideModeConfiguration<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut TwoPaneViewWideModeConfiguration) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WideModeConfiguration() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWideModeConfiguration<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: TwoPaneViewWideModeConfiguration) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetWideModeConfiguration(value).into()
        }
        unsafe extern "system" fn TallModeConfiguration<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut TwoPaneViewTallModeConfiguration) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TallModeConfiguration() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTallModeConfiguration<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: TwoPaneViewTallModeConfiguration) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetTallModeConfiguration(value).into()
        }
        unsafe extern "system" fn MinWideModeWidth<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinWideModeWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinWideModeWidth<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMinWideModeWidth(value).into()
        }
        unsafe extern "system" fn MinTallModeHeight<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinTallModeHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMinTallModeHeight<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMinTallModeHeight(value).into()
        }
        unsafe extern "system" fn ModeChanged<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ModeChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<TwoPaneView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<TwoPaneView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveModeChanged<Impl: ITwoPaneViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveModeChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ITwoPaneView>,
            base.5,
            Pane1::<Impl, OFFSET>,
            SetPane1::<Impl, OFFSET>,
            Pane2::<Impl, OFFSET>,
            SetPane2::<Impl, OFFSET>,
            Pane1Length::<Impl, OFFSET>,
            SetPane1Length::<Impl, OFFSET>,
            Pane2Length::<Impl, OFFSET>,
            SetPane2Length::<Impl, OFFSET>,
            PanePriority::<Impl, OFFSET>,
            SetPanePriority::<Impl, OFFSET>,
            Mode::<Impl, OFFSET>,
            WideModeConfiguration::<Impl, OFFSET>,
            SetWideModeConfiguration::<Impl, OFFSET>,
            TallModeConfiguration::<Impl, OFFSET>,
            SetTallModeConfiguration::<Impl, OFFSET>,
            MinWideModeWidth::<Impl, OFFSET>,
            SetMinWideModeWidth::<Impl, OFFSET>,
            MinTallModeHeight::<Impl, OFFSET>,
            SetMinTallModeHeight::<Impl, OFFSET>,
            ModeChanged::<Impl, OFFSET>,
            RemoveModeChanged::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITwoPaneViewFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<TwoPaneView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITwoPaneViewFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITwoPaneViewFactory";
}
#[cfg(feature = "implement_exclusive")]
impl ITwoPaneViewFactoryVtbl {
    pub const fn new<Impl: ITwoPaneViewFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITwoPaneViewFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: ITwoPaneViewFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITwoPaneViewFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait ITwoPaneViewStaticsImpl: Sized {
    fn Pane1Property(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn Pane2Property(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn Pane1LengthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn Pane2LengthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn PanePriorityProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn WideModeConfigurationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn TallModeConfigurationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinWideModeWidthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MinTallModeHeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for ITwoPaneViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.ITwoPaneViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl ITwoPaneViewStaticsVtbl {
    pub const fn new<Impl: ITwoPaneViewStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITwoPaneViewStaticsVtbl {
        unsafe extern "system" fn Pane1Property<Impl: ITwoPaneViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pane1Property() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pane2Property<Impl: ITwoPaneViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pane2Property() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pane1LengthProperty<Impl: ITwoPaneViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pane1LengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pane2LengthProperty<Impl: ITwoPaneViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pane2LengthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PanePriorityProperty<Impl: ITwoPaneViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PanePriorityProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ModeProperty<Impl: ITwoPaneViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WideModeConfigurationProperty<Impl: ITwoPaneViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WideModeConfigurationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TallModeConfigurationProperty<Impl: ITwoPaneViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TallModeConfigurationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinWideModeWidthProperty<Impl: ITwoPaneViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinWideModeWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MinTallModeHeightProperty<Impl: ITwoPaneViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MinTallModeHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ITwoPaneViewStatics>,
            base.5,
            Pane1Property::<Impl, OFFSET>,
            Pane2Property::<Impl, OFFSET>,
            Pane1LengthProperty::<Impl, OFFSET>,
            Pane2LengthProperty::<Impl, OFFSET>,
            PanePriorityProperty::<Impl, OFFSET>,
            ModeProperty::<Impl, OFFSET>,
            WideModeConfigurationProperty::<Impl, OFFSET>,
            TallModeConfigurationProperty::<Impl, OFFSET>,
            MinWideModeWidthProperty::<Impl, OFFSET>,
            MinTallModeHeightProperty::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IUIElementCollectionImpl: Sized {
    fn Move(&self, oldindex: u32, newindex: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IUIElementCollection {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IUIElementCollection";
}
#[cfg(feature = "implement_exclusive")]
impl IUIElementCollectionVtbl {
    pub const fn new<Impl: IUIElementCollectionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IUIElementCollectionVtbl {
        unsafe extern "system" fn Move<Impl: IUIElementCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, oldindex: u32, newindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Move(oldindex, newindex).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IUIElementCollection>, base.5, Move::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IUserControlImpl: Sized {
    fn Content(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetContent(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IUserControl {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IUserControl";
}
#[cfg(feature = "implement_exclusive")]
impl IUserControlVtbl {
    pub const fn new<Impl: IUserControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IUserControlVtbl {
        unsafe extern "system" fn Content<Impl: IUserControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Content() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContent<Impl: IUserControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetContent(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IUserControl>, base.5, Content::<Impl, OFFSET>, SetContent::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IUserControlFactoryImpl: Sized {
    fn CreateInstance(&self, baseinterface: &::core::option::Option<::windows::core::IInspectable>, innerinterface: &mut ::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<UserControl>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IUserControlFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IUserControlFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IUserControlFactoryVtbl {
    pub const fn new<Impl: IUserControlFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IUserControlFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IUserControlFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, baseinterface: *mut ::core::ffi::c_void, innerinterface: *mut *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&baseinterface as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&innerinterface)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IUserControlFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IUserControlStaticsImpl: Sized {
    fn ContentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IUserControlStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IUserControlStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IUserControlStaticsVtbl {
    pub const fn new<Impl: IUserControlStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IUserControlStaticsVtbl {
        unsafe extern "system" fn ContentProperty<Impl: IUserControlStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IUserControlStatics>, base.5, ContentProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVariableSizedWrapGridImpl: Sized {
    fn ItemHeight(&self) -> ::windows::core::Result<f64>;
    fn SetItemHeight(&self, value: f64) -> ::windows::core::Result<()>;
    fn ItemWidth(&self) -> ::windows::core::Result<f64>;
    fn SetItemWidth(&self, value: f64) -> ::windows::core::Result<()>;
    fn Orientation(&self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&self, value: Orientation) -> ::windows::core::Result<()>;
    fn HorizontalChildrenAlignment(&self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalChildrenAlignment(&self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalChildrenAlignment(&self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalChildrenAlignment(&self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
    fn MaximumRowsOrColumns(&self) -> ::windows::core::Result<i32>;
    fn SetMaximumRowsOrColumns(&self, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVariableSizedWrapGrid {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVariableSizedWrapGrid";
}
#[cfg(feature = "implement_exclusive")]
impl IVariableSizedWrapGridVtbl {
    pub const fn new<Impl: IVariableSizedWrapGridImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVariableSizedWrapGridVtbl {
        unsafe extern "system" fn ItemHeight<Impl: IVariableSizedWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemHeight<Impl: IVariableSizedWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemHeight(value).into()
        }
        unsafe extern "system" fn ItemWidth<Impl: IVariableSizedWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemWidth<Impl: IVariableSizedWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemWidth(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: IVariableSizedWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IVariableSizedWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn HorizontalChildrenAlignment<Impl: IVariableSizedWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalChildrenAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalChildrenAlignment<Impl: IVariableSizedWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalChildrenAlignment(value).into()
        }
        unsafe extern "system" fn VerticalChildrenAlignment<Impl: IVariableSizedWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalChildrenAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalChildrenAlignment<Impl: IVariableSizedWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalChildrenAlignment(value).into()
        }
        unsafe extern "system" fn MaximumRowsOrColumns<Impl: IVariableSizedWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumns() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaximumRowsOrColumns<Impl: IVariableSizedWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaximumRowsOrColumns(value).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IVariableSizedWrapGrid>,
            base.5,
            ItemHeight::<Impl, OFFSET>,
            SetItemHeight::<Impl, OFFSET>,
            ItemWidth::<Impl, OFFSET>,
            SetItemWidth::<Impl, OFFSET>,
            Orientation::<Impl, OFFSET>,
            SetOrientation::<Impl, OFFSET>,
            HorizontalChildrenAlignment::<Impl, OFFSET>,
            SetHorizontalChildrenAlignment::<Impl, OFFSET>,
            VerticalChildrenAlignment::<Impl, OFFSET>,
            SetVerticalChildrenAlignment::<Impl, OFFSET>,
            MaximumRowsOrColumns::<Impl, OFFSET>,
            SetMaximumRowsOrColumns::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVariableSizedWrapGridStaticsImpl: Sized {
    fn ItemHeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemWidthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalChildrenAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalChildrenAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaximumRowsOrColumnsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn RowSpanProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetRowSpan(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<i32>;
    fn SetRowSpan(&self, element: &::core::option::Option<super::UIElement>, value: i32) -> ::windows::core::Result<()>;
    fn ColumnSpanProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetColumnSpan(&self, element: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<i32>;
    fn SetColumnSpan(&self, element: &::core::option::Option<super::UIElement>, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVariableSizedWrapGridStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVariableSizedWrapGridStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IVariableSizedWrapGridStaticsVtbl {
    pub const fn new<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVariableSizedWrapGridStaticsVtbl {
        unsafe extern "system" fn ItemHeightProperty<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemWidthProperty<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalChildrenAlignmentProperty<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalChildrenAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalChildrenAlignmentProperty<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalChildrenAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaximumRowsOrColumnsProperty<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumnsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RowSpanProperty<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RowSpanProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRowSpan<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRowSpan(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRowSpan<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetRowSpan(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn ColumnSpanProperty<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ColumnSpanProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetColumnSpan<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetColumnSpan(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetColumnSpan<Impl: IVariableSizedWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetColumnSpan(&*(&element as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IVariableSizedWrapGridStatics>,
            base.5,
            ItemHeightProperty::<Impl, OFFSET>,
            ItemWidthProperty::<Impl, OFFSET>,
            OrientationProperty::<Impl, OFFSET>,
            HorizontalChildrenAlignmentProperty::<Impl, OFFSET>,
            VerticalChildrenAlignmentProperty::<Impl, OFFSET>,
            MaximumRowsOrColumnsProperty::<Impl, OFFSET>,
            RowSpanProperty::<Impl, OFFSET>,
            GetRowSpan::<Impl, OFFSET>,
            SetRowSpan::<Impl, OFFSET>,
            ColumnSpanProperty::<Impl, OFFSET>,
            GetColumnSpan::<Impl, OFFSET>,
            SetColumnSpan::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IViewboxImpl: Sized {
    fn Child(&self) -> ::windows::core::Result<super::UIElement>;
    fn SetChild(&self, value: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn Stretch(&self) -> ::windows::core::Result<super::Media::Stretch>;
    fn SetStretch(&self, value: super::Media::Stretch) -> ::windows::core::Result<()>;
    fn StretchDirection(&self) -> ::windows::core::Result<StretchDirection>;
    fn SetStretchDirection(&self, value: StretchDirection) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IViewbox {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IViewbox";
}
#[cfg(feature = "implement_exclusive")]
impl IViewboxVtbl {
    pub const fn new<Impl: IViewboxImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IViewboxVtbl {
        unsafe extern "system" fn Child<Impl: IViewboxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Child() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChild<Impl: IViewboxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetChild(&*(&value as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Stretch<Impl: IViewboxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stretch() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretch<Impl: IViewboxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::Media::Stretch) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetStretch(value).into()
        }
        unsafe extern "system" fn StretchDirection<Impl: IViewboxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut StretchDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StretchDirection() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStretchDirection<Impl: IViewboxImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: StretchDirection) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetStretchDirection(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IViewbox>, base.5, Child::<Impl, OFFSET>, SetChild::<Impl, OFFSET>, Stretch::<Impl, OFFSET>, SetStretch::<Impl, OFFSET>, StretchDirection::<Impl, OFFSET>, SetStretchDirection::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IViewboxStaticsImpl: Sized {
    fn StretchProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn StretchDirectionProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IViewboxStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IViewboxStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IViewboxStaticsVtbl {
    pub const fn new<Impl: IViewboxStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IViewboxStaticsVtbl {
        unsafe extern "system" fn StretchProperty<Impl: IViewboxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StretchProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StretchDirectionProperty<Impl: IViewboxStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StretchDirectionProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IViewboxStatics>, base.5, StretchProperty::<Impl, OFFSET>, StretchDirectionProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVirtualizingPanelImpl: Sized {
    fn ItemContainerGenerator(&self) -> ::windows::core::Result<ItemContainerGenerator>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVirtualizingPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingPanel";
}
#[cfg(feature = "implement_exclusive")]
impl IVirtualizingPanelVtbl {
    pub const fn new<Impl: IVirtualizingPanelImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVirtualizingPanelVtbl {
        unsafe extern "system" fn ItemContainerGenerator<Impl: IVirtualizingPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemContainerGenerator() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVirtualizingPanel>, base.5, ItemContainerGenerator::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVirtualizingPanelFactoryImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVirtualizingPanelFactory {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingPanelFactory";
}
#[cfg(feature = "implement_exclusive")]
impl IVirtualizingPanelFactoryVtbl {
    pub const fn new<Impl: IVirtualizingPanelFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVirtualizingPanelFactoryVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVirtualizingPanelFactory>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVirtualizingPanelOverridesImpl: Sized {
    fn OnItemsChanged(&self, sender: &::core::option::Option<::windows::core::IInspectable>, args: &::core::option::Option<Primitives::ItemsChangedEventArgs>) -> ::windows::core::Result<()>;
    fn OnClearChildren(&self) -> ::windows::core::Result<()>;
    fn BringIndexIntoView(&self, index: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVirtualizingPanelOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingPanelOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IVirtualizingPanelOverridesVtbl {
    pub const fn new<Impl: IVirtualizingPanelOverridesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVirtualizingPanelOverridesVtbl {
        unsafe extern "system" fn OnItemsChanged<Impl: IVirtualizingPanelOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sender: *mut ::core::ffi::c_void, args: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnItemsChanged(&*(&sender as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType), &*(&args as *const <Primitives::ItemsChangedEventArgs as ::windows::core::Abi>::Abi as *const <Primitives::ItemsChangedEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn OnClearChildren<Impl: IVirtualizingPanelOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnClearChildren().into()
        }
        unsafe extern "system" fn BringIndexIntoView<Impl: IVirtualizingPanelOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).BringIndexIntoView(index).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVirtualizingPanelOverrides>, base.5, OnItemsChanged::<Impl, OFFSET>, OnClearChildren::<Impl, OFFSET>, BringIndexIntoView::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVirtualizingPanelProtectedImpl: Sized {
    fn AddInternalChild(&self, child: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn InsertInternalChild(&self, index: i32, child: &::core::option::Option<super::UIElement>) -> ::windows::core::Result<()>;
    fn RemoveInternalChildRange(&self, index: i32, range: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVirtualizingPanelProtected {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingPanelProtected";
}
#[cfg(feature = "implement_exclusive")]
impl IVirtualizingPanelProtectedVtbl {
    pub const fn new<Impl: IVirtualizingPanelProtectedImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVirtualizingPanelProtectedVtbl {
        unsafe extern "system" fn AddInternalChild<Impl: IVirtualizingPanelProtectedImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, child: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).AddInternalChild(&*(&child as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn InsertInternalChild<Impl: IVirtualizingPanelProtectedImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: i32, child: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).InsertInternalChild(index, &*(&child as *const <super::UIElement as ::windows::core::Abi>::Abi as *const <super::UIElement as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn RemoveInternalChildRange<Impl: IVirtualizingPanelProtectedImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: i32, range: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveInternalChildRange(index, range).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVirtualizingPanelProtected>, base.5, AddInternalChild::<Impl, OFFSET>, InsertInternalChild::<Impl, OFFSET>, RemoveInternalChildRange::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVirtualizingStackPanelImpl: Sized {
    fn AreScrollSnapPointsRegular(&self) -> ::windows::core::Result<bool>;
    fn SetAreScrollSnapPointsRegular(&self, value: bool) -> ::windows::core::Result<()>;
    fn Orientation(&self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&self, value: Orientation) -> ::windows::core::Result<()>;
    fn CleanUpVirtualizedItemEvent(&self, handler: &::core::option::Option<CleanUpVirtualizedItemEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveCleanUpVirtualizedItemEvent(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVirtualizingStackPanel {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingStackPanel";
}
#[cfg(feature = "implement_exclusive")]
impl IVirtualizingStackPanelVtbl {
    pub const fn new<Impl: IVirtualizingStackPanelImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVirtualizingStackPanelVtbl {
        unsafe extern "system" fn AreScrollSnapPointsRegular<Impl: IVirtualizingStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AreScrollSnapPointsRegular() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAreScrollSnapPointsRegular<Impl: IVirtualizingStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAreScrollSnapPointsRegular(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: IVirtualizingStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IVirtualizingStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn CleanUpVirtualizedItemEvent<Impl: IVirtualizingStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CleanUpVirtualizedItemEvent(&*(&handler as *const <CleanUpVirtualizedItemEventHandler as ::windows::core::Abi>::Abi as *const <CleanUpVirtualizedItemEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCleanUpVirtualizedItemEvent<Impl: IVirtualizingStackPanelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveCleanUpVirtualizedItemEvent(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVirtualizingStackPanel>, base.5, AreScrollSnapPointsRegular::<Impl, OFFSET>, SetAreScrollSnapPointsRegular::<Impl, OFFSET>, Orientation::<Impl, OFFSET>, SetOrientation::<Impl, OFFSET>, CleanUpVirtualizedItemEvent::<Impl, OFFSET>, RemoveCleanUpVirtualizedItemEvent::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVirtualizingStackPanelOverridesImpl: Sized {
    fn OnCleanUpVirtualizedItem(&self, e: &::core::option::Option<CleanUpVirtualizedItemEventArgs>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVirtualizingStackPanelOverrides {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingStackPanelOverrides";
}
#[cfg(feature = "implement_exclusive")]
impl IVirtualizingStackPanelOverridesVtbl {
    pub const fn new<Impl: IVirtualizingStackPanelOverridesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVirtualizingStackPanelOverridesVtbl {
        unsafe extern "system" fn OnCleanUpVirtualizedItem<Impl: IVirtualizingStackPanelOverridesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, e: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnCleanUpVirtualizedItem(&*(&e as *const <CleanUpVirtualizedItemEventArgs as ::windows::core::Abi>::Abi as *const <CleanUpVirtualizedItemEventArgs as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVirtualizingStackPanelOverrides>, base.5, OnCleanUpVirtualizedItem::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IVirtualizingStackPanelStaticsImpl: Sized {
    fn AreScrollSnapPointsRegularProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VirtualizationModeProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetVirtualizationMode(&self, element: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<VirtualizationMode>;
    fn SetVirtualizationMode(&self, element: &::core::option::Option<super::DependencyObject>, value: VirtualizationMode) -> ::windows::core::Result<()>;
    fn IsVirtualizingProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn GetIsVirtualizing(&self, o: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IVirtualizingStackPanelStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IVirtualizingStackPanelStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IVirtualizingStackPanelStaticsVtbl {
    pub const fn new<Impl: IVirtualizingStackPanelStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IVirtualizingStackPanelStaticsVtbl {
        unsafe extern "system" fn AreScrollSnapPointsRegularProperty<Impl: IVirtualizingStackPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AreScrollSnapPointsRegularProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IVirtualizingStackPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VirtualizationModeProperty<Impl: IVirtualizingStackPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VirtualizationModeProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVirtualizationMode<Impl: IVirtualizingStackPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, result__: *mut VirtualizationMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVirtualizationMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVirtualizationMode<Impl: IVirtualizingStackPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, element: ::windows::core::RawPtr, value: VirtualizationMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVirtualizationMode(&*(&element as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType), value).into()
        }
        unsafe extern "system" fn IsVirtualizingProperty<Impl: IVirtualizingStackPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsVirtualizingProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIsVirtualizing<Impl: IVirtualizingStackPanelStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, o: ::windows::core::RawPtr, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIsVirtualizing(&*(&o as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IVirtualizingStackPanelStatics>, base.5, AreScrollSnapPointsRegularProperty::<Impl, OFFSET>, OrientationProperty::<Impl, OFFSET>, VirtualizationModeProperty::<Impl, OFFSET>, GetVirtualizationMode::<Impl, OFFSET>, SetVirtualizationMode::<Impl, OFFSET>, IsVirtualizingProperty::<Impl, OFFSET>, GetIsVirtualizing::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewImpl: Sized {
    fn Source(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn SetSource(&self, value: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
    fn AllowedScriptNotifyUris(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::Uri>>;
    fn SetAllowedScriptNotifyUris(&self, value: &::core::option::Option<super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::Uri>>) -> ::windows::core::Result<()>;
    fn DataTransferPackage(&self) -> ::windows::core::Result<super::super::super::ApplicationModel::DataTransfer::DataPackage>;
    fn LoadCompleted(&self, handler: &::core::option::Option<super::Navigation::LoadCompletedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveLoadCompleted(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ScriptNotify(&self, handler: &::core::option::Option<NotifyEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveScriptNotify(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn NavigationFailed(&self, handler: &::core::option::Option<WebViewNavigationFailedEventHandler>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigationFailed(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn InvokeScript(&self, scriptname: &::windows::core::HSTRING, arguments: &[<::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType]) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn Navigate(&self, source: &::core::option::Option<super::super::super::Foundation::Uri>) -> ::windows::core::Result<()>;
    fn NavigateToString(&self, text: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebView {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewVtbl {
    pub const fn new<Impl: IWebViewImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewVtbl {
        unsafe extern "system" fn Source<Impl: IWebViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Source() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IWebViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&value as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AllowedScriptNotifyUris<Impl: IWebViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AllowedScriptNotifyUris() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAllowedScriptNotifyUris<Impl: IWebViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetAllowedScriptNotifyUris(&*(&value as *const <super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::Uri> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::Uri> as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DataTransferPackage<Impl: IWebViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DataTransferPackage() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LoadCompleted<Impl: IWebViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LoadCompleted(&*(&handler as *const <super::Navigation::LoadCompletedEventHandler as ::windows::core::Abi>::Abi as *const <super::Navigation::LoadCompletedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveLoadCompleted<Impl: IWebViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveLoadCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ScriptNotify<Impl: IWebViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ScriptNotify(&*(&handler as *const <NotifyEventHandler as ::windows::core::Abi>::Abi as *const <NotifyEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveScriptNotify<Impl: IWebViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveScriptNotify(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigationFailed<Impl: IWebViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NavigationFailed(&*(&handler as *const <WebViewNavigationFailedEventHandler as ::windows::core::Abi>::Abi as *const <WebViewNavigationFailedEventHandler as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigationFailed<Impl: IWebViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveNavigationFailed(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn InvokeScript<Impl: IWebViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, scriptname: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, arguments_array_size: u32, arguments: *const ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InvokeScript(&*(&scriptname as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), ::core::slice::from_raw_parts(::core::mem::transmute_copy(&arguments), arguments_array_size as _)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Navigate<Impl: IWebViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Navigate(&*(&source as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigateToString<Impl: IWebViewImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, text: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).NavigateToString(&*(&text as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IWebView>,
            base.5,
            Source::<Impl, OFFSET>,
            SetSource::<Impl, OFFSET>,
            AllowedScriptNotifyUris::<Impl, OFFSET>,
            SetAllowedScriptNotifyUris::<Impl, OFFSET>,
            DataTransferPackage::<Impl, OFFSET>,
            LoadCompleted::<Impl, OFFSET>,
            RemoveLoadCompleted::<Impl, OFFSET>,
            ScriptNotify::<Impl, OFFSET>,
            RemoveScriptNotify::<Impl, OFFSET>,
            NavigationFailed::<Impl, OFFSET>,
            RemoveNavigationFailed::<Impl, OFFSET>,
            InvokeScript::<Impl, OFFSET>,
            Navigate::<Impl, OFFSET>,
            NavigateToString::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebView2Impl: Sized {
    fn CanGoBack(&self) -> ::windows::core::Result<bool>;
    fn CanGoForward(&self) -> ::windows::core::Result<bool>;
    fn DocumentTitle(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn NavigationStarting(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigationStarting(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn ContentLoading(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContentLoading(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn DOMContentLoaded(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveDOMContentLoaded(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn GoForward(&self) -> ::windows::core::Result<()>;
    fn GoBack(&self) -> ::windows::core::Result<()>;
    fn Refresh(&self) -> ::windows::core::Result<()>;
    fn Stop(&self) -> ::windows::core::Result<()>;
    fn CapturePreviewToStreamAsync(&self, stream: &::core::option::Option<super::super::super::Storage::Streams::IRandomAccessStream>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncAction>;
    fn InvokeScriptAsync(&self, scriptname: &::windows::core::HSTRING, arguments: &::core::option::Option<super::super::super::Foundation::Collections::IIterable<::windows::core::HSTRING>>) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<::windows::core::HSTRING>>;
    fn CaptureSelectedContentToDataPackageAsync(&self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncOperation<super::super::super::ApplicationModel::DataTransfer::DataPackage>>;
    fn NavigateToLocalStreamUri(&self, source: &::core::option::Option<super::super::super::Foundation::Uri>, streamresolver: &::core::option::Option<super::super::super::Web::IUriToStreamResolver>) -> ::windows::core::Result<()>;
    fn BuildLocalStreamUri(&self, contentidentifier: &::windows::core::HSTRING, relativepath: &::windows::core::HSTRING) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn DefaultBackgroundColor(&self) -> ::windows::core::Result<super::super::Color>;
    fn SetDefaultBackgroundColor(&self, value: &super::super::Color) -> ::windows::core::Result<()>;
    fn NavigationCompleted(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNavigationCompleted(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn FrameNavigationStarting(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFrameNavigationStarting(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn FrameContentLoading(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFrameContentLoading(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn FrameDOMContentLoaded(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFrameDOMContentLoaded(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn FrameNavigationCompleted(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveFrameNavigationCompleted(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn LongRunningScriptDetected(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewLongRunningScriptDetectedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveLongRunningScriptDetected(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn UnsafeContentWarningDisplaying(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveUnsafeContentWarningDisplaying(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn UnviewableContentIdentified(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnviewableContentIdentifiedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveUnviewableContentIdentified(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn NavigateWithHttpRequestMessage(&self, requestmessage: &::core::option::Option<super::super::super::Web::Http::HttpRequestMessage>) -> ::windows::core::Result<()>;
    fn Focus(&self, value: super::FocusState) -> ::windows::core::Result<bool>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebView2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView2";
}
#[cfg(feature = "implement_exclusive")]
impl IWebView2Vtbl {
    pub const fn new<Impl: IWebView2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebView2Vtbl {
        unsafe extern "system" fn CanGoBack<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanGoBack() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanGoForward<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanGoForward() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DocumentTitle<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DocumentTitle() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NavigationStarting<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NavigationStarting(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigationStarting<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveNavigationStarting(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn ContentLoading<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContentLoading(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContentLoading<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveContentLoading(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DOMContentLoaded<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DOMContentLoaded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveDOMContentLoaded<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveDOMContentLoaded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GoForward<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).GoForward().into()
        }
        unsafe extern "system" fn GoBack<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).GoBack().into()
        }
        unsafe extern "system" fn Refresh<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Refresh().into()
        }
        unsafe extern "system" fn Stop<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn CapturePreviewToStreamAsync<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, stream: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CapturePreviewToStreamAsync(&*(&stream as *const <super::super::super::Storage::Streams::IRandomAccessStream as ::windows::core::Abi>::Abi as *const <super::super::super::Storage::Streams::IRandomAccessStream as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InvokeScriptAsync<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, scriptname: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, arguments: ::windows::core::RawPtr, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InvokeScriptAsync(&*(&scriptname as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), &*(&arguments as *const <super::super::super::Foundation::Collections::IIterable<::windows::core::HSTRING> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Collections::IIterable<::windows::core::HSTRING> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CaptureSelectedContentToDataPackageAsync<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CaptureSelectedContentToDataPackageAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NavigateToLocalStreamUri<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr, streamresolver: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).NavigateToLocalStreamUri(&*(&source as *const <super::super::super::Foundation::Uri as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::Uri as ::windows::core::DefaultType>::DefaultType), &*(&streamresolver as *const <super::super::super::Web::IUriToStreamResolver as ::windows::core::Abi>::Abi as *const <super::super::super::Web::IUriToStreamResolver as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BuildLocalStreamUri<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, contentidentifier: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, relativepath: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BuildLocalStreamUri(&*(&contentidentifier as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), &*(&relativepath as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultBackgroundColor<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultBackgroundColor() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultBackgroundColor<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::super::Color) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDefaultBackgroundColor(&*(&value as *const <super::super::Color as ::windows::core::Abi>::Abi as *const <super::super::Color as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigationCompleted<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NavigationCompleted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNavigationCompleted<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveNavigationCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FrameNavigationStarting<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FrameNavigationStarting(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationStartingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFrameNavigationStarting<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveFrameNavigationStarting(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FrameContentLoading<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FrameContentLoading(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewContentLoadingEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFrameContentLoading<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveFrameContentLoading(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FrameDOMContentLoaded<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FrameDOMContentLoaded(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewDOMContentLoadedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFrameDOMContentLoaded<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveFrameDOMContentLoaded(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn FrameNavigationCompleted<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FrameNavigationCompleted(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNavigationCompletedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveFrameNavigationCompleted<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveFrameNavigationCompleted(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn LongRunningScriptDetected<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LongRunningScriptDetected(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewLongRunningScriptDetectedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewLongRunningScriptDetectedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveLongRunningScriptDetected<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveLongRunningScriptDetected(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UnsafeContentWarningDisplaying<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnsafeContentWarningDisplaying(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveUnsafeContentWarningDisplaying<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveUnsafeContentWarningDisplaying(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn UnviewableContentIdentified<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnviewableContentIdentified(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnviewableContentIdentifiedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnviewableContentIdentifiedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveUnviewableContentIdentified<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveUnviewableContentIdentified(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NavigateWithHttpRequestMessage<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, requestmessage: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).NavigateWithHttpRequestMessage(&*(&requestmessage as *const <super::super::super::Web::Http::HttpRequestMessage as ::windows::core::Abi>::Abi as *const <super::super::super::Web::Http::HttpRequestMessage as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Focus<Impl: IWebView2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::FocusState, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Focus(value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IWebView2>,
            base.5,
            CanGoBack::<Impl, OFFSET>,
            CanGoForward::<Impl, OFFSET>,
            DocumentTitle::<Impl, OFFSET>,
            NavigationStarting::<Impl, OFFSET>,
            RemoveNavigationStarting::<Impl, OFFSET>,
            ContentLoading::<Impl, OFFSET>,
            RemoveContentLoading::<Impl, OFFSET>,
            DOMContentLoaded::<Impl, OFFSET>,
            RemoveDOMContentLoaded::<Impl, OFFSET>,
            GoForward::<Impl, OFFSET>,
            GoBack::<Impl, OFFSET>,
            Refresh::<Impl, OFFSET>,
            Stop::<Impl, OFFSET>,
            CapturePreviewToStreamAsync::<Impl, OFFSET>,
            InvokeScriptAsync::<Impl, OFFSET>,
            CaptureSelectedContentToDataPackageAsync::<Impl, OFFSET>,
            NavigateToLocalStreamUri::<Impl, OFFSET>,
            BuildLocalStreamUri::<Impl, OFFSET>,
            DefaultBackgroundColor::<Impl, OFFSET>,
            SetDefaultBackgroundColor::<Impl, OFFSET>,
            NavigationCompleted::<Impl, OFFSET>,
            RemoveNavigationCompleted::<Impl, OFFSET>,
            FrameNavigationStarting::<Impl, OFFSET>,
            RemoveFrameNavigationStarting::<Impl, OFFSET>,
            FrameContentLoading::<Impl, OFFSET>,
            RemoveFrameContentLoading::<Impl, OFFSET>,
            FrameDOMContentLoaded::<Impl, OFFSET>,
            RemoveFrameDOMContentLoaded::<Impl, OFFSET>,
            FrameNavigationCompleted::<Impl, OFFSET>,
            RemoveFrameNavigationCompleted::<Impl, OFFSET>,
            LongRunningScriptDetected::<Impl, OFFSET>,
            RemoveLongRunningScriptDetected::<Impl, OFFSET>,
            UnsafeContentWarningDisplaying::<Impl, OFFSET>,
            RemoveUnsafeContentWarningDisplaying::<Impl, OFFSET>,
            UnviewableContentIdentified::<Impl, OFFSET>,
            RemoveUnviewableContentIdentified::<Impl, OFFSET>,
            NavigateWithHttpRequestMessage::<Impl, OFFSET>,
            Focus::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebView3Impl: Sized {
    fn ContainsFullScreenElement(&self) -> ::windows::core::Result<bool>;
    fn ContainsFullScreenElementChanged(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveContainsFullScreenElementChanged(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebView3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView3";
}
#[cfg(feature = "implement_exclusive")]
impl IWebView3Vtbl {
    pub const fn new<Impl: IWebView3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebView3Vtbl {
        unsafe extern "system" fn ContainsFullScreenElement<Impl: IWebView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContainsFullScreenElement() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainsFullScreenElementChanged<Impl: IWebView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContainsFullScreenElementChanged(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, ::windows::core::IInspectable> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveContainsFullScreenElementChanged<Impl: IWebView3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveContainsFullScreenElementChanged(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebView3>, base.5, ContainsFullScreenElement::<Impl, OFFSET>, ContainsFullScreenElementChanged::<Impl, OFFSET>, RemoveContainsFullScreenElementChanged::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebView4Impl: Sized {
    fn ExecutionMode(&self) -> ::windows::core::Result<WebViewExecutionMode>;
    fn DeferredPermissionRequests(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<WebViewDeferredPermissionRequest>>;
    fn Settings(&self) -> ::windows::core::Result<WebViewSettings>;
    fn UnsupportedUriSchemeIdentified(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnsupportedUriSchemeIdentifiedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveUnsupportedUriSchemeIdentified(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn NewWindowRequested(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewNewWindowRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveNewWindowRequested(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn PermissionRequested(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewPermissionRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemovePermissionRequested(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
    fn AddWebAllowedObject(&self, name: &::windows::core::HSTRING, pobject: &::core::option::Option<::windows::core::IInspectable>) -> ::windows::core::Result<()>;
    fn DeferredPermissionRequestById(&self, id: u32) -> ::windows::core::Result<WebViewDeferredPermissionRequest>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebView4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView4";
}
#[cfg(feature = "implement_exclusive")]
impl IWebView4Vtbl {
    pub const fn new<Impl: IWebView4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebView4Vtbl {
        unsafe extern "system" fn ExecutionMode<Impl: IWebView4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut WebViewExecutionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExecutionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeferredPermissionRequests<Impl: IWebView4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DeferredPermissionRequests() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Settings<Impl: IWebView4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Settings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnsupportedUriSchemeIdentified<Impl: IWebView4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnsupportedUriSchemeIdentified(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnsupportedUriSchemeIdentifiedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewUnsupportedUriSchemeIdentifiedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveUnsupportedUriSchemeIdentified<Impl: IWebView4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveUnsupportedUriSchemeIdentified(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn NewWindowRequested<Impl: IWebView4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NewWindowRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNewWindowRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewNewWindowRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNewWindowRequested<Impl: IWebView4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveNewWindowRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn PermissionRequested<Impl: IWebView4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PermissionRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewPermissionRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewPermissionRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemovePermissionRequested<Impl: IWebView4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemovePermissionRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn AddWebAllowedObject<Impl: IWebView4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, name: ::core::mem::ManuallyDrop<::windows::core::HSTRING>, pobject: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).AddWebAllowedObject(&*(&name as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType), &*(&pobject as *const <::windows::core::IInspectable as ::windows::core::Abi>::Abi as *const <::windows::core::IInspectable as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DeferredPermissionRequestById<Impl: IWebView4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, id: u32, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DeferredPermissionRequestById(id) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IWebView4>,
            base.5,
            ExecutionMode::<Impl, OFFSET>,
            DeferredPermissionRequests::<Impl, OFFSET>,
            Settings::<Impl, OFFSET>,
            UnsupportedUriSchemeIdentified::<Impl, OFFSET>,
            RemoveUnsupportedUriSchemeIdentified::<Impl, OFFSET>,
            NewWindowRequested::<Impl, OFFSET>,
            RemoveNewWindowRequested::<Impl, OFFSET>,
            PermissionRequested::<Impl, OFFSET>,
            RemovePermissionRequested::<Impl, OFFSET>,
            AddWebAllowedObject::<Impl, OFFSET>,
            DeferredPermissionRequestById::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebView5Impl: Sized {
    fn XYFocusLeft(&self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusLeft(&self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusRight(&self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusRight(&self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusUp(&self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusUp(&self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
    fn XYFocusDown(&self) -> ::windows::core::Result<super::DependencyObject>;
    fn SetXYFocusDown(&self, value: &::core::option::Option<super::DependencyObject>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebView5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView5";
}
#[cfg(feature = "implement_exclusive")]
impl IWebView5Vtbl {
    pub const fn new<Impl: IWebView5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebView5Vtbl {
        unsafe extern "system" fn XYFocusLeft<Impl: IWebView5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).XYFocusLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusLeft<Impl: IWebView5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetXYFocusLeft(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusRight<Impl: IWebView5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).XYFocusRight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusRight<Impl: IWebView5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetXYFocusRight(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusUp<Impl: IWebView5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).XYFocusUp() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusUp<Impl: IWebView5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetXYFocusUp(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn XYFocusDown<Impl: IWebView5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).XYFocusDown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetXYFocusDown<Impl: IWebView5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetXYFocusDown(&*(&value as *const <super::DependencyObject as ::windows::core::Abi>::Abi as *const <super::DependencyObject as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebView5>, base.5, XYFocusLeft::<Impl, OFFSET>, SetXYFocusLeft::<Impl, OFFSET>, XYFocusRight::<Impl, OFFSET>, SetXYFocusRight::<Impl, OFFSET>, XYFocusUp::<Impl, OFFSET>, SetXYFocusUp::<Impl, OFFSET>, XYFocusDown::<Impl, OFFSET>, SetXYFocusDown::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebView6Impl: Sized {
    fn SeparateProcessLost(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewSeparateProcessLostEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveSeparateProcessLost(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebView6 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView6";
}
#[cfg(feature = "implement_exclusive")]
impl IWebView6Vtbl {
    pub const fn new<Impl: IWebView6Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebView6Vtbl {
        unsafe extern "system" fn SeparateProcessLost<Impl: IWebView6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SeparateProcessLost(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewSeparateProcessLostEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewSeparateProcessLostEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSeparateProcessLost<Impl: IWebView6Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveSeparateProcessLost(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebView6>, base.5, SeparateProcessLost::<Impl, OFFSET>, RemoveSeparateProcessLost::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebView7Impl: Sized {
    fn WebResourceRequested(&self, handler: &::core::option::Option<super::super::super::Foundation::TypedEventHandler<WebView, WebViewWebResourceRequestedEventArgs>>) -> ::windows::core::Result<super::super::super::Foundation::EventRegistrationToken>;
    fn RemoveWebResourceRequested(&self, token: &super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebView7 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebView7";
}
#[cfg(feature = "implement_exclusive")]
impl IWebView7Vtbl {
    pub const fn new<Impl: IWebView7Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebView7Vtbl {
        unsafe extern "system" fn WebResourceRequested<Impl: IWebView7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handler: ::windows::core::RawPtr, result__: *mut super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WebResourceRequested(&*(&handler as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewWebResourceRequestedEventArgs> as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::TypedEventHandler<WebView, WebViewWebResourceRequestedEventArgs> as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveWebResourceRequested<Impl: IWebView7Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, token: super::super::super::Foundation::EventRegistrationToken) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveWebResourceRequested(&*(&token as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::Abi>::Abi as *const <super::super::super::Foundation::EventRegistrationToken as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebView7>, base.5, WebResourceRequested::<Impl, OFFSET>, RemoveWebResourceRequested::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewBrushImpl: Sized {
    fn SourceName(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
    fn SetSourceName(&self, value: &::windows::core::HSTRING) -> ::windows::core::Result<()>;
    fn Redraw(&self) -> ::windows::core::Result<()>;
    fn SetSource(&self, source: &::core::option::Option<WebView>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewBrush {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewBrush";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewBrushVtbl {
    pub const fn new<Impl: IWebViewBrushImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewBrushVtbl {
        unsafe extern "system" fn SourceName<Impl: IWebViewBrushImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceName() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceName<Impl: IWebViewBrushImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSourceName(&*(&value as *const <::windows::core::HSTRING as ::windows::core::Abi>::Abi as *const <::windows::core::HSTRING as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Redraw<Impl: IWebViewBrushImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Redraw().into()
        }
        unsafe extern "system" fn SetSource<Impl: IWebViewBrushImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, source: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetSource(&*(&source as *const <WebView as ::windows::core::Abi>::Abi as *const <WebView as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewBrush>, base.5, SourceName::<Impl, OFFSET>, SetSourceName::<Impl, OFFSET>, Redraw::<Impl, OFFSET>, SetSource::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewBrushStaticsImpl: Sized {
    fn SourceNameProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewBrushStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewBrushStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewBrushStaticsVtbl {
    pub const fn new<Impl: IWebViewBrushStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewBrushStaticsVtbl {
        unsafe extern "system" fn SourceNameProperty<Impl: IWebViewBrushStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceNameProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewBrushStatics>, base.5, SourceNameProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewContentLoadingEventArgsImpl: Sized {
    fn Uri(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewContentLoadingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewContentLoadingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewContentLoadingEventArgsVtbl {
    pub const fn new<Impl: IWebViewContentLoadingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewContentLoadingEventArgsVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewContentLoadingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewContentLoadingEventArgs>, base.5, Uri::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewDOMContentLoadedEventArgsImpl: Sized {
    fn Uri(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewDOMContentLoadedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewDOMContentLoadedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewDOMContentLoadedEventArgsVtbl {
    pub const fn new<Impl: IWebViewDOMContentLoadedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewDOMContentLoadedEventArgsVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewDOMContentLoadedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewDOMContentLoadedEventArgs>, base.5, Uri::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewDeferredPermissionRequestImpl: Sized {
    fn Uri(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn PermissionType(&self) -> ::windows::core::Result<WebViewPermissionType>;
    fn Id(&self) -> ::windows::core::Result<u32>;
    fn Allow(&self) -> ::windows::core::Result<()>;
    fn Deny(&self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewDeferredPermissionRequest {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewDeferredPermissionRequest";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewDeferredPermissionRequestVtbl {
    pub const fn new<Impl: IWebViewDeferredPermissionRequestImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewDeferredPermissionRequestVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewDeferredPermissionRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PermissionType<Impl: IWebViewDeferredPermissionRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut WebViewPermissionType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PermissionType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Id<Impl: IWebViewDeferredPermissionRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Id() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Allow<Impl: IWebViewDeferredPermissionRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Allow().into()
        }
        unsafe extern "system" fn Deny<Impl: IWebViewDeferredPermissionRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Deny().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewDeferredPermissionRequest>, base.5, Uri::<Impl, OFFSET>, PermissionType::<Impl, OFFSET>, Id::<Impl, OFFSET>, Allow::<Impl, OFFSET>, Deny::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewFactory4Impl: Sized {
    fn CreateInstanceWithExecutionMode(&self, executionmode: WebViewExecutionMode) -> ::windows::core::Result<WebView>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewFactory4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewFactory4";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewFactory4Vtbl {
    pub const fn new<Impl: IWebViewFactory4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewFactory4Vtbl {
        unsafe extern "system" fn CreateInstanceWithExecutionMode<Impl: IWebViewFactory4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, executionmode: WebViewExecutionMode, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstanceWithExecutionMode(executionmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewFactory4>, base.5, CreateInstanceWithExecutionMode::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewLongRunningScriptDetectedEventArgsImpl: Sized {
    fn ExecutionTime(&self) -> ::windows::core::Result<super::super::super::Foundation::TimeSpan>;
    fn StopPageScriptExecution(&self) -> ::windows::core::Result<bool>;
    fn SetStopPageScriptExecution(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewLongRunningScriptDetectedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewLongRunningScriptDetectedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewLongRunningScriptDetectedEventArgsVtbl {
    pub const fn new<Impl: IWebViewLongRunningScriptDetectedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewLongRunningScriptDetectedEventArgsVtbl {
        unsafe extern "system" fn ExecutionTime<Impl: IWebViewLongRunningScriptDetectedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Foundation::TimeSpan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExecutionTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StopPageScriptExecution<Impl: IWebViewLongRunningScriptDetectedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StopPageScriptExecution() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStopPageScriptExecution<Impl: IWebViewLongRunningScriptDetectedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetStopPageScriptExecution(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewLongRunningScriptDetectedEventArgs>, base.5, ExecutionTime::<Impl, OFFSET>, StopPageScriptExecution::<Impl, OFFSET>, SetStopPageScriptExecution::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewNavigationCompletedEventArgsImpl: Sized {
    fn Uri(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn IsSuccess(&self) -> ::windows::core::Result<bool>;
    fn WebErrorStatus(&self) -> ::windows::core::Result<super::super::super::Web::WebErrorStatus>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewNavigationCompletedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewNavigationCompletedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewNavigationCompletedEventArgsVtbl {
    pub const fn new<Impl: IWebViewNavigationCompletedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewNavigationCompletedEventArgsVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewNavigationCompletedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSuccess<Impl: IWebViewNavigationCompletedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSuccess() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WebErrorStatus<Impl: IWebViewNavigationCompletedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Web::WebErrorStatus) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WebErrorStatus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewNavigationCompletedEventArgs>, base.5, Uri::<Impl, OFFSET>, IsSuccess::<Impl, OFFSET>, WebErrorStatus::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewNavigationFailedEventArgsImpl: Sized {
    fn Uri(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn WebErrorStatus(&self) -> ::windows::core::Result<super::super::super::Web::WebErrorStatus>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewNavigationFailedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewNavigationFailedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewNavigationFailedEventArgsVtbl {
    pub const fn new<Impl: IWebViewNavigationFailedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewNavigationFailedEventArgsVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewNavigationFailedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WebErrorStatus<Impl: IWebViewNavigationFailedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::super::super::Web::WebErrorStatus) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WebErrorStatus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewNavigationFailedEventArgs>, base.5, Uri::<Impl, OFFSET>, WebErrorStatus::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewNavigationStartingEventArgsImpl: Sized {
    fn Uri(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn Cancel(&self) -> ::windows::core::Result<bool>;
    fn SetCancel(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewNavigationStartingEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewNavigationStartingEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewNavigationStartingEventArgsVtbl {
    pub const fn new<Impl: IWebViewNavigationStartingEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewNavigationStartingEventArgsVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewNavigationStartingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: IWebViewNavigationStartingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCancel<Impl: IWebViewNavigationStartingEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetCancel(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewNavigationStartingEventArgs>, base.5, Uri::<Impl, OFFSET>, Cancel::<Impl, OFFSET>, SetCancel::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewNewWindowRequestedEventArgsImpl: Sized {
    fn Uri(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn Referrer(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn Handled(&self) -> ::windows::core::Result<bool>;
    fn SetHandled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewNewWindowRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewNewWindowRequestedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewNewWindowRequestedEventArgsVtbl {
    pub const fn new<Impl: IWebViewNewWindowRequestedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewNewWindowRequestedEventArgsVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewNewWindowRequestedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Referrer<Impl: IWebViewNewWindowRequestedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Referrer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Handled<Impl: IWebViewNewWindowRequestedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IWebViewNewWindowRequestedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewNewWindowRequestedEventArgs>, base.5, Uri::<Impl, OFFSET>, Referrer::<Impl, OFFSET>, Handled::<Impl, OFFSET>, SetHandled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewPermissionRequestImpl: Sized {
    fn Uri(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn PermissionType(&self) -> ::windows::core::Result<WebViewPermissionType>;
    fn Id(&self) -> ::windows::core::Result<u32>;
    fn State(&self) -> ::windows::core::Result<WebViewPermissionState>;
    fn Defer(&self) -> ::windows::core::Result<()>;
    fn Allow(&self) -> ::windows::core::Result<()>;
    fn Deny(&self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewPermissionRequest {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewPermissionRequest";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewPermissionRequestVtbl {
    pub const fn new<Impl: IWebViewPermissionRequestImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewPermissionRequestVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewPermissionRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PermissionType<Impl: IWebViewPermissionRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut WebViewPermissionType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PermissionType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Id<Impl: IWebViewPermissionRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Id() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn State<Impl: IWebViewPermissionRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut WebViewPermissionState) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).State() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Defer<Impl: IWebViewPermissionRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Defer().into()
        }
        unsafe extern "system" fn Allow<Impl: IWebViewPermissionRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Allow().into()
        }
        unsafe extern "system" fn Deny<Impl: IWebViewPermissionRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Deny().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewPermissionRequest>, base.5, Uri::<Impl, OFFSET>, PermissionType::<Impl, OFFSET>, Id::<Impl, OFFSET>, State::<Impl, OFFSET>, Defer::<Impl, OFFSET>, Allow::<Impl, OFFSET>, Deny::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewPermissionRequestedEventArgsImpl: Sized {
    fn PermissionRequest(&self) -> ::windows::core::Result<WebViewPermissionRequest>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewPermissionRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewPermissionRequestedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewPermissionRequestedEventArgsVtbl {
    pub const fn new<Impl: IWebViewPermissionRequestedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewPermissionRequestedEventArgsVtbl {
        unsafe extern "system" fn PermissionRequest<Impl: IWebViewPermissionRequestedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PermissionRequest() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewPermissionRequestedEventArgs>, base.5, PermissionRequest::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewSeparateProcessLostEventArgsImpl: Sized {}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewSeparateProcessLostEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewSeparateProcessLostEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewSeparateProcessLostEventArgsVtbl {
    pub const fn new<Impl: IWebViewSeparateProcessLostEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewSeparateProcessLostEventArgsVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewSeparateProcessLostEventArgs>, base.5)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewSettingsImpl: Sized {
    fn IsJavaScriptEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsJavaScriptEnabled(&self, value: bool) -> ::windows::core::Result<()>;
    fn IsIndexedDBEnabled(&self) -> ::windows::core::Result<bool>;
    fn SetIsIndexedDBEnabled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewSettings {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewSettings";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewSettingsVtbl {
    pub const fn new<Impl: IWebViewSettingsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewSettingsVtbl {
        unsafe extern "system" fn IsJavaScriptEnabled<Impl: IWebViewSettingsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsJavaScriptEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsJavaScriptEnabled<Impl: IWebViewSettingsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsJavaScriptEnabled(value).into()
        }
        unsafe extern "system" fn IsIndexedDBEnabled<Impl: IWebViewSettingsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsIndexedDBEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIsIndexedDBEnabled<Impl: IWebViewSettingsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetIsIndexedDBEnabled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewSettings>, base.5, IsJavaScriptEnabled::<Impl, OFFSET>, SetIsJavaScriptEnabled::<Impl, OFFSET>, IsIndexedDBEnabled::<Impl, OFFSET>, SetIsIndexedDBEnabled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewStaticsImpl: Sized {
    fn AnyScriptNotifyUri(&self) -> ::windows::core::Result<super::super::super::Foundation::Collections::IVector<super::super::super::Foundation::Uri>>;
    fn SourceProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn AllowedScriptNotifyUrisProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DataTransferPackageProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewStaticsVtbl {
    pub const fn new<Impl: IWebViewStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewStaticsVtbl {
        unsafe extern "system" fn AnyScriptNotifyUri<Impl: IWebViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AnyScriptNotifyUri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SourceProperty<Impl: IWebViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SourceProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AllowedScriptNotifyUrisProperty<Impl: IWebViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AllowedScriptNotifyUrisProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DataTransferPackageProperty<Impl: IWebViewStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DataTransferPackageProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewStatics>, base.5, AnyScriptNotifyUri::<Impl, OFFSET>, SourceProperty::<Impl, OFFSET>, AllowedScriptNotifyUrisProperty::<Impl, OFFSET>, DataTransferPackageProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewStatics2Impl: Sized {
    fn CanGoBackProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn CanGoForwardProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DocumentTitleProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn DefaultBackgroundColorProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewStatics2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewStatics2";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewStatics2Vtbl {
    pub const fn new<Impl: IWebViewStatics2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewStatics2Vtbl {
        unsafe extern "system" fn CanGoBackProperty<Impl: IWebViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanGoBackProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanGoForwardProperty<Impl: IWebViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanGoForwardProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DocumentTitleProperty<Impl: IWebViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DocumentTitleProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DefaultBackgroundColorProperty<Impl: IWebViewStatics2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultBackgroundColorProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewStatics2>, base.5, CanGoBackProperty::<Impl, OFFSET>, CanGoForwardProperty::<Impl, OFFSET>, DocumentTitleProperty::<Impl, OFFSET>, DefaultBackgroundColorProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewStatics3Impl: Sized {
    fn ContainsFullScreenElementProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewStatics3 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewStatics3";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewStatics3Vtbl {
    pub const fn new<Impl: IWebViewStatics3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewStatics3Vtbl {
        unsafe extern "system" fn ContainsFullScreenElementProperty<Impl: IWebViewStatics3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContainsFullScreenElementProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewStatics3>, base.5, ContainsFullScreenElementProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewStatics4Impl: Sized {
    fn DefaultExecutionMode(&self) -> ::windows::core::Result<WebViewExecutionMode>;
    fn ClearTemporaryWebDataAsync(&self) -> ::windows::core::Result<super::super::super::Foundation::IAsyncAction>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewStatics4 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewStatics4";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewStatics4Vtbl {
    pub const fn new<Impl: IWebViewStatics4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewStatics4Vtbl {
        unsafe extern "system" fn DefaultExecutionMode<Impl: IWebViewStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut WebViewExecutionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DefaultExecutionMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClearTemporaryWebDataAsync<Impl: IWebViewStatics4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ClearTemporaryWebDataAsync() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewStatics4>, base.5, DefaultExecutionMode::<Impl, OFFSET>, ClearTemporaryWebDataAsync::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewStatics5Impl: Sized {
    fn XYFocusLeftProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusRightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusUpProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn XYFocusDownProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewStatics5 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewStatics5";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewStatics5Vtbl {
    pub const fn new<Impl: IWebViewStatics5Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewStatics5Vtbl {
        unsafe extern "system" fn XYFocusLeftProperty<Impl: IWebViewStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).XYFocusLeftProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusRightProperty<Impl: IWebViewStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).XYFocusRightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusUpProperty<Impl: IWebViewStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).XYFocusUpProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn XYFocusDownProperty<Impl: IWebViewStatics5Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).XYFocusDownProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewStatics5>, base.5, XYFocusLeftProperty::<Impl, OFFSET>, XYFocusRightProperty::<Impl, OFFSET>, XYFocusUpProperty::<Impl, OFFSET>, XYFocusDownProperty::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewUnsupportedUriSchemeIdentifiedEventArgsImpl: Sized {
    fn Uri(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn Handled(&self) -> ::windows::core::Result<bool>;
    fn SetHandled(&self, value: bool) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewUnsupportedUriSchemeIdentifiedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewUnsupportedUriSchemeIdentifiedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewUnsupportedUriSchemeIdentifiedEventArgsVtbl {
    pub const fn new<Impl: IWebViewUnsupportedUriSchemeIdentifiedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewUnsupportedUriSchemeIdentifiedEventArgsVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewUnsupportedUriSchemeIdentifiedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Handled<Impl: IWebViewUnsupportedUriSchemeIdentifiedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Handled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHandled<Impl: IWebViewUnsupportedUriSchemeIdentifiedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: bool) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHandled(value).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewUnsupportedUriSchemeIdentifiedEventArgs>, base.5, Uri::<Impl, OFFSET>, Handled::<Impl, OFFSET>, SetHandled::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewUnviewableContentIdentifiedEventArgsImpl: Sized {
    fn Uri(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
    fn Referrer(&self) -> ::windows::core::Result<super::super::super::Foundation::Uri>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewUnviewableContentIdentifiedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewUnviewableContentIdentifiedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewUnviewableContentIdentifiedEventArgsVtbl {
    pub const fn new<Impl: IWebViewUnviewableContentIdentifiedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewUnviewableContentIdentifiedEventArgsVtbl {
        unsafe extern "system" fn Uri<Impl: IWebViewUnviewableContentIdentifiedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Uri() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Referrer<Impl: IWebViewUnviewableContentIdentifiedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Referrer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewUnviewableContentIdentifiedEventArgs>, base.5, Uri::<Impl, OFFSET>, Referrer::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewUnviewableContentIdentifiedEventArgs2Impl: Sized {
    fn MediaType(&self) -> ::windows::core::Result<::windows::core::HSTRING>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewUnviewableContentIdentifiedEventArgs2 {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewUnviewableContentIdentifiedEventArgs2";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewUnviewableContentIdentifiedEventArgs2Vtbl {
    pub const fn new<Impl: IWebViewUnviewableContentIdentifiedEventArgs2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewUnviewableContentIdentifiedEventArgs2Vtbl {
        unsafe extern "system" fn MediaType<Impl: IWebViewUnviewableContentIdentifiedEventArgs2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::core::mem::ManuallyDrop<::windows::core::HSTRING>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MediaType() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewUnviewableContentIdentifiedEventArgs2>, base.5, MediaType::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWebViewWebResourceRequestedEventArgsImpl: Sized {
    fn Request(&self) -> ::windows::core::Result<super::super::super::Web::Http::HttpRequestMessage>;
    fn Response(&self) -> ::windows::core::Result<super::super::super::Web::Http::HttpResponseMessage>;
    fn SetResponse(&self, value: &::core::option::Option<super::super::super::Web::Http::HttpResponseMessage>) -> ::windows::core::Result<()>;
    fn GetDeferral(&self) -> ::windows::core::Result<super::super::super::Foundation::Deferral>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWebViewWebResourceRequestedEventArgs {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWebViewWebResourceRequestedEventArgs";
}
#[cfg(feature = "implement_exclusive")]
impl IWebViewWebResourceRequestedEventArgsVtbl {
    pub const fn new<Impl: IWebViewWebResourceRequestedEventArgsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWebViewWebResourceRequestedEventArgsVtbl {
        unsafe extern "system" fn Request<Impl: IWebViewWebResourceRequestedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Request() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Response<Impl: IWebViewWebResourceRequestedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Response() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetResponse<Impl: IWebViewWebResourceRequestedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetResponse(&*(&value as *const <super::super::super::Web::Http::HttpResponseMessage as ::windows::core::Abi>::Abi as *const <super::super::super::Web::Http::HttpResponseMessage as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn GetDeferral<Impl: IWebViewWebResourceRequestedEventArgsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDeferral() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWebViewWebResourceRequestedEventArgs>, base.5, Request::<Impl, OFFSET>, Response::<Impl, OFFSET>, SetResponse::<Impl, OFFSET>, GetDeferral::<Impl, OFFSET>)
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWrapGridImpl: Sized {
    fn ItemWidth(&self) -> ::windows::core::Result<f64>;
    fn SetItemWidth(&self, value: f64) -> ::windows::core::Result<()>;
    fn ItemHeight(&self) -> ::windows::core::Result<f64>;
    fn SetItemHeight(&self, value: f64) -> ::windows::core::Result<()>;
    fn Orientation(&self) -> ::windows::core::Result<Orientation>;
    fn SetOrientation(&self, value: Orientation) -> ::windows::core::Result<()>;
    fn HorizontalChildrenAlignment(&self) -> ::windows::core::Result<super::HorizontalAlignment>;
    fn SetHorizontalChildrenAlignment(&self, value: super::HorizontalAlignment) -> ::windows::core::Result<()>;
    fn VerticalChildrenAlignment(&self) -> ::windows::core::Result<super::VerticalAlignment>;
    fn SetVerticalChildrenAlignment(&self, value: super::VerticalAlignment) -> ::windows::core::Result<()>;
    fn MaximumRowsOrColumns(&self) -> ::windows::core::Result<i32>;
    fn SetMaximumRowsOrColumns(&self, value: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWrapGrid {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWrapGrid";
}
#[cfg(feature = "implement_exclusive")]
impl IWrapGridVtbl {
    pub const fn new<Impl: IWrapGridImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWrapGridVtbl {
        unsafe extern "system" fn ItemWidth<Impl: IWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemWidth() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemWidth<Impl: IWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemWidth(value).into()
        }
        unsafe extern "system" fn ItemHeight<Impl: IWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemHeight() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItemHeight<Impl: IWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetItemHeight(value).into()
        }
        unsafe extern "system" fn Orientation<Impl: IWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Orientation() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOrientation<Impl: IWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: Orientation) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetOrientation(value).into()
        }
        unsafe extern "system" fn HorizontalChildrenAlignment<Impl: IWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalChildrenAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetHorizontalChildrenAlignment<Impl: IWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::HorizontalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetHorizontalChildrenAlignment(value).into()
        }
        unsafe extern "system" fn VerticalChildrenAlignment<Impl: IWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalChildrenAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVerticalChildrenAlignment<Impl: IWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: super::VerticalAlignment) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetVerticalChildrenAlignment(value).into()
        }
        unsafe extern "system" fn MaximumRowsOrColumns<Impl: IWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumns() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMaximumRowsOrColumns<Impl: IWrapGridImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMaximumRowsOrColumns(value).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IWrapGrid>,
            base.5,
            ItemWidth::<Impl, OFFSET>,
            SetItemWidth::<Impl, OFFSET>,
            ItemHeight::<Impl, OFFSET>,
            SetItemHeight::<Impl, OFFSET>,
            Orientation::<Impl, OFFSET>,
            SetOrientation::<Impl, OFFSET>,
            HorizontalChildrenAlignment::<Impl, OFFSET>,
            SetHorizontalChildrenAlignment::<Impl, OFFSET>,
            VerticalChildrenAlignment::<Impl, OFFSET>,
            SetVerticalChildrenAlignment::<Impl, OFFSET>,
            MaximumRowsOrColumns::<Impl, OFFSET>,
            SetMaximumRowsOrColumns::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "implement_exclusive")]
pub trait IWrapGridStaticsImpl: Sized {
    fn ItemWidthProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn ItemHeightProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn OrientationProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn HorizontalChildrenAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn VerticalChildrenAlignmentProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
    fn MaximumRowsOrColumnsProperty(&self) -> ::windows::core::Result<super::DependencyProperty>;
}
#[cfg(feature = "implement_exclusive")]
impl ::windows::core::RuntimeName for IWrapGridStatics {
    const NAME: &'static str = "Windows.UI.Xaml.Controls.IWrapGridStatics";
}
#[cfg(feature = "implement_exclusive")]
impl IWrapGridStaticsVtbl {
    pub const fn new<Impl: IWrapGridStaticsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWrapGridStaticsVtbl {
        unsafe extern "system" fn ItemWidthProperty<Impl: IWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemWidthProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ItemHeightProperty<Impl: IWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ItemHeightProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OrientationProperty<Impl: IWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OrientationProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HorizontalChildrenAlignmentProperty<Impl: IWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HorizontalChildrenAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VerticalChildrenAlignmentProperty<Impl: IWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VerticalChildrenAlignmentProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MaximumRowsOrColumnsProperty<Impl: IWrapGridStaticsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MaximumRowsOrColumnsProperty() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWrapGridStatics>, base.5, ItemWidthProperty::<Impl, OFFSET>, ItemHeightProperty::<Impl, OFFSET>, OrientationProperty::<Impl, OFFSET>, HorizontalChildrenAlignmentProperty::<Impl, OFFSET>, VerticalChildrenAlignmentProperty::<Impl, OFFSET>, MaximumRowsOrColumnsProperty::<Impl, OFFSET>)
    }
}
