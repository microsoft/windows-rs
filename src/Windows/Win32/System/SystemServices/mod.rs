#![allow(
    unused_variables,
    non_upper_case_globals,
    non_snake_case,
    unused_unsafe,
    non_camel_case_types,
    dead_code,
    clippy::all
)]
pub const ACCESS_ALLOWED_ACE_TYPE: u32 = 0u32;
pub const ACCESS_ALLOWED_CALLBACK_ACE_TYPE: u32 = 9u32;
pub const ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE: u32 = 11u32;
pub const ACCESS_ALLOWED_COMPOUND_ACE_TYPE: u32 = 4u32;
pub const ACCESS_ALLOWED_OBJECT_ACE_TYPE: u32 = 5u32;
pub const ACCESS_DENIED_ACE_TYPE: u32 = 1u32;
pub const ACCESS_DENIED_CALLBACK_ACE_TYPE: u32 = 10u32;
pub const ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE: u32 = 12u32;
pub const ACCESS_DENIED_OBJECT_ACE_TYPE: u32 = 6u32;
pub const ACCESS_FILTER_SECURITY_INFORMATION: i32 = 256i32;
pub const ACCESS_MAX_LEVEL: u32 = 4u32;
pub const ACCESS_MAX_MS_ACE_TYPE: u32 = 8u32;
pub const ACCESS_MAX_MS_OBJECT_ACE_TYPE: u32 = 8u32;
pub const ACCESS_MAX_MS_V2_ACE_TYPE: u32 = 3u32;
pub const ACCESS_MAX_MS_V3_ACE_TYPE: u32 = 4u32;
pub const ACCESS_MAX_MS_V4_ACE_TYPE: u32 = 8u32;
pub const ACCESS_MAX_MS_V5_ACE_TYPE: u32 = 21u32;
pub const ACCESS_MIN_MS_ACE_TYPE: u32 = 0u32;
pub const ACCESS_MIN_MS_OBJECT_ACE_TYPE: u32 = 5u32;
pub const ACCESS_OBJECT_GUID: u32 = 0u32;
pub const ACCESS_PROPERTY_GUID: u32 = 2u32;
pub const ACCESS_PROPERTY_SET_GUID: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct ACCESS_REASONS {
    pub Data: [u32; 32],
}
impl ACCESS_REASONS {}
impl ::std::default::Default for ACCESS_REASONS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for ACCESS_REASONS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("ACCESS_REASONS")
            .field("Data", &self.Data)
            .finish()
    }
}
impl ::std::cmp::PartialEq for ACCESS_REASONS {
    fn eq(&self, other: &Self) -> bool {
        self.Data == other.Data
    }
}
impl ::std::cmp::Eq for ACCESS_REASONS {}
unsafe impl ::windows::runtime::Abi for ACCESS_REASONS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const ACCESS_REASON_DATA_MASK: u32 = 65535u32;
pub const ACCESS_REASON_EXDATA_MASK: u32 = 2130706432u32;
pub const ACCESS_REASON_STAGING_MASK: u32 = 2147483648u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct ACCESS_REASON_TYPE(pub i32);
pub const AccessReasonNone: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(0i32);
pub const AccessReasonAllowedAce: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(65536i32);
pub const AccessReasonDeniedAce: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(131072i32);
pub const AccessReasonAllowedParentAce: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(196608i32);
pub const AccessReasonDeniedParentAce: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(262144i32);
pub const AccessReasonNotGrantedByCape: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(327680i32);
pub const AccessReasonNotGrantedByParentCape: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(393216i32);
pub const AccessReasonNotGrantedToAppContainer: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(458752i32);
pub const AccessReasonMissingPrivilege: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(1048576i32);
pub const AccessReasonFromPrivilege: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(2097152i32);
pub const AccessReasonIntegrityLevel: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(3145728i32);
pub const AccessReasonOwnership: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(4194304i32);
pub const AccessReasonNullDacl: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(5242880i32);
pub const AccessReasonEmptyDacl: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(6291456i32);
pub const AccessReasonNoSD: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(7340032i32);
pub const AccessReasonNoGrant: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(8388608i32);
pub const AccessReasonTrustLabel: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(9437184i32);
pub const AccessReasonFilterAce: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(10485760i32);
impl ::std::convert::From<i32> for ACCESS_REASON_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for ACCESS_REASON_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const ACCESS_REASON_TYPE_MASK: u32 = 16711680u32;
pub const ACCESS_SYSTEM_SECURITY: u32 = 16777216u32;
pub const ACL_REVISION1: u32 = 1u32;
pub const ACL_REVISION2: u32 = 2u32;
pub const ACL_REVISION3: u32 = 3u32;
pub const ACL_REVISION4: u32 = 4u32;
pub const ACPI_PPM_HARDWARE_ALL: u32 = 254u32;
pub const ACPI_PPM_SOFTWARE_ALL: u32 = 252u32;
pub const ACPI_PPM_SOFTWARE_ANY: u32 = 253u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct ACTIVATION_CONTEXT_INFO_CLASS(pub i32);
pub const ActivationContextBasicInformation: ACTIVATION_CONTEXT_INFO_CLASS =
    ACTIVATION_CONTEXT_INFO_CLASS(1i32);
pub const ActivationContextDetailedInformation: ACTIVATION_CONTEXT_INFO_CLASS =
    ACTIVATION_CONTEXT_INFO_CLASS(2i32);
pub const AssemblyDetailedInformationInActivationContext: ACTIVATION_CONTEXT_INFO_CLASS =
    ACTIVATION_CONTEXT_INFO_CLASS(3i32);
pub const FileInformationInAssemblyOfAssemblyInActivationContext: ACTIVATION_CONTEXT_INFO_CLASS =
    ACTIVATION_CONTEXT_INFO_CLASS(4i32);
pub const RunlevelInformationInActivationContext: ACTIVATION_CONTEXT_INFO_CLASS =
    ACTIVATION_CONTEXT_INFO_CLASS(5i32);
pub const CompatibilityInformationInActivationContext: ACTIVATION_CONTEXT_INFO_CLASS =
    ACTIVATION_CONTEXT_INFO_CLASS(6i32);
pub const ActivationContextManifestResourceName: ACTIVATION_CONTEXT_INFO_CLASS =
    ACTIVATION_CONTEXT_INFO_CLASS(7i32);
pub const MaxActivationContextInfoClass: ACTIVATION_CONTEXT_INFO_CLASS =
    ACTIVATION_CONTEXT_INFO_CLASS(8i32);
pub const AssemblyDetailedInformationInActivationContxt: ACTIVATION_CONTEXT_INFO_CLASS =
    ACTIVATION_CONTEXT_INFO_CLASS(3i32);
pub const FileInformationInAssemblyOfAssemblyInActivationContxt: ACTIVATION_CONTEXT_INFO_CLASS =
    ACTIVATION_CONTEXT_INFO_CLASS(4i32);
impl ::std::convert::From<i32> for ACTIVATION_CONTEXT_INFO_CLASS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for ACTIVATION_CONTEXT_INFO_CLASS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const ACTIVATION_CONTEXT_PATH_TYPE_ASSEMBLYREF: u32 = 4u32;
pub const ACTIVATION_CONTEXT_PATH_TYPE_NONE: u32 = 1u32;
pub const ACTIVATION_CONTEXT_PATH_TYPE_URL: u32 = 3u32;
pub const ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE: u32 = 2u32;
pub const ACTIVATION_CONTEXT_SECTION_APPLICATION_SETTINGS: u32 = 10u32;
pub const ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION: u32 = 1u32;
pub const ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES: u32 = 9u32;
pub const ACTIVATION_CONTEXT_SECTION_COMPATIBILITY_INFO: u32 = 11u32;
pub const ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION: u32 = 5u32;
pub const ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION: u32 = 7u32;
pub const ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION: u32 = 4u32;
pub const ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION: u32 = 6u32;
pub const ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION: u32 = 2u32;
pub const ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE: u32 = 8u32;
pub const ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION: u32 = 3u32;
pub const ACTIVATION_CONTEXT_SECTION_WINRT_ACTIVATABLE_CLASSES: u32 = 12u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct ALERT_SYSTEM_SEV(pub u32);
pub const ALERT_SYSTEM_INFORMATIONAL: ALERT_SYSTEM_SEV = ALERT_SYSTEM_SEV(1u32);
pub const ALERT_SYSTEM_WARNING: ALERT_SYSTEM_SEV = ALERT_SYSTEM_SEV(2u32);
pub const ALERT_SYSTEM_ERROR: ALERT_SYSTEM_SEV = ALERT_SYSTEM_SEV(3u32);
pub const ALERT_SYSTEM_QUERY: ALERT_SYSTEM_SEV = ALERT_SYSTEM_SEV(4u32);
pub const ALERT_SYSTEM_CRITICAL: ALERT_SYSTEM_SEV = ALERT_SYSTEM_SEV(5u32);
impl ::std::convert::From<u32> for ALERT_SYSTEM_SEV {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for ALERT_SYSTEM_SEV {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for ALERT_SYSTEM_SEV {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for ALERT_SYSTEM_SEV {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for ALERT_SYSTEM_SEV {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for ALERT_SYSTEM_SEV {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for ALERT_SYSTEM_SEV {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const ALL_POWERSCHEMES_GUID: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    1755441502,
    5098,
    16865,
    [128, 17, 12, 73, 108, 164, 144, 176],
);
pub const ALL_PROCESSOR_GROUPS: u32 = 65535u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct ANON_OBJECT_HEADER {
    pub Sig1: u16,
    pub Sig2: u16,
    pub Version: u16,
    pub Machine: u16,
    pub TimeDateStamp: u32,
    pub ClassID: ::windows::runtime::GUID,
    pub SizeOfData: u32,
}
impl ANON_OBJECT_HEADER {}
impl ::std::default::Default for ANON_OBJECT_HEADER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for ANON_OBJECT_HEADER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("ANON_OBJECT_HEADER")
            .field("Sig1", &self.Sig1)
            .field("Sig2", &self.Sig2)
            .field("Version", &self.Version)
            .field("Machine", &self.Machine)
            .field("TimeDateStamp", &self.TimeDateStamp)
            .field("ClassID", &self.ClassID)
            .field("SizeOfData", &self.SizeOfData)
            .finish()
    }
}
impl ::std::cmp::PartialEq for ANON_OBJECT_HEADER {
    fn eq(&self, other: &Self) -> bool {
        self.Sig1 == other.Sig1
            && self.Sig2 == other.Sig2
            && self.Version == other.Version
            && self.Machine == other.Machine
            && self.TimeDateStamp == other.TimeDateStamp
            && self.ClassID == other.ClassID
            && self.SizeOfData == other.SizeOfData
    }
}
impl ::std::cmp::Eq for ANON_OBJECT_HEADER {}
unsafe impl ::windows::runtime::Abi for ANON_OBJECT_HEADER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct ANON_OBJECT_HEADER_BIGOBJ {
    pub Sig1: u16,
    pub Sig2: u16,
    pub Version: u16,
    pub Machine: u16,
    pub TimeDateStamp: u32,
    pub ClassID: ::windows::runtime::GUID,
    pub SizeOfData: u32,
    pub Flags: u32,
    pub MetaDataSize: u32,
    pub MetaDataOffset: u32,
    pub NumberOfSections: u32,
    pub PointerToSymbolTable: u32,
    pub NumberOfSymbols: u32,
}
impl ANON_OBJECT_HEADER_BIGOBJ {}
impl ::std::default::Default for ANON_OBJECT_HEADER_BIGOBJ {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for ANON_OBJECT_HEADER_BIGOBJ {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("ANON_OBJECT_HEADER_BIGOBJ")
            .field("Sig1", &self.Sig1)
            .field("Sig2", &self.Sig2)
            .field("Version", &self.Version)
            .field("Machine", &self.Machine)
            .field("TimeDateStamp", &self.TimeDateStamp)
            .field("ClassID", &self.ClassID)
            .field("SizeOfData", &self.SizeOfData)
            .field("Flags", &self.Flags)
            .field("MetaDataSize", &self.MetaDataSize)
            .field("MetaDataOffset", &self.MetaDataOffset)
            .field("NumberOfSections", &self.NumberOfSections)
            .field("PointerToSymbolTable", &self.PointerToSymbolTable)
            .field("NumberOfSymbols", &self.NumberOfSymbols)
            .finish()
    }
}
impl ::std::cmp::PartialEq for ANON_OBJECT_HEADER_BIGOBJ {
    fn eq(&self, other: &Self) -> bool {
        self.Sig1 == other.Sig1
            && self.Sig2 == other.Sig2
            && self.Version == other.Version
            && self.Machine == other.Machine
            && self.TimeDateStamp == other.TimeDateStamp
            && self.ClassID == other.ClassID
            && self.SizeOfData == other.SizeOfData
            && self.Flags == other.Flags
            && self.MetaDataSize == other.MetaDataSize
            && self.MetaDataOffset == other.MetaDataOffset
            && self.NumberOfSections == other.NumberOfSections
            && self.PointerToSymbolTable == other.PointerToSymbolTable
            && self.NumberOfSymbols == other.NumberOfSymbols
    }
}
impl ::std::cmp::Eq for ANON_OBJECT_HEADER_BIGOBJ {}
unsafe impl ::windows::runtime::Abi for ANON_OBJECT_HEADER_BIGOBJ {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct ANON_OBJECT_HEADER_V2 {
    pub Sig1: u16,
    pub Sig2: u16,
    pub Version: u16,
    pub Machine: u16,
    pub TimeDateStamp: u32,
    pub ClassID: ::windows::runtime::GUID,
    pub SizeOfData: u32,
    pub Flags: u32,
    pub MetaDataSize: u32,
    pub MetaDataOffset: u32,
}
impl ANON_OBJECT_HEADER_V2 {}
impl ::std::default::Default for ANON_OBJECT_HEADER_V2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for ANON_OBJECT_HEADER_V2 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("ANON_OBJECT_HEADER_V2")
            .field("Sig1", &self.Sig1)
            .field("Sig2", &self.Sig2)
            .field("Version", &self.Version)
            .field("Machine", &self.Machine)
            .field("TimeDateStamp", &self.TimeDateStamp)
            .field("ClassID", &self.ClassID)
            .field("SizeOfData", &self.SizeOfData)
            .field("Flags", &self.Flags)
            .field("MetaDataSize", &self.MetaDataSize)
            .field("MetaDataOffset", &self.MetaDataOffset)
            .finish()
    }
}
impl ::std::cmp::PartialEq for ANON_OBJECT_HEADER_V2 {
    fn eq(&self, other: &Self) -> bool {
        self.Sig1 == other.Sig1
            && self.Sig2 == other.Sig2
            && self.Version == other.Version
            && self.Machine == other.Machine
            && self.TimeDateStamp == other.TimeDateStamp
            && self.ClassID == other.ClassID
            && self.SizeOfData == other.SizeOfData
            && self.Flags == other.Flags
            && self.MetaDataSize == other.MetaDataSize
            && self.MetaDataOffset == other.MetaDataOffset
    }
}
impl ::std::cmp::Eq for ANON_OBJECT_HEADER_V2 {}
unsafe impl ::windows::runtime::Abi for ANON_OBJECT_HEADER_V2 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const ANYSIZE_ARRAY: u32 = 1u32;
pub type APC_CALLBACK_FUNCTION = unsafe extern "system" fn(
    param0: u32,
    param1: *mut ::std::ffi::c_void,
    param2: *mut ::std::ffi::c_void,
);
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct APPCOMMAND_ID(pub u32);
pub const APPCOMMAND_BROWSER_BACKWARD: APPCOMMAND_ID = APPCOMMAND_ID(1u32);
pub const APPCOMMAND_BROWSER_FORWARD: APPCOMMAND_ID = APPCOMMAND_ID(2u32);
pub const APPCOMMAND_BROWSER_REFRESH: APPCOMMAND_ID = APPCOMMAND_ID(3u32);
pub const APPCOMMAND_BROWSER_STOP: APPCOMMAND_ID = APPCOMMAND_ID(4u32);
pub const APPCOMMAND_BROWSER_SEARCH: APPCOMMAND_ID = APPCOMMAND_ID(5u32);
pub const APPCOMMAND_BROWSER_FAVORITES: APPCOMMAND_ID = APPCOMMAND_ID(6u32);
pub const APPCOMMAND_BROWSER_HOME: APPCOMMAND_ID = APPCOMMAND_ID(7u32);
pub const APPCOMMAND_VOLUME_MUTE: APPCOMMAND_ID = APPCOMMAND_ID(8u32);
pub const APPCOMMAND_VOLUME_DOWN: APPCOMMAND_ID = APPCOMMAND_ID(9u32);
pub const APPCOMMAND_VOLUME_UP: APPCOMMAND_ID = APPCOMMAND_ID(10u32);
pub const APPCOMMAND_MEDIA_NEXTTRACK: APPCOMMAND_ID = APPCOMMAND_ID(11u32);
pub const APPCOMMAND_MEDIA_PREVIOUSTRACK: APPCOMMAND_ID = APPCOMMAND_ID(12u32);
pub const APPCOMMAND_MEDIA_STOP: APPCOMMAND_ID = APPCOMMAND_ID(13u32);
pub const APPCOMMAND_MEDIA_PLAY_PAUSE: APPCOMMAND_ID = APPCOMMAND_ID(14u32);
pub const APPCOMMAND_LAUNCH_MAIL: APPCOMMAND_ID = APPCOMMAND_ID(15u32);
pub const APPCOMMAND_LAUNCH_MEDIA_SELECT: APPCOMMAND_ID = APPCOMMAND_ID(16u32);
pub const APPCOMMAND_LAUNCH_APP1: APPCOMMAND_ID = APPCOMMAND_ID(17u32);
pub const APPCOMMAND_LAUNCH_APP2: APPCOMMAND_ID = APPCOMMAND_ID(18u32);
pub const APPCOMMAND_BASS_DOWN: APPCOMMAND_ID = APPCOMMAND_ID(19u32);
pub const APPCOMMAND_BASS_BOOST: APPCOMMAND_ID = APPCOMMAND_ID(20u32);
pub const APPCOMMAND_BASS_UP: APPCOMMAND_ID = APPCOMMAND_ID(21u32);
pub const APPCOMMAND_TREBLE_DOWN: APPCOMMAND_ID = APPCOMMAND_ID(22u32);
pub const APPCOMMAND_TREBLE_UP: APPCOMMAND_ID = APPCOMMAND_ID(23u32);
pub const APPCOMMAND_MICROPHONE_VOLUME_MUTE: APPCOMMAND_ID = APPCOMMAND_ID(24u32);
pub const APPCOMMAND_MICROPHONE_VOLUME_DOWN: APPCOMMAND_ID = APPCOMMAND_ID(25u32);
pub const APPCOMMAND_MICROPHONE_VOLUME_UP: APPCOMMAND_ID = APPCOMMAND_ID(26u32);
pub const APPCOMMAND_HELP: APPCOMMAND_ID = APPCOMMAND_ID(27u32);
pub const APPCOMMAND_FIND: APPCOMMAND_ID = APPCOMMAND_ID(28u32);
pub const APPCOMMAND_NEW: APPCOMMAND_ID = APPCOMMAND_ID(29u32);
pub const APPCOMMAND_OPEN: APPCOMMAND_ID = APPCOMMAND_ID(30u32);
pub const APPCOMMAND_CLOSE: APPCOMMAND_ID = APPCOMMAND_ID(31u32);
pub const APPCOMMAND_SAVE: APPCOMMAND_ID = APPCOMMAND_ID(32u32);
pub const APPCOMMAND_PRINT: APPCOMMAND_ID = APPCOMMAND_ID(33u32);
pub const APPCOMMAND_UNDO: APPCOMMAND_ID = APPCOMMAND_ID(34u32);
pub const APPCOMMAND_REDO: APPCOMMAND_ID = APPCOMMAND_ID(35u32);
pub const APPCOMMAND_COPY: APPCOMMAND_ID = APPCOMMAND_ID(36u32);
pub const APPCOMMAND_CUT: APPCOMMAND_ID = APPCOMMAND_ID(37u32);
pub const APPCOMMAND_PASTE: APPCOMMAND_ID = APPCOMMAND_ID(38u32);
pub const APPCOMMAND_REPLY_TO_MAIL: APPCOMMAND_ID = APPCOMMAND_ID(39u32);
pub const APPCOMMAND_FORWARD_MAIL: APPCOMMAND_ID = APPCOMMAND_ID(40u32);
pub const APPCOMMAND_SEND_MAIL: APPCOMMAND_ID = APPCOMMAND_ID(41u32);
pub const APPCOMMAND_SPELL_CHECK: APPCOMMAND_ID = APPCOMMAND_ID(42u32);
pub const APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE: APPCOMMAND_ID = APPCOMMAND_ID(43u32);
pub const APPCOMMAND_MIC_ON_OFF_TOGGLE: APPCOMMAND_ID = APPCOMMAND_ID(44u32);
pub const APPCOMMAND_CORRECTION_LIST: APPCOMMAND_ID = APPCOMMAND_ID(45u32);
pub const APPCOMMAND_MEDIA_PLAY: APPCOMMAND_ID = APPCOMMAND_ID(46u32);
pub const APPCOMMAND_MEDIA_PAUSE: APPCOMMAND_ID = APPCOMMAND_ID(47u32);
pub const APPCOMMAND_MEDIA_RECORD: APPCOMMAND_ID = APPCOMMAND_ID(48u32);
pub const APPCOMMAND_MEDIA_FAST_FORWARD: APPCOMMAND_ID = APPCOMMAND_ID(49u32);
pub const APPCOMMAND_MEDIA_REWIND: APPCOMMAND_ID = APPCOMMAND_ID(50u32);
pub const APPCOMMAND_MEDIA_CHANNEL_UP: APPCOMMAND_ID = APPCOMMAND_ID(51u32);
pub const APPCOMMAND_MEDIA_CHANNEL_DOWN: APPCOMMAND_ID = APPCOMMAND_ID(52u32);
pub const APPCOMMAND_DELETE: APPCOMMAND_ID = APPCOMMAND_ID(53u32);
pub const APPCOMMAND_DWM_FLIP3D: APPCOMMAND_ID = APPCOMMAND_ID(54u32);
impl ::std::convert::From<u32> for APPCOMMAND_ID {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for APPCOMMAND_ID {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for APPCOMMAND_ID {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for APPCOMMAND_ID {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for APPCOMMAND_ID {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for APPCOMMAND_ID {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for APPCOMMAND_ID {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct APPLICATIONLAUNCH_SETTING_VALUE {
    pub ActivationTime: i64,
    pub Flags: u32,
    pub ButtonInstanceID: u32,
}
impl APPLICATIONLAUNCH_SETTING_VALUE {}
impl ::std::default::Default for APPLICATIONLAUNCH_SETTING_VALUE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for APPLICATIONLAUNCH_SETTING_VALUE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("APPLICATIONLAUNCH_SETTING_VALUE")
            .field("ActivationTime", &self.ActivationTime)
            .field("Flags", &self.Flags)
            .field("ButtonInstanceID", &self.ButtonInstanceID)
            .finish()
    }
}
impl ::std::cmp::PartialEq for APPLICATIONLAUNCH_SETTING_VALUE {
    fn eq(&self, other: &Self) -> bool {
        self.ActivationTime == other.ActivationTime
            && self.Flags == other.Flags
            && self.ButtonInstanceID == other.ButtonInstanceID
    }
}
impl ::std::cmp::Eq for APPLICATIONLAUNCH_SETTING_VALUE {}
unsafe impl ::windows::runtime::Abi for APPLICATIONLAUNCH_SETTING_VALUE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const APPLICATION_ERROR_MASK: u32 = 536870912u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct ARM64_FNPDATA_CR(pub i32);
pub const PdataCrUnchained: ARM64_FNPDATA_CR = ARM64_FNPDATA_CR(0i32);
pub const PdataCrUnchainedSavedLr: ARM64_FNPDATA_CR = ARM64_FNPDATA_CR(1i32);
pub const PdataCrChainedWithPac: ARM64_FNPDATA_CR = ARM64_FNPDATA_CR(2i32);
pub const PdataCrChained: ARM64_FNPDATA_CR = ARM64_FNPDATA_CR(3i32);
impl ::std::convert::From<i32> for ARM64_FNPDATA_CR {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for ARM64_FNPDATA_CR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct ARM64_FNPDATA_FLAGS(pub i32);
pub const PdataRefToFullXdata: ARM64_FNPDATA_FLAGS = ARM64_FNPDATA_FLAGS(0i32);
pub const PdataPackedUnwindFunction: ARM64_FNPDATA_FLAGS = ARM64_FNPDATA_FLAGS(1i32);
pub const PdataPackedUnwindFragment: ARM64_FNPDATA_FLAGS = ARM64_FNPDATA_FLAGS(2i32);
impl ::std::convert::From<i32> for ARM64_FNPDATA_FLAGS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for ARM64_FNPDATA_FLAGS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const ARM64_MAX_BREAKPOINTS: u32 = 8u32;
pub const ARM64_MAX_WATCHPOINTS: u32 = 2u32;
pub const ARM64_MULT_INTRINSICS_SUPPORTED: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct ARM64_NT_CONTEXT {
    pub ContextFlags: u32,
    pub Cpsr: u32,
    pub Anonymous: ARM64_NT_CONTEXT_0,
    pub Sp: u64,
    pub Pc: u64,
    pub V: [ARM64_NT_NEON128; 32],
    pub Fpcr: u32,
    pub Fpsr: u32,
    pub Bcr: [u32; 8],
    pub Bvr: [u64; 8],
    pub Wcr: [u32; 2],
    pub Wvr: [u64; 2],
}
impl ARM64_NT_CONTEXT {}
impl ::std::default::Default for ARM64_NT_CONTEXT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for ARM64_NT_CONTEXT {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for ARM64_NT_CONTEXT {}
unsafe impl ::windows::runtime::Abi for ARM64_NT_CONTEXT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union ARM64_NT_CONTEXT_0 {
    pub Anonymous: ARM64_NT_CONTEXT_0_0,
    pub X: [u64; 31],
}
impl ARM64_NT_CONTEXT_0 {}
impl ::std::default::Default for ARM64_NT_CONTEXT_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for ARM64_NT_CONTEXT_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for ARM64_NT_CONTEXT_0 {}
unsafe impl ::windows::runtime::Abi for ARM64_NT_CONTEXT_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct ARM64_NT_CONTEXT_0_0 {
    pub X0: u64,
    pub X1: u64,
    pub X2: u64,
    pub X3: u64,
    pub X4: u64,
    pub X5: u64,
    pub X6: u64,
    pub X7: u64,
    pub X8: u64,
    pub X9: u64,
    pub X10: u64,
    pub X11: u64,
    pub X12: u64,
    pub X13: u64,
    pub X14: u64,
    pub X15: u64,
    pub X16: u64,
    pub X17: u64,
    pub X18: u64,
    pub X19: u64,
    pub X20: u64,
    pub X21: u64,
    pub X22: u64,
    pub X23: u64,
    pub X24: u64,
    pub X25: u64,
    pub X26: u64,
    pub X27: u64,
    pub X28: u64,
    pub Fp: u64,
    pub Lr: u64,
}
impl ARM64_NT_CONTEXT_0_0 {}
impl ::std::default::Default for ARM64_NT_CONTEXT_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for ARM64_NT_CONTEXT_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("X0", &self.X0)
            .field("X1", &self.X1)
            .field("X2", &self.X2)
            .field("X3", &self.X3)
            .field("X4", &self.X4)
            .field("X5", &self.X5)
            .field("X6", &self.X6)
            .field("X7", &self.X7)
            .field("X8", &self.X8)
            .field("X9", &self.X9)
            .field("X10", &self.X10)
            .field("X11", &self.X11)
            .field("X12", &self.X12)
            .field("X13", &self.X13)
            .field("X14", &self.X14)
            .field("X15", &self.X15)
            .field("X16", &self.X16)
            .field("X17", &self.X17)
            .field("X18", &self.X18)
            .field("X19", &self.X19)
            .field("X20", &self.X20)
            .field("X21", &self.X21)
            .field("X22", &self.X22)
            .field("X23", &self.X23)
            .field("X24", &self.X24)
            .field("X25", &self.X25)
            .field("X26", &self.X26)
            .field("X27", &self.X27)
            .field("X28", &self.X28)
            .field("Fp", &self.Fp)
            .field("Lr", &self.Lr)
            .finish()
    }
}
impl ::std::cmp::PartialEq for ARM64_NT_CONTEXT_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.X0 == other.X0
            && self.X1 == other.X1
            && self.X2 == other.X2
            && self.X3 == other.X3
            && self.X4 == other.X4
            && self.X5 == other.X5
            && self.X6 == other.X6
            && self.X7 == other.X7
            && self.X8 == other.X8
            && self.X9 == other.X9
            && self.X10 == other.X10
            && self.X11 == other.X11
            && self.X12 == other.X12
            && self.X13 == other.X13
            && self.X14 == other.X14
            && self.X15 == other.X15
            && self.X16 == other.X16
            && self.X17 == other.X17
            && self.X18 == other.X18
            && self.X19 == other.X19
            && self.X20 == other.X20
            && self.X21 == other.X21
            && self.X22 == other.X22
            && self.X23 == other.X23
            && self.X24 == other.X24
            && self.X25 == other.X25
            && self.X26 == other.X26
            && self.X27 == other.X27
            && self.X28 == other.X28
            && self.Fp == other.Fp
            && self.Lr == other.Lr
    }
}
impl ::std::cmp::Eq for ARM64_NT_CONTEXT_0_0 {}
unsafe impl ::windows::runtime::Abi for ARM64_NT_CONTEXT_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union ARM64_NT_NEON128 {
    pub Anonymous: ARM64_NT_NEON128_0,
    pub D: [f64; 2],
    pub S: [f32; 4],
    pub H: [u16; 8],
    pub B: [u8; 16],
}
impl ARM64_NT_NEON128 {}
impl ::std::default::Default for ARM64_NT_NEON128 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for ARM64_NT_NEON128 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for ARM64_NT_NEON128 {}
unsafe impl ::windows::runtime::Abi for ARM64_NT_NEON128 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct ARM64_NT_NEON128_0 {
    pub Low: u64,
    pub High: i64,
}
impl ARM64_NT_NEON128_0 {}
impl ::std::default::Default for ARM64_NT_NEON128_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for ARM64_NT_NEON128_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("Low", &self.Low)
            .field("High", &self.High)
            .finish()
    }
}
impl ::std::cmp::PartialEq for ARM64_NT_NEON128_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Low == other.Low && self.High == other.High
    }
}
impl ::std::cmp::Eq for ARM64_NT_NEON128_0 {}
unsafe impl ::windows::runtime::Abi for ARM64_NT_NEON128_0 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const ARM64_PREFETCH_KEEP: u32 = 0u32;
pub const ARM64_PREFETCH_L1: u32 = 0u32;
pub const ARM64_PREFETCH_L2: u32 = 2u32;
pub const ARM64_PREFETCH_L3: u32 = 4u32;
pub const ARM64_PREFETCH_PLD: u32 = 0u32;
pub const ARM64_PREFETCH_PLI: u32 = 8u32;
pub const ARM64_PREFETCH_PST: u32 = 16u32;
pub const ARM64_PREFETCH_STRM: u32 = 1u32;
pub const ARM_CACHE_ALIGNMENT_SIZE: u32 = 128u32;
pub const ARM_MAX_BREAKPOINTS: u32 = 8u32;
pub const ARM_MAX_WATCHPOINTS: u32 = 1u32;
pub const ASSERT_ALTERNATE: u32 = 9u32;
pub const ASSERT_BREAKPOINT: u32 = 524291u32;
pub const ASSERT_PRIMARY: u32 = 8u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct ASYNC_DUPLICATE_EXTENTS_STATUS {
    pub Version: u32,
    pub State: DUPLICATE_EXTENTS_STATE,
    pub SourceFileOffset: u64,
    pub TargetFileOffset: u64,
    pub ByteCount: u64,
    pub BytesDuplicated: u64,
}
impl ASYNC_DUPLICATE_EXTENTS_STATUS {}
impl ::std::default::Default for ASYNC_DUPLICATE_EXTENTS_STATUS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for ASYNC_DUPLICATE_EXTENTS_STATUS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("ASYNC_DUPLICATE_EXTENTS_STATUS")
            .field("Version", &self.Version)
            .field("State", &self.State)
            .field("SourceFileOffset", &self.SourceFileOffset)
            .field("TargetFileOffset", &self.TargetFileOffset)
            .field("ByteCount", &self.ByteCount)
            .field("BytesDuplicated", &self.BytesDuplicated)
            .finish()
    }
}
impl ::std::cmp::PartialEq for ASYNC_DUPLICATE_EXTENTS_STATUS {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.State == other.State
            && self.SourceFileOffset == other.SourceFileOffset
            && self.TargetFileOffset == other.TargetFileOffset
            && self.ByteCount == other.ByteCount
            && self.BytesDuplicated == other.BytesDuplicated
    }
}
impl ::std::cmp::Eq for ASYNC_DUPLICATE_EXTENTS_STATUS {}
unsafe impl ::windows::runtime::Abi for ASYNC_DUPLICATE_EXTENTS_STATUS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const ATAPI_ID_CMD: u32 = 161u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct ATF_FLAGS(pub u32);
pub const ATF_TIMEOUTON: ATF_FLAGS = ATF_FLAGS(1u32);
pub const ATF_ONOFFFEEDBACK: ATF_FLAGS = ATF_FLAGS(2u32);
impl ::std::convert::From<u32> for ATF_FLAGS {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for ATF_FLAGS {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for ATF_FLAGS {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for ATF_FLAGS {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for ATF_FLAGS {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for ATF_FLAGS {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for ATF_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const AUDIT_ALLOW_NO_PRIVILEGE: u32 = 1u32;
#[repr(C)]
#[derive(
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
)]
pub struct AtlThunkData_t(pub u8);
pub const BATTERY_DISCHARGE_FLAGS_ENABLE: u32 = 2147483648u32;
pub const BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK: u32 = 7u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct BIN_COUNT {
    pub BinRange: BIN_RANGE,
    pub BinCount: u32,
}
impl BIN_COUNT {}
impl ::std::default::Default for BIN_COUNT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for BIN_COUNT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("BIN_COUNT")
            .field("BinRange", &self.BinRange)
            .field("BinCount", &self.BinCount)
            .finish()
    }
}
impl ::std::cmp::PartialEq for BIN_COUNT {
    fn eq(&self, other: &Self) -> bool {
        self.BinRange == other.BinRange && self.BinCount == other.BinCount
    }
}
impl ::std::cmp::Eq for BIN_COUNT {}
unsafe impl ::windows::runtime::Abi for BIN_COUNT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct BIN_RANGE {
    pub StartValue: i64,
    pub Length: i64,
}
impl BIN_RANGE {}
impl ::std::default::Default for BIN_RANGE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for BIN_RANGE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("BIN_RANGE")
            .field("StartValue", &self.StartValue)
            .field("Length", &self.Length)
            .finish()
    }
}
impl ::std::cmp::PartialEq for BIN_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.StartValue == other.StartValue && self.Length == other.Length
    }
}
impl ::std::cmp::Eq for BIN_RANGE {}
unsafe impl ::windows::runtime::Abi for BIN_RANGE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct BIN_RESULTS {
    pub NumberOfBins: u32,
    pub BinCounts: [BIN_COUNT; 1],
}
impl BIN_RESULTS {}
impl ::std::default::Default for BIN_RESULTS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for BIN_RESULTS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("BIN_RESULTS")
            .field("NumberOfBins", &self.NumberOfBins)
            .field("BinCounts", &self.BinCounts)
            .finish()
    }
}
impl ::std::cmp::PartialEq for BIN_RESULTS {
    fn eq(&self, other: &Self) -> bool {
        self.NumberOfBins == other.NumberOfBins && self.BinCounts == other.BinCounts
    }
}
impl ::std::cmp::Eq for BIN_RESULTS {}
unsafe impl ::windows::runtime::Abi for BIN_RESULTS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct BIN_TYPES(pub i32);
pub const RequestSize: BIN_TYPES = BIN_TYPES(0i32);
pub const RequestLocation: BIN_TYPES = BIN_TYPES(1i32);
impl ::std::convert::From<i32> for BIN_TYPES {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for BIN_TYPES {
    type Abi = Self;
    type DefaultType = Self;
}
pub const BMF_16BPP: i32 = 4i32;
pub const BMF_1BPP: i32 = 1i32;
pub const BMF_24BPP: i32 = 5i32;
pub const BMF_32BPP: i32 = 6i32;
pub const BMF_4BPP: i32 = 2i32;
pub const BMF_4RLE: i32 = 7i32;
pub const BMF_8BPP: i32 = 3i32;
pub const BMF_8RLE: i32 = 8i32;
pub const BMF_ACC_NOTIFY: u32 = 32768u32;
pub const BMF_DONTCACHE: u32 = 4u32;
pub const BMF_JPEG: i32 = 9i32;
pub const BMF_KMSECTION: u32 = 16u32;
pub const BMF_NOTSYSMEM: u32 = 32u32;
pub const BMF_NOZEROINIT: u32 = 2u32;
pub const BMF_PNG: i32 = 10i32;
pub const BMF_RESERVED: u32 = 15872u32;
pub const BMF_RMT_ENTER: u32 = 16384u32;
pub const BMF_TEMP_ALPHA: u32 = 256u32;
pub const BMF_TOPDOWN: u32 = 1u32;
pub const BMF_UMPDMEM: u32 = 128u32;
pub const BMF_USERMEM: u32 = 8u32;
pub const BMF_WINDOW_BLT: u32 = 64u32;
pub const BREAK_DEBUG_BASE: u32 = 524288u32;
pub const BR_CMYKCOLOR: u32 = 4u32;
pub const BR_DEVICE_ICM: u32 = 1u32;
pub const BR_HOST_ICM: u32 = 2u32;
pub const BR_ORIGCOLOR: u32 = 8u32;
pub const BSF_MSGSRV32ISOK: u32 = 2147483648u32;
pub const BSF_MSGSRV32ISOK_BIT: u32 = 31u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct BSTRBLOB {
    pub cbSize: u32,
    pub pData: *mut u8,
}
impl BSTRBLOB {}
impl ::std::default::Default for BSTRBLOB {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for BSTRBLOB {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("BSTRBLOB")
            .field("cbSize", &self.cbSize)
            .field("pData", &self.pData)
            .finish()
    }
}
impl ::std::cmp::PartialEq for BSTRBLOB {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize && self.pData == other.pData
    }
}
impl ::std::cmp::Eq for BSTRBLOB {}
unsafe impl ::windows::runtime::Abi for BSTRBLOB {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct BULK_SECURITY_TEST_DATA {
    pub DesiredAccess: u32,
    pub SecurityIds: [u32; 1],
}
impl BULK_SECURITY_TEST_DATA {}
impl ::std::default::Default for BULK_SECURITY_TEST_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for BULK_SECURITY_TEST_DATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("BULK_SECURITY_TEST_DATA")
            .field("DesiredAccess", &self.DesiredAccess)
            .field("SecurityIds", &self.SecurityIds)
            .finish()
    }
}
impl ::std::cmp::PartialEq for BULK_SECURITY_TEST_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.DesiredAccess == other.DesiredAccess && self.SecurityIds == other.SecurityIds
    }
}
impl ::std::cmp::Eq for BULK_SECURITY_TEST_DATA {}
unsafe impl ::windows::runtime::Abi for BULK_SECURITY_TEST_DATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
pub unsafe fn BindIoCompletionCallback<
    'a,
    Param0: ::windows::runtime::IntoParam<'a, super::super::Foundation::HANDLE>,
>(
    filehandle: Param0,
    function: ::std::option::Option<
        super::super::Storage::FileSystem::LPOVERLAPPED_COMPLETION_ROUTINE,
    >,
    flags: u32,
) -> super::super::Foundation::BOOL {
    #[cfg(windows)]
    {
        #[link(name = "kernel32")]
        extern "system" {
            fn BindIoCompletionCallback(
                filehandle: super::super::Foundation::HANDLE,
                function: ::windows::runtime::RawPtr,
                flags: u32,
            ) -> super::super::Foundation::BOOL;
        }
        ::std::mem::transmute(BindIoCompletionCallback(
            filehandle.into_param().abi(),
            ::std::mem::transmute(function),
            ::std::mem::transmute(flags),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CACHE_DESCRIPTOR {
    pub Level: u8,
    pub Associativity: u8,
    pub LineSize: u16,
    pub Size: u32,
    pub Type: PROCESSOR_CACHE_TYPE,
}
impl CACHE_DESCRIPTOR {}
impl ::std::default::Default for CACHE_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CACHE_DESCRIPTOR {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CACHE_DESCRIPTOR")
            .field("Level", &self.Level)
            .field("Associativity", &self.Associativity)
            .field("LineSize", &self.LineSize)
            .field("Size", &self.Size)
            .field("Type", &self.Type)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CACHE_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.Level == other.Level
            && self.Associativity == other.Associativity
            && self.LineSize == other.LineSize
            && self.Size == other.Size
            && self.Type == other.Type
    }
}
impl ::std::cmp::Eq for CACHE_DESCRIPTOR {}
unsafe impl ::windows::runtime::Abi for CACHE_DESCRIPTOR {
    type Abi = Self;
    type DefaultType = Self;
}
pub const CACHE_FULLY_ASSOCIATIVE: u32 = 255u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Kernel")]
pub struct CACHE_RELATIONSHIP {
    pub Level: u8,
    pub Associativity: u8,
    pub LineSize: u16,
    pub CacheSize: u32,
    pub Type: PROCESSOR_CACHE_TYPE,
    pub Reserved: [u8; 18],
    pub GroupCount: u16,
    pub Anonymous: CACHE_RELATIONSHIP_0,
}
#[cfg(feature = "Win32_System_Kernel")]
impl CACHE_RELATIONSHIP {}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::default::Default for CACHE_RELATIONSHIP {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::cmp::PartialEq for CACHE_RELATIONSHIP {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::cmp::Eq for CACHE_RELATIONSHIP {}
#[cfg(feature = "Win32_System_Kernel")]
unsafe impl ::windows::runtime::Abi for CACHE_RELATIONSHIP {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Kernel")]
pub union CACHE_RELATIONSHIP_0 {
    pub GroupMask: super::Kernel::GROUP_AFFINITY,
    pub GroupMasks: [super::Kernel::GROUP_AFFINITY; 1],
}
#[cfg(feature = "Win32_System_Kernel")]
impl CACHE_RELATIONSHIP_0 {}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::default::Default for CACHE_RELATIONSHIP_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::cmp::PartialEq for CACHE_RELATIONSHIP_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::cmp::Eq for CACHE_RELATIONSHIP_0 {}
#[cfg(feature = "Win32_System_Kernel")]
unsafe impl ::windows::runtime::Abi for CACHE_RELATIONSHIP_0 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const CAP_ATAPI_ID_CMD: u32 = 2u32;
pub const CAP_ATA_ID_CMD: u32 = 1u32;
pub const CAP_SMART_CMD: u32 = 4u32;
pub const CDBEX_CROSSADAPTER: u32 = 8u32;
pub const CDBEX_DXINTEROP: u32 = 2u32;
pub const CDBEX_NTSHAREDSURFACEHANDLE: u32 = 4u32;
pub const CDBEX_REDIRECTION: u32 = 1u32;
pub const CDBEX_REUSE: u32 = 16u32;
pub const CDB_SIZE: u32 = 16u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct CDDDXGK_REDIRBITMAPPRESENTINFO {
    pub NumDirtyRects: u32,
    pub DirtyRect: *mut super::super::Foundation::RECT,
    pub NumContexts: u32,
    pub hContext: [super::super::Foundation::HANDLE; 65],
    pub bDoNotSynchronizeWithDxContent: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl CDDDXGK_REDIRBITMAPPRESENTINFO {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for CDDDXGK_REDIRBITMAPPRESENTINFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for CDDDXGK_REDIRBITMAPPRESENTINFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CDDDXGK_REDIRBITMAPPRESENTINFO")
            .field("NumDirtyRects", &self.NumDirtyRects)
            .field("DirtyRect", &self.DirtyRect)
            .field("NumContexts", &self.NumContexts)
            .field("hContext", &self.hContext)
            .field(
                "bDoNotSynchronizeWithDxContent",
                &self.bDoNotSynchronizeWithDxContent,
            )
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for CDDDXGK_REDIRBITMAPPRESENTINFO {
    fn eq(&self, other: &Self) -> bool {
        self.NumDirtyRects == other.NumDirtyRects
            && self.DirtyRect == other.DirtyRect
            && self.NumContexts == other.NumContexts
            && self.hContext == other.hContext
            && self.bDoNotSynchronizeWithDxContent == other.bDoNotSynchronizeWithDxContent
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for CDDDXGK_REDIRBITMAPPRESENTINFO {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for CDDDXGK_REDIRBITMAPPRESENTINFO {
    type Abi = Self;
    type DefaultType = Self;
}
pub const CD_ANY: i32 = 4i32;
pub const CD_LEFTDOWN: i32 = 1i32;
pub const CD_LEFTUP: i32 = 3i32;
pub const CD_LEFTWARDS: i32 = 1i32;
pub const CD_RIGHTDOWN: i32 = 0i32;
pub const CD_RIGHTUP: i32 = 2i32;
pub const CD_UPWARDS: i32 = 2i32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct CERT_VIEWPROPERTIES_STRUCT_FLAGS(pub u32);
pub const CM_ENABLEHOOK: CERT_VIEWPROPERTIES_STRUCT_FLAGS = CERT_VIEWPROPERTIES_STRUCT_FLAGS(1u32);
pub const CM_SHOW_HELP: CERT_VIEWPROPERTIES_STRUCT_FLAGS = CERT_VIEWPROPERTIES_STRUCT_FLAGS(2u32);
pub const CM_SHOW_HELPICON: CERT_VIEWPROPERTIES_STRUCT_FLAGS =
    CERT_VIEWPROPERTIES_STRUCT_FLAGS(4u32);
pub const CM_ENABLETEMPLATE: CERT_VIEWPROPERTIES_STRUCT_FLAGS =
    CERT_VIEWPROPERTIES_STRUCT_FLAGS(8u32);
pub const CM_HIDE_ADVANCEPAGE: CERT_VIEWPROPERTIES_STRUCT_FLAGS =
    CERT_VIEWPROPERTIES_STRUCT_FLAGS(16u32);
pub const CM_HIDE_TRUSTPAGE: CERT_VIEWPROPERTIES_STRUCT_FLAGS =
    CERT_VIEWPROPERTIES_STRUCT_FLAGS(32u32);
pub const CM_NO_NAMECHANGE: CERT_VIEWPROPERTIES_STRUCT_FLAGS =
    CERT_VIEWPROPERTIES_STRUCT_FLAGS(64u32);
pub const CM_NO_EDITTRUST: CERT_VIEWPROPERTIES_STRUCT_FLAGS =
    CERT_VIEWPROPERTIES_STRUCT_FLAGS(128u32);
pub const CM_HIDE_DETAILPAGE: CERT_VIEWPROPERTIES_STRUCT_FLAGS =
    CERT_VIEWPROPERTIES_STRUCT_FLAGS(256u32);
pub const CM_ADD_CERT_STORES: CERT_VIEWPROPERTIES_STRUCT_FLAGS =
    CERT_VIEWPROPERTIES_STRUCT_FLAGS(512u32);
impl ::std::convert::From<u32> for CERT_VIEWPROPERTIES_STRUCT_FLAGS {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for CERT_VIEWPROPERTIES_STRUCT_FLAGS {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for CERT_VIEWPROPERTIES_STRUCT_FLAGS {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for CERT_VIEWPROPERTIES_STRUCT_FLAGS {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for CERT_VIEWPROPERTIES_STRUCT_FLAGS {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for CERT_VIEWPROPERTIES_STRUCT_FLAGS {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for CERT_VIEWPROPERTIES_STRUCT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct CFE_UNDERLINE(pub u32);
pub const CFU_CF1UNDERLINE: CFE_UNDERLINE = CFE_UNDERLINE(255u32);
pub const CFU_INVERT: CFE_UNDERLINE = CFE_UNDERLINE(254u32);
pub const CFU_UNDERLINETHICKLONGDASH: CFE_UNDERLINE = CFE_UNDERLINE(18u32);
pub const CFU_UNDERLINETHICKDOTTED: CFE_UNDERLINE = CFE_UNDERLINE(17u32);
pub const CFU_UNDERLINETHICKDASHDOTDOT: CFE_UNDERLINE = CFE_UNDERLINE(16u32);
pub const CFU_UNDERLINETHICKDASHDOT: CFE_UNDERLINE = CFE_UNDERLINE(15u32);
pub const CFU_UNDERLINETHICKDASH: CFE_UNDERLINE = CFE_UNDERLINE(14u32);
pub const CFU_UNDERLINELONGDASH: CFE_UNDERLINE = CFE_UNDERLINE(13u32);
pub const CFU_UNDERLINEHEAVYWAVE: CFE_UNDERLINE = CFE_UNDERLINE(12u32);
pub const CFU_UNDERLINEDOUBLEWAVE: CFE_UNDERLINE = CFE_UNDERLINE(11u32);
pub const CFU_UNDERLINEHAIRLINE: CFE_UNDERLINE = CFE_UNDERLINE(10u32);
pub const CFU_UNDERLINETHICK: CFE_UNDERLINE = CFE_UNDERLINE(9u32);
pub const CFU_UNDERLINEWAVE: CFE_UNDERLINE = CFE_UNDERLINE(8u32);
pub const CFU_UNDERLINEDASHDOTDOT: CFE_UNDERLINE = CFE_UNDERLINE(7u32);
pub const CFU_UNDERLINEDASHDOT: CFE_UNDERLINE = CFE_UNDERLINE(6u32);
pub const CFU_UNDERLINEDASH: CFE_UNDERLINE = CFE_UNDERLINE(5u32);
pub const CFU_UNDERLINEDOTTED: CFE_UNDERLINE = CFE_UNDERLINE(4u32);
pub const CFU_UNDERLINEDOUBLE: CFE_UNDERLINE = CFE_UNDERLINE(3u32);
pub const CFU_UNDERLINEWORD: CFE_UNDERLINE = CFE_UNDERLINE(2u32);
pub const CFU_UNDERLINE: CFE_UNDERLINE = CFE_UNDERLINE(1u32);
pub const CFU_UNDERLINENONE: CFE_UNDERLINE = CFE_UNDERLINE(0u32);
impl ::std::convert::From<u32> for CFE_UNDERLINE {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for CFE_UNDERLINE {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for CFE_UNDERLINE {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for CFE_UNDERLINE {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for CFE_UNDERLINE {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for CFE_UNDERLINE {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for CFE_UNDERLINE {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const CFG_CALL_TARGET_CONVERT_EXPORT_SUPPRESSED_TO_VALID: u32 = 4u32;
pub const CFG_CALL_TARGET_CONVERT_XFG_TO_CFG: u32 = 16u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CFG_CALL_TARGET_INFO {
    pub Offset: usize,
    pub Flags: usize,
}
impl CFG_CALL_TARGET_INFO {}
impl ::std::default::Default for CFG_CALL_TARGET_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CFG_CALL_TARGET_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CFG_CALL_TARGET_INFO")
            .field("Offset", &self.Offset)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CFG_CALL_TARGET_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Offset == other.Offset && self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for CFG_CALL_TARGET_INFO {}
unsafe impl ::windows::runtime::Abi for CFG_CALL_TARGET_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
pub const CFG_CALL_TARGET_PROCESSED: u32 = 2u32;
pub const CFG_CALL_TARGET_VALID: u32 = 1u32;
pub const CFG_CALL_TARGET_VALID_XFG: u32 = 8u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct CHANGER_DEVICE_PROBLEM_TYPE(pub i32);
pub const DeviceProblemNone: CHANGER_DEVICE_PROBLEM_TYPE = CHANGER_DEVICE_PROBLEM_TYPE(0i32);
pub const DeviceProblemHardware: CHANGER_DEVICE_PROBLEM_TYPE = CHANGER_DEVICE_PROBLEM_TYPE(1i32);
pub const DeviceProblemCHMError: CHANGER_DEVICE_PROBLEM_TYPE = CHANGER_DEVICE_PROBLEM_TYPE(2i32);
pub const DeviceProblemDoorOpen: CHANGER_DEVICE_PROBLEM_TYPE = CHANGER_DEVICE_PROBLEM_TYPE(3i32);
pub const DeviceProblemCalibrationError: CHANGER_DEVICE_PROBLEM_TYPE =
    CHANGER_DEVICE_PROBLEM_TYPE(4i32);
pub const DeviceProblemTargetFailure: CHANGER_DEVICE_PROBLEM_TYPE =
    CHANGER_DEVICE_PROBLEM_TYPE(5i32);
pub const DeviceProblemCHMMoveError: CHANGER_DEVICE_PROBLEM_TYPE =
    CHANGER_DEVICE_PROBLEM_TYPE(6i32);
pub const DeviceProblemCHMZeroError: CHANGER_DEVICE_PROBLEM_TYPE =
    CHANGER_DEVICE_PROBLEM_TYPE(7i32);
pub const DeviceProblemCartridgeInsertError: CHANGER_DEVICE_PROBLEM_TYPE =
    CHANGER_DEVICE_PROBLEM_TYPE(8i32);
pub const DeviceProblemPositionError: CHANGER_DEVICE_PROBLEM_TYPE =
    CHANGER_DEVICE_PROBLEM_TYPE(9i32);
pub const DeviceProblemSensorError: CHANGER_DEVICE_PROBLEM_TYPE =
    CHANGER_DEVICE_PROBLEM_TYPE(10i32);
pub const DeviceProblemCartridgeEjectError: CHANGER_DEVICE_PROBLEM_TYPE =
    CHANGER_DEVICE_PROBLEM_TYPE(11i32);
pub const DeviceProblemGripperError: CHANGER_DEVICE_PROBLEM_TYPE =
    CHANGER_DEVICE_PROBLEM_TYPE(12i32);
pub const DeviceProblemDriveError: CHANGER_DEVICE_PROBLEM_TYPE = CHANGER_DEVICE_PROBLEM_TYPE(13i32);
impl ::std::convert::From<i32> for CHANGER_DEVICE_PROBLEM_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for CHANGER_DEVICE_PROBLEM_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CHANGER_ELEMENT {
    pub ElementType: ELEMENT_TYPE,
    pub ElementAddress: u32,
}
impl CHANGER_ELEMENT {}
impl ::std::default::Default for CHANGER_ELEMENT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CHANGER_ELEMENT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CHANGER_ELEMENT")
            .field("ElementType", &self.ElementType)
            .field("ElementAddress", &self.ElementAddress)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CHANGER_ELEMENT {
    fn eq(&self, other: &Self) -> bool {
        self.ElementType == other.ElementType && self.ElementAddress == other.ElementAddress
    }
}
impl ::std::cmp::Eq for CHANGER_ELEMENT {}
unsafe impl ::windows::runtime::Abi for CHANGER_ELEMENT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CHANGER_ELEMENT_LIST {
    pub Element: CHANGER_ELEMENT,
    pub NumberOfElements: u32,
}
impl CHANGER_ELEMENT_LIST {}
impl ::std::default::Default for CHANGER_ELEMENT_LIST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CHANGER_ELEMENT_LIST {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CHANGER_ELEMENT_LIST")
            .field("Element", &self.Element)
            .field("NumberOfElements", &self.NumberOfElements)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CHANGER_ELEMENT_LIST {
    fn eq(&self, other: &Self) -> bool {
        self.Element == other.Element && self.NumberOfElements == other.NumberOfElements
    }
}
impl ::std::cmp::Eq for CHANGER_ELEMENT_LIST {}
unsafe impl ::windows::runtime::Abi for CHANGER_ELEMENT_LIST {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CHANGER_ELEMENT_STATUS {
    pub Element: CHANGER_ELEMENT,
    pub SrcElementAddress: CHANGER_ELEMENT,
    pub Flags: CHANGER_ELEMENT_STATUS_FLAGS,
    pub ExceptionCode: u32,
    pub TargetId: u8,
    pub Lun: u8,
    pub Reserved: u16,
    pub PrimaryVolumeID: [u8; 36],
    pub AlternateVolumeID: [u8; 36],
}
impl CHANGER_ELEMENT_STATUS {}
impl ::std::default::Default for CHANGER_ELEMENT_STATUS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CHANGER_ELEMENT_STATUS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CHANGER_ELEMENT_STATUS")
            .field("Element", &self.Element)
            .field("SrcElementAddress", &self.SrcElementAddress)
            .field("Flags", &self.Flags)
            .field("ExceptionCode", &self.ExceptionCode)
            .field("TargetId", &self.TargetId)
            .field("Lun", &self.Lun)
            .field("Reserved", &self.Reserved)
            .field("PrimaryVolumeID", &self.PrimaryVolumeID)
            .field("AlternateVolumeID", &self.AlternateVolumeID)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CHANGER_ELEMENT_STATUS {
    fn eq(&self, other: &Self) -> bool {
        self.Element == other.Element
            && self.SrcElementAddress == other.SrcElementAddress
            && self.Flags == other.Flags
            && self.ExceptionCode == other.ExceptionCode
            && self.TargetId == other.TargetId
            && self.Lun == other.Lun
            && self.Reserved == other.Reserved
            && self.PrimaryVolumeID == other.PrimaryVolumeID
            && self.AlternateVolumeID == other.AlternateVolumeID
    }
}
impl ::std::cmp::Eq for CHANGER_ELEMENT_STATUS {}
unsafe impl ::windows::runtime::Abi for CHANGER_ELEMENT_STATUS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CHANGER_ELEMENT_STATUS_EX {
    pub Element: CHANGER_ELEMENT,
    pub SrcElementAddress: CHANGER_ELEMENT,
    pub Flags: CHANGER_ELEMENT_STATUS_FLAGS,
    pub ExceptionCode: u32,
    pub TargetId: u8,
    pub Lun: u8,
    pub Reserved: u16,
    pub PrimaryVolumeID: [u8; 36],
    pub AlternateVolumeID: [u8; 36],
    pub VendorIdentification: [u8; 8],
    pub ProductIdentification: [u8; 16],
    pub SerialNumber: [u8; 32],
}
impl CHANGER_ELEMENT_STATUS_EX {}
impl ::std::default::Default for CHANGER_ELEMENT_STATUS_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CHANGER_ELEMENT_STATUS_EX {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CHANGER_ELEMENT_STATUS_EX")
            .field("Element", &self.Element)
            .field("SrcElementAddress", &self.SrcElementAddress)
            .field("Flags", &self.Flags)
            .field("ExceptionCode", &self.ExceptionCode)
            .field("TargetId", &self.TargetId)
            .field("Lun", &self.Lun)
            .field("Reserved", &self.Reserved)
            .field("PrimaryVolumeID", &self.PrimaryVolumeID)
            .field("AlternateVolumeID", &self.AlternateVolumeID)
            .field("VendorIdentification", &self.VendorIdentification)
            .field("ProductIdentification", &self.ProductIdentification)
            .field("SerialNumber", &self.SerialNumber)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CHANGER_ELEMENT_STATUS_EX {
    fn eq(&self, other: &Self) -> bool {
        self.Element == other.Element
            && self.SrcElementAddress == other.SrcElementAddress
            && self.Flags == other.Flags
            && self.ExceptionCode == other.ExceptionCode
            && self.TargetId == other.TargetId
            && self.Lun == other.Lun
            && self.Reserved == other.Reserved
            && self.PrimaryVolumeID == other.PrimaryVolumeID
            && self.AlternateVolumeID == other.AlternateVolumeID
            && self.VendorIdentification == other.VendorIdentification
            && self.ProductIdentification == other.ProductIdentification
            && self.SerialNumber == other.SerialNumber
    }
}
impl ::std::cmp::Eq for CHANGER_ELEMENT_STATUS_EX {}
unsafe impl ::windows::runtime::Abi for CHANGER_ELEMENT_STATUS_EX {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct CHANGER_ELEMENT_STATUS_FLAGS(pub u32);
pub const ELEMENT_STATUS_ACCESS: CHANGER_ELEMENT_STATUS_FLAGS = CHANGER_ELEMENT_STATUS_FLAGS(8u32);
pub const ELEMENT_STATUS_AVOLTAG: CHANGER_ELEMENT_STATUS_FLAGS =
    CHANGER_ELEMENT_STATUS_FLAGS(536870912u32);
pub const ELEMENT_STATUS_EXCEPT: CHANGER_ELEMENT_STATUS_FLAGS = CHANGER_ELEMENT_STATUS_FLAGS(4u32);
pub const ELEMENT_STATUS_EXENAB: CHANGER_ELEMENT_STATUS_FLAGS = CHANGER_ELEMENT_STATUS_FLAGS(16u32);
pub const ELEMENT_STATUS_FULL: CHANGER_ELEMENT_STATUS_FLAGS = CHANGER_ELEMENT_STATUS_FLAGS(1u32);
pub const ELEMENT_STATUS_ID_VALID: CHANGER_ELEMENT_STATUS_FLAGS =
    CHANGER_ELEMENT_STATUS_FLAGS(8192u32);
pub const ELEMENT_STATUS_IMPEXP: CHANGER_ELEMENT_STATUS_FLAGS = CHANGER_ELEMENT_STATUS_FLAGS(2u32);
pub const ELEMENT_STATUS_INENAB: CHANGER_ELEMENT_STATUS_FLAGS = CHANGER_ELEMENT_STATUS_FLAGS(32u32);
pub const ELEMENT_STATUS_INVERT: CHANGER_ELEMENT_STATUS_FLAGS =
    CHANGER_ELEMENT_STATUS_FLAGS(4194304u32);
pub const ELEMENT_STATUS_LUN_VALID: CHANGER_ELEMENT_STATUS_FLAGS =
    CHANGER_ELEMENT_STATUS_FLAGS(4096u32);
pub const ELEMENT_STATUS_NOT_BUS: CHANGER_ELEMENT_STATUS_FLAGS =
    CHANGER_ELEMENT_STATUS_FLAGS(32768u32);
pub const ELEMENT_STATUS_PVOLTAG: CHANGER_ELEMENT_STATUS_FLAGS =
    CHANGER_ELEMENT_STATUS_FLAGS(268435456u32);
pub const ELEMENT_STATUS_SVALID: CHANGER_ELEMENT_STATUS_FLAGS =
    CHANGER_ELEMENT_STATUS_FLAGS(8388608u32);
pub const ELEMENT_STATUS_PRODUCT_DATA: CHANGER_ELEMENT_STATUS_FLAGS =
    CHANGER_ELEMENT_STATUS_FLAGS(64u32);
impl ::std::convert::From<u32> for CHANGER_ELEMENT_STATUS_FLAGS {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for CHANGER_ELEMENT_STATUS_FLAGS {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for CHANGER_ELEMENT_STATUS_FLAGS {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for CHANGER_ELEMENT_STATUS_FLAGS {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for CHANGER_ELEMENT_STATUS_FLAGS {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for CHANGER_ELEMENT_STATUS_FLAGS {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for CHANGER_ELEMENT_STATUS_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct CHANGER_EXCHANGE_MEDIUM {
    pub Transport: CHANGER_ELEMENT,
    pub Source: CHANGER_ELEMENT,
    pub Destination1: CHANGER_ELEMENT,
    pub Destination2: CHANGER_ELEMENT,
    pub Flip1: super::super::Foundation::BOOLEAN,
    pub Flip2: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl CHANGER_EXCHANGE_MEDIUM {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for CHANGER_EXCHANGE_MEDIUM {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for CHANGER_EXCHANGE_MEDIUM {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CHANGER_EXCHANGE_MEDIUM")
            .field("Transport", &self.Transport)
            .field("Source", &self.Source)
            .field("Destination1", &self.Destination1)
            .field("Destination2", &self.Destination2)
            .field("Flip1", &self.Flip1)
            .field("Flip2", &self.Flip2)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for CHANGER_EXCHANGE_MEDIUM {
    fn eq(&self, other: &Self) -> bool {
        self.Transport == other.Transport
            && self.Source == other.Source
            && self.Destination1 == other.Destination1
            && self.Destination2 == other.Destination2
            && self.Flip1 == other.Flip1
            && self.Flip2 == other.Flip2
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for CHANGER_EXCHANGE_MEDIUM {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for CHANGER_EXCHANGE_MEDIUM {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct CHANGER_FEATURES(pub u32);
pub const CHANGER_BAR_CODE_SCANNER_INSTALLED: CHANGER_FEATURES = CHANGER_FEATURES(1u32);
pub const CHANGER_CARTRIDGE_MAGAZINE: CHANGER_FEATURES = CHANGER_FEATURES(256u32);
pub const CHANGER_CLEANER_ACCESS_NOT_VALID: CHANGER_FEATURES = CHANGER_FEATURES(262144u32);
pub const CHANGER_CLEANER_SLOT: CHANGER_FEATURES = CHANGER_FEATURES(64u32);
pub const CHANGER_CLOSE_IEPORT: CHANGER_FEATURES = CHANGER_FEATURES(4u32);
pub const CHANGER_DEVICE_REINITIALIZE_CAPABLE: CHANGER_FEATURES = CHANGER_FEATURES(134217728u32);
pub const CHANGER_DRIVE_CLEANING_REQUIRED: CHANGER_FEATURES = CHANGER_FEATURES(65536u32);
pub const CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS: CHANGER_FEATURES = CHANGER_FEATURES(536870912u32);
pub const CHANGER_EXCHANGE_MEDIA: CHANGER_FEATURES = CHANGER_FEATURES(32u32);
pub const CHANGER_INIT_ELEM_STAT_WITH_RANGE: CHANGER_FEATURES = CHANGER_FEATURES(2u32);
pub const CHANGER_KEYPAD_ENABLE_DISABLE: CHANGER_FEATURES = CHANGER_FEATURES(268435456u32);
pub const CHANGER_LOCK_UNLOCK: CHANGER_FEATURES = CHANGER_FEATURES(128u32);
pub const CHANGER_MEDIUM_FLIP: CHANGER_FEATURES = CHANGER_FEATURES(512u32);
pub const CHANGER_OPEN_IEPORT: CHANGER_FEATURES = CHANGER_FEATURES(8u32);
pub const CHANGER_POSITION_TO_ELEMENT: CHANGER_FEATURES = CHANGER_FEATURES(1024u32);
pub const CHANGER_PREDISMOUNT_EJECT_REQUIRED: CHANGER_FEATURES = CHANGER_FEATURES(131072u32);
pub const CHANGER_PREMOUNT_EJECT_REQUIRED: CHANGER_FEATURES = CHANGER_FEATURES(524288u32);
pub const CHANGER_REPORT_IEPORT_STATE: CHANGER_FEATURES = CHANGER_FEATURES(2048u32);
pub const CHANGER_SERIAL_NUMBER_VALID: CHANGER_FEATURES = CHANGER_FEATURES(67108864u32);
pub const CHANGER_STATUS_NON_VOLATILE: CHANGER_FEATURES = CHANGER_FEATURES(16u32);
pub const CHANGER_STORAGE_DRIVE: CHANGER_FEATURES = CHANGER_FEATURES(4096u32);
pub const CHANGER_STORAGE_IEPORT: CHANGER_FEATURES = CHANGER_FEATURES(8192u32);
pub const CHANGER_STORAGE_SLOT: CHANGER_FEATURES = CHANGER_FEATURES(16384u32);
pub const CHANGER_STORAGE_TRANSPORT: CHANGER_FEATURES = CHANGER_FEATURES(32768u32);
pub const CHANGER_VOLUME_ASSERT: CHANGER_FEATURES = CHANGER_FEATURES(4194304u32);
pub const CHANGER_VOLUME_IDENTIFICATION: CHANGER_FEATURES = CHANGER_FEATURES(1048576u32);
pub const CHANGER_VOLUME_REPLACE: CHANGER_FEATURES = CHANGER_FEATURES(8388608u32);
pub const CHANGER_VOLUME_SEARCH: CHANGER_FEATURES = CHANGER_FEATURES(2097152u32);
pub const CHANGER_VOLUME_UNDEFINE: CHANGER_FEATURES = CHANGER_FEATURES(16777216u32);
impl ::std::convert::From<u32> for CHANGER_FEATURES {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for CHANGER_FEATURES {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for CHANGER_FEATURES {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for CHANGER_FEATURES {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for CHANGER_FEATURES {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for CHANGER_FEATURES {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for CHANGER_FEATURES {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct CHANGER_INITIALIZE_ELEMENT_STATUS {
    pub ElementList: CHANGER_ELEMENT_LIST,
    pub BarCodeScan: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl CHANGER_INITIALIZE_ELEMENT_STATUS {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for CHANGER_INITIALIZE_ELEMENT_STATUS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for CHANGER_INITIALIZE_ELEMENT_STATUS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CHANGER_INITIALIZE_ELEMENT_STATUS")
            .field("ElementList", &self.ElementList)
            .field("BarCodeScan", &self.BarCodeScan)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for CHANGER_INITIALIZE_ELEMENT_STATUS {
    fn eq(&self, other: &Self) -> bool {
        self.ElementList == other.ElementList && self.BarCodeScan == other.BarCodeScan
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for CHANGER_INITIALIZE_ELEMENT_STATUS {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for CHANGER_INITIALIZE_ELEMENT_STATUS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct CHANGER_MOVE_MEDIUM {
    pub Transport: CHANGER_ELEMENT,
    pub Source: CHANGER_ELEMENT,
    pub Destination: CHANGER_ELEMENT,
    pub Flip: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl CHANGER_MOVE_MEDIUM {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for CHANGER_MOVE_MEDIUM {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for CHANGER_MOVE_MEDIUM {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CHANGER_MOVE_MEDIUM")
            .field("Transport", &self.Transport)
            .field("Source", &self.Source)
            .field("Destination", &self.Destination)
            .field("Flip", &self.Flip)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for CHANGER_MOVE_MEDIUM {
    fn eq(&self, other: &Self) -> bool {
        self.Transport == other.Transport
            && self.Source == other.Source
            && self.Destination == other.Destination
            && self.Flip == other.Flip
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for CHANGER_MOVE_MEDIUM {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for CHANGER_MOVE_MEDIUM {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CHANGER_PRODUCT_DATA {
    pub VendorId: [u8; 8],
    pub ProductId: [u8; 16],
    pub Revision: [u8; 4],
    pub SerialNumber: [u8; 32],
    pub DeviceType: u8,
}
impl CHANGER_PRODUCT_DATA {}
impl ::std::default::Default for CHANGER_PRODUCT_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CHANGER_PRODUCT_DATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CHANGER_PRODUCT_DATA")
            .field("VendorId", &self.VendorId)
            .field("ProductId", &self.ProductId)
            .field("Revision", &self.Revision)
            .field("SerialNumber", &self.SerialNumber)
            .field("DeviceType", &self.DeviceType)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CHANGER_PRODUCT_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.VendorId == other.VendorId
            && self.ProductId == other.ProductId
            && self.Revision == other.Revision
            && self.SerialNumber == other.SerialNumber
            && self.DeviceType == other.DeviceType
    }
}
impl ::std::cmp::Eq for CHANGER_PRODUCT_DATA {}
unsafe impl ::windows::runtime::Abi for CHANGER_PRODUCT_DATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct CHANGER_READ_ELEMENT_STATUS {
    pub ElementList: CHANGER_ELEMENT_LIST,
    pub VolumeTagInfo: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl CHANGER_READ_ELEMENT_STATUS {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for CHANGER_READ_ELEMENT_STATUS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for CHANGER_READ_ELEMENT_STATUS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CHANGER_READ_ELEMENT_STATUS")
            .field("ElementList", &self.ElementList)
            .field("VolumeTagInfo", &self.VolumeTagInfo)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for CHANGER_READ_ELEMENT_STATUS {
    fn eq(&self, other: &Self) -> bool {
        self.ElementList == other.ElementList && self.VolumeTagInfo == other.VolumeTagInfo
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for CHANGER_READ_ELEMENT_STATUS {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for CHANGER_READ_ELEMENT_STATUS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const CHANGER_RESERVED_BIT: u32 = 2147483648u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CHANGER_SEND_VOLUME_TAG_INFORMATION {
    pub StartingElement: CHANGER_ELEMENT,
    pub ActionCode: u32,
    pub VolumeIDTemplate: [u8; 40],
}
impl CHANGER_SEND_VOLUME_TAG_INFORMATION {}
impl ::std::default::Default for CHANGER_SEND_VOLUME_TAG_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CHANGER_SEND_VOLUME_TAG_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CHANGER_SEND_VOLUME_TAG_INFORMATION")
            .field("StartingElement", &self.StartingElement)
            .field("ActionCode", &self.ActionCode)
            .field("VolumeIDTemplate", &self.VolumeIDTemplate)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CHANGER_SEND_VOLUME_TAG_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.StartingElement == other.StartingElement
            && self.ActionCode == other.ActionCode
            && self.VolumeIDTemplate == other.VolumeIDTemplate
    }
}
impl ::std::cmp::Eq for CHANGER_SEND_VOLUME_TAG_INFORMATION {}
unsafe impl ::windows::runtime::Abi for CHANGER_SEND_VOLUME_TAG_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CHANGER_SET_ACCESS {
    pub Element: CHANGER_ELEMENT,
    pub Control: u32,
}
impl CHANGER_SET_ACCESS {}
impl ::std::default::Default for CHANGER_SET_ACCESS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CHANGER_SET_ACCESS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CHANGER_SET_ACCESS")
            .field("Element", &self.Element)
            .field("Control", &self.Control)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CHANGER_SET_ACCESS {
    fn eq(&self, other: &Self) -> bool {
        self.Element == other.Element && self.Control == other.Control
    }
}
impl ::std::cmp::Eq for CHANGER_SET_ACCESS {}
unsafe impl ::windows::runtime::Abi for CHANGER_SET_ACCESS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct CHANGER_SET_POSITION {
    pub Transport: CHANGER_ELEMENT,
    pub Destination: CHANGER_ELEMENT,
    pub Flip: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl CHANGER_SET_POSITION {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for CHANGER_SET_POSITION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for CHANGER_SET_POSITION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CHANGER_SET_POSITION")
            .field("Transport", &self.Transport)
            .field("Destination", &self.Destination)
            .field("Flip", &self.Flip)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for CHANGER_SET_POSITION {
    fn eq(&self, other: &Self) -> bool {
        self.Transport == other.Transport
            && self.Destination == other.Destination
            && self.Flip == other.Flip
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for CHANGER_SET_POSITION {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for CHANGER_SET_POSITION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const CHANGER_TO_DRIVE: u32 = 8u32;
pub const CHANGER_TO_IEPORT: u32 = 4u32;
pub const CHANGER_TO_SLOT: u32 = 2u32;
pub const CHANGER_TO_TRANSPORT: u32 = 1u32;
#[derive(
    :: std :: clone :: Clone,
    :: std :: marker :: Copy,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
)]
#[repr(transparent)]
pub struct CHAR(pub u8);
impl ::std::default::Default for CHAR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
unsafe impl ::windows::runtime::Handle for CHAR {}
unsafe impl ::windows::runtime::Abi for CHAR {
    type Abi = Self;
    type DefaultType = Self;
}
pub const CHECKSUM_TYPE_CRC32: u32 = 1u32;
pub const CHECKSUM_TYPE_CRC64: u32 = 2u32;
pub const CHECKSUM_TYPE_ECC: u32 = 3u32;
pub const CHECKSUM_TYPE_FIRST_UNUSED_TYPE: u32 = 4u32;
pub const CHECKSUM_TYPE_NONE: u32 = 0u32;
pub const CHECKSUM_TYPE_UNCHANGED: i32 = -1i32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct CHOOSECOLOR_FLAGS(pub u32);
pub const CC_RGBINIT: CHOOSECOLOR_FLAGS = CHOOSECOLOR_FLAGS(1u32);
pub const CC_FULLOPEN: CHOOSECOLOR_FLAGS = CHOOSECOLOR_FLAGS(2u32);
pub const CC_PREVENTFULLOPEN: CHOOSECOLOR_FLAGS = CHOOSECOLOR_FLAGS(4u32);
pub const CC_SHOWHELP: CHOOSECOLOR_FLAGS = CHOOSECOLOR_FLAGS(8u32);
pub const CC_ENABLEHOOK: CHOOSECOLOR_FLAGS = CHOOSECOLOR_FLAGS(16u32);
pub const CC_ENABLETEMPLATE: CHOOSECOLOR_FLAGS = CHOOSECOLOR_FLAGS(32u32);
pub const CC_ENABLETEMPLATEHANDLE: CHOOSECOLOR_FLAGS = CHOOSECOLOR_FLAGS(64u32);
pub const CC_SOLIDCOLOR: CHOOSECOLOR_FLAGS = CHOOSECOLOR_FLAGS(128u32);
pub const CC_ANYCOLOR: CHOOSECOLOR_FLAGS = CHOOSECOLOR_FLAGS(256u32);
impl ::std::convert::From<u32> for CHOOSECOLOR_FLAGS {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for CHOOSECOLOR_FLAGS {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for CHOOSECOLOR_FLAGS {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for CHOOSECOLOR_FLAGS {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for CHOOSECOLOR_FLAGS {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for CHOOSECOLOR_FLAGS {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for CHOOSECOLOR_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION: u32 = 1u32;
pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1: u32 = 1u32;
pub const CLAIM_SECURITY_ATTRIBUTE_CUSTOM_FLAGS: u32 = 4294901760u32;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INVALID: u32 = 0u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CLASS_MEDIA_CHANGE_CONTEXT {
    pub MediaChangeCount: u32,
    pub NewState: u32,
}
impl CLASS_MEDIA_CHANGE_CONTEXT {}
impl ::std::default::Default for CLASS_MEDIA_CHANGE_CONTEXT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CLASS_MEDIA_CHANGE_CONTEXT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CLASS_MEDIA_CHANGE_CONTEXT")
            .field("MediaChangeCount", &self.MediaChangeCount)
            .field("NewState", &self.NewState)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CLASS_MEDIA_CHANGE_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.MediaChangeCount == other.MediaChangeCount && self.NewState == other.NewState
    }
}
impl ::std::cmp::Eq for CLASS_MEDIA_CHANGE_CONTEXT {}
unsafe impl ::windows::runtime::Abi for CLASS_MEDIA_CHANGE_CONTEXT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct CLIPBOARD_FORMATS(pub u32);
pub const CF_TEXT: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(1u32);
pub const CF_BITMAP: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(2u32);
pub const CF_METAFILEPICT: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(3u32);
pub const CF_SYLK: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(4u32);
pub const CF_DIF: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(5u32);
pub const CF_TIFF: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(6u32);
pub const CF_OEMTEXT: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(7u32);
pub const CF_DIB: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(8u32);
pub const CF_PALETTE: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(9u32);
pub const CF_PENDATA: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(10u32);
pub const CF_RIFF: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(11u32);
pub const CF_WAVE: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(12u32);
pub const CF_UNICODETEXT: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(13u32);
pub const CF_ENHMETAFILE: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(14u32);
pub const CF_HDROP: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(15u32);
pub const CF_LOCALE: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(16u32);
pub const CF_DIBV5: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(17u32);
pub const CF_MAX: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(18u32);
pub const CF_OWNERDISPLAY: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(128u32);
pub const CF_DSPTEXT: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(129u32);
pub const CF_DSPBITMAP: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(130u32);
pub const CF_DSPMETAFILEPICT: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(131u32);
pub const CF_DSPENHMETAFILE: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(142u32);
pub const CF_PRIVATEFIRST: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(512u32);
pub const CF_PRIVATELAST: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(767u32);
pub const CF_GDIOBJFIRST: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(768u32);
pub const CF_GDIOBJLAST: CLIPBOARD_FORMATS = CLIPBOARD_FORMATS(1023u32);
impl ::std::convert::From<u32> for CLIPBOARD_FORMATS {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for CLIPBOARD_FORMATS {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for CLIPBOARD_FORMATS {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for CLIPBOARD_FORMATS {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for CLIPBOARD_FORMATS {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for CLIPBOARD_FORMATS {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for CLIPBOARD_FORMATS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CLIPDATA {
    pub cbSize: u32,
    pub ulClipFmt: i32,
    pub pClipData: *mut u8,
}
impl CLIPDATA {}
impl ::std::default::Default for CLIPDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CLIPDATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CLIPDATA")
            .field("cbSize", &self.cbSize)
            .field("ulClipFmt", &self.ulClipFmt)
            .field("pClipData", &self.pClipData)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CLIPDATA {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.ulClipFmt == other.ulClipFmt
            && self.pClipData == other.pClipData
    }
}
impl ::std::cmp::Eq for CLIPDATA {}
unsafe impl ::windows::runtime::Abi for CLIPDATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CLUSTER_RANGE {
    pub StartingCluster: i64,
    pub ClusterCount: i64,
}
impl CLUSTER_RANGE {}
impl ::std::default::Default for CLUSTER_RANGE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CLUSTER_RANGE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CLUSTER_RANGE")
            .field("StartingCluster", &self.StartingCluster)
            .field("ClusterCount", &self.ClusterCount)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CLUSTER_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.StartingCluster == other.StartingCluster && self.ClusterCount == other.ClusterCount
    }
}
impl ::std::cmp::Eq for CLUSTER_RANGE {}
unsafe impl ::windows::runtime::Abi for CLUSTER_RANGE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct CM_ERROR_CONTROL_TYPE(pub i32);
pub const IgnoreError: CM_ERROR_CONTROL_TYPE = CM_ERROR_CONTROL_TYPE(0i32);
pub const NormalError: CM_ERROR_CONTROL_TYPE = CM_ERROR_CONTROL_TYPE(1i32);
pub const SevereError: CM_ERROR_CONTROL_TYPE = CM_ERROR_CONTROL_TYPE(2i32);
pub const CriticalError: CM_ERROR_CONTROL_TYPE = CM_ERROR_CONTROL_TYPE(3i32);
impl ::std::convert::From<i32> for CM_ERROR_CONTROL_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for CM_ERROR_CONTROL_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Power")]
pub struct CM_Power_Data_s {
    pub PD_Size: u32,
    pub PD_MostRecentPowerState: DEVICE_POWER_STATE,
    pub PD_Capabilities: u32,
    pub PD_D1Latency: u32,
    pub PD_D2Latency: u32,
    pub PD_D3Latency: u32,
    pub PD_PowerStateMapping: [DEVICE_POWER_STATE; 7],
    pub PD_DeepestSystemWake: super::Power::SYSTEM_POWER_STATE,
}
#[cfg(feature = "Win32_System_Power")]
impl CM_Power_Data_s {}
#[cfg(feature = "Win32_System_Power")]
impl ::std::default::Default for CM_Power_Data_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Power")]
impl ::std::fmt::Debug for CM_Power_Data_s {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CM_Power_Data_s")
            .field("PD_Size", &self.PD_Size)
            .field("PD_MostRecentPowerState", &self.PD_MostRecentPowerState)
            .field("PD_Capabilities", &self.PD_Capabilities)
            .field("PD_D1Latency", &self.PD_D1Latency)
            .field("PD_D2Latency", &self.PD_D2Latency)
            .field("PD_D3Latency", &self.PD_D3Latency)
            .field("PD_PowerStateMapping", &self.PD_PowerStateMapping)
            .field("PD_DeepestSystemWake", &self.PD_DeepestSystemWake)
            .finish()
    }
}
#[cfg(feature = "Win32_System_Power")]
impl ::std::cmp::PartialEq for CM_Power_Data_s {
    fn eq(&self, other: &Self) -> bool {
        self.PD_Size == other.PD_Size
            && self.PD_MostRecentPowerState == other.PD_MostRecentPowerState
            && self.PD_Capabilities == other.PD_Capabilities
            && self.PD_D1Latency == other.PD_D1Latency
            && self.PD_D2Latency == other.PD_D2Latency
            && self.PD_D3Latency == other.PD_D3Latency
            && self.PD_PowerStateMapping == other.PD_PowerStateMapping
            && self.PD_DeepestSystemWake == other.PD_DeepestSystemWake
    }
}
#[cfg(feature = "Win32_System_Power")]
impl ::std::cmp::Eq for CM_Power_Data_s {}
#[cfg(feature = "Win32_System_Power")]
unsafe impl ::windows::runtime::Abi for CM_Power_Data_s {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct CM_SERVICE_LOAD_TYPE(pub i32);
pub const BootLoad: CM_SERVICE_LOAD_TYPE = CM_SERVICE_LOAD_TYPE(0i32);
pub const SystemLoad: CM_SERVICE_LOAD_TYPE = CM_SERVICE_LOAD_TYPE(1i32);
pub const AutoLoad: CM_SERVICE_LOAD_TYPE = CM_SERVICE_LOAD_TYPE(2i32);
pub const DemandLoad: CM_SERVICE_LOAD_TYPE = CM_SERVICE_LOAD_TYPE(3i32);
pub const DisableLoad: CM_SERVICE_LOAD_TYPE = CM_SERVICE_LOAD_TYPE(4i32);
impl ::std::convert::From<i32> for CM_SERVICE_LOAD_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for CM_SERVICE_LOAD_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const CM_SERVICE_MEASURED_BOOT_LOAD: u32 = 32u32;
pub const CM_SERVICE_NETWORK_BOOT_LOAD: u32 = 1u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct CM_SERVICE_NODE_TYPE(pub i32);
pub const DriverType: CM_SERVICE_NODE_TYPE = CM_SERVICE_NODE_TYPE(1i32);
pub const FileSystemType: CM_SERVICE_NODE_TYPE = CM_SERVICE_NODE_TYPE(2i32);
pub const Win32ServiceOwnProcess: CM_SERVICE_NODE_TYPE = CM_SERVICE_NODE_TYPE(16i32);
pub const Win32ServiceShareProcess: CM_SERVICE_NODE_TYPE = CM_SERVICE_NODE_TYPE(32i32);
pub const AdapterType: CM_SERVICE_NODE_TYPE = CM_SERVICE_NODE_TYPE(4i32);
pub const RecognizerType: CM_SERVICE_NODE_TYPE = CM_SERVICE_NODE_TYPE(8i32);
impl ::std::convert::From<i32> for CM_SERVICE_NODE_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for CM_SERVICE_NODE_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const CM_SERVICE_RAM_DISK_BOOT_LOAD: u32 = 256u32;
pub const CM_SERVICE_SD_DISK_BOOT_LOAD: u32 = 8u32;
pub const CM_SERVICE_USB3_DISK_BOOT_LOAD: u32 = 16u32;
pub const CM_SERVICE_USB_DISK_BOOT_LOAD: u32 = 4u32;
pub const CM_SERVICE_VERIFIER_BOOT_LOAD: u32 = 64u32;
pub const CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD: u32 = 2u32;
pub const CM_SERVICE_WINPE_BOOT_LOAD: u32 = 128u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct COMPONENT_FILTER {
    pub ComponentFlags: u32,
}
impl COMPONENT_FILTER {}
impl ::std::default::Default for COMPONENT_FILTER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for COMPONENT_FILTER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("COMPONENT_FILTER")
            .field("ComponentFlags", &self.ComponentFlags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for COMPONENT_FILTER {
    fn eq(&self, other: &Self) -> bool {
        self.ComponentFlags == other.ComponentFlags
    }
}
impl ::std::cmp::Eq for COMPONENT_FILTER {}
unsafe impl ::windows::runtime::Abi for COMPONENT_FILTER {
    type Abi = Self;
    type DefaultType = Self;
}
pub const COMPONENT_KTM: u32 = 1u32;
pub const COMPONENT_VALID_FLAGS: u32 = 1u32;
pub const COMPRESSION_ENGINE_HIBER: u32 = 512u32;
pub const COMPRESSION_ENGINE_MAXIMUM: u32 = 256u32;
pub const COMPRESSION_ENGINE_STANDARD: u32 = 0u32;
pub const COMPRESSION_FORMAT_DEFAULT: u32 = 1u32;
pub const COMPRESSION_FORMAT_LZNT1: u32 = 2u32;
pub const COMPRESSION_FORMAT_NONE: u32 = 0u32;
pub const COMPRESSION_FORMAT_XP10: u32 = 5u32;
pub const COMPRESSION_FORMAT_XPRESS: u32 = 3u32;
pub const COMPRESSION_FORMAT_XPRESS_HUFF: u32 = 4u32;
pub const CONTAINER_ROOT_INFO_FLAG_BIND_DO_NOT_MAP_NAME: u32 = 256u32;
pub const CONTAINER_ROOT_INFO_FLAG_BIND_EXCEPTION_ROOT: u32 = 128u32;
pub const CONTAINER_ROOT_INFO_FLAG_BIND_ROOT: u32 = 32u32;
pub const CONTAINER_ROOT_INFO_FLAG_BIND_TARGET_ROOT: u32 = 64u32;
pub const CONTAINER_ROOT_INFO_FLAG_LAYER_ROOT: u32 = 2u32;
pub const CONTAINER_ROOT_INFO_FLAG_SCRATCH_ROOT: u32 = 1u32;
pub const CONTAINER_ROOT_INFO_FLAG_UNION_LAYER_ROOT: u32 = 512u32;
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_EXCEPTION_ROOT: u32 = 16u32;
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_ROOT: u32 = 4u32;
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_TARGET_ROOT: u32 = 8u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CONTAINER_ROOT_INFO_INPUT {
    pub Flags: u32,
}
impl CONTAINER_ROOT_INFO_INPUT {}
impl ::std::default::Default for CONTAINER_ROOT_INFO_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CONTAINER_ROOT_INFO_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CONTAINER_ROOT_INFO_INPUT")
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CONTAINER_ROOT_INFO_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for CONTAINER_ROOT_INFO_INPUT {}
unsafe impl ::windows::runtime::Abi for CONTAINER_ROOT_INFO_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CONTAINER_ROOT_INFO_OUTPUT {
    pub ContainerRootIdLength: u16,
    pub ContainerRootId: [u8; 1],
}
impl CONTAINER_ROOT_INFO_OUTPUT {}
impl ::std::default::Default for CONTAINER_ROOT_INFO_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CONTAINER_ROOT_INFO_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CONTAINER_ROOT_INFO_OUTPUT")
            .field("ContainerRootIdLength", &self.ContainerRootIdLength)
            .field("ContainerRootId", &self.ContainerRootId)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CONTAINER_ROOT_INFO_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.ContainerRootIdLength == other.ContainerRootIdLength
            && self.ContainerRootId == other.ContainerRootId
    }
}
impl ::std::cmp::Eq for CONTAINER_ROOT_INFO_OUTPUT {}
unsafe impl ::windows::runtime::Abi for CONTAINER_ROOT_INFO_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const CONTAINER_ROOT_INFO_VALID_FLAGS: u32 = 1023u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CONTAINER_VOLUME_STATE {
    pub Flags: u32,
}
impl CONTAINER_VOLUME_STATE {}
impl ::std::default::Default for CONTAINER_VOLUME_STATE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CONTAINER_VOLUME_STATE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CONTAINER_VOLUME_STATE")
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CONTAINER_VOLUME_STATE {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for CONTAINER_VOLUME_STATE {}
unsafe impl ::windows::runtime::Abi for CONTAINER_VOLUME_STATE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const CONTAINER_VOLUME_STATE_HOSTING_CONTAINER: u32 = 1u32;
pub const CONTEXT_AMD64: i32 = 1048576i32;
pub const CONTEXT_ARM: i32 = 2097152i32;
pub const CONTEXT_ARM64: i32 = 4194304i32;
pub const CONTEXT_ARM64_RET_TO_GUEST: u32 = 67108864u32;
pub const CONTEXT_ARM64_UNWOUND_TO_CALL: u32 = 536870912u32;
pub const CONTEXT_EXCEPTION_ACTIVE: i32 = 134217728i32;
pub const CONTEXT_EXCEPTION_REPORTING: i32 = -2147483648i32;
pub const CONTEXT_EXCEPTION_REQUEST: i32 = 1073741824i32;
pub const CONTEXT_KERNEL_DEBUGGER: i32 = 67108864i32;
pub const CONTEXT_RET_TO_GUEST: u32 = 67108864u32;
pub const CONTEXT_SERVICE_ACTIVE: i32 = 268435456i32;
pub const CONTEXT_UNWOUND_TO_CALL: u32 = 536870912u32;
pub const CONTEXT_i386: i32 = 65536i32;
pub const CONTEXT_i486: i32 = 65536i32;
pub const COPYFILE_SIS_FLAGS: u32 = 3u32;
pub const COPYFILE_SIS_LINK: u32 = 1u32;
pub const COPYFILE_SIS_REPLACE: u32 = 2u32;
pub const CORE_PARKING_POLICY_CHANGE_IDEAL: u32 = 0u32;
pub const CORE_PARKING_POLICY_CHANGE_MAX: u32 = 3u32;
pub const CORE_PARKING_POLICY_CHANGE_MULTISTEP: u32 = 3u32;
pub const CORE_PARKING_POLICY_CHANGE_ROCKET: u32 = 2u32;
pub const CORE_PARKING_POLICY_CHANGE_SINGLE: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CORRELATION_VECTOR {
    pub Version: CHAR,
    pub Vector: [CHAR; 129],
}
impl CORRELATION_VECTOR {}
impl ::std::default::Default for CORRELATION_VECTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CORRELATION_VECTOR {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CORRELATION_VECTOR")
            .field("Version", &self.Version)
            .field("Vector", &self.Vector)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CORRELATION_VECTOR {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Vector == other.Vector
    }
}
impl ::std::cmp::Eq for CORRELATION_VECTOR {}
unsafe impl ::windows::runtime::Abi for CORRELATION_VECTOR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct CPU_SET_INFORMATION_TYPE(pub i32);
pub const CpuSetInformation: CPU_SET_INFORMATION_TYPE = CPU_SET_INFORMATION_TYPE(0i32);
impl ::std::convert::From<i32> for CPU_SET_INFORMATION_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for CPU_SET_INFORMATION_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const CREATE_BOUNDARY_DESCRIPTOR_ADD_APPCONTAINER_SID: u32 = 1u32;
pub const CRITICAL_ACE_FLAG: u32 = 32u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct CSVFS_DISK_CONNECTIVITY(pub i32);
pub const CsvFsDiskConnectivityNone: CSVFS_DISK_CONNECTIVITY = CSVFS_DISK_CONNECTIVITY(0i32);
pub const CsvFsDiskConnectivityMdsNodeOnly: CSVFS_DISK_CONNECTIVITY = CSVFS_DISK_CONNECTIVITY(1i32);
pub const CsvFsDiskConnectivitySubsetOfNodes: CSVFS_DISK_CONNECTIVITY =
    CSVFS_DISK_CONNECTIVITY(2i32);
pub const CsvFsDiskConnectivityAllNodes: CSVFS_DISK_CONNECTIVITY = CSVFS_DISK_CONNECTIVITY(3i32);
impl ::std::convert::From<i32> for CSVFS_DISK_CONNECTIVITY {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for CSVFS_DISK_CONNECTIVITY {
    type Abi = Self;
    type DefaultType = Self;
}
pub const CSV_INVALID_DEVICE_NUMBER: u32 = 4294967295u32;
pub const CSV_MGMTLOCK_CHECK_VOLUME_REDIRECTED: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CSV_MGMT_LOCK {
    pub Flags: u32,
}
impl CSV_MGMT_LOCK {}
impl ::std::default::Default for CSV_MGMT_LOCK {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CSV_MGMT_LOCK {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CSV_MGMT_LOCK")
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CSV_MGMT_LOCK {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for CSV_MGMT_LOCK {}
unsafe impl ::windows::runtime::Abi for CSV_MGMT_LOCK {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Storage_FileSystem")]
pub struct CSV_QUERY_FILE_REVISION_FILE_ID_128 {
    pub FileId: super::super::Storage::FileSystem::FILE_ID_128,
    pub FileRevision: [i64; 3],
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl CSV_QUERY_FILE_REVISION_FILE_ID_128 {}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::default::Default for CSV_QUERY_FILE_REVISION_FILE_ID_128 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::fmt::Debug for CSV_QUERY_FILE_REVISION_FILE_ID_128 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CSV_QUERY_FILE_REVISION_FILE_ID_128")
            .field("FileId", &self.FileId)
            .field("FileRevision", &self.FileRevision)
            .finish()
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::PartialEq for CSV_QUERY_FILE_REVISION_FILE_ID_128 {
    fn eq(&self, other: &Self) -> bool {
        self.FileId == other.FileId && self.FileRevision == other.FileRevision
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::Eq for CSV_QUERY_FILE_REVISION_FILE_ID_128 {}
#[cfg(feature = "Win32_Storage_FileSystem")]
unsafe impl ::windows::runtime::Abi for CSV_QUERY_FILE_REVISION_FILE_ID_128 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const CSV_QUERY_MDS_PATH_FLAG_CSV_DIRECT_IO_ENABLED: u32 = 2u32;
pub const CSV_QUERY_MDS_PATH_FLAG_SMB_BYPASS_CSV_ENABLED: u32 = 4u32;
pub const CSV_QUERY_MDS_PATH_FLAG_STORAGE_ON_THIS_NODE_IS_CONNECTED: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CSV_QUERY_MDS_PATH_V2 {
    pub Version: i64,
    pub RequiredSize: u32,
    pub MdsNodeId: u32,
    pub DsNodeId: u32,
    pub Flags: u32,
    pub DiskConnectivity: CSVFS_DISK_CONNECTIVITY,
    pub VolumeId: ::windows::runtime::GUID,
    pub IpAddressOffset: u32,
    pub IpAddressLength: u32,
    pub PathOffset: u32,
    pub PathLength: u32,
}
impl CSV_QUERY_MDS_PATH_V2 {}
impl ::std::default::Default for CSV_QUERY_MDS_PATH_V2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CSV_QUERY_MDS_PATH_V2 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CSV_QUERY_MDS_PATH_V2")
            .field("Version", &self.Version)
            .field("RequiredSize", &self.RequiredSize)
            .field("MdsNodeId", &self.MdsNodeId)
            .field("DsNodeId", &self.DsNodeId)
            .field("Flags", &self.Flags)
            .field("DiskConnectivity", &self.DiskConnectivity)
            .field("VolumeId", &self.VolumeId)
            .field("IpAddressOffset", &self.IpAddressOffset)
            .field("IpAddressLength", &self.IpAddressLength)
            .field("PathOffset", &self.PathOffset)
            .field("PathLength", &self.PathLength)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CSV_QUERY_MDS_PATH_V2 {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.RequiredSize == other.RequiredSize
            && self.MdsNodeId == other.MdsNodeId
            && self.DsNodeId == other.DsNodeId
            && self.Flags == other.Flags
            && self.DiskConnectivity == other.DiskConnectivity
            && self.VolumeId == other.VolumeId
            && self.IpAddressOffset == other.IpAddressOffset
            && self.IpAddressLength == other.IpAddressLength
            && self.PathOffset == other.PathOffset
            && self.PathLength == other.PathLength
    }
}
impl ::std::cmp::Eq for CSV_QUERY_MDS_PATH_V2 {}
unsafe impl ::windows::runtime::Abi for CSV_QUERY_MDS_PATH_V2 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const CSV_QUERY_MDS_PATH_V2_VERSION_1: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CSV_QUERY_VOLUME_ID {
    pub VolumeId: ::windows::runtime::GUID,
}
impl CSV_QUERY_VOLUME_ID {}
impl ::std::default::Default for CSV_QUERY_VOLUME_ID {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CSV_QUERY_VOLUME_ID {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CSV_QUERY_VOLUME_ID")
            .field("VolumeId", &self.VolumeId)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CSV_QUERY_VOLUME_ID {
    fn eq(&self, other: &Self) -> bool {
        self.VolumeId == other.VolumeId
    }
}
impl ::std::cmp::Eq for CSV_QUERY_VOLUME_ID {}
unsafe impl ::windows::runtime::Abi for CSV_QUERY_VOLUME_ID {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct CSV_QUERY_VOLUME_REDIRECT_STATE {
    pub MdsNodeId: u32,
    pub DsNodeId: u32,
    pub IsDiskConnected: super::super::Foundation::BOOLEAN,
    pub ClusterEnableDirectIo: super::super::Foundation::BOOLEAN,
    pub DiskConnectivity: CSVFS_DISK_CONNECTIVITY,
}
#[cfg(feature = "Win32_Foundation")]
impl CSV_QUERY_VOLUME_REDIRECT_STATE {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for CSV_QUERY_VOLUME_REDIRECT_STATE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for CSV_QUERY_VOLUME_REDIRECT_STATE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CSV_QUERY_VOLUME_REDIRECT_STATE")
            .field("MdsNodeId", &self.MdsNodeId)
            .field("DsNodeId", &self.DsNodeId)
            .field("IsDiskConnected", &self.IsDiskConnected)
            .field("ClusterEnableDirectIo", &self.ClusterEnableDirectIo)
            .field("DiskConnectivity", &self.DiskConnectivity)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for CSV_QUERY_VOLUME_REDIRECT_STATE {
    fn eq(&self, other: &Self) -> bool {
        self.MdsNodeId == other.MdsNodeId
            && self.DsNodeId == other.DsNodeId
            && self.IsDiskConnected == other.IsDiskConnected
            && self.ClusterEnableDirectIo == other.ClusterEnableDirectIo
            && self.DiskConnectivity == other.DiskConnectivity
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for CSV_QUERY_VOLUME_REDIRECT_STATE {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for CSV_QUERY_VOLUME_REDIRECT_STATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CSV_SET_VOLUME_ID {
    pub VolumeId: ::windows::runtime::GUID,
}
impl CSV_SET_VOLUME_ID {}
impl ::std::default::Default for CSV_SET_VOLUME_ID {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CSV_SET_VOLUME_ID {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CSV_SET_VOLUME_ID")
            .field("VolumeId", &self.VolumeId)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CSV_SET_VOLUME_ID {
    fn eq(&self, other: &Self) -> bool {
        self.VolumeId == other.VolumeId
    }
}
impl ::std::cmp::Eq for CSV_SET_VOLUME_ID {}
unsafe impl ::windows::runtime::Abi for CSV_SET_VOLUME_ID {
    type Abi = Self;
    type DefaultType = Self;
}
pub const CTMF_INCLUDE_APPCONTAINER: u32 = 1u32;
pub const CTMF_INCLUDE_LPAC: u32 = 2u32;
pub const CT_RECTANGLES: i32 = 0i32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG {
    pub Size: u32,
    pub TriggerId: super::super::Foundation::PWSTR,
}
#[cfg(feature = "Win32_Foundation")]
impl CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG")
            .field("Size", &self.Size)
            .field("TriggerId", &self.TriggerId)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.TriggerId == other.TriggerId
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union CY {
    pub Anonymous: CY_0,
    pub int64: i64,
}
impl CY {}
impl ::std::default::Default for CY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for CY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for CY {}
unsafe impl ::windows::runtime::Abi for CY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct CY_0 {
    pub Lo: u32,
    pub Hi: i32,
}
impl CY_0 {}
impl ::std::default::Default for CY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for CY_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("Lo", &self.Lo)
            .field("Hi", &self.Hi)
            .finish()
    }
}
impl ::std::cmp::PartialEq for CY_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Lo == other.Lo && self.Hi == other.Hi
    }
}
impl ::std::cmp::Eq for CY_0 {}
unsafe impl ::windows::runtime::Abi for CY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct D3DANTIALIASMODE(pub i32);
pub const D3DANTIALIAS_NONE: D3DANTIALIASMODE = D3DANTIALIASMODE(0i32);
pub const D3DANTIALIAS_SORTDEPENDENT: D3DANTIALIASMODE = D3DANTIALIASMODE(1i32);
pub const D3DANTIALIAS_SORTINDEPENDENT: D3DANTIALIASMODE = D3DANTIALIASMODE(2i32);
pub const D3DANTIALIAS_FORCE_DWORD: D3DANTIALIASMODE = D3DANTIALIASMODE(2147483647i32);
impl ::std::convert::From<i32> for D3DANTIALIASMODE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for D3DANTIALIASMODE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct D3DBRANCH {
    pub dwMask: u32,
    pub dwValue: u32,
    pub bNegate: super::super::Foundation::BOOL,
    pub dwOffset: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl D3DBRANCH {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for D3DBRANCH {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for D3DBRANCH {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DBRANCH")
            .field("dwMask", &self.dwMask)
            .field("dwValue", &self.dwValue)
            .field("bNegate", &self.bNegate)
            .field("dwOffset", &self.dwOffset)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for D3DBRANCH {
    fn eq(&self, other: &Self) -> bool {
        self.dwMask == other.dwMask
            && self.dwValue == other.dwValue
            && self.bNegate == other.bNegate
            && self.dwOffset == other.dwOffset
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for D3DBRANCH {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for D3DBRANCH {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DCLEAR_STENCIL: i32 = 4i32;
pub const D3DCLEAR_TARGET: i32 = 1i32;
pub const D3DCLEAR_ZBUFFER: i32 = 2i32;
pub const D3DCLIPPLANE0: u32 = 1u32;
pub const D3DCLIPPLANE1: u32 = 2u32;
pub const D3DCLIPPLANE2: u32 = 4u32;
pub const D3DCLIPPLANE3: u32 = 8u32;
pub const D3DCLIPPLANE4: u32 = 16u32;
pub const D3DCLIPPLANE5: u32 = 32u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DCLIPSTATUS {
    pub dwFlags: u32,
    pub dwStatus: u32,
    pub minx: f32,
    pub maxx: f32,
    pub miny: f32,
    pub maxy: f32,
    pub minz: f32,
    pub maxz: f32,
}
impl D3DCLIPSTATUS {}
impl ::std::default::Default for D3DCLIPSTATUS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DCLIPSTATUS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DCLIPSTATUS")
            .field("dwFlags", &self.dwFlags)
            .field("dwStatus", &self.dwStatus)
            .field("minx", &self.minx)
            .field("maxx", &self.maxx)
            .field("miny", &self.miny)
            .field("maxy", &self.maxy)
            .field("minz", &self.minz)
            .field("maxz", &self.maxz)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DCLIPSTATUS {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags
            && self.dwStatus == other.dwStatus
            && self.minx == other.minx
            && self.maxx == other.maxx
            && self.miny == other.miny
            && self.maxy == other.maxy
            && self.minz == other.minz
            && self.maxz == other.maxz
    }
}
impl ::std::cmp::Eq for D3DCLIPSTATUS {}
unsafe impl ::windows::runtime::Abi for D3DCLIPSTATUS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DCLIPSTATUS_EXTENTS2: i32 = 2i32;
pub const D3DCLIPSTATUS_EXTENTS3: i32 = 4i32;
pub const D3DCLIPSTATUS_STATUS: i32 = 1i32;
pub const D3DCLIP_BACK: i32 = 32i32;
pub const D3DCLIP_BOTTOM: i32 = 8i32;
pub const D3DCLIP_FRONT: i32 = 16i32;
pub const D3DCLIP_GEN0: i32 = 64i32;
pub const D3DCLIP_GEN1: i32 = 128i32;
pub const D3DCLIP_GEN2: i32 = 256i32;
pub const D3DCLIP_GEN3: i32 = 512i32;
pub const D3DCLIP_GEN4: i32 = 1024i32;
pub const D3DCLIP_GEN5: i32 = 2048i32;
pub const D3DCLIP_LEFT: i32 = 1i32;
pub const D3DCLIP_RIGHT: i32 = 2i32;
pub const D3DCLIP_TOP: i32 = 4i32;
pub const D3DCOLOR_MONO: u32 = 1u32;
pub const D3DCOLOR_RGB: u32 = 2u32;
pub const D3DDD_BCLIPPING: i32 = 16i32;
pub const D3DDD_COLORMODEL: i32 = 1i32;
pub const D3DDD_DEVCAPS: i32 = 2i32;
pub const D3DDD_DEVICERENDERBITDEPTH: i32 = 128i32;
pub const D3DDD_DEVICEZBUFFERBITDEPTH: i32 = 256i32;
pub const D3DDD_LIGHTINGCAPS: i32 = 8i32;
pub const D3DDD_LINECAPS: i32 = 32i32;
pub const D3DDD_MAXBUFFERSIZE: i32 = 512i32;
pub const D3DDD_MAXVERTEXCOUNT: i32 = 1024i32;
pub const D3DDD_TRANSFORMCAPS: i32 = 4i32;
pub const D3DDD_TRICAPS: i32 = 64i32;
pub const D3DDEBCAPS_SYSTEMMEMORY: i32 = 1i32;
pub const D3DDEBCAPS_VIDEOMEMORY: i32 = 2i32;
pub const D3DDEB_BUFSIZE: i32 = 1i32;
pub const D3DDEB_CAPS: i32 = 2i32;
pub const D3DDEB_LPDATA: i32 = 4i32;
pub const D3DDEVCAPS_CANBLTSYSTONONLOCAL: i32 = 131072i32;
pub const D3DDEVCAPS_CANRENDERAFTERFLIP: i32 = 2048i32;
pub const D3DDEVCAPS_DRAWPRIMITIVES2: i32 = 8192i32;
pub const D3DDEVCAPS_DRAWPRIMITIVES2EX: i32 = 32768i32;
pub const D3DDEVCAPS_DRAWPRIMTLVERTEX: i32 = 1024i32;
pub const D3DDEVCAPS_EXECUTESYSTEMMEMORY: i32 = 16i32;
pub const D3DDEVCAPS_EXECUTEVIDEOMEMORY: i32 = 32i32;
pub const D3DDEVCAPS_FLOATTLVERTEX: i32 = 1i32;
pub const D3DDEVCAPS_HWRASTERIZATION: i32 = 524288i32;
pub const D3DDEVCAPS_HWTRANSFORMANDLIGHT: i32 = 65536i32;
pub const D3DDEVCAPS_SEPARATETEXTUREMEMORIES: i32 = 16384i32;
pub const D3DDEVCAPS_SORTDECREASINGZ: i32 = 4i32;
pub const D3DDEVCAPS_SORTEXACT: i32 = 8i32;
pub const D3DDEVCAPS_SORTINCREASINGZ: i32 = 2i32;
pub const D3DDEVCAPS_TEXTURENONLOCALVIDMEM: i32 = 4096i32;
pub const D3DDEVCAPS_TEXTURESYSTEMMEMORY: i32 = 256i32;
pub const D3DDEVCAPS_TEXTUREVIDEOMEMORY: i32 = 512i32;
pub const D3DDEVCAPS_TLVERTEXSYSTEMMEMORY: i32 = 64i32;
pub const D3DDEVCAPS_TLVERTEXVIDEOMEMORY: i32 = 128i32;
pub const D3DDEVINFOID_D3DTEXTUREMANAGER: u32 = 2u32;
pub const D3DDEVINFOID_TEXTUREMANAGER: u32 = 1u32;
pub const D3DDEVINFOID_TEXTURING: u32 = 3u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct D3DDEVINFO_TEXTUREMANAGER {
    pub bThrashing: super::super::Foundation::BOOL,
    pub dwApproxBytesDownloaded: u32,
    pub dwNumEvicts: u32,
    pub dwNumVidCreates: u32,
    pub dwNumTexturesUsed: u32,
    pub dwNumUsedTexInVid: u32,
    pub dwWorkingSet: u32,
    pub dwWorkingSetBytes: u32,
    pub dwTotalManaged: u32,
    pub dwTotalBytes: u32,
    pub dwLastPri: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl D3DDEVINFO_TEXTUREMANAGER {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for D3DDEVINFO_TEXTUREMANAGER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for D3DDEVINFO_TEXTUREMANAGER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DDEVINFO_TEXTUREMANAGER")
            .field("bThrashing", &self.bThrashing)
            .field("dwApproxBytesDownloaded", &self.dwApproxBytesDownloaded)
            .field("dwNumEvicts", &self.dwNumEvicts)
            .field("dwNumVidCreates", &self.dwNumVidCreates)
            .field("dwNumTexturesUsed", &self.dwNumTexturesUsed)
            .field("dwNumUsedTexInVid", &self.dwNumUsedTexInVid)
            .field("dwWorkingSet", &self.dwWorkingSet)
            .field("dwWorkingSetBytes", &self.dwWorkingSetBytes)
            .field("dwTotalManaged", &self.dwTotalManaged)
            .field("dwTotalBytes", &self.dwTotalBytes)
            .field("dwLastPri", &self.dwLastPri)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for D3DDEVINFO_TEXTUREMANAGER {
    fn eq(&self, other: &Self) -> bool {
        self.bThrashing == other.bThrashing
            && self.dwApproxBytesDownloaded == other.dwApproxBytesDownloaded
            && self.dwNumEvicts == other.dwNumEvicts
            && self.dwNumVidCreates == other.dwNumVidCreates
            && self.dwNumTexturesUsed == other.dwNumTexturesUsed
            && self.dwNumUsedTexInVid == other.dwNumUsedTexInVid
            && self.dwWorkingSet == other.dwWorkingSet
            && self.dwWorkingSetBytes == other.dwWorkingSetBytes
            && self.dwTotalManaged == other.dwTotalManaged
            && self.dwTotalBytes == other.dwTotalBytes
            && self.dwLastPri == other.dwLastPri
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for D3DDEVINFO_TEXTUREMANAGER {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for D3DDEVINFO_TEXTUREMANAGER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DDEVINFO_TEXTURING {
    pub dwNumLoads: u32,
    pub dwApproxBytesLoaded: u32,
    pub dwNumPreLoads: u32,
    pub dwNumSet: u32,
    pub dwNumCreates: u32,
    pub dwNumDestroys: u32,
    pub dwNumSetPriorities: u32,
    pub dwNumSetLODs: u32,
    pub dwNumLocks: u32,
    pub dwNumGetDCs: u32,
}
impl D3DDEVINFO_TEXTURING {}
impl ::std::default::Default for D3DDEVINFO_TEXTURING {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DDEVINFO_TEXTURING {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DDEVINFO_TEXTURING")
            .field("dwNumLoads", &self.dwNumLoads)
            .field("dwApproxBytesLoaded", &self.dwApproxBytesLoaded)
            .field("dwNumPreLoads", &self.dwNumPreLoads)
            .field("dwNumSet", &self.dwNumSet)
            .field("dwNumCreates", &self.dwNumCreates)
            .field("dwNumDestroys", &self.dwNumDestroys)
            .field("dwNumSetPriorities", &self.dwNumSetPriorities)
            .field("dwNumSetLODs", &self.dwNumSetLODs)
            .field("dwNumLocks", &self.dwNumLocks)
            .field("dwNumGetDCs", &self.dwNumGetDCs)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DDEVINFO_TEXTURING {
    fn eq(&self, other: &Self) -> bool {
        self.dwNumLoads == other.dwNumLoads
            && self.dwApproxBytesLoaded == other.dwApproxBytesLoaded
            && self.dwNumPreLoads == other.dwNumPreLoads
            && self.dwNumSet == other.dwNumSet
            && self.dwNumCreates == other.dwNumCreates
            && self.dwNumDestroys == other.dwNumDestroys
            && self.dwNumSetPriorities == other.dwNumSetPriorities
            && self.dwNumSetLODs == other.dwNumSetLODs
            && self.dwNumLocks == other.dwNumLocks
            && self.dwNumGetDCs == other.dwNumGetDCs
    }
}
impl ::std::cmp::Eq for D3DDEVINFO_TEXTURING {}
unsafe impl ::windows::runtime::Abi for D3DDEVINFO_TEXTURING {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DDP_MAXTEXCOORD: u32 = 8u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DDP_PTRSTRIDE {
    pub lpvData: *mut ::std::ffi::c_void,
    pub dwStride: u32,
}
impl D3DDP_PTRSTRIDE {}
impl ::std::default::Default for D3DDP_PTRSTRIDE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DDP_PTRSTRIDE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DDP_PTRSTRIDE")
            .field("lpvData", &self.lpvData)
            .field("dwStride", &self.dwStride)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DDP_PTRSTRIDE {
    fn eq(&self, other: &Self) -> bool {
        self.lpvData == other.lpvData && self.dwStride == other.dwStride
    }
}
impl ::std::cmp::Eq for D3DDP_PTRSTRIDE {}
unsafe impl ::windows::runtime::Abi for D3DDP_PTRSTRIDE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DDRAWPRIMITIVESTRIDEDDATA {
    pub position: D3DDP_PTRSTRIDE,
    pub normal: D3DDP_PTRSTRIDE,
    pub diffuse: D3DDP_PTRSTRIDE,
    pub specular: D3DDP_PTRSTRIDE,
    pub textureCoords: [D3DDP_PTRSTRIDE; 8],
}
impl D3DDRAWPRIMITIVESTRIDEDDATA {}
impl ::std::default::Default for D3DDRAWPRIMITIVESTRIDEDDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DDRAWPRIMITIVESTRIDEDDATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DDRAWPRIMITIVESTRIDEDDATA")
            .field("position", &self.position)
            .field("normal", &self.normal)
            .field("diffuse", &self.diffuse)
            .field("specular", &self.specular)
            .field("textureCoords", &self.textureCoords)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DDRAWPRIMITIVESTRIDEDDATA {
    fn eq(&self, other: &Self) -> bool {
        self.position == other.position
            && self.normal == other.normal
            && self.diffuse == other.diffuse
            && self.specular == other.specular
            && self.textureCoords == other.textureCoords
    }
}
impl ::std::cmp::Eq for D3DDRAWPRIMITIVESTRIDEDDATA {}
unsafe impl ::windows::runtime::Abi for D3DDRAWPRIMITIVESTRIDEDDATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct D3DEXECUTEDATA {
    pub dwSize: u32,
    pub dwVertexOffset: u32,
    pub dwVertexCount: u32,
    pub dwInstructionOffset: u32,
    pub dwInstructionLength: u32,
    pub dwHVertexOffset: u32,
    pub dsStatus: D3DSTATUS,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DEXECUTEDATA {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DEXECUTEDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::fmt::Debug for D3DEXECUTEDATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DEXECUTEDATA")
            .field("dwSize", &self.dwSize)
            .field("dwVertexOffset", &self.dwVertexOffset)
            .field("dwVertexCount", &self.dwVertexCount)
            .field("dwInstructionOffset", &self.dwInstructionOffset)
            .field("dwInstructionLength", &self.dwInstructionLength)
            .field("dwHVertexOffset", &self.dwHVertexOffset)
            .field("dsStatus", &self.dsStatus)
            .finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DEXECUTEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwVertexOffset == other.dwVertexOffset
            && self.dwVertexCount == other.dwVertexCount
            && self.dwInstructionOffset == other.dwInstructionOffset
            && self.dwInstructionLength == other.dwInstructionLength
            && self.dwHVertexOffset == other.dwHVertexOffset
            && self.dsStatus == other.dsStatus
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DEXECUTEDATA {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DEXECUTEDATA {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DEXECUTE_CLIPPED: i32 = 1i32;
pub const D3DEXECUTE_UNCLIPPED: i32 = 2i32;
pub const D3DFDS_ALPHACMPCAPS: i32 = 256i32;
pub const D3DFDS_COLORMODEL: i32 = 1i32;
pub const D3DFDS_DSTBLENDCAPS: i32 = 1024i32;
pub const D3DFDS_GUID: i32 = 2i32;
pub const D3DFDS_HARDWARE: i32 = 4i32;
pub const D3DFDS_LINES: i32 = 16i32;
pub const D3DFDS_MISCCAPS: i32 = 32i32;
pub const D3DFDS_RASTERCAPS: i32 = 64i32;
pub const D3DFDS_SHADECAPS: i32 = 2048i32;
pub const D3DFDS_SRCBLENDCAPS: i32 = 512i32;
pub const D3DFDS_TEXTUREADDRESSCAPS: i32 = 32768i32;
pub const D3DFDS_TEXTUREBLENDCAPS: i32 = 16384i32;
pub const D3DFDS_TEXTURECAPS: i32 = 4096i32;
pub const D3DFDS_TEXTUREFILTERCAPS: i32 = 8192i32;
pub const D3DFDS_TRIANGLES: i32 = 8i32;
pub const D3DFDS_ZCMPCAPS: i32 = 128i32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct D3DFINDDEVICERESULT {
    pub dwSize: u32,
    pub guid: ::windows::runtime::GUID,
    pub ddHwDesc: _D3DDeviceDesc,
    pub ddSwDesc: _D3DDeviceDesc,
}
#[cfg(feature = "Win32_Foundation")]
impl D3DFINDDEVICERESULT {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for D3DFINDDEVICERESULT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for D3DFINDDEVICERESULT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DFINDDEVICERESULT")
            .field("dwSize", &self.dwSize)
            .field("guid", &self.guid)
            .field("ddHwDesc", &self.ddHwDesc)
            .field("ddSwDesc", &self.ddSwDesc)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for D3DFINDDEVICERESULT {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.guid == other.guid
            && self.ddHwDesc == other.ddHwDesc
            && self.ddSwDesc == other.ddSwDesc
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for D3DFINDDEVICERESULT {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for D3DFINDDEVICERESULT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct D3DFINDDEVICESEARCH {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub bHardware: super::super::Foundation::BOOL,
    pub dcmColorModel: u32,
    pub guid: ::windows::runtime::GUID,
    pub dwCaps: u32,
    pub dpcPrimCaps: _D3DPrimCaps,
}
#[cfg(feature = "Win32_Foundation")]
impl D3DFINDDEVICESEARCH {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for D3DFINDDEVICESEARCH {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for D3DFINDDEVICESEARCH {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DFINDDEVICESEARCH")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("bHardware", &self.bHardware)
            .field("dcmColorModel", &self.dcmColorModel)
            .field("guid", &self.guid)
            .field("dwCaps", &self.dwCaps)
            .field("dpcPrimCaps", &self.dpcPrimCaps)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for D3DFINDDEVICESEARCH {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.bHardware == other.bHardware
            && self.dcmColorModel == other.dcmColorModel
            && self.guid == other.guid
            && self.dwCaps == other.dwCaps
            && self.dpcPrimCaps == other.dpcPrimCaps
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for D3DFINDDEVICESEARCH {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for D3DFINDDEVICESEARCH {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DFVFCAPS_DONOTSTRIPELEMENTS: i32 = 524288i32;
pub const D3DFVFCAPS_TEXCOORDCOUNTMASK: i32 = 65535i32;
pub const D3DFVF_DIFFUSE: u32 = 64u32;
pub const D3DFVF_NORMAL: u32 = 16u32;
pub const D3DFVF_POSITION_MASK: u32 = 14u32;
pub const D3DFVF_RESERVED0: u32 = 1u32;
pub const D3DFVF_RESERVED1: u32 = 32u32;
pub const D3DFVF_RESERVED2: u32 = 61440u32;
pub const D3DFVF_SPECULAR: u32 = 128u32;
pub const D3DFVF_TEX0: u32 = 0u32;
pub const D3DFVF_TEX1: u32 = 256u32;
pub const D3DFVF_TEX2: u32 = 512u32;
pub const D3DFVF_TEX3: u32 = 768u32;
pub const D3DFVF_TEX4: u32 = 1024u32;
pub const D3DFVF_TEX5: u32 = 1280u32;
pub const D3DFVF_TEX6: u32 = 1536u32;
pub const D3DFVF_TEX7: u32 = 1792u32;
pub const D3DFVF_TEX8: u32 = 2048u32;
pub const D3DFVF_TEXCOUNT_MASK: u32 = 3840u32;
pub const D3DFVF_TEXCOUNT_SHIFT: u32 = 8u32;
pub const D3DFVF_TEXTUREFORMAT1: u32 = 3u32;
pub const D3DFVF_TEXTUREFORMAT2: u32 = 0u32;
pub const D3DFVF_TEXTUREFORMAT3: u32 = 1u32;
pub const D3DFVF_TEXTUREFORMAT4: u32 = 2u32;
pub const D3DFVF_XYZ: u32 = 2u32;
pub const D3DFVF_XYZB1: u32 = 6u32;
pub const D3DFVF_XYZB2: u32 = 8u32;
pub const D3DFVF_XYZB3: u32 = 10u32;
pub const D3DFVF_XYZB4: u32 = 12u32;
pub const D3DFVF_XYZB5: u32 = 14u32;
pub const D3DFVF_XYZRHW: u32 = 4u32;
pub const D3DHAL_SAMPLER_MAXSAMP: u32 = 16u32;
pub const D3DHAL_SAMPLER_MAXVERTEXSAMP: u32 = 4u32;
pub const D3DHAL_STATESETBEGIN: u32 = 0u32;
pub const D3DHAL_STATESETCAPTURE: u32 = 4u32;
pub const D3DHAL_STATESETDELETE: u32 = 2u32;
pub const D3DHAL_STATESETEND: u32 = 1u32;
pub const D3DHAL_STATESETEXECUTE: u32 = 3u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DHVERTEX {
    pub dwFlags: u32,
    pub Anonymous1: D3DHVERTEX_0,
    pub Anonymous2: D3DHVERTEX_1,
    pub Anonymous3: D3DHVERTEX_2,
}
impl D3DHVERTEX {}
impl ::std::default::Default for D3DHVERTEX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DHVERTEX {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DHVERTEX {}
unsafe impl ::windows::runtime::Abi for D3DHVERTEX {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DHVERTEX_0 {
    pub hx: f32,
    pub dvHX: f32,
}
impl D3DHVERTEX_0 {}
impl ::std::default::Default for D3DHVERTEX_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DHVERTEX_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DHVERTEX_0 {}
unsafe impl ::windows::runtime::Abi for D3DHVERTEX_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DHVERTEX_1 {
    pub hy: f32,
    pub dvHY: f32,
}
impl D3DHVERTEX_1 {}
impl ::std::default::Default for D3DHVERTEX_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DHVERTEX_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DHVERTEX_1 {}
unsafe impl ::windows::runtime::Abi for D3DHVERTEX_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DHVERTEX_2 {
    pub hz: f32,
    pub dvHZ: f32,
}
impl D3DHVERTEX_2 {}
impl ::std::default::Default for D3DHVERTEX_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DHVERTEX_2 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DHVERTEX_2 {}
unsafe impl ::windows::runtime::Abi for D3DHVERTEX_2 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DINFINITEINSTRUCTIONS: u32 = 4294967295u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DINSTRUCTION {
    pub bOpcode: u8,
    pub bSize: u8,
    pub wCount: u16,
}
impl D3DINSTRUCTION {}
impl ::std::default::Default for D3DINSTRUCTION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DINSTRUCTION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DINSTRUCTION")
            .field("bOpcode", &self.bOpcode)
            .field("bSize", &self.bSize)
            .field("wCount", &self.wCount)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DINSTRUCTION {
    fn eq(&self, other: &Self) -> bool {
        self.bOpcode == other.bOpcode && self.bSize == other.bSize && self.wCount == other.wCount
    }
}
impl ::std::cmp::Eq for D3DINSTRUCTION {}
unsafe impl ::windows::runtime::Abi for D3DINSTRUCTION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct D3DLIGHT {
    pub dwSize: u32,
    pub dltType: super::super::Graphics::Direct3D9::D3DLIGHTTYPE,
    pub dcvColor: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
    pub dvPosition: super::super::Graphics::Direct3D9::D3DVECTOR,
    pub dvDirection: super::super::Graphics::Direct3D9::D3DVECTOR,
    pub dvRange: f32,
    pub dvFalloff: f32,
    pub dvAttenuation0: f32,
    pub dvAttenuation1: f32,
    pub dvAttenuation2: f32,
    pub dvTheta: f32,
    pub dvPhi: f32,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DLIGHT {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DLIGHT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::fmt::Debug for D3DLIGHT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DLIGHT")
            .field("dwSize", &self.dwSize)
            .field("dltType", &self.dltType)
            .field("dcvColor", &self.dcvColor)
            .field("dvPosition", &self.dvPosition)
            .field("dvDirection", &self.dvDirection)
            .field("dvRange", &self.dvRange)
            .field("dvFalloff", &self.dvFalloff)
            .field("dvAttenuation0", &self.dvAttenuation0)
            .field("dvAttenuation1", &self.dvAttenuation1)
            .field("dvAttenuation2", &self.dvAttenuation2)
            .field("dvTheta", &self.dvTheta)
            .field("dvPhi", &self.dvPhi)
            .finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DLIGHT {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dltType == other.dltType
            && self.dcvColor == other.dcvColor
            && self.dvPosition == other.dvPosition
            && self.dvDirection == other.dvDirection
            && self.dvRange == other.dvRange
            && self.dvFalloff == other.dvFalloff
            && self.dvAttenuation0 == other.dvAttenuation0
            && self.dvAttenuation1 == other.dvAttenuation1
            && self.dvAttenuation2 == other.dvAttenuation2
            && self.dvTheta == other.dvTheta
            && self.dvPhi == other.dvPhi
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DLIGHT {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DLIGHT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct D3DLIGHT2 {
    pub dwSize: u32,
    pub dltType: super::super::Graphics::Direct3D9::D3DLIGHTTYPE,
    pub dcvColor: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
    pub dvPosition: super::super::Graphics::Direct3D9::D3DVECTOR,
    pub dvDirection: super::super::Graphics::Direct3D9::D3DVECTOR,
    pub dvRange: f32,
    pub dvFalloff: f32,
    pub dvAttenuation0: f32,
    pub dvAttenuation1: f32,
    pub dvAttenuation2: f32,
    pub dvTheta: f32,
    pub dvPhi: f32,
    pub dwFlags: u32,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DLIGHT2 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DLIGHT2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::fmt::Debug for D3DLIGHT2 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DLIGHT2")
            .field("dwSize", &self.dwSize)
            .field("dltType", &self.dltType)
            .field("dcvColor", &self.dcvColor)
            .field("dvPosition", &self.dvPosition)
            .field("dvDirection", &self.dvDirection)
            .field("dvRange", &self.dvRange)
            .field("dvFalloff", &self.dvFalloff)
            .field("dvAttenuation0", &self.dvAttenuation0)
            .field("dvAttenuation1", &self.dvAttenuation1)
            .field("dvAttenuation2", &self.dvAttenuation2)
            .field("dvTheta", &self.dvTheta)
            .field("dvPhi", &self.dvPhi)
            .field("dwFlags", &self.dwFlags)
            .finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DLIGHT2 {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dltType == other.dltType
            && self.dcvColor == other.dcvColor
            && self.dvPosition == other.dvPosition
            && self.dvDirection == other.dvDirection
            && self.dvRange == other.dvRange
            && self.dvFalloff == other.dvFalloff
            && self.dvAttenuation0 == other.dvAttenuation0
            && self.dvAttenuation1 == other.dvAttenuation1
            && self.dvAttenuation2 == other.dvAttenuation2
            && self.dvTheta == other.dvTheta
            && self.dvPhi == other.dvPhi
            && self.dwFlags == other.dwFlags
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DLIGHT2 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DLIGHT2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct D3DLIGHT7 {
    pub dltType: super::super::Graphics::Direct3D9::D3DLIGHTTYPE,
    pub dcvDiffuse: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
    pub dcvSpecular: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
    pub dcvAmbient: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
    pub dvPosition: super::super::Graphics::Direct3D9::D3DVECTOR,
    pub dvDirection: super::super::Graphics::Direct3D9::D3DVECTOR,
    pub dvRange: f32,
    pub dvFalloff: f32,
    pub dvAttenuation0: f32,
    pub dvAttenuation1: f32,
    pub dvAttenuation2: f32,
    pub dvTheta: f32,
    pub dvPhi: f32,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DLIGHT7 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DLIGHT7 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::fmt::Debug for D3DLIGHT7 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DLIGHT7")
            .field("dltType", &self.dltType)
            .field("dcvDiffuse", &self.dcvDiffuse)
            .field("dcvSpecular", &self.dcvSpecular)
            .field("dcvAmbient", &self.dcvAmbient)
            .field("dvPosition", &self.dvPosition)
            .field("dvDirection", &self.dvDirection)
            .field("dvRange", &self.dvRange)
            .field("dvFalloff", &self.dvFalloff)
            .field("dvAttenuation0", &self.dvAttenuation0)
            .field("dvAttenuation1", &self.dvAttenuation1)
            .field("dvAttenuation2", &self.dvAttenuation2)
            .field("dvTheta", &self.dvTheta)
            .field("dvPhi", &self.dvPhi)
            .finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DLIGHT7 {
    fn eq(&self, other: &Self) -> bool {
        self.dltType == other.dltType
            && self.dcvDiffuse == other.dcvDiffuse
            && self.dcvSpecular == other.dcvSpecular
            && self.dcvAmbient == other.dcvAmbient
            && self.dvPosition == other.dvPosition
            && self.dvDirection == other.dvDirection
            && self.dvRange == other.dvRange
            && self.dvFalloff == other.dvFalloff
            && self.dvAttenuation0 == other.dvAttenuation0
            && self.dvAttenuation1 == other.dvAttenuation1
            && self.dvAttenuation2 == other.dvAttenuation2
            && self.dvTheta == other.dvTheta
            && self.dvPhi == other.dvPhi
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DLIGHT7 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DLIGHT7 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DLIGHTCAPS_DIRECTIONAL: i32 = 4i32;
pub const D3DLIGHTCAPS_GLSPOT: i32 = 16i32;
pub const D3DLIGHTCAPS_PARALLELPOINT: i32 = 8i32;
pub const D3DLIGHTCAPS_POINT: i32 = 1i32;
pub const D3DLIGHTCAPS_SPOT: i32 = 2i32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct D3DLIGHTDATA {
    pub dwSize: u32,
    pub lpIn: *mut D3DLIGHTINGELEMENT,
    pub dwInSize: u32,
    pub lpOut: *mut D3DTLVERTEX,
    pub dwOutSize: u32,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DLIGHTDATA {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DLIGHTDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::fmt::Debug for D3DLIGHTDATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DLIGHTDATA")
            .field("dwSize", &self.dwSize)
            .field("lpIn", &self.lpIn)
            .field("dwInSize", &self.dwInSize)
            .field("lpOut", &self.lpOut)
            .field("dwOutSize", &self.dwOutSize)
            .finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DLIGHTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.lpIn == other.lpIn
            && self.dwInSize == other.dwInSize
            && self.lpOut == other.lpOut
            && self.dwOutSize == other.dwOutSize
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DLIGHTDATA {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DLIGHTDATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DLIGHTINGCAPS {
    pub dwSize: u32,
    pub dwCaps: u32,
    pub dwLightingModel: u32,
    pub dwNumLights: u32,
}
impl D3DLIGHTINGCAPS {}
impl ::std::default::Default for D3DLIGHTINGCAPS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DLIGHTINGCAPS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DLIGHTINGCAPS")
            .field("dwSize", &self.dwSize)
            .field("dwCaps", &self.dwCaps)
            .field("dwLightingModel", &self.dwLightingModel)
            .field("dwNumLights", &self.dwNumLights)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DLIGHTINGCAPS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwCaps == other.dwCaps
            && self.dwLightingModel == other.dwLightingModel
            && self.dwNumLights == other.dwNumLights
    }
}
impl ::std::cmp::Eq for D3DLIGHTINGCAPS {}
unsafe impl ::windows::runtime::Abi for D3DLIGHTINGCAPS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct D3DLIGHTINGELEMENT {
    pub dvPosition: super::super::Graphics::Direct3D9::D3DVECTOR,
    pub dvNormal: super::super::Graphics::Direct3D9::D3DVECTOR,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DLIGHTINGELEMENT {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DLIGHTINGELEMENT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::fmt::Debug for D3DLIGHTINGELEMENT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DLIGHTINGELEMENT")
            .field("dvPosition", &self.dvPosition)
            .field("dvNormal", &self.dvNormal)
            .finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DLIGHTINGELEMENT {
    fn eq(&self, other: &Self) -> bool {
        self.dvPosition == other.dvPosition && self.dvNormal == other.dvNormal
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DLIGHTINGELEMENT {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DLIGHTINGELEMENT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DLIGHTINGMODEL_MONO: i32 = 2i32;
pub const D3DLIGHTINGMODEL_RGB: i32 = 1i32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct D3DLIGHTSTATETYPE(pub i32);
pub const D3DLIGHTSTATE_MATERIAL: D3DLIGHTSTATETYPE = D3DLIGHTSTATETYPE(1i32);
pub const D3DLIGHTSTATE_AMBIENT: D3DLIGHTSTATETYPE = D3DLIGHTSTATETYPE(2i32);
pub const D3DLIGHTSTATE_COLORMODEL: D3DLIGHTSTATETYPE = D3DLIGHTSTATETYPE(3i32);
pub const D3DLIGHTSTATE_FOGMODE: D3DLIGHTSTATETYPE = D3DLIGHTSTATETYPE(4i32);
pub const D3DLIGHTSTATE_FOGSTART: D3DLIGHTSTATETYPE = D3DLIGHTSTATETYPE(5i32);
pub const D3DLIGHTSTATE_FOGEND: D3DLIGHTSTATETYPE = D3DLIGHTSTATETYPE(6i32);
pub const D3DLIGHTSTATE_FOGDENSITY: D3DLIGHTSTATETYPE = D3DLIGHTSTATETYPE(7i32);
pub const D3DLIGHTSTATE_COLORVERTEX: D3DLIGHTSTATETYPE = D3DLIGHTSTATETYPE(8i32);
pub const D3DLIGHTSTATE_FORCE_DWORD: D3DLIGHTSTATETYPE = D3DLIGHTSTATETYPE(2147483647i32);
impl ::std::convert::From<i32> for D3DLIGHTSTATETYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for D3DLIGHTSTATETYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DLIGHT_ACTIVE: u32 = 1u32;
pub const D3DLIGHT_NO_SPECULAR: u32 = 2u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DLINE {
    pub Anonymous1: D3DLINE_0,
    pub Anonymous2: D3DLINE_1,
}
impl D3DLINE {}
impl ::std::default::Default for D3DLINE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DLINE {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DLINE {}
unsafe impl ::windows::runtime::Abi for D3DLINE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DLINE_0 {
    pub v1: u16,
    pub wV1: u16,
}
impl D3DLINE_0 {}
impl ::std::default::Default for D3DLINE_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DLINE_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DLINE_0 {}
unsafe impl ::windows::runtime::Abi for D3DLINE_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DLINE_1 {
    pub v2: u16,
    pub wV2: u16,
}
impl D3DLINE_1 {}
impl ::std::default::Default for D3DLINE_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DLINE_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DLINE_1 {}
unsafe impl ::windows::runtime::Abi for D3DLINE_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DLINEPATTERN {
    pub wRepeatFactor: u16,
    pub wLinePattern: u16,
}
impl D3DLINEPATTERN {}
impl ::std::default::Default for D3DLINEPATTERN {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DLINEPATTERN {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DLINEPATTERN")
            .field("wRepeatFactor", &self.wRepeatFactor)
            .field("wLinePattern", &self.wLinePattern)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DLINEPATTERN {
    fn eq(&self, other: &Self) -> bool {
        self.wRepeatFactor == other.wRepeatFactor && self.wLinePattern == other.wLinePattern
    }
}
impl ::std::cmp::Eq for D3DLINEPATTERN {}
unsafe impl ::windows::runtime::Abi for D3DLINEPATTERN {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DLVERTEX {
    pub Anonymous1: D3DLVERTEX_0,
    pub Anonymous2: D3DLVERTEX_1,
    pub Anonymous3: D3DLVERTEX_2,
    pub dwReserved: u32,
    pub Anonymous4: D3DLVERTEX_3,
    pub Anonymous5: D3DLVERTEX_4,
    pub Anonymous6: D3DLVERTEX_5,
    pub Anonymous7: D3DLVERTEX_6,
}
impl D3DLVERTEX {}
impl ::std::default::Default for D3DLVERTEX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DLVERTEX {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DLVERTEX {}
unsafe impl ::windows::runtime::Abi for D3DLVERTEX {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DLVERTEX_0 {
    pub x: f32,
    pub dvX: f32,
}
impl D3DLVERTEX_0 {}
impl ::std::default::Default for D3DLVERTEX_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DLVERTEX_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DLVERTEX_0 {}
unsafe impl ::windows::runtime::Abi for D3DLVERTEX_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DLVERTEX_1 {
    pub y: f32,
    pub dvY: f32,
}
impl D3DLVERTEX_1 {}
impl ::std::default::Default for D3DLVERTEX_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DLVERTEX_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DLVERTEX_1 {}
unsafe impl ::windows::runtime::Abi for D3DLVERTEX_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DLVERTEX_2 {
    pub z: f32,
    pub dvZ: f32,
}
impl D3DLVERTEX_2 {}
impl ::std::default::Default for D3DLVERTEX_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DLVERTEX_2 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DLVERTEX_2 {}
unsafe impl ::windows::runtime::Abi for D3DLVERTEX_2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DLVERTEX_3 {
    pub color: u32,
    pub dcColor: u32,
}
impl D3DLVERTEX_3 {}
impl ::std::default::Default for D3DLVERTEX_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DLVERTEX_3 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DLVERTEX_3 {}
unsafe impl ::windows::runtime::Abi for D3DLVERTEX_3 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DLVERTEX_4 {
    pub specular: u32,
    pub dcSpecular: u32,
}
impl D3DLVERTEX_4 {}
impl ::std::default::Default for D3DLVERTEX_4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DLVERTEX_4 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DLVERTEX_4 {}
unsafe impl ::windows::runtime::Abi for D3DLVERTEX_4 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DLVERTEX_5 {
    pub tu: f32,
    pub dvTU: f32,
}
impl D3DLVERTEX_5 {}
impl ::std::default::Default for D3DLVERTEX_5 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DLVERTEX_5 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DLVERTEX_5 {}
unsafe impl ::windows::runtime::Abi for D3DLVERTEX_5 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DLVERTEX_6 {
    pub tv: f32,
    pub dvTV: f32,
}
impl D3DLVERTEX_6 {}
impl ::std::default::Default for D3DLVERTEX_6 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DLVERTEX_6 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DLVERTEX_6 {}
unsafe impl ::windows::runtime::Abi for D3DLVERTEX_6 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct D3DMATERIAL {
    pub dwSize: u32,
    pub Anonymous1: D3DMATERIAL_0,
    pub Anonymous2: D3DMATERIAL_1,
    pub Anonymous3: D3DMATERIAL_2,
    pub Anonymous4: D3DMATERIAL_3,
    pub Anonymous5: D3DMATERIAL_4,
    pub hTexture: u32,
    pub dwRampSize: u32,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DMATERIAL {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DMATERIAL {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DMATERIAL {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DMATERIAL {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DMATERIAL {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub union D3DMATERIAL_0 {
    pub diffuse: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
    pub dcvDiffuse: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DMATERIAL_0 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DMATERIAL_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DMATERIAL_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DMATERIAL_0 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DMATERIAL_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub union D3DMATERIAL_1 {
    pub ambient: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
    pub dcvAmbient: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DMATERIAL_1 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DMATERIAL_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DMATERIAL_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DMATERIAL_1 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DMATERIAL_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub union D3DMATERIAL_2 {
    pub specular: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
    pub dcvSpecular: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DMATERIAL_2 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DMATERIAL_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DMATERIAL_2 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DMATERIAL_2 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DMATERIAL_2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub union D3DMATERIAL_3 {
    pub emissive: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
    pub dcvEmissive: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DMATERIAL_3 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DMATERIAL_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DMATERIAL_3 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DMATERIAL_3 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DMATERIAL_3 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DMATERIAL_4 {
    pub power: f32,
    pub dvPower: f32,
}
impl D3DMATERIAL_4 {}
impl ::std::default::Default for D3DMATERIAL_4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DMATERIAL_4 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DMATERIAL_4 {}
unsafe impl ::windows::runtime::Abi for D3DMATERIAL_4 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct D3DMATERIAL7 {
    pub Anonymous1: D3DMATERIAL7_0,
    pub Anonymous2: D3DMATERIAL7_1,
    pub Anonymous3: D3DMATERIAL7_2,
    pub Anonymous4: D3DMATERIAL7_3,
    pub Anonymous5: D3DMATERIAL7_4,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DMATERIAL7 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DMATERIAL7 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DMATERIAL7 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DMATERIAL7 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DMATERIAL7 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub union D3DMATERIAL7_0 {
    pub diffuse: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
    pub dcvDiffuse: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DMATERIAL7_0 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DMATERIAL7_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DMATERIAL7_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DMATERIAL7_0 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DMATERIAL7_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub union D3DMATERIAL7_1 {
    pub ambient: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
    pub dcvAmbient: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DMATERIAL7_1 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DMATERIAL7_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DMATERIAL7_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DMATERIAL7_1 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DMATERIAL7_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub union D3DMATERIAL7_2 {
    pub specular: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
    pub dcvSpecular: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DMATERIAL7_2 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DMATERIAL7_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DMATERIAL7_2 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DMATERIAL7_2 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DMATERIAL7_2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub union D3DMATERIAL7_3 {
    pub emissive: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
    pub dcvEmissive: super::super::Graphics::Direct3D9::D3DCOLORVALUE,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DMATERIAL7_3 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DMATERIAL7_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DMATERIAL7_3 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DMATERIAL7_3 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DMATERIAL7_3 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DMATERIAL7_4 {
    pub power: f32,
    pub dvPower: f32,
}
impl D3DMATERIAL7_4 {}
impl ::std::default::Default for D3DMATERIAL7_4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DMATERIAL7_4 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DMATERIAL7_4 {}
unsafe impl ::windows::runtime::Abi for D3DMATERIAL7_4 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DMATRIXLOAD {
    pub hDestMatrix: u32,
    pub hSrcMatrix: u32,
}
impl D3DMATRIXLOAD {}
impl ::std::default::Default for D3DMATRIXLOAD {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DMATRIXLOAD {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DMATRIXLOAD")
            .field("hDestMatrix", &self.hDestMatrix)
            .field("hSrcMatrix", &self.hSrcMatrix)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DMATRIXLOAD {
    fn eq(&self, other: &Self) -> bool {
        self.hDestMatrix == other.hDestMatrix && self.hSrcMatrix == other.hSrcMatrix
    }
}
impl ::std::cmp::Eq for D3DMATRIXLOAD {}
unsafe impl ::windows::runtime::Abi for D3DMATRIXLOAD {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DMATRIXMULTIPLY {
    pub hDestMatrix: u32,
    pub hSrcMatrix1: u32,
    pub hSrcMatrix2: u32,
}
impl D3DMATRIXMULTIPLY {}
impl ::std::default::Default for D3DMATRIXMULTIPLY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DMATRIXMULTIPLY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DMATRIXMULTIPLY")
            .field("hDestMatrix", &self.hDestMatrix)
            .field("hSrcMatrix1", &self.hSrcMatrix1)
            .field("hSrcMatrix2", &self.hSrcMatrix2)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DMATRIXMULTIPLY {
    fn eq(&self, other: &Self) -> bool {
        self.hDestMatrix == other.hDestMatrix
            && self.hSrcMatrix1 == other.hSrcMatrix1
            && self.hSrcMatrix2 == other.hSrcMatrix2
    }
}
impl ::std::cmp::Eq for D3DMATRIXMULTIPLY {}
unsafe impl ::windows::runtime::Abi for D3DMATRIXMULTIPLY {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DMAXUSERCLIPPLANES: u32 = 32u32;
pub const D3DNTCLEAR_COMPUTERECTS: i32 = 8i32;
pub const D3DNTHAL2_CB32_SETRENDERTARGET: i32 = 1i32;
pub const D3DNTHAL3_CB32_CLEAR2: i32 = 1i32;
pub const D3DNTHAL3_CB32_DRAWPRIMITIVES2: i32 = 8i32;
pub const D3DNTHAL3_CB32_RESERVED: i32 = 2i32;
pub const D3DNTHAL3_CB32_VALIDATETEXTURESTAGESTATE: i32 = 4i32;
pub const D3DNTHALDP2_EXECUTEBUFFER: i32 = 2i32;
pub const D3DNTHALDP2_REQCOMMANDBUFSIZE: i32 = 32i32;
pub const D3DNTHALDP2_REQVERTEXBUFSIZE: i32 = 16i32;
pub const D3DNTHALDP2_SWAPCOMMANDBUFFER: i32 = 8i32;
pub const D3DNTHALDP2_SWAPVERTEXBUFFER: i32 = 4i32;
pub const D3DNTHALDP2_USERMEMVERTICES: i32 = 1i32;
pub const D3DNTHALDP2_VIDMEMCOMMANDBUF: i32 = 128i32;
pub const D3DNTHALDP2_VIDMEMVERTEXBUF: i32 = 64i32;
#[derive(:: std :: clone :: Clone)]
#[repr(C)]
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
pub struct D3DNTHAL_CALLBACKS {
    pub dwSize: u32,
    pub ContextCreate: ::std::option::Option<LPD3DNTHAL_CONTEXTCREATECB>,
    pub ContextDestroy: ::std::option::Option<LPD3DNTHAL_CONTEXTDESTROYCB>,
    pub ContextDestroyAll: ::std::option::Option<LPD3DNTHAL_CONTEXTDESTROYALLCB>,
    pub SceneCapture: ::std::option::Option<LPD3DNTHAL_SCENECAPTURECB>,
    pub dwReserved10: *mut ::std::ffi::c_void,
    pub dwReserved11: *mut ::std::ffi::c_void,
    pub dwReserved22: *mut ::std::ffi::c_void,
    pub dwReserved23: *mut ::std::ffi::c_void,
    pub dwReserved: usize,
    pub TextureCreate: ::std::option::Option<LPD3DNTHAL_TEXTURECREATECB>,
    pub TextureDestroy: ::std::option::Option<LPD3DNTHAL_TEXTUREDESTROYCB>,
    pub TextureSwap: ::std::option::Option<LPD3DNTHAL_TEXTURESWAPCB>,
    pub TextureGetSurf: ::std::option::Option<LPD3DNTHAL_TEXTUREGETSURFCB>,
    pub dwReserved12: *mut ::std::ffi::c_void,
    pub dwReserved13: *mut ::std::ffi::c_void,
    pub dwReserved14: *mut ::std::ffi::c_void,
    pub dwReserved15: *mut ::std::ffi::c_void,
    pub dwReserved16: *mut ::std::ffi::c_void,
    pub dwReserved17: *mut ::std::ffi::c_void,
    pub dwReserved18: *mut ::std::ffi::c_void,
    pub dwReserved19: *mut ::std::ffi::c_void,
    pub dwReserved20: *mut ::std::ffi::c_void,
    pub dwReserved21: *mut ::std::ffi::c_void,
    pub dwReserved24: *mut ::std::ffi::c_void,
    pub dwReserved0: usize,
    pub dwReserved1: usize,
    pub dwReserved2: usize,
    pub dwReserved3: usize,
    pub dwReserved4: usize,
    pub dwReserved5: usize,
    pub dwReserved6: usize,
    pub dwReserved7: usize,
    pub dwReserved8: usize,
    pub dwReserved9: usize,
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl D3DNTHAL_CALLBACKS {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::default::Default for D3DNTHAL_CALLBACKS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::fmt::Debug for D3DNTHAL_CALLBACKS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_CALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwReserved10", &self.dwReserved10)
            .field("dwReserved11", &self.dwReserved11)
            .field("dwReserved22", &self.dwReserved22)
            .field("dwReserved23", &self.dwReserved23)
            .field("dwReserved", &self.dwReserved)
            .field("dwReserved12", &self.dwReserved12)
            .field("dwReserved13", &self.dwReserved13)
            .field("dwReserved14", &self.dwReserved14)
            .field("dwReserved15", &self.dwReserved15)
            .field("dwReserved16", &self.dwReserved16)
            .field("dwReserved17", &self.dwReserved17)
            .field("dwReserved18", &self.dwReserved18)
            .field("dwReserved19", &self.dwReserved19)
            .field("dwReserved20", &self.dwReserved20)
            .field("dwReserved21", &self.dwReserved21)
            .field("dwReserved24", &self.dwReserved24)
            .field("dwReserved0", &self.dwReserved0)
            .field("dwReserved1", &self.dwReserved1)
            .field("dwReserved2", &self.dwReserved2)
            .field("dwReserved3", &self.dwReserved3)
            .field("dwReserved4", &self.dwReserved4)
            .field("dwReserved5", &self.dwReserved5)
            .field("dwReserved6", &self.dwReserved6)
            .field("dwReserved7", &self.dwReserved7)
            .field("dwReserved8", &self.dwReserved8)
            .field("dwReserved9", &self.dwReserved9)
            .finish()
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::PartialEq for D3DNTHAL_CALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.ContextCreate.map(|f| f as usize) == other.ContextCreate.map(|f| f as usize)
            && self.ContextDestroy.map(|f| f as usize) == other.ContextDestroy.map(|f| f as usize)
            && self.ContextDestroyAll.map(|f| f as usize)
                == other.ContextDestroyAll.map(|f| f as usize)
            && self.SceneCapture.map(|f| f as usize) == other.SceneCapture.map(|f| f as usize)
            && self.dwReserved10 == other.dwReserved10
            && self.dwReserved11 == other.dwReserved11
            && self.dwReserved22 == other.dwReserved22
            && self.dwReserved23 == other.dwReserved23
            && self.dwReserved == other.dwReserved
            && self.TextureCreate.map(|f| f as usize) == other.TextureCreate.map(|f| f as usize)
            && self.TextureDestroy.map(|f| f as usize) == other.TextureDestroy.map(|f| f as usize)
            && self.TextureSwap.map(|f| f as usize) == other.TextureSwap.map(|f| f as usize)
            && self.TextureGetSurf.map(|f| f as usize) == other.TextureGetSurf.map(|f| f as usize)
            && self.dwReserved12 == other.dwReserved12
            && self.dwReserved13 == other.dwReserved13
            && self.dwReserved14 == other.dwReserved14
            && self.dwReserved15 == other.dwReserved15
            && self.dwReserved16 == other.dwReserved16
            && self.dwReserved17 == other.dwReserved17
            && self.dwReserved18 == other.dwReserved18
            && self.dwReserved19 == other.dwReserved19
            && self.dwReserved20 == other.dwReserved20
            && self.dwReserved21 == other.dwReserved21
            && self.dwReserved24 == other.dwReserved24
            && self.dwReserved0 == other.dwReserved0
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
            && self.dwReserved3 == other.dwReserved3
            && self.dwReserved4 == other.dwReserved4
            && self.dwReserved5 == other.dwReserved5
            && self.dwReserved6 == other.dwReserved6
            && self.dwReserved7 == other.dwReserved7
            && self.dwReserved8 == other.dwReserved8
            && self.dwReserved9 == other.dwReserved9
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::Eq for D3DNTHAL_CALLBACKS {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_CALLBACKS {
    type Abi = ::std::mem::ManuallyDrop<Self>;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone)]
#[repr(C)]
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
pub struct D3DNTHAL_CALLBACKS2 {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub SetRenderTarget: ::std::option::Option<LPD3DNTHAL_SETRENDERTARGETCB>,
    pub dwReserved1: *mut ::std::ffi::c_void,
    pub dwReserved2: *mut ::std::ffi::c_void,
    pub dwReserved3: *mut ::std::ffi::c_void,
    pub dwReserved4: *mut ::std::ffi::c_void,
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl D3DNTHAL_CALLBACKS2 {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::default::Default for D3DNTHAL_CALLBACKS2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::fmt::Debug for D3DNTHAL_CALLBACKS2 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_CALLBACKS2")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("dwReserved1", &self.dwReserved1)
            .field("dwReserved2", &self.dwReserved2)
            .field("dwReserved3", &self.dwReserved3)
            .field("dwReserved4", &self.dwReserved4)
            .finish()
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::PartialEq for D3DNTHAL_CALLBACKS2 {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.SetRenderTarget.map(|f| f as usize) == other.SetRenderTarget.map(|f| f as usize)
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
            && self.dwReserved3 == other.dwReserved3
            && self.dwReserved4 == other.dwReserved4
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::Eq for D3DNTHAL_CALLBACKS2 {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_CALLBACKS2 {
    type Abi = ::std::mem::ManuallyDrop<Self>;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone)]
#[repr(C)]
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_Direct3D9",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
pub struct D3DNTHAL_CALLBACKS3 {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub Clear2: ::std::option::Option<LPD3DNTHAL_CLEAR2CB>,
    pub lpvReserved: *mut ::std::ffi::c_void,
    pub ValidateTextureStageState: ::std::option::Option<LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB>,
    pub DrawPrimitives2: ::std::option::Option<LPD3DNTHAL_DRAWPRIMITIVES2CB>,
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_Direct3D9",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl D3DNTHAL_CALLBACKS3 {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_Direct3D9",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::default::Default for D3DNTHAL_CALLBACKS3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_Direct3D9",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::fmt::Debug for D3DNTHAL_CALLBACKS3 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_CALLBACKS3")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("lpvReserved", &self.lpvReserved)
            .finish()
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_Direct3D9",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::PartialEq for D3DNTHAL_CALLBACKS3 {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.Clear2.map(|f| f as usize) == other.Clear2.map(|f| f as usize)
            && self.lpvReserved == other.lpvReserved
            && self.ValidateTextureStageState.map(|f| f as usize)
                == other.ValidateTextureStageState.map(|f| f as usize)
            && self.DrawPrimitives2.map(|f| f as usize) == other.DrawPrimitives2.map(|f| f as usize)
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_Direct3D9",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::Eq for D3DNTHAL_CALLBACKS3 {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_Direct3D9",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_CALLBACKS3 {
    type Abi = ::std::mem::ManuallyDrop<Self>;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct D3DNTHAL_CLEAR2DATA {
    pub dwhContext: usize,
    pub dwFlags: u32,
    pub dwFillColor: u32,
    pub dvFillDepth: f32,
    pub dwFillStencil: u32,
    pub lpRects: *mut super::super::Graphics::Direct3D9::D3DRECT,
    pub dwNumRects: u32,
    pub ddrval: ::windows::runtime::HRESULT,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DNTHAL_CLEAR2DATA {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DNTHAL_CLEAR2DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::fmt::Debug for D3DNTHAL_CLEAR2DATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_CLEAR2DATA")
            .field("dwhContext", &self.dwhContext)
            .field("dwFlags", &self.dwFlags)
            .field("dwFillColor", &self.dwFillColor)
            .field("dvFillDepth", &self.dvFillDepth)
            .field("dwFillStencil", &self.dwFillStencil)
            .field("lpRects", &self.lpRects)
            .field("dwNumRects", &self.dwNumRects)
            .field("ddrval", &self.ddrval)
            .finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DNTHAL_CLEAR2DATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwhContext == other.dwhContext
            && self.dwFlags == other.dwFlags
            && self.dwFillColor == other.dwFillColor
            && self.dvFillDepth == other.dvFillDepth
            && self.dwFillStencil == other.dwFillStencil
            && self.lpRects == other.lpRects
            && self.dwNumRects == other.dwNumRects
            && self.ddrval == other.ddrval
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DNTHAL_CLEAR2DATA {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_CLEAR2DATA {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DNTHAL_COL_WEIGHTS: u32 = 2u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
pub struct D3DNTHAL_CONTEXTCREATEDATA {
    pub Anonymous1: D3DNTHAL_CONTEXTCREATEDATA_0,
    pub Anonymous2: D3DNTHAL_CONTEXTCREATEDATA_1,
    pub Anonymous3: D3DNTHAL_CONTEXTCREATEDATA_2,
    pub dwPID: u32,
    pub dwhContext: usize,
    pub ddrval: ::windows::runtime::HRESULT,
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl D3DNTHAL_CONTEXTCREATEDATA {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::default::Default for D3DNTHAL_CONTEXTCREATEDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::PartialEq for D3DNTHAL_CONTEXTCREATEDATA {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::Eq for D3DNTHAL_CONTEXTCREATEDATA {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_CONTEXTCREATEDATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_UI_DisplayDevices")]
pub union D3DNTHAL_CONTEXTCREATEDATA_0 {
    pub lpDDGbl: *mut super::super::UI::DisplayDevices::DD_DIRECTDRAW_GLOBAL,
    pub lpDDLcl: *mut super::super::UI::DisplayDevices::DD_DIRECTDRAW_LOCAL,
}
#[cfg(feature = "Win32_UI_DisplayDevices")]
impl D3DNTHAL_CONTEXTCREATEDATA_0 {}
#[cfg(feature = "Win32_UI_DisplayDevices")]
impl ::std::default::Default for D3DNTHAL_CONTEXTCREATEDATA_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_UI_DisplayDevices")]
impl ::std::cmp::PartialEq for D3DNTHAL_CONTEXTCREATEDATA_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_UI_DisplayDevices")]
impl ::std::cmp::Eq for D3DNTHAL_CONTEXTCREATEDATA_0 {}
#[cfg(feature = "Win32_UI_DisplayDevices")]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_CONTEXTCREATEDATA_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
pub union D3DNTHAL_CONTEXTCREATEDATA_1 {
    pub lpDDS: *mut super::super::UI::DisplayDevices::DD_SURFACE_LOCAL,
    pub lpDDSLcl: *mut super::super::UI::DisplayDevices::DD_SURFACE_LOCAL,
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl D3DNTHAL_CONTEXTCREATEDATA_1 {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::default::Default for D3DNTHAL_CONTEXTCREATEDATA_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::PartialEq for D3DNTHAL_CONTEXTCREATEDATA_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::Eq for D3DNTHAL_CONTEXTCREATEDATA_1 {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_CONTEXTCREATEDATA_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
pub union D3DNTHAL_CONTEXTCREATEDATA_2 {
    pub lpDDSZ: *mut super::super::UI::DisplayDevices::DD_SURFACE_LOCAL,
    pub lpDDSZLcl: *mut super::super::UI::DisplayDevices::DD_SURFACE_LOCAL,
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl D3DNTHAL_CONTEXTCREATEDATA_2 {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::default::Default for D3DNTHAL_CONTEXTCREATEDATA_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::PartialEq for D3DNTHAL_CONTEXTCREATEDATA_2 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::Eq for D3DNTHAL_CONTEXTCREATEDATA_2 {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_CONTEXTCREATEDATA_2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_CONTEXTDESTROYALLDATA {
    pub dwPID: u32,
    pub ddrval: ::windows::runtime::HRESULT,
}
impl D3DNTHAL_CONTEXTDESTROYALLDATA {}
impl ::std::default::Default for D3DNTHAL_CONTEXTDESTROYALLDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_CONTEXTDESTROYALLDATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_CONTEXTDESTROYALLDATA")
            .field("dwPID", &self.dwPID)
            .field("ddrval", &self.ddrval)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_CONTEXTDESTROYALLDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwPID == other.dwPID && self.ddrval == other.ddrval
    }
}
impl ::std::cmp::Eq for D3DNTHAL_CONTEXTDESTROYALLDATA {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_CONTEXTDESTROYALLDATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_CONTEXTDESTROYDATA {
    pub dwhContext: usize,
    pub ddrval: ::windows::runtime::HRESULT,
}
impl D3DNTHAL_CONTEXTDESTROYDATA {}
impl ::std::default::Default for D3DNTHAL_CONTEXTDESTROYDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_CONTEXTDESTROYDATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_CONTEXTDESTROYDATA")
            .field("dwhContext", &self.dwhContext)
            .field("ddrval", &self.ddrval)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_CONTEXTDESTROYDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwhContext == other.dwhContext && self.ddrval == other.ddrval
    }
}
impl ::std::cmp::Eq for D3DNTHAL_CONTEXTDESTROYDATA {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_CONTEXTDESTROYDATA {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DNTHAL_CONTEXT_BAD: i64 = 512i64;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_D3DDX6EXTENDEDCAPS {
    pub dwSize: u32,
    pub dwMinTextureWidth: u32,
    pub dwMaxTextureWidth: u32,
    pub dwMinTextureHeight: u32,
    pub dwMaxTextureHeight: u32,
    pub dwMinStippleWidth: u32,
    pub dwMaxStippleWidth: u32,
    pub dwMinStippleHeight: u32,
    pub dwMaxStippleHeight: u32,
    pub dwMaxTextureRepeat: u32,
    pub dwMaxTextureAspectRatio: u32,
    pub dwMaxAnisotropy: u32,
    pub dvGuardBandLeft: f32,
    pub dvGuardBandTop: f32,
    pub dvGuardBandRight: f32,
    pub dvGuardBandBottom: f32,
    pub dvExtentsAdjust: f32,
    pub dwStencilCaps: u32,
    pub dwFVFCaps: u32,
    pub dwTextureOpCaps: u32,
    pub wMaxTextureBlendStages: u16,
    pub wMaxSimultaneousTextures: u16,
}
impl D3DNTHAL_D3DDX6EXTENDEDCAPS {}
impl ::std::default::Default for D3DNTHAL_D3DDX6EXTENDEDCAPS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_D3DDX6EXTENDEDCAPS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_D3DDX6EXTENDEDCAPS")
            .field("dwSize", &self.dwSize)
            .field("dwMinTextureWidth", &self.dwMinTextureWidth)
            .field("dwMaxTextureWidth", &self.dwMaxTextureWidth)
            .field("dwMinTextureHeight", &self.dwMinTextureHeight)
            .field("dwMaxTextureHeight", &self.dwMaxTextureHeight)
            .field("dwMinStippleWidth", &self.dwMinStippleWidth)
            .field("dwMaxStippleWidth", &self.dwMaxStippleWidth)
            .field("dwMinStippleHeight", &self.dwMinStippleHeight)
            .field("dwMaxStippleHeight", &self.dwMaxStippleHeight)
            .field("dwMaxTextureRepeat", &self.dwMaxTextureRepeat)
            .field("dwMaxTextureAspectRatio", &self.dwMaxTextureAspectRatio)
            .field("dwMaxAnisotropy", &self.dwMaxAnisotropy)
            .field("dvGuardBandLeft", &self.dvGuardBandLeft)
            .field("dvGuardBandTop", &self.dvGuardBandTop)
            .field("dvGuardBandRight", &self.dvGuardBandRight)
            .field("dvGuardBandBottom", &self.dvGuardBandBottom)
            .field("dvExtentsAdjust", &self.dvExtentsAdjust)
            .field("dwStencilCaps", &self.dwStencilCaps)
            .field("dwFVFCaps", &self.dwFVFCaps)
            .field("dwTextureOpCaps", &self.dwTextureOpCaps)
            .field("wMaxTextureBlendStages", &self.wMaxTextureBlendStages)
            .field("wMaxSimultaneousTextures", &self.wMaxSimultaneousTextures)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_D3DDX6EXTENDEDCAPS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwMinTextureWidth == other.dwMinTextureWidth
            && self.dwMaxTextureWidth == other.dwMaxTextureWidth
            && self.dwMinTextureHeight == other.dwMinTextureHeight
            && self.dwMaxTextureHeight == other.dwMaxTextureHeight
            && self.dwMinStippleWidth == other.dwMinStippleWidth
            && self.dwMaxStippleWidth == other.dwMaxStippleWidth
            && self.dwMinStippleHeight == other.dwMinStippleHeight
            && self.dwMaxStippleHeight == other.dwMaxStippleHeight
            && self.dwMaxTextureRepeat == other.dwMaxTextureRepeat
            && self.dwMaxTextureAspectRatio == other.dwMaxTextureAspectRatio
            && self.dwMaxAnisotropy == other.dwMaxAnisotropy
            && self.dvGuardBandLeft == other.dvGuardBandLeft
            && self.dvGuardBandTop == other.dvGuardBandTop
            && self.dvGuardBandRight == other.dvGuardBandRight
            && self.dvGuardBandBottom == other.dvGuardBandBottom
            && self.dvExtentsAdjust == other.dvExtentsAdjust
            && self.dwStencilCaps == other.dwStencilCaps
            && self.dwFVFCaps == other.dwFVFCaps
            && self.dwTextureOpCaps == other.dwTextureOpCaps
            && self.wMaxTextureBlendStages == other.wMaxTextureBlendStages
            && self.wMaxSimultaneousTextures == other.wMaxSimultaneousTextures
    }
}
impl ::std::cmp::Eq for D3DNTHAL_D3DDX6EXTENDEDCAPS {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_D3DDX6EXTENDEDCAPS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_D3DEXTENDEDCAPS {
    pub dwSize: u32,
    pub dwMinTextureWidth: u32,
    pub dwMaxTextureWidth: u32,
    pub dwMinTextureHeight: u32,
    pub dwMaxTextureHeight: u32,
    pub dwMinStippleWidth: u32,
    pub dwMaxStippleWidth: u32,
    pub dwMinStippleHeight: u32,
    pub dwMaxStippleHeight: u32,
    pub dwMaxTextureRepeat: u32,
    pub dwMaxTextureAspectRatio: u32,
    pub dwMaxAnisotropy: u32,
    pub dvGuardBandLeft: f32,
    pub dvGuardBandTop: f32,
    pub dvGuardBandRight: f32,
    pub dvGuardBandBottom: f32,
    pub dvExtentsAdjust: f32,
    pub dwStencilCaps: u32,
    pub dwFVFCaps: u32,
    pub dwTextureOpCaps: u32,
    pub wMaxTextureBlendStages: u16,
    pub wMaxSimultaneousTextures: u16,
    pub dwMaxActiveLights: u32,
    pub dvMaxVertexW: f32,
    pub wMaxUserClipPlanes: u16,
    pub wMaxVertexBlendMatrices: u16,
    pub dwVertexProcessingCaps: u32,
    pub dwReserved1: u32,
    pub dwReserved2: u32,
    pub dwReserved3: u32,
    pub dwReserved4: u32,
}
impl D3DNTHAL_D3DEXTENDEDCAPS {}
impl ::std::default::Default for D3DNTHAL_D3DEXTENDEDCAPS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_D3DEXTENDEDCAPS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_D3DEXTENDEDCAPS")
            .field("dwSize", &self.dwSize)
            .field("dwMinTextureWidth", &self.dwMinTextureWidth)
            .field("dwMaxTextureWidth", &self.dwMaxTextureWidth)
            .field("dwMinTextureHeight", &self.dwMinTextureHeight)
            .field("dwMaxTextureHeight", &self.dwMaxTextureHeight)
            .field("dwMinStippleWidth", &self.dwMinStippleWidth)
            .field("dwMaxStippleWidth", &self.dwMaxStippleWidth)
            .field("dwMinStippleHeight", &self.dwMinStippleHeight)
            .field("dwMaxStippleHeight", &self.dwMaxStippleHeight)
            .field("dwMaxTextureRepeat", &self.dwMaxTextureRepeat)
            .field("dwMaxTextureAspectRatio", &self.dwMaxTextureAspectRatio)
            .field("dwMaxAnisotropy", &self.dwMaxAnisotropy)
            .field("dvGuardBandLeft", &self.dvGuardBandLeft)
            .field("dvGuardBandTop", &self.dvGuardBandTop)
            .field("dvGuardBandRight", &self.dvGuardBandRight)
            .field("dvGuardBandBottom", &self.dvGuardBandBottom)
            .field("dvExtentsAdjust", &self.dvExtentsAdjust)
            .field("dwStencilCaps", &self.dwStencilCaps)
            .field("dwFVFCaps", &self.dwFVFCaps)
            .field("dwTextureOpCaps", &self.dwTextureOpCaps)
            .field("wMaxTextureBlendStages", &self.wMaxTextureBlendStages)
            .field("wMaxSimultaneousTextures", &self.wMaxSimultaneousTextures)
            .field("dwMaxActiveLights", &self.dwMaxActiveLights)
            .field("dvMaxVertexW", &self.dvMaxVertexW)
            .field("wMaxUserClipPlanes", &self.wMaxUserClipPlanes)
            .field("wMaxVertexBlendMatrices", &self.wMaxVertexBlendMatrices)
            .field("dwVertexProcessingCaps", &self.dwVertexProcessingCaps)
            .field("dwReserved1", &self.dwReserved1)
            .field("dwReserved2", &self.dwReserved2)
            .field("dwReserved3", &self.dwReserved3)
            .field("dwReserved4", &self.dwReserved4)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_D3DEXTENDEDCAPS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwMinTextureWidth == other.dwMinTextureWidth
            && self.dwMaxTextureWidth == other.dwMaxTextureWidth
            && self.dwMinTextureHeight == other.dwMinTextureHeight
            && self.dwMaxTextureHeight == other.dwMaxTextureHeight
            && self.dwMinStippleWidth == other.dwMinStippleWidth
            && self.dwMaxStippleWidth == other.dwMaxStippleWidth
            && self.dwMinStippleHeight == other.dwMinStippleHeight
            && self.dwMaxStippleHeight == other.dwMaxStippleHeight
            && self.dwMaxTextureRepeat == other.dwMaxTextureRepeat
            && self.dwMaxTextureAspectRatio == other.dwMaxTextureAspectRatio
            && self.dwMaxAnisotropy == other.dwMaxAnisotropy
            && self.dvGuardBandLeft == other.dvGuardBandLeft
            && self.dvGuardBandTop == other.dvGuardBandTop
            && self.dvGuardBandRight == other.dvGuardBandRight
            && self.dvGuardBandBottom == other.dvGuardBandBottom
            && self.dvExtentsAdjust == other.dvExtentsAdjust
            && self.dwStencilCaps == other.dwStencilCaps
            && self.dwFVFCaps == other.dwFVFCaps
            && self.dwTextureOpCaps == other.dwTextureOpCaps
            && self.wMaxTextureBlendStages == other.wMaxTextureBlendStages
            && self.wMaxSimultaneousTextures == other.wMaxSimultaneousTextures
            && self.dwMaxActiveLights == other.dwMaxActiveLights
            && self.dvMaxVertexW == other.dvMaxVertexW
            && self.wMaxUserClipPlanes == other.wMaxUserClipPlanes
            && self.wMaxVertexBlendMatrices == other.wMaxVertexBlendMatrices
            && self.dwVertexProcessingCaps == other.dwVertexProcessingCaps
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
            && self.dwReserved3 == other.dwReserved3
            && self.dwReserved4 == other.dwReserved4
    }
}
impl ::std::cmp::Eq for D3DNTHAL_D3DEXTENDEDCAPS {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_D3DEXTENDEDCAPS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct D3DNTHAL_DP2CLEAR {
    pub dwFlags: u32,
    pub dwFillColor: u32,
    pub dvFillDepth: f32,
    pub dwFillStencil: u32,
    pub Rects: [super::super::Foundation::RECT; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl D3DNTHAL_DP2CLEAR {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for D3DNTHAL_DP2CLEAR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for D3DNTHAL_DP2CLEAR {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2CLEAR")
            .field("dwFlags", &self.dwFlags)
            .field("dwFillColor", &self.dwFillColor)
            .field("dvFillDepth", &self.dvFillDepth)
            .field("dwFillStencil", &self.dwFillStencil)
            .field("Rects", &self.Rects)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for D3DNTHAL_DP2CLEAR {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags
            && self.dwFillColor == other.dwFillColor
            && self.dvFillDepth == other.dvFillDepth
            && self.dwFillStencil == other.dwFillStencil
            && self.Rects == other.Rects
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for D3DNTHAL_DP2CLEAR {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2CLEAR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2COMMAND {
    pub bCommand: u8,
    pub bReserved: u8,
    pub Anonymous: D3DNTHAL_DP2COMMAND_0,
}
impl D3DNTHAL_DP2COMMAND {}
impl ::std::default::Default for D3DNTHAL_DP2COMMAND {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2COMMAND {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2COMMAND {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2COMMAND {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DNTHAL_DP2COMMAND_0 {
    pub wPrimitiveCount: u16,
    pub wStateCount: u16,
}
impl D3DNTHAL_DP2COMMAND_0 {}
impl ::std::default::Default for D3DNTHAL_DP2COMMAND_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2COMMAND_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2COMMAND_0 {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2COMMAND_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2CREATELIGHT {
    pub dwIndex: u32,
}
impl D3DNTHAL_DP2CREATELIGHT {}
impl ::std::default::Default for D3DNTHAL_DP2CREATELIGHT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2CREATELIGHT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2CREATELIGHT")
            .field("dwIndex", &self.dwIndex)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2CREATELIGHT {
    fn eq(&self, other: &Self) -> bool {
        self.dwIndex == other.dwIndex
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2CREATELIGHT {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2CREATELIGHT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2EXT {
    pub dwExtToken: u32,
    pub dwSize: u32,
}
impl D3DNTHAL_DP2EXT {}
impl ::std::default::Default for D3DNTHAL_DP2EXT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2EXT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2EXT")
            .field("dwExtToken", &self.dwExtToken)
            .field("dwSize", &self.dwSize)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2EXT {
    fn eq(&self, other: &Self) -> bool {
        self.dwExtToken == other.dwExtToken && self.dwSize == other.dwSize
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2EXT {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2EXT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2INDEXEDLINELIST {
    pub wV1: u16,
    pub wV2: u16,
}
impl D3DNTHAL_DP2INDEXEDLINELIST {}
impl ::std::default::Default for D3DNTHAL_DP2INDEXEDLINELIST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2INDEXEDLINELIST {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2INDEXEDLINELIST")
            .field("wV1", &self.wV1)
            .field("wV2", &self.wV2)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2INDEXEDLINELIST {
    fn eq(&self, other: &Self) -> bool {
        self.wV1 == other.wV1 && self.wV2 == other.wV2
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2INDEXEDLINELIST {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2INDEXEDLINELIST {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2INDEXEDLINESTRIP {
    pub wV: [u16; 2],
}
impl D3DNTHAL_DP2INDEXEDLINESTRIP {}
impl ::std::default::Default for D3DNTHAL_DP2INDEXEDLINESTRIP {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2INDEXEDLINESTRIP {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2INDEXEDLINESTRIP")
            .field("wV", &self.wV)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2INDEXEDLINESTRIP {
    fn eq(&self, other: &Self) -> bool {
        self.wV == other.wV
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2INDEXEDLINESTRIP {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2INDEXEDLINESTRIP {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2INDEXEDTRIANGLEFAN {
    pub wV: [u16; 3],
}
impl D3DNTHAL_DP2INDEXEDTRIANGLEFAN {}
impl ::std::default::Default for D3DNTHAL_DP2INDEXEDTRIANGLEFAN {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2INDEXEDTRIANGLEFAN {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2INDEXEDTRIANGLEFAN")
            .field("wV", &self.wV)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2INDEXEDTRIANGLEFAN {
    fn eq(&self, other: &Self) -> bool {
        self.wV == other.wV
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2INDEXEDTRIANGLEFAN {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2INDEXEDTRIANGLEFAN {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2INDEXEDTRIANGLELIST {
    pub wV1: u16,
    pub wV2: u16,
    pub wV3: u16,
    pub wFlags: u16,
}
impl D3DNTHAL_DP2INDEXEDTRIANGLELIST {}
impl ::std::default::Default for D3DNTHAL_DP2INDEXEDTRIANGLELIST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2INDEXEDTRIANGLELIST {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2INDEXEDTRIANGLELIST")
            .field("wV1", &self.wV1)
            .field("wV2", &self.wV2)
            .field("wV3", &self.wV3)
            .field("wFlags", &self.wFlags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2INDEXEDTRIANGLELIST {
    fn eq(&self, other: &Self) -> bool {
        self.wV1 == other.wV1
            && self.wV2 == other.wV2
            && self.wV3 == other.wV3
            && self.wFlags == other.wFlags
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2INDEXEDTRIANGLELIST {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2INDEXEDTRIANGLELIST {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2INDEXEDTRIANGLELIST2 {
    pub wV1: u16,
    pub wV2: u16,
    pub wV3: u16,
}
impl D3DNTHAL_DP2INDEXEDTRIANGLELIST2 {}
impl ::std::default::Default for D3DNTHAL_DP2INDEXEDTRIANGLELIST2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2INDEXEDTRIANGLELIST2 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2INDEXEDTRIANGLELIST2")
            .field("wV1", &self.wV1)
            .field("wV2", &self.wV2)
            .field("wV3", &self.wV3)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2INDEXEDTRIANGLELIST2 {
    fn eq(&self, other: &Self) -> bool {
        self.wV1 == other.wV1 && self.wV2 == other.wV2 && self.wV3 == other.wV3
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2INDEXEDTRIANGLELIST2 {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2INDEXEDTRIANGLELIST2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2INDEXEDTRIANGLESTRIP {
    pub wV: [u16; 3],
}
impl D3DNTHAL_DP2INDEXEDTRIANGLESTRIP {}
impl ::std::default::Default for D3DNTHAL_DP2INDEXEDTRIANGLESTRIP {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2INDEXEDTRIANGLESTRIP {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2INDEXEDTRIANGLESTRIP")
            .field("wV", &self.wV)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2INDEXEDTRIANGLESTRIP {
    fn eq(&self, other: &Self) -> bool {
        self.wV == other.wV
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2INDEXEDTRIANGLESTRIP {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2INDEXEDTRIANGLESTRIP {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2LINELIST {
    pub wVStart: u16,
}
impl D3DNTHAL_DP2LINELIST {}
impl ::std::default::Default for D3DNTHAL_DP2LINELIST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2LINELIST {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2LINELIST")
            .field("wVStart", &self.wVStart)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2LINELIST {
    fn eq(&self, other: &Self) -> bool {
        self.wVStart == other.wVStart
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2LINELIST {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2LINELIST {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2LINESTRIP {
    pub wVStart: u16,
}
impl D3DNTHAL_DP2LINESTRIP {}
impl ::std::default::Default for D3DNTHAL_DP2LINESTRIP {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2LINESTRIP {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2LINESTRIP")
            .field("wVStart", &self.wVStart)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2LINESTRIP {
    fn eq(&self, other: &Self) -> bool {
        self.wVStart == other.wVStart
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2LINESTRIP {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2LINESTRIP {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct D3DNTHAL_DP2OPERATION(pub i32);
pub const D3DNTDP2OP_POINTS: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(1i32);
pub const D3DNTDP2OP_INDEXEDLINELIST: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(2i32);
pub const D3DNTDP2OP_INDEXEDTRIANGLELIST: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(3i32);
pub const D3DNTDP2OP_RENDERSTATE: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(8i32);
pub const D3DNTDP2OP_LINELIST: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(15i32);
pub const D3DNTDP2OP_LINESTRIP: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(16i32);
pub const D3DNTDP2OP_INDEXEDLINESTRIP: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(17i32);
pub const D3DNTDP2OP_TRIANGLELIST: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(18i32);
pub const D3DNTDP2OP_TRIANGLESTRIP: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(19i32);
pub const D3DNTDP2OP_INDEXEDTRIANGLESTRIP: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(20i32);
pub const D3DNTDP2OP_TRIANGLEFAN: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(21i32);
pub const D3DNTDP2OP_INDEXEDTRIANGLEFAN: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(22i32);
pub const D3DNTDP2OP_TRIANGLEFAN_IMM: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(23i32);
pub const D3DNTDP2OP_LINELIST_IMM: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(24i32);
pub const D3DNTDP2OP_TEXTURESTAGESTATE: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(25i32);
pub const D3DNTDP2OP_INDEXEDTRIANGLELIST2: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(26i32);
pub const D3DNTDP2OP_INDEXEDLINELIST2: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(27i32);
pub const D3DNTDP2OP_VIEWPORTINFO: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(28i32);
pub const D3DNTDP2OP_WINFO: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(29i32);
pub const D3DNTDP2OP_SETPALETTE: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(30i32);
pub const D3DNTDP2OP_UPDATEPALETTE: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(31i32);
pub const D3DNTDP2OP_ZRANGE: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(32i32);
pub const D3DNTDP2OP_SETMATERIAL: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(33i32);
pub const D3DNTDP2OP_SETLIGHT: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(34i32);
pub const D3DNTDP2OP_CREATELIGHT: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(35i32);
pub const D3DNTDP2OP_SETTRANSFORM: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(36i32);
pub const D3DNTDP2OP_TEXBLT: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(38i32);
pub const D3DNTDP2OP_STATESET: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(39i32);
pub const D3DNTDP2OP_SETPRIORITY: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(40i32);
pub const D3DNTDP2OP_SETRENDERTARGET: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(41i32);
pub const D3DNTDP2OP_CLEAR: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(42i32);
pub const D3DNTDP2OP_SETTEXLOD: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(43i32);
pub const D3DNTDP2OP_SETCLIPPLANE: D3DNTHAL_DP2OPERATION = D3DNTHAL_DP2OPERATION(44i32);
impl ::std::convert::From<i32> for D3DNTHAL_DP2OPERATION {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2OPERATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2POINTS {
    pub wCount: u16,
    pub wVStart: u16,
}
impl D3DNTHAL_DP2POINTS {}
impl ::std::default::Default for D3DNTHAL_DP2POINTS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2POINTS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2POINTS")
            .field("wCount", &self.wCount)
            .field("wVStart", &self.wVStart)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2POINTS {
    fn eq(&self, other: &Self) -> bool {
        self.wCount == other.wCount && self.wVStart == other.wVStart
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2POINTS {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2POINTS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct D3DNTHAL_DP2RENDERSTATE {
    pub RenderState: super::super::Graphics::Direct3D9::D3DRENDERSTATETYPE,
    pub Anonymous: D3DNTHAL_DP2RENDERSTATE_0,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DNTHAL_DP2RENDERSTATE {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DNTHAL_DP2RENDERSTATE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DNTHAL_DP2RENDERSTATE {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DNTHAL_DP2RENDERSTATE {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2RENDERSTATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DNTHAL_DP2RENDERSTATE_0 {
    pub fState: f32,
    pub dwState: u32,
}
impl D3DNTHAL_DP2RENDERSTATE_0 {}
impl ::std::default::Default for D3DNTHAL_DP2RENDERSTATE_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2RENDERSTATE_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2RENDERSTATE_0 {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2RENDERSTATE_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2SETCLIPPLANE {
    pub dwIndex: u32,
    pub plane: [f32; 4],
}
impl D3DNTHAL_DP2SETCLIPPLANE {}
impl ::std::default::Default for D3DNTHAL_DP2SETCLIPPLANE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2SETCLIPPLANE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2SETCLIPPLANE")
            .field("dwIndex", &self.dwIndex)
            .field("plane", &self.plane)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2SETCLIPPLANE {
    fn eq(&self, other: &Self) -> bool {
        self.dwIndex == other.dwIndex && self.plane == other.plane
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2SETCLIPPLANE {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2SETCLIPPLANE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2SETLIGHT {
    pub dwIndex: u32,
    pub Anonymous: D3DNTHAL_DP2SETLIGHT_0,
}
impl D3DNTHAL_DP2SETLIGHT {}
impl ::std::default::Default for D3DNTHAL_DP2SETLIGHT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2SETLIGHT {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2SETLIGHT {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2SETLIGHT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DNTHAL_DP2SETLIGHT_0 {
    pub lightData: u32,
    pub dwDataType: u32,
}
impl D3DNTHAL_DP2SETLIGHT_0 {}
impl ::std::default::Default for D3DNTHAL_DP2SETLIGHT_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2SETLIGHT_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2SETLIGHT_0 {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2SETLIGHT_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2SETPALETTE {
    pub dwPaletteHandle: u32,
    pub dwPaletteFlags: u32,
    pub dwSurfaceHandle: u32,
}
impl D3DNTHAL_DP2SETPALETTE {}
impl ::std::default::Default for D3DNTHAL_DP2SETPALETTE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2SETPALETTE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2SETPALETTE")
            .field("dwPaletteHandle", &self.dwPaletteHandle)
            .field("dwPaletteFlags", &self.dwPaletteFlags)
            .field("dwSurfaceHandle", &self.dwSurfaceHandle)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2SETPALETTE {
    fn eq(&self, other: &Self) -> bool {
        self.dwPaletteHandle == other.dwPaletteHandle
            && self.dwPaletteFlags == other.dwPaletteFlags
            && self.dwSurfaceHandle == other.dwSurfaceHandle
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2SETPALETTE {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2SETPALETTE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2SETPRIORITY {
    pub dwDDDestSurface: u32,
    pub dwPriority: u32,
}
impl D3DNTHAL_DP2SETPRIORITY {}
impl ::std::default::Default for D3DNTHAL_DP2SETPRIORITY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2SETPRIORITY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2SETPRIORITY")
            .field("dwDDDestSurface", &self.dwDDDestSurface)
            .field("dwPriority", &self.dwPriority)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2SETPRIORITY {
    fn eq(&self, other: &Self) -> bool {
        self.dwDDDestSurface == other.dwDDDestSurface && self.dwPriority == other.dwPriority
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2SETPRIORITY {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2SETPRIORITY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2SETRENDERTARGET {
    pub hRenderTarget: u32,
    pub hZBuffer: u32,
}
impl D3DNTHAL_DP2SETRENDERTARGET {}
impl ::std::default::Default for D3DNTHAL_DP2SETRENDERTARGET {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2SETRENDERTARGET {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2SETRENDERTARGET")
            .field("hRenderTarget", &self.hRenderTarget)
            .field("hZBuffer", &self.hZBuffer)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2SETRENDERTARGET {
    fn eq(&self, other: &Self) -> bool {
        self.hRenderTarget == other.hRenderTarget && self.hZBuffer == other.hZBuffer
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2SETRENDERTARGET {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2SETRENDERTARGET {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2SETTEXLOD {
    pub dwDDSurface: u32,
    pub dwLOD: u32,
}
impl D3DNTHAL_DP2SETTEXLOD {}
impl ::std::default::Default for D3DNTHAL_DP2SETTEXLOD {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2SETTEXLOD {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2SETTEXLOD")
            .field("dwDDSurface", &self.dwDDSurface)
            .field("dwLOD", &self.dwLOD)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2SETTEXLOD {
    fn eq(&self, other: &Self) -> bool {
        self.dwDDSurface == other.dwDDSurface && self.dwLOD == other.dwLOD
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2SETTEXLOD {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2SETTEXLOD {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct D3DNTHAL_DP2SETTRANSFORM {
    pub xfrmType: super::super::Graphics::Direct3D9::D3DTRANSFORMSTATETYPE,
    pub matrix: super::super::Graphics::Direct3D9::D3DMATRIX,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DNTHAL_DP2SETTRANSFORM {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DNTHAL_DP2SETTRANSFORM {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DNTHAL_DP2SETTRANSFORM {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DNTHAL_DP2SETTRANSFORM {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2SETTRANSFORM {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2STARTVERTEX {
    pub wVStart: u16,
}
impl D3DNTHAL_DP2STARTVERTEX {}
impl ::std::default::Default for D3DNTHAL_DP2STARTVERTEX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2STARTVERTEX {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2STARTVERTEX")
            .field("wVStart", &self.wVStart)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2STARTVERTEX {
    fn eq(&self, other: &Self) -> bool {
        self.wVStart == other.wVStart
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2STARTVERTEX {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2STARTVERTEX {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct D3DNTHAL_DP2STATESET {
    pub dwOperation: u32,
    pub dwParam: u32,
    pub sbType: super::super::Graphics::Direct3D9::D3DSTATEBLOCKTYPE,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DNTHAL_DP2STATESET {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DNTHAL_DP2STATESET {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::fmt::Debug for D3DNTHAL_DP2STATESET {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2STATESET")
            .field("dwOperation", &self.dwOperation)
            .field("dwParam", &self.dwParam)
            .field("sbType", &self.sbType)
            .finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DNTHAL_DP2STATESET {
    fn eq(&self, other: &Self) -> bool {
        self.dwOperation == other.dwOperation
            && self.dwParam == other.dwParam
            && self.sbType == other.sbType
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DNTHAL_DP2STATESET {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2STATESET {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct D3DNTHAL_DP2TEXBLT {
    pub dwDDDestSurface: u32,
    pub dwDDSrcSurface: u32,
    pub pDest: super::super::Foundation::POINT,
    pub rSrc: super::super::Foundation::RECTL,
    pub dwFlags: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl D3DNTHAL_DP2TEXBLT {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for D3DNTHAL_DP2TEXBLT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for D3DNTHAL_DP2TEXBLT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2TEXBLT")
            .field("dwDDDestSurface", &self.dwDDDestSurface)
            .field("dwDDSrcSurface", &self.dwDDSrcSurface)
            .field("pDest", &self.pDest)
            .field("rSrc", &self.rSrc)
            .field("dwFlags", &self.dwFlags)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for D3DNTHAL_DP2TEXBLT {
    fn eq(&self, other: &Self) -> bool {
        self.dwDDDestSurface == other.dwDDDestSurface
            && self.dwDDSrcSurface == other.dwDDSrcSurface
            && self.pDest == other.pDest
            && self.rSrc == other.rSrc
            && self.dwFlags == other.dwFlags
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for D3DNTHAL_DP2TEXBLT {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2TEXBLT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2TEXTURESTAGESTATE {
    pub wStage: u16,
    pub TSState: u16,
    pub dwValue: u32,
}
impl D3DNTHAL_DP2TEXTURESTAGESTATE {}
impl ::std::default::Default for D3DNTHAL_DP2TEXTURESTAGESTATE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2TEXTURESTAGESTATE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2TEXTURESTAGESTATE")
            .field("wStage", &self.wStage)
            .field("TSState", &self.TSState)
            .field("dwValue", &self.dwValue)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2TEXTURESTAGESTATE {
    fn eq(&self, other: &Self) -> bool {
        self.wStage == other.wStage
            && self.TSState == other.TSState
            && self.dwValue == other.dwValue
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2TEXTURESTAGESTATE {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2TEXTURESTAGESTATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2TRIANGLEFAN {
    pub wVStart: u16,
}
impl D3DNTHAL_DP2TRIANGLEFAN {}
impl ::std::default::Default for D3DNTHAL_DP2TRIANGLEFAN {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2TRIANGLEFAN {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2TRIANGLEFAN")
            .field("wVStart", &self.wVStart)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2TRIANGLEFAN {
    fn eq(&self, other: &Self) -> bool {
        self.wVStart == other.wVStart
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2TRIANGLEFAN {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2TRIANGLEFAN {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2TRIANGLEFAN_IMM {
    pub dwEdgeFlags: u32,
}
impl D3DNTHAL_DP2TRIANGLEFAN_IMM {}
impl ::std::default::Default for D3DNTHAL_DP2TRIANGLEFAN_IMM {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2TRIANGLEFAN_IMM {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2TRIANGLEFAN_IMM")
            .field("dwEdgeFlags", &self.dwEdgeFlags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2TRIANGLEFAN_IMM {
    fn eq(&self, other: &Self) -> bool {
        self.dwEdgeFlags == other.dwEdgeFlags
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2TRIANGLEFAN_IMM {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2TRIANGLEFAN_IMM {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2TRIANGLELIST {
    pub wVStart: u16,
}
impl D3DNTHAL_DP2TRIANGLELIST {}
impl ::std::default::Default for D3DNTHAL_DP2TRIANGLELIST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2TRIANGLELIST {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2TRIANGLELIST")
            .field("wVStart", &self.wVStart)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2TRIANGLELIST {
    fn eq(&self, other: &Self) -> bool {
        self.wVStart == other.wVStart
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2TRIANGLELIST {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2TRIANGLELIST {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2TRIANGLESTRIP {
    pub wVStart: u16,
}
impl D3DNTHAL_DP2TRIANGLESTRIP {}
impl ::std::default::Default for D3DNTHAL_DP2TRIANGLESTRIP {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2TRIANGLESTRIP {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2TRIANGLESTRIP")
            .field("wVStart", &self.wVStart)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2TRIANGLESTRIP {
    fn eq(&self, other: &Self) -> bool {
        self.wVStart == other.wVStart
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2TRIANGLESTRIP {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2TRIANGLESTRIP {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2UPDATEPALETTE {
    pub dwPaletteHandle: u32,
    pub wStartIndex: u16,
    pub wNumEntries: u16,
}
impl D3DNTHAL_DP2UPDATEPALETTE {}
impl ::std::default::Default for D3DNTHAL_DP2UPDATEPALETTE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2UPDATEPALETTE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2UPDATEPALETTE")
            .field("dwPaletteHandle", &self.dwPaletteHandle)
            .field("wStartIndex", &self.wStartIndex)
            .field("wNumEntries", &self.wNumEntries)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2UPDATEPALETTE {
    fn eq(&self, other: &Self) -> bool {
        self.dwPaletteHandle == other.dwPaletteHandle
            && self.wStartIndex == other.wStartIndex
            && self.wNumEntries == other.wNumEntries
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2UPDATEPALETTE {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2UPDATEPALETTE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2VIEWPORTINFO {
    pub dwX: u32,
    pub dwY: u32,
    pub dwWidth: u32,
    pub dwHeight: u32,
}
impl D3DNTHAL_DP2VIEWPORTINFO {}
impl ::std::default::Default for D3DNTHAL_DP2VIEWPORTINFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2VIEWPORTINFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2VIEWPORTINFO")
            .field("dwX", &self.dwX)
            .field("dwY", &self.dwY)
            .field("dwWidth", &self.dwWidth)
            .field("dwHeight", &self.dwHeight)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2VIEWPORTINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwX == other.dwX
            && self.dwY == other.dwY
            && self.dwWidth == other.dwWidth
            && self.dwHeight == other.dwHeight
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2VIEWPORTINFO {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2VIEWPORTINFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2WINFO {
    pub dvWNear: f32,
    pub dvWFar: f32,
}
impl D3DNTHAL_DP2WINFO {}
impl ::std::default::Default for D3DNTHAL_DP2WINFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2WINFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2WINFO")
            .field("dvWNear", &self.dvWNear)
            .field("dvWFar", &self.dvWFar)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2WINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dvWNear == other.dvWNear && self.dvWFar == other.dvWFar
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2WINFO {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2WINFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_DP2ZRANGE {
    pub dvMinZ: f32,
    pub dvMaxZ: f32,
}
impl D3DNTHAL_DP2ZRANGE {}
impl ::std::default::Default for D3DNTHAL_DP2ZRANGE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_DP2ZRANGE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_DP2ZRANGE")
            .field("dvMinZ", &self.dvMinZ)
            .field("dvMaxZ", &self.dvMaxZ)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DP2ZRANGE {
    fn eq(&self, other: &Self) -> bool {
        self.dvMinZ == other.dvMinZ && self.dvMaxZ == other.dvMaxZ
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DP2ZRANGE {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DP2ZRANGE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
pub struct D3DNTHAL_DRAWPRIMITIVES2DATA {
    pub dwhContext: usize,
    pub dwFlags: u32,
    pub dwVertexType: u32,
    pub lpDDCommands: *mut super::super::UI::DisplayDevices::DD_SURFACE_LOCAL,
    pub dwCommandOffset: u32,
    pub dwCommandLength: u32,
    pub Anonymous1: D3DNTHAL_DRAWPRIMITIVES2DATA_0,
    pub dwVertexOffset: u32,
    pub dwVertexLength: u32,
    pub dwReqVertexBufSize: u32,
    pub dwReqCommandBufSize: u32,
    pub lpdwRStates: *mut u32,
    pub Anonymous2: D3DNTHAL_DRAWPRIMITIVES2DATA_1,
    pub dwErrorOffset: u32,
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl D3DNTHAL_DRAWPRIMITIVES2DATA {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::default::Default for D3DNTHAL_DRAWPRIMITIVES2DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::PartialEq for D3DNTHAL_DRAWPRIMITIVES2DATA {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::Eq for D3DNTHAL_DRAWPRIMITIVES2DATA {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DRAWPRIMITIVES2DATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
pub union D3DNTHAL_DRAWPRIMITIVES2DATA_0 {
    pub lpDDVertex: *mut super::super::UI::DisplayDevices::DD_SURFACE_LOCAL,
    pub lpVertices: *mut ::std::ffi::c_void,
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl D3DNTHAL_DRAWPRIMITIVES2DATA_0 {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::default::Default for D3DNTHAL_DRAWPRIMITIVES2DATA_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::PartialEq for D3DNTHAL_DRAWPRIMITIVES2DATA_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::Eq for D3DNTHAL_DRAWPRIMITIVES2DATA_0 {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DRAWPRIMITIVES2DATA_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DNTHAL_DRAWPRIMITIVES2DATA_1 {
    pub dwVertexSize: u32,
    pub ddrval: ::windows::runtime::HRESULT,
}
impl D3DNTHAL_DRAWPRIMITIVES2DATA_1 {}
impl ::std::default::Default for D3DNTHAL_DRAWPRIMITIVES2DATA_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_DRAWPRIMITIVES2DATA_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DNTHAL_DRAWPRIMITIVES2DATA_1 {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_DRAWPRIMITIVES2DATA_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
pub struct D3DNTHAL_GLOBALDRIVERDATA {
    pub dwSize: u32,
    pub hwCaps: _D3DNTHALDeviceDesc_V1,
    pub dwNumVertices: u32,
    pub dwNumClipVertices: u32,
    pub dwNumTextureFormats: u32,
    pub lpTextureFormats: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl D3DNTHAL_GLOBALDRIVERDATA {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl ::std::default::Default for D3DNTHAL_GLOBALDRIVERDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl ::std::fmt::Debug for D3DNTHAL_GLOBALDRIVERDATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_GLOBALDRIVERDATA")
            .field("dwSize", &self.dwSize)
            .field("hwCaps", &self.hwCaps)
            .field("dwNumVertices", &self.dwNumVertices)
            .field("dwNumClipVertices", &self.dwNumClipVertices)
            .field("dwNumTextureFormats", &self.dwNumTextureFormats)
            .field("lpTextureFormats", &self.lpTextureFormats)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl ::std::cmp::PartialEq for D3DNTHAL_GLOBALDRIVERDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.hwCaps == other.hwCaps
            && self.dwNumVertices == other.dwNumVertices
            && self.dwNumClipVertices == other.dwNumClipVertices
            && self.dwNumTextureFormats == other.dwNumTextureFormats
            && self.lpTextureFormats == other.lpTextureFormats
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl ::std::cmp::Eq for D3DNTHAL_GLOBALDRIVERDATA {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_GLOBALDRIVERDATA {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DNTHAL_NUMCLIPVERTICES: u32 = 20u32;
pub const D3DNTHAL_OUTOFCONTEXTS: i64 = 513i64;
pub const D3DNTHAL_ROW_WEIGHTS: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_SCENECAPTUREDATA {
    pub dwhContext: usize,
    pub dwFlag: u32,
    pub ddrval: ::windows::runtime::HRESULT,
}
impl D3DNTHAL_SCENECAPTUREDATA {}
impl ::std::default::Default for D3DNTHAL_SCENECAPTUREDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_SCENECAPTUREDATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_SCENECAPTUREDATA")
            .field("dwhContext", &self.dwhContext)
            .field("dwFlag", &self.dwFlag)
            .field("ddrval", &self.ddrval)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_SCENECAPTUREDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwhContext == other.dwhContext
            && self.dwFlag == other.dwFlag
            && self.ddrval == other.ddrval
    }
}
impl ::std::cmp::Eq for D3DNTHAL_SCENECAPTUREDATA {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_SCENECAPTUREDATA {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DNTHAL_SCENE_CAPTURE_END: i32 = 1i32;
pub const D3DNTHAL_SCENE_CAPTURE_START: i32 = 0i32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
pub struct D3DNTHAL_SETRENDERTARGETDATA {
    pub dwhContext: usize,
    pub lpDDS: *mut super::super::UI::DisplayDevices::DD_SURFACE_LOCAL,
    pub lpDDSZ: *mut super::super::UI::DisplayDevices::DD_SURFACE_LOCAL,
    pub ddrval: ::windows::runtime::HRESULT,
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl D3DNTHAL_SETRENDERTARGETDATA {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::default::Default for D3DNTHAL_SETRENDERTARGETDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::fmt::Debug for D3DNTHAL_SETRENDERTARGETDATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_SETRENDERTARGETDATA")
            .field("dwhContext", &self.dwhContext)
            .field("lpDDS", &self.lpDDS)
            .field("lpDDSZ", &self.lpDDSZ)
            .field("ddrval", &self.ddrval)
            .finish()
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::PartialEq for D3DNTHAL_SETRENDERTARGETDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwhContext == other.dwhContext
            && self.lpDDS == other.lpDDS
            && self.lpDDSZ == other.lpDDSZ
            && self.ddrval == other.ddrval
    }
}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
impl ::std::cmp::Eq for D3DNTHAL_SETRENDERTARGETDATA {}
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_SETRENDERTARGETDATA {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DNTHAL_STATESETCREATE: u32 = 5u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct D3DNTHAL_TEXTURECREATEDATA {
    pub dwhContext: usize,
    pub hDDS: super::super::Foundation::HANDLE,
    pub dwHandle: usize,
    pub ddrval: ::windows::runtime::HRESULT,
}
#[cfg(feature = "Win32_Foundation")]
impl D3DNTHAL_TEXTURECREATEDATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for D3DNTHAL_TEXTURECREATEDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for D3DNTHAL_TEXTURECREATEDATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_TEXTURECREATEDATA")
            .field("dwhContext", &self.dwhContext)
            .field("hDDS", &self.hDDS)
            .field("dwHandle", &self.dwHandle)
            .field("ddrval", &self.ddrval)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for D3DNTHAL_TEXTURECREATEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwhContext == other.dwhContext
            && self.hDDS == other.hDDS
            && self.dwHandle == other.dwHandle
            && self.ddrval == other.ddrval
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for D3DNTHAL_TEXTURECREATEDATA {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_TEXTURECREATEDATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_TEXTUREDESTROYDATA {
    pub dwhContext: usize,
    pub dwHandle: usize,
    pub ddrval: ::windows::runtime::HRESULT,
}
impl D3DNTHAL_TEXTUREDESTROYDATA {}
impl ::std::default::Default for D3DNTHAL_TEXTUREDESTROYDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_TEXTUREDESTROYDATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_TEXTUREDESTROYDATA")
            .field("dwhContext", &self.dwhContext)
            .field("dwHandle", &self.dwHandle)
            .field("ddrval", &self.ddrval)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_TEXTUREDESTROYDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwhContext == other.dwhContext
            && self.dwHandle == other.dwHandle
            && self.ddrval == other.ddrval
    }
}
impl ::std::cmp::Eq for D3DNTHAL_TEXTUREDESTROYDATA {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_TEXTUREDESTROYDATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct D3DNTHAL_TEXTUREGETSURFDATA {
    pub dwhContext: usize,
    pub hDDS: super::super::Foundation::HANDLE,
    pub dwHandle: usize,
    pub ddrval: ::windows::runtime::HRESULT,
}
#[cfg(feature = "Win32_Foundation")]
impl D3DNTHAL_TEXTUREGETSURFDATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for D3DNTHAL_TEXTUREGETSURFDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for D3DNTHAL_TEXTUREGETSURFDATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_TEXTUREGETSURFDATA")
            .field("dwhContext", &self.dwhContext)
            .field("hDDS", &self.hDDS)
            .field("dwHandle", &self.dwHandle)
            .field("ddrval", &self.ddrval)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for D3DNTHAL_TEXTUREGETSURFDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwhContext == other.dwhContext
            && self.hDDS == other.hDDS
            && self.dwHandle == other.dwHandle
            && self.ddrval == other.ddrval
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for D3DNTHAL_TEXTUREGETSURFDATA {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for D3DNTHAL_TEXTUREGETSURFDATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_TEXTURESWAPDATA {
    pub dwhContext: usize,
    pub dwHandle1: usize,
    pub dwHandle2: usize,
    pub ddrval: ::windows::runtime::HRESULT,
}
impl D3DNTHAL_TEXTURESWAPDATA {}
impl ::std::default::Default for D3DNTHAL_TEXTURESWAPDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_TEXTURESWAPDATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_TEXTURESWAPDATA")
            .field("dwhContext", &self.dwhContext)
            .field("dwHandle1", &self.dwHandle1)
            .field("dwHandle2", &self.dwHandle2)
            .field("ddrval", &self.ddrval)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_TEXTURESWAPDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwhContext == other.dwhContext
            && self.dwHandle1 == other.dwHandle1
            && self.dwHandle2 == other.dwHandle2
            && self.ddrval == other.ddrval
    }
}
impl ::std::cmp::Eq for D3DNTHAL_TEXTURESWAPDATA {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_TEXTURESWAPDATA {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DNTHAL_TSS_MAXSTAGES: u32 = 8u32;
pub const D3DNTHAL_TSS_RENDERSTATEBASE: u32 = 256u32;
pub const D3DNTHAL_TSS_STATESPERSTAGE: u32 = 64u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA {
    pub dwhContext: usize,
    pub dwFlags: u32,
    pub dwReserved: usize,
    pub dwNumPasses: u32,
    pub ddrval: ::windows::runtime::HRESULT,
}
impl D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA {}
impl ::std::default::Default for D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA")
            .field("dwhContext", &self.dwhContext)
            .field("dwFlags", &self.dwFlags)
            .field("dwReserved", &self.dwReserved)
            .field("dwNumPasses", &self.dwNumPasses)
            .field("ddrval", &self.ddrval)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwhContext == other.dwhContext
            && self.dwFlags == other.dwFlags
            && self.dwReserved == other.dwReserved
            && self.dwNumPasses == other.dwNumPasses
            && self.ddrval == other.ddrval
    }
}
impl ::std::cmp::Eq for D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA {}
unsafe impl ::windows::runtime::Abi for D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct D3DOPCODE(pub i32);
pub const D3DOP_POINT: D3DOPCODE = D3DOPCODE(1i32);
pub const D3DOP_LINE: D3DOPCODE = D3DOPCODE(2i32);
pub const D3DOP_TRIANGLE: D3DOPCODE = D3DOPCODE(3i32);
pub const D3DOP_MATRIXLOAD: D3DOPCODE = D3DOPCODE(4i32);
pub const D3DOP_MATRIXMULTIPLY: D3DOPCODE = D3DOPCODE(5i32);
pub const D3DOP_STATETRANSFORM: D3DOPCODE = D3DOPCODE(6i32);
pub const D3DOP_STATELIGHT: D3DOPCODE = D3DOPCODE(7i32);
pub const D3DOP_STATERENDER: D3DOPCODE = D3DOPCODE(8i32);
pub const D3DOP_PROCESSVERTICES: D3DOPCODE = D3DOPCODE(9i32);
pub const D3DOP_TEXTURELOAD: D3DOPCODE = D3DOPCODE(10i32);
pub const D3DOP_EXIT: D3DOPCODE = D3DOPCODE(11i32);
pub const D3DOP_BRANCHFORWARD: D3DOPCODE = D3DOPCODE(12i32);
pub const D3DOP_SPAN: D3DOPCODE = D3DOPCODE(13i32);
pub const D3DOP_SETSTATUS: D3DOPCODE = D3DOPCODE(14i32);
pub const D3DOP_FORCE_DWORD: D3DOPCODE = D3DOPCODE(2147483647i32);
impl ::std::convert::From<i32> for D3DOPCODE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for D3DOPCODE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DPAL_FREE: u32 = 0u32;
pub const D3DPAL_READONLY: u32 = 64u32;
pub const D3DPAL_RESERVED: u32 = 128u32;
pub const D3DPBLENDCAPS_BOTHINVSRCALPHA: i32 = 4096i32;
pub const D3DPBLENDCAPS_BOTHSRCALPHA: i32 = 2048i32;
pub const D3DPBLENDCAPS_DESTALPHA: i32 = 64i32;
pub const D3DPBLENDCAPS_DESTCOLOR: i32 = 256i32;
pub const D3DPBLENDCAPS_INVDESTALPHA: i32 = 128i32;
pub const D3DPBLENDCAPS_INVDESTCOLOR: i32 = 512i32;
pub const D3DPBLENDCAPS_INVSRCALPHA: i32 = 32i32;
pub const D3DPBLENDCAPS_INVSRCCOLOR: i32 = 8i32;
pub const D3DPBLENDCAPS_ONE: i32 = 2i32;
pub const D3DPBLENDCAPS_SRCALPHA: i32 = 16i32;
pub const D3DPBLENDCAPS_SRCALPHASAT: i32 = 1024i32;
pub const D3DPBLENDCAPS_SRCCOLOR: i32 = 4i32;
pub const D3DPBLENDCAPS_ZERO: i32 = 1i32;
pub const D3DPCMPCAPS_ALWAYS: i32 = 128i32;
pub const D3DPCMPCAPS_EQUAL: i32 = 4i32;
pub const D3DPCMPCAPS_GREATER: i32 = 16i32;
pub const D3DPCMPCAPS_GREATEREQUAL: i32 = 64i32;
pub const D3DPCMPCAPS_LESS: i32 = 2i32;
pub const D3DPCMPCAPS_LESSEQUAL: i32 = 8i32;
pub const D3DPCMPCAPS_NEVER: i32 = 1i32;
pub const D3DPCMPCAPS_NOTEQUAL: i32 = 32i32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DPICKRECORD {
    pub bOpcode: u8,
    pub bPad: u8,
    pub dwOffset: u32,
    pub dvZ: f32,
}
impl D3DPICKRECORD {}
impl ::std::default::Default for D3DPICKRECORD {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DPICKRECORD {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DPICKRECORD")
            .field("bOpcode", &self.bOpcode)
            .field("bPad", &self.bPad)
            .field("dwOffset", &self.dwOffset)
            .field("dvZ", &self.dvZ)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DPICKRECORD {
    fn eq(&self, other: &Self) -> bool {
        self.bOpcode == other.bOpcode
            && self.bPad == other.bPad
            && self.dwOffset == other.dwOffset
            && self.dvZ == other.dvZ
    }
}
impl ::std::cmp::Eq for D3DPICKRECORD {}
unsafe impl ::windows::runtime::Abi for D3DPICKRECORD {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DPMISCCAPS_CONFORMANT: i32 = 8i32;
pub const D3DPMISCCAPS_CULLCCW: i32 = 64i32;
pub const D3DPMISCCAPS_CULLCW: i32 = 32i32;
pub const D3DPMISCCAPS_CULLNONE: i32 = 16i32;
pub const D3DPMISCCAPS_LINEPATTERNREP: i32 = 4i32;
pub const D3DPMISCCAPS_MASKPLANES: i32 = 1i32;
pub const D3DPMISCCAPS_MASKZ: i32 = 2i32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DPOINT {
    pub wCount: u16,
    pub wFirst: u16,
}
impl D3DPOINT {}
impl ::std::default::Default for D3DPOINT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DPOINT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DPOINT")
            .field("wCount", &self.wCount)
            .field("wFirst", &self.wFirst)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DPOINT {
    fn eq(&self, other: &Self) -> bool {
        self.wCount == other.wCount && self.wFirst == other.wFirst
    }
}
impl ::std::cmp::Eq for D3DPOINT {}
unsafe impl ::windows::runtime::Abi for D3DPOINT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DPRASTERCAPS_ANISOTROPY: i32 = 131072i32;
pub const D3DPRASTERCAPS_ANTIALIASEDGES: i32 = 4096i32;
pub const D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT: i32 = 1024i32;
pub const D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT: i32 = 2048i32;
pub const D3DPRASTERCAPS_DITHER: i32 = 1i32;
pub const D3DPRASTERCAPS_FOGRANGE: i32 = 65536i32;
pub const D3DPRASTERCAPS_FOGTABLE: i32 = 256i32;
pub const D3DPRASTERCAPS_FOGVERTEX: i32 = 128i32;
pub const D3DPRASTERCAPS_MIPMAPLODBIAS: i32 = 8192i32;
pub const D3DPRASTERCAPS_PAT: i32 = 8i32;
pub const D3DPRASTERCAPS_ROP2: i32 = 2i32;
pub const D3DPRASTERCAPS_STIPPLE: i32 = 512i32;
pub const D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE: i32 = 8388608i32;
pub const D3DPRASTERCAPS_SUBPIXEL: i32 = 32i32;
pub const D3DPRASTERCAPS_SUBPIXELX: i32 = 64i32;
pub const D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT: i32 = 524288i32;
pub const D3DPRASTERCAPS_WBUFFER: i32 = 262144i32;
pub const D3DPRASTERCAPS_WFOG: i32 = 1048576i32;
pub const D3DPRASTERCAPS_XOR: i32 = 4i32;
pub const D3DPRASTERCAPS_ZBIAS: i32 = 16384i32;
pub const D3DPRASTERCAPS_ZBUFFERLESSHSR: i32 = 32768i32;
pub const D3DPRASTERCAPS_ZFOG: i32 = 2097152i32;
pub const D3DPRASTERCAPS_ZTEST: i32 = 16i32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DPROCESSVERTICES {
    pub dwFlags: u32,
    pub wStart: u16,
    pub wDest: u16,
    pub dwCount: u32,
    pub dwReserved: u32,
}
impl D3DPROCESSVERTICES {}
impl ::std::default::Default for D3DPROCESSVERTICES {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DPROCESSVERTICES {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DPROCESSVERTICES")
            .field("dwFlags", &self.dwFlags)
            .field("wStart", &self.wStart)
            .field("wDest", &self.wDest)
            .field("dwCount", &self.dwCount)
            .field("dwReserved", &self.dwReserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DPROCESSVERTICES {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags
            && self.wStart == other.wStart
            && self.wDest == other.wDest
            && self.dwCount == other.dwCount
            && self.dwReserved == other.dwReserved
    }
}
impl ::std::cmp::Eq for D3DPROCESSVERTICES {}
unsafe impl ::windows::runtime::Abi for D3DPROCESSVERTICES {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DPROCESSVERTICES_COPY: i32 = 2i32;
pub const D3DPROCESSVERTICES_NOCOLOR: i32 = 16i32;
pub const D3DPROCESSVERTICES_OPMASK: i32 = 7i32;
pub const D3DPROCESSVERTICES_TRANSFORM: i32 = 1i32;
pub const D3DPROCESSVERTICES_TRANSFORMLIGHT: i32 = 0i32;
pub const D3DPROCESSVERTICES_UPDATEEXTENTS: i32 = 8i32;
pub const D3DPSHADECAPS_ALPHAFLATBLEND: i32 = 4096i32;
pub const D3DPSHADECAPS_ALPHAFLATSTIPPLED: i32 = 8192i32;
pub const D3DPSHADECAPS_ALPHAGOURAUDBLEND: i32 = 16384i32;
pub const D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED: i32 = 32768i32;
pub const D3DPSHADECAPS_ALPHAPHONGBLEND: i32 = 65536i32;
pub const D3DPSHADECAPS_ALPHAPHONGSTIPPLED: i32 = 131072i32;
pub const D3DPSHADECAPS_COLORFLATMONO: i32 = 1i32;
pub const D3DPSHADECAPS_COLORFLATRGB: i32 = 2i32;
pub const D3DPSHADECAPS_COLORGOURAUDMONO: i32 = 4i32;
pub const D3DPSHADECAPS_COLORGOURAUDRGB: i32 = 8i32;
pub const D3DPSHADECAPS_COLORPHONGMONO: i32 = 16i32;
pub const D3DPSHADECAPS_COLORPHONGRGB: i32 = 32i32;
pub const D3DPSHADECAPS_FOGFLAT: i32 = 262144i32;
pub const D3DPSHADECAPS_FOGGOURAUD: i32 = 524288i32;
pub const D3DPSHADECAPS_FOGPHONG: i32 = 1048576i32;
pub const D3DPSHADECAPS_SPECULARFLATMONO: i32 = 64i32;
pub const D3DPSHADECAPS_SPECULARFLATRGB: i32 = 128i32;
pub const D3DPSHADECAPS_SPECULARGOURAUDMONO: i32 = 256i32;
pub const D3DPSHADECAPS_SPECULARGOURAUDRGB: i32 = 512i32;
pub const D3DPSHADECAPS_SPECULARPHONGMONO: i32 = 1024i32;
pub const D3DPSHADECAPS_SPECULARPHONGRGB: i32 = 2048i32;
pub const D3DPTADDRESSCAPS_BORDER: i32 = 8i32;
pub const D3DPTADDRESSCAPS_CLAMP: i32 = 4i32;
pub const D3DPTADDRESSCAPS_INDEPENDENTUV: i32 = 16i32;
pub const D3DPTADDRESSCAPS_MIRROR: i32 = 2i32;
pub const D3DPTADDRESSCAPS_WRAP: i32 = 1i32;
pub const D3DPTBLENDCAPS_ADD: i32 = 128i32;
pub const D3DPTBLENDCAPS_COPY: i32 = 64i32;
pub const D3DPTBLENDCAPS_DECAL: i32 = 1i32;
pub const D3DPTBLENDCAPS_DECALALPHA: i32 = 4i32;
pub const D3DPTBLENDCAPS_DECALMASK: i32 = 16i32;
pub const D3DPTBLENDCAPS_MODULATE: i32 = 2i32;
pub const D3DPTBLENDCAPS_MODULATEALPHA: i32 = 8i32;
pub const D3DPTBLENDCAPS_MODULATEMASK: i32 = 32i32;
pub const D3DPTEXTURECAPS_ALPHA: i32 = 4i32;
pub const D3DPTEXTURECAPS_ALPHAPALETTE: i32 = 128i32;
pub const D3DPTEXTURECAPS_BORDER: i32 = 16i32;
pub const D3DPTEXTURECAPS_COLORKEYBLEND: i32 = 4096i32;
pub const D3DPTEXTURECAPS_CUBEMAP: i32 = 2048i32;
pub const D3DPTEXTURECAPS_NONPOW2CONDITIONAL: i32 = 256i32;
pub const D3DPTEXTURECAPS_PERSPECTIVE: i32 = 1i32;
pub const D3DPTEXTURECAPS_POW2: i32 = 2i32;
pub const D3DPTEXTURECAPS_PROJECTED: i32 = 1024i32;
pub const D3DPTEXTURECAPS_SQUAREONLY: i32 = 32i32;
pub const D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE: i32 = 64i32;
pub const D3DPTEXTURECAPS_TRANSPARENCY: i32 = 8i32;
pub const D3DPTFILTERCAPS_LINEAR: i32 = 2i32;
pub const D3DPTFILTERCAPS_LINEARMIPLINEAR: i32 = 32i32;
pub const D3DPTFILTERCAPS_LINEARMIPNEAREST: i32 = 16i32;
pub const D3DPTFILTERCAPS_MAGFAFLATCUBIC: i32 = 134217728i32;
pub const D3DPTFILTERCAPS_MAGFANISOTROPIC: i32 = 67108864i32;
pub const D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC: i32 = 268435456i32;
pub const D3DPTFILTERCAPS_MAGFLINEAR: i32 = 33554432i32;
pub const D3DPTFILTERCAPS_MAGFPOINT: i32 = 16777216i32;
pub const D3DPTFILTERCAPS_MINFANISOTROPIC: i32 = 1024i32;
pub const D3DPTFILTERCAPS_MINFLINEAR: i32 = 512i32;
pub const D3DPTFILTERCAPS_MINFPOINT: i32 = 256i32;
pub const D3DPTFILTERCAPS_MIPFLINEAR: i32 = 131072i32;
pub const D3DPTFILTERCAPS_MIPFPOINT: i32 = 65536i32;
pub const D3DPTFILTERCAPS_MIPLINEAR: i32 = 8i32;
pub const D3DPTFILTERCAPS_MIPNEAREST: i32 = 4i32;
pub const D3DPTFILTERCAPS_NEAREST: i32 = 1i32;
pub const D3DPV_DONOTCOPYDATA: u32 = 1u32;
pub const D3DRENDERSTATE_EVICTMANAGEDTEXTURES: u32 = 61u32;
pub const D3DRENDERSTATE_SCENECAPTURE: u32 = 62u32;
pub const D3DRENDERSTATE_WRAPBIAS: u32 = 128u32;
pub const D3DRS_MAXPIXELSHADERINST: u32 = 197u32;
pub const D3DRS_MAXVERTEXSHADERINST: u32 = 196u32;
pub const D3DSETSTATUS_EXTENTS: i32 = 2i32;
pub const D3DSETSTATUS_STATUS: i32 = 1i32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DSPAN {
    pub wCount: u16,
    pub wFirst: u16,
}
impl D3DSPAN {}
impl ::std::default::Default for D3DSPAN {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DSPAN {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DSPAN")
            .field("wCount", &self.wCount)
            .field("wFirst", &self.wFirst)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DSPAN {
    fn eq(&self, other: &Self) -> bool {
        self.wCount == other.wCount && self.wFirst == other.wFirst
    }
}
impl ::std::cmp::Eq for D3DSPAN {}
unsafe impl ::windows::runtime::Abi for D3DSPAN {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct D3DSTATE {
    pub Anonymous1: D3DSTATE_0,
    pub Anonymous2: D3DSTATE_1,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DSTATE {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DSTATE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DSTATE {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DSTATE {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DSTATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub union D3DSTATE_0 {
    pub dtstTransformStateType: super::super::Graphics::Direct3D9::D3DTRANSFORMSTATETYPE,
    pub dlstLightStateType: D3DLIGHTSTATETYPE,
    pub drstRenderStateType: super::super::Graphics::Direct3D9::D3DRENDERSTATETYPE,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DSTATE_0 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DSTATE_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DSTATE_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DSTATE_0 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DSTATE_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DSTATE_1 {
    pub dwArg: [u32; 1],
    pub dvArg: [f32; 1],
}
impl D3DSTATE_1 {}
impl ::std::default::Default for D3DSTATE_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DSTATE_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DSTATE_1 {}
unsafe impl ::windows::runtime::Abi for D3DSTATE_1 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DSTATE_OVERRIDE_BIAS: u32 = 256u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DSTATS {
    pub dwSize: u32,
    pub dwTrianglesDrawn: u32,
    pub dwLinesDrawn: u32,
    pub dwPointsDrawn: u32,
    pub dwSpansDrawn: u32,
    pub dwVerticesProcessed: u32,
}
impl D3DSTATS {}
impl ::std::default::Default for D3DSTATS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DSTATS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DSTATS")
            .field("dwSize", &self.dwSize)
            .field("dwTrianglesDrawn", &self.dwTrianglesDrawn)
            .field("dwLinesDrawn", &self.dwLinesDrawn)
            .field("dwPointsDrawn", &self.dwPointsDrawn)
            .field("dwSpansDrawn", &self.dwSpansDrawn)
            .field("dwVerticesProcessed", &self.dwVerticesProcessed)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DSTATS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwTrianglesDrawn == other.dwTrianglesDrawn
            && self.dwLinesDrawn == other.dwLinesDrawn
            && self.dwPointsDrawn == other.dwPointsDrawn
            && self.dwSpansDrawn == other.dwSpansDrawn
            && self.dwVerticesProcessed == other.dwVerticesProcessed
    }
}
impl ::std::cmp::Eq for D3DSTATS {}
unsafe impl ::windows::runtime::Abi for D3DSTATS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct D3DSTATUS {
    pub dwFlags: u32,
    pub dwStatus: u32,
    pub drExtent: super::super::Graphics::Direct3D9::D3DRECT,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DSTATUS {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DSTATUS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::fmt::Debug for D3DSTATUS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DSTATUS")
            .field("dwFlags", &self.dwFlags)
            .field("dwStatus", &self.dwStatus)
            .field("drExtent", &self.drExtent)
            .finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DSTATUS {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags
            && self.dwStatus == other.dwStatus
            && self.drExtent == other.drExtent
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DSTATUS {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DSTATUS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DSTATUS_CLIPINTERSECTIONBACK: i32 = 131072i32;
pub const D3DSTATUS_CLIPINTERSECTIONBOTTOM: i32 = 32768i32;
pub const D3DSTATUS_CLIPINTERSECTIONFRONT: i32 = 65536i32;
pub const D3DSTATUS_CLIPINTERSECTIONGEN0: i32 = 262144i32;
pub const D3DSTATUS_CLIPINTERSECTIONGEN1: i32 = 524288i32;
pub const D3DSTATUS_CLIPINTERSECTIONGEN2: i32 = 1048576i32;
pub const D3DSTATUS_CLIPINTERSECTIONGEN3: i32 = 2097152i32;
pub const D3DSTATUS_CLIPINTERSECTIONGEN4: i32 = 4194304i32;
pub const D3DSTATUS_CLIPINTERSECTIONGEN5: i32 = 8388608i32;
pub const D3DSTATUS_CLIPINTERSECTIONLEFT: i32 = 4096i32;
pub const D3DSTATUS_CLIPINTERSECTIONRIGHT: i32 = 8192i32;
pub const D3DSTATUS_CLIPINTERSECTIONTOP: i32 = 16384i32;
pub const D3DSTATUS_CLIPUNIONBACK: i32 = 32i32;
pub const D3DSTATUS_CLIPUNIONBOTTOM: i32 = 8i32;
pub const D3DSTATUS_CLIPUNIONFRONT: i32 = 16i32;
pub const D3DSTATUS_CLIPUNIONGEN0: i32 = 64i32;
pub const D3DSTATUS_CLIPUNIONGEN1: i32 = 128i32;
pub const D3DSTATUS_CLIPUNIONGEN2: i32 = 256i32;
pub const D3DSTATUS_CLIPUNIONGEN3: i32 = 512i32;
pub const D3DSTATUS_CLIPUNIONGEN4: i32 = 1024i32;
pub const D3DSTATUS_CLIPUNIONGEN5: i32 = 2048i32;
pub const D3DSTATUS_CLIPUNIONLEFT: i32 = 1i32;
pub const D3DSTATUS_CLIPUNIONRIGHT: i32 = 2i32;
pub const D3DSTATUS_CLIPUNIONTOP: i32 = 4i32;
pub const D3DSTATUS_ZNOTVISIBLE: i32 = 16777216i32;
pub const D3DSTENCILCAPS_DECR: i32 = 128i32;
pub const D3DSTENCILCAPS_DECRSAT: i32 = 16i32;
pub const D3DSTENCILCAPS_INCR: i32 = 64i32;
pub const D3DSTENCILCAPS_INCRSAT: i32 = 8i32;
pub const D3DSTENCILCAPS_INVERT: i32 = 32i32;
pub const D3DSTENCILCAPS_KEEP: i32 = 1i32;
pub const D3DSTENCILCAPS_REPLACE: i32 = 4i32;
pub const D3DSTENCILCAPS_ZERO: i32 = 2i32;
pub const D3DTA_ALPHAREPLICATE: u32 = 32u32;
pub const D3DTA_COMPLEMENT: u32 = 16u32;
pub const D3DTA_CURRENT: u32 = 1u32;
pub const D3DTA_DIFFUSE: u32 = 0u32;
pub const D3DTA_SELECTMASK: u32 = 15u32;
pub const D3DTA_SPECULAR: u32 = 4u32;
pub const D3DTA_TEXTURE: u32 = 2u32;
pub const D3DTA_TFACTOR: u32 = 3u32;
pub const D3DTEXOPCAPS_ADD: i32 = 64i32;
pub const D3DTEXOPCAPS_ADDSIGNED: i32 = 128i32;
pub const D3DTEXOPCAPS_ADDSIGNED2X: i32 = 256i32;
pub const D3DTEXOPCAPS_ADDSMOOTH: i32 = 1024i32;
pub const D3DTEXOPCAPS_BLENDCURRENTALPHA: i32 = 32768i32;
pub const D3DTEXOPCAPS_BLENDDIFFUSEALPHA: i32 = 2048i32;
pub const D3DTEXOPCAPS_BLENDFACTORALPHA: i32 = 8192i32;
pub const D3DTEXOPCAPS_BLENDTEXTUREALPHA: i32 = 4096i32;
pub const D3DTEXOPCAPS_BLENDTEXTUREALPHAPM: i32 = 16384i32;
pub const D3DTEXOPCAPS_BUMPENVMAP: i32 = 2097152i32;
pub const D3DTEXOPCAPS_BUMPENVMAPLUMINANCE: i32 = 4194304i32;
pub const D3DTEXOPCAPS_DISABLE: i32 = 1i32;
pub const D3DTEXOPCAPS_DOTPRODUCT3: i32 = 8388608i32;
pub const D3DTEXOPCAPS_MODULATE: i32 = 8i32;
pub const D3DTEXOPCAPS_MODULATE2X: i32 = 16i32;
pub const D3DTEXOPCAPS_MODULATE4X: i32 = 32i32;
pub const D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR: i32 = 131072i32;
pub const D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA: i32 = 262144i32;
pub const D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR: i32 = 524288i32;
pub const D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA: i32 = 1048576i32;
pub const D3DTEXOPCAPS_PREMODULATE: i32 = 65536i32;
pub const D3DTEXOPCAPS_SELECTARG1: i32 = 2i32;
pub const D3DTEXOPCAPS_SELECTARG2: i32 = 4i32;
pub const D3DTEXOPCAPS_SUBTRACT: i32 = 512i32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct D3DTEXTUREBLEND(pub i32);
pub const D3DTBLEND_DECAL: D3DTEXTUREBLEND = D3DTEXTUREBLEND(1i32);
pub const D3DTBLEND_MODULATE: D3DTEXTUREBLEND = D3DTEXTUREBLEND(2i32);
pub const D3DTBLEND_DECALALPHA: D3DTEXTUREBLEND = D3DTEXTUREBLEND(3i32);
pub const D3DTBLEND_MODULATEALPHA: D3DTEXTUREBLEND = D3DTEXTUREBLEND(4i32);
pub const D3DTBLEND_DECALMASK: D3DTEXTUREBLEND = D3DTEXTUREBLEND(5i32);
pub const D3DTBLEND_MODULATEMASK: D3DTEXTUREBLEND = D3DTEXTUREBLEND(6i32);
pub const D3DTBLEND_COPY: D3DTEXTUREBLEND = D3DTEXTUREBLEND(7i32);
pub const D3DTBLEND_ADD: D3DTEXTUREBLEND = D3DTEXTUREBLEND(8i32);
pub const D3DTBLEND_FORCE_DWORD: D3DTEXTUREBLEND = D3DTEXTUREBLEND(2147483647i32);
impl ::std::convert::From<i32> for D3DTEXTUREBLEND {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for D3DTEXTUREBLEND {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct D3DTEXTUREFILTER(pub i32);
pub const D3DFILTER_NEAREST: D3DTEXTUREFILTER = D3DTEXTUREFILTER(1i32);
pub const D3DFILTER_LINEAR: D3DTEXTUREFILTER = D3DTEXTUREFILTER(2i32);
pub const D3DFILTER_MIPNEAREST: D3DTEXTUREFILTER = D3DTEXTUREFILTER(3i32);
pub const D3DFILTER_MIPLINEAR: D3DTEXTUREFILTER = D3DTEXTUREFILTER(4i32);
pub const D3DFILTER_LINEARMIPNEAREST: D3DTEXTUREFILTER = D3DTEXTUREFILTER(5i32);
pub const D3DFILTER_LINEARMIPLINEAR: D3DTEXTUREFILTER = D3DTEXTUREFILTER(6i32);
pub const D3DFILTER_FORCE_DWORD: D3DTEXTUREFILTER = D3DTEXTUREFILTER(2147483647i32);
impl ::std::convert::From<i32> for D3DTEXTUREFILTER {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for D3DTEXTUREFILTER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DTEXTURELOAD {
    pub hDestTexture: u32,
    pub hSrcTexture: u32,
}
impl D3DTEXTURELOAD {}
impl ::std::default::Default for D3DTEXTURELOAD {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DTEXTURELOAD {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DTEXTURELOAD")
            .field("hDestTexture", &self.hDestTexture)
            .field("hSrcTexture", &self.hSrcTexture)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DTEXTURELOAD {
    fn eq(&self, other: &Self) -> bool {
        self.hDestTexture == other.hDestTexture && self.hSrcTexture == other.hSrcTexture
    }
}
impl ::std::cmp::Eq for D3DTEXTURELOAD {}
unsafe impl ::windows::runtime::Abi for D3DTEXTURELOAD {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct D3DTEXTUREMAGFILTER(pub i32);
pub const D3DTFG_POINT: D3DTEXTUREMAGFILTER = D3DTEXTUREMAGFILTER(1i32);
pub const D3DTFG_LINEAR: D3DTEXTUREMAGFILTER = D3DTEXTUREMAGFILTER(2i32);
pub const D3DTFG_FLATCUBIC: D3DTEXTUREMAGFILTER = D3DTEXTUREMAGFILTER(3i32);
pub const D3DTFG_GAUSSIANCUBIC: D3DTEXTUREMAGFILTER = D3DTEXTUREMAGFILTER(4i32);
pub const D3DTFG_ANISOTROPIC: D3DTEXTUREMAGFILTER = D3DTEXTUREMAGFILTER(5i32);
pub const D3DTFG_FORCE_DWORD: D3DTEXTUREMAGFILTER = D3DTEXTUREMAGFILTER(2147483647i32);
impl ::std::convert::From<i32> for D3DTEXTUREMAGFILTER {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for D3DTEXTUREMAGFILTER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct D3DTEXTUREMINFILTER(pub i32);
pub const D3DTFN_POINT: D3DTEXTUREMINFILTER = D3DTEXTUREMINFILTER(1i32);
pub const D3DTFN_LINEAR: D3DTEXTUREMINFILTER = D3DTEXTUREMINFILTER(2i32);
pub const D3DTFN_ANISOTROPIC: D3DTEXTUREMINFILTER = D3DTEXTUREMINFILTER(3i32);
pub const D3DTFN_FORCE_DWORD: D3DTEXTUREMINFILTER = D3DTEXTUREMINFILTER(2147483647i32);
impl ::std::convert::From<i32> for D3DTEXTUREMINFILTER {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for D3DTEXTUREMINFILTER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct D3DTEXTUREMIPFILTER(pub i32);
pub const D3DTFP_NONE: D3DTEXTUREMIPFILTER = D3DTEXTUREMIPFILTER(1i32);
pub const D3DTFP_POINT: D3DTEXTUREMIPFILTER = D3DTEXTUREMIPFILTER(2i32);
pub const D3DTFP_LINEAR: D3DTEXTUREMIPFILTER = D3DTEXTUREMIPFILTER(3i32);
pub const D3DTFP_FORCE_DWORD: D3DTEXTUREMIPFILTER = D3DTEXTUREMIPFILTER(2147483647i32);
impl ::std::convert::From<i32> for D3DTEXTUREMIPFILTER {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for D3DTEXTUREMIPFILTER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DTLVERTEX {
    pub Anonymous1: D3DTLVERTEX_0,
    pub Anonymous2: D3DTLVERTEX_1,
    pub Anonymous3: D3DTLVERTEX_2,
    pub Anonymous4: D3DTLVERTEX_3,
    pub Anonymous5: D3DTLVERTEX_4,
    pub Anonymous6: D3DTLVERTEX_5,
    pub Anonymous7: D3DTLVERTEX_6,
    pub Anonymous8: D3DTLVERTEX_7,
}
impl D3DTLVERTEX {}
impl ::std::default::Default for D3DTLVERTEX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DTLVERTEX {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DTLVERTEX {}
unsafe impl ::windows::runtime::Abi for D3DTLVERTEX {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DTLVERTEX_0 {
    pub sx: f32,
    pub dvSX: f32,
}
impl D3DTLVERTEX_0 {}
impl ::std::default::Default for D3DTLVERTEX_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DTLVERTEX_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DTLVERTEX_0 {}
unsafe impl ::windows::runtime::Abi for D3DTLVERTEX_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DTLVERTEX_1 {
    pub sy: f32,
    pub dvSY: f32,
}
impl D3DTLVERTEX_1 {}
impl ::std::default::Default for D3DTLVERTEX_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DTLVERTEX_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DTLVERTEX_1 {}
unsafe impl ::windows::runtime::Abi for D3DTLVERTEX_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DTLVERTEX_2 {
    pub sz: f32,
    pub dvSZ: f32,
}
impl D3DTLVERTEX_2 {}
impl ::std::default::Default for D3DTLVERTEX_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DTLVERTEX_2 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DTLVERTEX_2 {}
unsafe impl ::windows::runtime::Abi for D3DTLVERTEX_2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DTLVERTEX_3 {
    pub rhw: f32,
    pub dvRHW: f32,
}
impl D3DTLVERTEX_3 {}
impl ::std::default::Default for D3DTLVERTEX_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DTLVERTEX_3 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DTLVERTEX_3 {}
unsafe impl ::windows::runtime::Abi for D3DTLVERTEX_3 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DTLVERTEX_4 {
    pub color: u32,
    pub dcColor: u32,
}
impl D3DTLVERTEX_4 {}
impl ::std::default::Default for D3DTLVERTEX_4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DTLVERTEX_4 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DTLVERTEX_4 {}
unsafe impl ::windows::runtime::Abi for D3DTLVERTEX_4 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DTLVERTEX_5 {
    pub specular: u32,
    pub dcSpecular: u32,
}
impl D3DTLVERTEX_5 {}
impl ::std::default::Default for D3DTLVERTEX_5 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DTLVERTEX_5 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DTLVERTEX_5 {}
unsafe impl ::windows::runtime::Abi for D3DTLVERTEX_5 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DTLVERTEX_6 {
    pub tu: f32,
    pub dvTU: f32,
}
impl D3DTLVERTEX_6 {}
impl ::std::default::Default for D3DTLVERTEX_6 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DTLVERTEX_6 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DTLVERTEX_6 {}
unsafe impl ::windows::runtime::Abi for D3DTLVERTEX_6 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DTLVERTEX_7 {
    pub tv: f32,
    pub dvTV: f32,
}
impl D3DTLVERTEX_7 {}
impl ::std::default::Default for D3DTLVERTEX_7 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DTLVERTEX_7 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DTLVERTEX_7 {}
unsafe impl ::windows::runtime::Abi for D3DTLVERTEX_7 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DTRANSFORMCAPS {
    pub dwSize: u32,
    pub dwCaps: u32,
}
impl D3DTRANSFORMCAPS {}
impl ::std::default::Default for D3DTRANSFORMCAPS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DTRANSFORMCAPS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DTRANSFORMCAPS")
            .field("dwSize", &self.dwSize)
            .field("dwCaps", &self.dwCaps)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DTRANSFORMCAPS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize && self.dwCaps == other.dwCaps
    }
}
impl ::std::cmp::Eq for D3DTRANSFORMCAPS {}
unsafe impl ::windows::runtime::Abi for D3DTRANSFORMCAPS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DTRANSFORMCAPS_CLIP: i32 = 1i32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct D3DTRANSFORMDATA {
    pub dwSize: u32,
    pub lpIn: *mut ::std::ffi::c_void,
    pub dwInSize: u32,
    pub lpOut: *mut ::std::ffi::c_void,
    pub dwOutSize: u32,
    pub lpHOut: *mut D3DHVERTEX,
    pub dwClip: u32,
    pub dwClipIntersection: u32,
    pub dwClipUnion: u32,
    pub drExtent: super::super::Graphics::Direct3D9::D3DRECT,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl D3DTRANSFORMDATA {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::default::Default for D3DTRANSFORMDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::fmt::Debug for D3DTRANSFORMDATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DTRANSFORMDATA")
            .field("dwSize", &self.dwSize)
            .field("lpIn", &self.lpIn)
            .field("dwInSize", &self.dwInSize)
            .field("lpOut", &self.lpOut)
            .field("dwOutSize", &self.dwOutSize)
            .field("lpHOut", &self.lpHOut)
            .field("dwClip", &self.dwClip)
            .field("dwClipIntersection", &self.dwClipIntersection)
            .field("dwClipUnion", &self.dwClipUnion)
            .field("drExtent", &self.drExtent)
            .finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::PartialEq for D3DTRANSFORMDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.lpIn == other.lpIn
            && self.dwInSize == other.dwInSize
            && self.lpOut == other.lpOut
            && self.dwOutSize == other.dwOutSize
            && self.lpHOut == other.lpHOut
            && self.dwClip == other.dwClip
            && self.dwClipIntersection == other.dwClipIntersection
            && self.dwClipUnion == other.dwClipUnion
            && self.drExtent == other.drExtent
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::std::cmp::Eq for D3DTRANSFORMDATA {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
unsafe impl ::windows::runtime::Abi for D3DTRANSFORMDATA {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DTRANSFORM_CLIPPED: i32 = 1i32;
pub const D3DTRANSFORM_UNCLIPPED: i32 = 2i32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DTRIANGLE {
    pub Anonymous1: D3DTRIANGLE_0,
    pub Anonymous2: D3DTRIANGLE_1,
    pub Anonymous3: D3DTRIANGLE_2,
    pub wFlags: u16,
}
impl D3DTRIANGLE {}
impl ::std::default::Default for D3DTRIANGLE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DTRIANGLE {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DTRIANGLE {}
unsafe impl ::windows::runtime::Abi for D3DTRIANGLE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DTRIANGLE_0 {
    pub v1: u16,
    pub wV1: u16,
}
impl D3DTRIANGLE_0 {}
impl ::std::default::Default for D3DTRIANGLE_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DTRIANGLE_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DTRIANGLE_0 {}
unsafe impl ::windows::runtime::Abi for D3DTRIANGLE_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DTRIANGLE_1 {
    pub v2: u16,
    pub wV2: u16,
}
impl D3DTRIANGLE_1 {}
impl ::std::default::Default for D3DTRIANGLE_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DTRIANGLE_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DTRIANGLE_1 {}
unsafe impl ::windows::runtime::Abi for D3DTRIANGLE_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DTRIANGLE_2 {
    pub v3: u16,
    pub wV3: u16,
}
impl D3DTRIANGLE_2 {}
impl ::std::default::Default for D3DTRIANGLE_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DTRIANGLE_2 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DTRIANGLE_2 {}
unsafe impl ::windows::runtime::Abi for D3DTRIANGLE_2 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DTRIFLAG_EDGEENABLE1: i32 = 256i32;
pub const D3DTRIFLAG_EDGEENABLE2: i32 = 512i32;
pub const D3DTRIFLAG_EDGEENABLE3: i32 = 1024i32;
pub const D3DTRIFLAG_EVEN: i32 = 31i32;
pub const D3DTRIFLAG_ODD: i32 = 30i32;
pub const D3DTRIFLAG_START: i32 = 0i32;
pub const D3DTSS_TCI_CAMERASPACENORMAL: u32 = 65536u32;
pub const D3DTSS_TCI_CAMERASPACEPOSITION: u32 = 131072u32;
pub const D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR: u32 = 196608u32;
pub const D3DTSS_TCI_PASSTHRU: u32 = 0u32;
pub const D3DTSS_TEXTUREMAP: u32 = 0u32;
pub const D3DVBCAPS_DONOTCLIP: i32 = 1i32;
pub const D3DVBCAPS_OPTIMIZED: i32 = -2147483648i32;
pub const D3DVBCAPS_SYSTEMMEMORY: i32 = 2048i32;
pub const D3DVBCAPS_WRITEONLY: i32 = 65536i32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DVERTEX {
    pub Anonymous1: D3DVERTEX_0,
    pub Anonymous2: D3DVERTEX_1,
    pub Anonymous3: D3DVERTEX_2,
    pub Anonymous4: D3DVERTEX_3,
    pub Anonymous5: D3DVERTEX_4,
    pub Anonymous6: D3DVERTEX_5,
    pub Anonymous7: D3DVERTEX_6,
    pub Anonymous8: D3DVERTEX_7,
}
impl D3DVERTEX {}
impl ::std::default::Default for D3DVERTEX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DVERTEX {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DVERTEX {}
unsafe impl ::windows::runtime::Abi for D3DVERTEX {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DVERTEX_0 {
    pub x: f32,
    pub dvX: f32,
}
impl D3DVERTEX_0 {}
impl ::std::default::Default for D3DVERTEX_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DVERTEX_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DVERTEX_0 {}
unsafe impl ::windows::runtime::Abi for D3DVERTEX_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DVERTEX_1 {
    pub y: f32,
    pub dvY: f32,
}
impl D3DVERTEX_1 {}
impl ::std::default::Default for D3DVERTEX_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DVERTEX_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DVERTEX_1 {}
unsafe impl ::windows::runtime::Abi for D3DVERTEX_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DVERTEX_2 {
    pub z: f32,
    pub dvZ: f32,
}
impl D3DVERTEX_2 {}
impl ::std::default::Default for D3DVERTEX_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DVERTEX_2 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DVERTEX_2 {}
unsafe impl ::windows::runtime::Abi for D3DVERTEX_2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DVERTEX_3 {
    pub nx: f32,
    pub dvNX: f32,
}
impl D3DVERTEX_3 {}
impl ::std::default::Default for D3DVERTEX_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DVERTEX_3 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DVERTEX_3 {}
unsafe impl ::windows::runtime::Abi for D3DVERTEX_3 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DVERTEX_4 {
    pub ny: f32,
    pub dvNY: f32,
}
impl D3DVERTEX_4 {}
impl ::std::default::Default for D3DVERTEX_4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DVERTEX_4 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DVERTEX_4 {}
unsafe impl ::windows::runtime::Abi for D3DVERTEX_4 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DVERTEX_5 {
    pub nz: f32,
    pub dvNZ: f32,
}
impl D3DVERTEX_5 {}
impl ::std::default::Default for D3DVERTEX_5 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DVERTEX_5 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DVERTEX_5 {}
unsafe impl ::windows::runtime::Abi for D3DVERTEX_5 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DVERTEX_6 {
    pub tu: f32,
    pub dvTU: f32,
}
impl D3DVERTEX_6 {}
impl ::std::default::Default for D3DVERTEX_6 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DVERTEX_6 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DVERTEX_6 {}
unsafe impl ::windows::runtime::Abi for D3DVERTEX_6 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union D3DVERTEX_7 {
    pub tv: f32,
    pub dvTV: f32,
}
impl D3DVERTEX_7 {}
impl ::std::default::Default for D3DVERTEX_7 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for D3DVERTEX_7 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for D3DVERTEX_7 {}
unsafe impl ::windows::runtime::Abi for D3DVERTEX_7 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DVERTEXBUFFERDESC {
    pub dwSize: u32,
    pub dwCaps: u32,
    pub dwFVF: u32,
    pub dwNumVertices: u32,
}
impl D3DVERTEXBUFFERDESC {}
impl ::std::default::Default for D3DVERTEXBUFFERDESC {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DVERTEXBUFFERDESC {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DVERTEXBUFFERDESC")
            .field("dwSize", &self.dwSize)
            .field("dwCaps", &self.dwCaps)
            .field("dwFVF", &self.dwFVF)
            .field("dwNumVertices", &self.dwNumVertices)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DVERTEXBUFFERDESC {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwCaps == other.dwCaps
            && self.dwFVF == other.dwFVF
            && self.dwNumVertices == other.dwNumVertices
    }
}
impl ::std::cmp::Eq for D3DVERTEXBUFFERDESC {}
unsafe impl ::windows::runtime::Abi for D3DVERTEXBUFFERDESC {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct D3DVERTEXTYPE(pub i32);
pub const D3DVT_VERTEX: D3DVERTEXTYPE = D3DVERTEXTYPE(1i32);
pub const D3DVT_LVERTEX: D3DVERTEXTYPE = D3DVERTEXTYPE(2i32);
pub const D3DVT_TLVERTEX: D3DVERTEXTYPE = D3DVERTEXTYPE(3i32);
pub const D3DVT_FORCE_DWORD: D3DVERTEXTYPE = D3DVERTEXTYPE(2147483647i32);
impl ::std::convert::From<i32> for D3DVERTEXTYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for D3DVERTEXTYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DVIEWPORT {
    pub dwSize: u32,
    pub dwX: u32,
    pub dwY: u32,
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub dvScaleX: f32,
    pub dvScaleY: f32,
    pub dvMaxX: f32,
    pub dvMaxY: f32,
    pub dvMinZ: f32,
    pub dvMaxZ: f32,
}
impl D3DVIEWPORT {}
impl ::std::default::Default for D3DVIEWPORT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DVIEWPORT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DVIEWPORT")
            .field("dwSize", &self.dwSize)
            .field("dwX", &self.dwX)
            .field("dwY", &self.dwY)
            .field("dwWidth", &self.dwWidth)
            .field("dwHeight", &self.dwHeight)
            .field("dvScaleX", &self.dvScaleX)
            .field("dvScaleY", &self.dvScaleY)
            .field("dvMaxX", &self.dvMaxX)
            .field("dvMaxY", &self.dvMaxY)
            .field("dvMinZ", &self.dvMinZ)
            .field("dvMaxZ", &self.dvMaxZ)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DVIEWPORT {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwX == other.dwX
            && self.dwY == other.dwY
            && self.dwWidth == other.dwWidth
            && self.dwHeight == other.dwHeight
            && self.dvScaleX == other.dvScaleX
            && self.dvScaleY == other.dvScaleY
            && self.dvMaxX == other.dvMaxX
            && self.dvMaxY == other.dvMaxY
            && self.dvMinZ == other.dvMinZ
            && self.dvMaxZ == other.dvMaxZ
    }
}
impl ::std::cmp::Eq for D3DVIEWPORT {}
unsafe impl ::windows::runtime::Abi for D3DVIEWPORT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DVIEWPORT2 {
    pub dwSize: u32,
    pub dwX: u32,
    pub dwY: u32,
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub dvClipX: f32,
    pub dvClipY: f32,
    pub dvClipWidth: f32,
    pub dvClipHeight: f32,
    pub dvMinZ: f32,
    pub dvMaxZ: f32,
}
impl D3DVIEWPORT2 {}
impl ::std::default::Default for D3DVIEWPORT2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DVIEWPORT2 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DVIEWPORT2")
            .field("dwSize", &self.dwSize)
            .field("dwX", &self.dwX)
            .field("dwY", &self.dwY)
            .field("dwWidth", &self.dwWidth)
            .field("dwHeight", &self.dwHeight)
            .field("dvClipX", &self.dvClipX)
            .field("dvClipY", &self.dvClipY)
            .field("dvClipWidth", &self.dvClipWidth)
            .field("dvClipHeight", &self.dvClipHeight)
            .field("dvMinZ", &self.dvMinZ)
            .field("dvMaxZ", &self.dvMaxZ)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DVIEWPORT2 {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwX == other.dwX
            && self.dwY == other.dwY
            && self.dwWidth == other.dwWidth
            && self.dwHeight == other.dwHeight
            && self.dvClipX == other.dvClipX
            && self.dvClipY == other.dvClipY
            && self.dvClipWidth == other.dvClipWidth
            && self.dvClipHeight == other.dvClipHeight
            && self.dvMinZ == other.dvMinZ
            && self.dvMaxZ == other.dvMaxZ
    }
}
impl ::std::cmp::Eq for D3DVIEWPORT2 {}
unsafe impl ::windows::runtime::Abi for D3DVIEWPORT2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct D3DVIEWPORT7 {
    pub dwX: u32,
    pub dwY: u32,
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub dvMinZ: f32,
    pub dvMaxZ: f32,
}
impl D3DVIEWPORT7 {}
impl ::std::default::Default for D3DVIEWPORT7 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for D3DVIEWPORT7 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("D3DVIEWPORT7")
            .field("dwX", &self.dwX)
            .field("dwY", &self.dwY)
            .field("dwWidth", &self.dwWidth)
            .field("dwHeight", &self.dwHeight)
            .field("dvMinZ", &self.dvMinZ)
            .field("dvMaxZ", &self.dvMaxZ)
            .finish()
    }
}
impl ::std::cmp::PartialEq for D3DVIEWPORT7 {
    fn eq(&self, other: &Self) -> bool {
        self.dwX == other.dwX
            && self.dwY == other.dwY
            && self.dwWidth == other.dwWidth
            && self.dwHeight == other.dwHeight
            && self.dvMinZ == other.dvMinZ
            && self.dvMaxZ == other.dvMaxZ
    }
}
impl ::std::cmp::Eq for D3DVIEWPORT7 {}
unsafe impl ::windows::runtime::Abi for D3DVIEWPORT7 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const D3DVIS_INSIDE_BOTTOM: u32 = 0u32;
pub const D3DVIS_INSIDE_FAR: u32 = 0u32;
pub const D3DVIS_INSIDE_FRUSTUM: u32 = 0u32;
pub const D3DVIS_INSIDE_LEFT: u32 = 0u32;
pub const D3DVIS_INSIDE_NEAR: u32 = 0u32;
pub const D3DVIS_INSIDE_RIGHT: u32 = 0u32;
pub const D3DVIS_INSIDE_TOP: u32 = 0u32;
pub const D3DVIS_INTERSECT_BOTTOM: u32 = 256u32;
pub const D3DVIS_INTERSECT_FAR: u32 = 4096u32;
pub const D3DVIS_INTERSECT_FRUSTUM: u32 = 1u32;
pub const D3DVIS_INTERSECT_LEFT: u32 = 4u32;
pub const D3DVIS_INTERSECT_NEAR: u32 = 1024u32;
pub const D3DVIS_INTERSECT_RIGHT: u32 = 16u32;
pub const D3DVIS_INTERSECT_TOP: u32 = 64u32;
pub const D3DVIS_MASK_BOTTOM: u32 = 768u32;
pub const D3DVIS_MASK_FAR: u32 = 12288u32;
pub const D3DVIS_MASK_FRUSTUM: u32 = 3u32;
pub const D3DVIS_MASK_LEFT: u32 = 12u32;
pub const D3DVIS_MASK_NEAR: u32 = 3072u32;
pub const D3DVIS_MASK_RIGHT: u32 = 48u32;
pub const D3DVIS_MASK_TOP: u32 = 192u32;
pub const D3DVIS_OUTSIDE_BOTTOM: u32 = 512u32;
pub const D3DVIS_OUTSIDE_FAR: u32 = 8192u32;
pub const D3DVIS_OUTSIDE_FRUSTUM: u32 = 2u32;
pub const D3DVIS_OUTSIDE_LEFT: u32 = 8u32;
pub const D3DVIS_OUTSIDE_NEAR: u32 = 2048u32;
pub const D3DVIS_OUTSIDE_RIGHT: u32 = 32u32;
pub const D3DVIS_OUTSIDE_TOP: u32 = 128u32;
pub const D3DVOP_CLIP: u32 = 4u32;
pub const D3DVOP_EXTENTS: u32 = 8u32;
pub const D3DVOP_LIGHT: u32 = 1024u32;
pub const D3DVOP_TRANSFORM: u32 = 1u32;
pub const D3DVSDE_BLENDINDICES: u32 = 2u32;
pub const D3DVSDE_BLENDWEIGHT: u32 = 1u32;
pub const D3DVSDE_DIFFUSE: u32 = 5u32;
pub const D3DVSDE_NORMAL: u32 = 3u32;
pub const D3DVSDE_NORMAL2: u32 = 16u32;
pub const D3DVSDE_POSITION: u32 = 0u32;
pub const D3DVSDE_POSITION2: u32 = 15u32;
pub const D3DVSDE_PSIZE: u32 = 4u32;
pub const D3DVSDE_SPECULAR: u32 = 6u32;
pub const D3DVSDE_TEXCOORD0: u32 = 7u32;
pub const D3DVSDE_TEXCOORD1: u32 = 8u32;
pub const D3DVSDE_TEXCOORD2: u32 = 9u32;
pub const D3DVSDE_TEXCOORD3: u32 = 10u32;
pub const D3DVSDE_TEXCOORD4: u32 = 11u32;
pub const D3DVSDE_TEXCOORD5: u32 = 12u32;
pub const D3DVSDE_TEXCOORD6: u32 = 13u32;
pub const D3DVSDE_TEXCOORD7: u32 = 14u32;
pub const D3DVSDT_D3DCOLOR: u32 = 4u32;
pub const D3DVSDT_FLOAT1: u32 = 0u32;
pub const D3DVSDT_FLOAT2: u32 = 1u32;
pub const D3DVSDT_FLOAT3: u32 = 2u32;
pub const D3DVSDT_FLOAT4: u32 = 3u32;
pub const D3DVSDT_SHORT2: u32 = 6u32;
pub const D3DVSDT_SHORT4: u32 = 7u32;
pub const D3DVSDT_UBYTE4: u32 = 5u32;
pub const D3DVSD_CONSTADDRESSSHIFT: u32 = 0u32;
pub const D3DVSD_CONSTCOUNTSHIFT: u32 = 25u32;
pub const D3DVSD_CONSTRSSHIFT: u32 = 16u32;
pub const D3DVSD_DATALOADTYPESHIFT: u32 = 28u32;
pub const D3DVSD_DATATYPESHIFT: u32 = 16u32;
pub const D3DVSD_EXTCOUNTSHIFT: u32 = 24u32;
pub const D3DVSD_EXTINFOSHIFT: u32 = 0u32;
pub const D3DVSD_SKIPCOUNTSHIFT: u32 = 16u32;
pub const D3DVSD_STREAMNUMBERSHIFT: u32 = 0u32;
pub const D3DVSD_STREAMTESSSHIFT: u32 = 28u32;
pub const D3DVSD_TOKENTYPESHIFT: u32 = 29u32;
pub const D3DVSD_VERTEXREGINSHIFT: u32 = 20u32;
pub const D3DVSD_VERTEXREGSHIFT: u32 = 0u32;
pub const D3DVTXPCAPS_DIRECTIONALLIGHTS: i32 = 8i32;
pub const D3DVTXPCAPS_LOCALVIEWER: i32 = 32i32;
pub const D3DVTXPCAPS_MATERIALSOURCE7: i32 = 2i32;
pub const D3DVTXPCAPS_POSITIONALLIGHTS: i32 = 16i32;
pub const D3DVTXPCAPS_TEXGEN: i32 = 1i32;
pub const D3DVTXPCAPS_VERTEXFOG: i32 = 4i32;
pub const D3DWRAPCOORD_0: i32 = 1i32;
pub const D3DWRAPCOORD_1: i32 = 2i32;
pub const D3DWRAPCOORD_2: i32 = 4i32;
pub const D3DWRAPCOORD_3: i32 = 8i32;
pub const D3DWRAP_U: i32 = 1i32;
pub const D3DWRAP_V: i32 = 2i32;
pub const DAX_ALLOC_ALIGNMENT_FLAG_FALLBACK_SPECIFIED: u32 = 2u32;
pub const DAX_ALLOC_ALIGNMENT_FLAG_MANDATORY: u32 = 1u32;
pub const DBTF_RESOURCE: u32 = 1u32;
pub const DBTF_SLOWNET: u32 = 4u32;
pub const DBTF_XPORT: u32 = 2u32;
pub const DBT_APPYBEGIN: u32 = 0u32;
pub const DBT_APPYEND: u32 = 1u32;
pub const DBT_CONFIGCHANGECANCELED: u32 = 25u32;
pub const DBT_CONFIGCHANGED: u32 = 24u32;
pub const DBT_CONFIGMGAPI32: u32 = 34u32;
pub const DBT_CONFIGMGPRIVATE: u32 = 32767u32;
pub const DBT_CUSTOMEVENT: u32 = 32774u32;
pub const DBT_DEVICEARRIVAL: u32 = 32768u32;
pub const DBT_DEVICEQUERYREMOVE: u32 = 32769u32;
pub const DBT_DEVICEQUERYREMOVEFAILED: u32 = 32770u32;
pub const DBT_DEVICEREMOVECOMPLETE: u32 = 32772u32;
pub const DBT_DEVICEREMOVEPENDING: u32 = 32771u32;
pub const DBT_DEVICETYPESPECIFIC: u32 = 32773u32;
pub const DBT_DEVNODES_CHANGED: u32 = 7u32;
pub const DBT_DEVTYP_DEVNODE: u32 = 1u32;
pub const DBT_DEVTYP_NET: u32 = 4u32;
pub const DBT_LOW_DISK_SPACE: u32 = 72u32;
pub const DBT_MONITORCHANGE: u32 = 27u32;
pub const DBT_NO_DISK_SPACE: u32 = 71u32;
pub const DBT_QUERYCHANGECONFIG: u32 = 23u32;
pub const DBT_SHELLLOGGEDON: u32 = 32u32;
pub const DBT_USERDEFINED: u32 = 65535u32;
pub const DBT_VOLLOCKLOCKFAILED: u32 = 32835u32;
pub const DBT_VOLLOCKLOCKRELEASED: u32 = 32837u32;
pub const DBT_VOLLOCKLOCKTAKEN: u32 = 32834u32;
pub const DBT_VOLLOCKQUERYLOCK: u32 = 32833u32;
pub const DBT_VOLLOCKQUERYUNLOCK: u32 = 32836u32;
pub const DBT_VOLLOCKUNLOCKFAILED: u32 = 32838u32;
pub const DBT_VPOWERDAPI: u32 = 33024u32;
pub const DBT_VXDINITCOMPLETE: u32 = 35u32;
pub const DCR_DRIVER: u32 = 1u32;
pub const DCR_HALFTONE: u32 = 2u32;
pub const DCR_SOLID: u32 = 0u32;
pub const DC_COMPLEX: u32 = 3u32;
pub const DC_RECT: u32 = 1u32;
pub const DC_TRIVIAL: u32 = 0u32;
pub const DDBLT_EXTENDED_PRESENTATION_STRETCHFACTOR: i32 = 16i32;
pub const DDI_DRIVER_VERSION_NT4: u32 = 131072u32;
pub const DDI_DRIVER_VERSION_NT5: u32 = 196608u32;
pub const DDI_DRIVER_VERSION_NT5_01: u32 = 196864u32;
pub const DDI_DRIVER_VERSION_NT5_01_SP1: u32 = 196865u32;
pub const DDI_DRIVER_VERSION_SP3: u32 = 131075u32;
pub const DDI_ERROR: u32 = 4294967295u32;
pub const DDUMP_FLAG_DATA_READ_FROM_DEVICE: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DECIMAL {
    pub wReserved: u16,
    pub Anonymous1: DECIMAL_0,
    pub Hi32: u32,
    pub Anonymous2: DECIMAL_1,
}
impl DECIMAL {}
impl ::std::default::Default for DECIMAL {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DECIMAL {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DECIMAL {}
unsafe impl ::windows::runtime::Abi for DECIMAL {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union DECIMAL_0 {
    pub Anonymous: DECIMAL_0_0,
    pub signscale: u16,
}
impl DECIMAL_0 {}
impl ::std::default::Default for DECIMAL_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DECIMAL_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DECIMAL_0 {}
unsafe impl ::windows::runtime::Abi for DECIMAL_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DECIMAL_0_0 {
    pub scale: u8,
    pub sign: u8,
}
impl DECIMAL_0_0 {}
impl ::std::default::Default for DECIMAL_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DECIMAL_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("scale", &self.scale)
            .field("sign", &self.sign)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DECIMAL_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.scale == other.scale && self.sign == other.sign
    }
}
impl ::std::cmp::Eq for DECIMAL_0_0 {}
unsafe impl ::windows::runtime::Abi for DECIMAL_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union DECIMAL_1 {
    pub Anonymous: DECIMAL_1_0,
    pub Lo64: u64,
}
impl DECIMAL_1 {}
impl ::std::default::Default for DECIMAL_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DECIMAL_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DECIMAL_1 {}
unsafe impl ::windows::runtime::Abi for DECIMAL_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DECIMAL_1_0 {
    pub Lo32: u32,
    pub Mid32: u32,
}
impl DECIMAL_1_0 {}
impl ::std::default::Default for DECIMAL_1_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DECIMAL_1_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("Lo32", &self.Lo32)
            .field("Mid32", &self.Mid32)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DECIMAL_1_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Lo32 == other.Lo32 && self.Mid32 == other.Mid32
    }
}
impl ::std::cmp::Eq for DECIMAL_1_0 {}
unsafe impl ::windows::runtime::Abi for DECIMAL_1_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct DECRYPTION_STATUS_BUFFER {
    pub NoEncryptedStreams: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl DECRYPTION_STATUS_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for DECRYPTION_STATUS_BUFFER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for DECRYPTION_STATUS_BUFFER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DECRYPTION_STATUS_BUFFER")
            .field("NoEncryptedStreams", &self.NoEncryptedStreams)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for DECRYPTION_STATUS_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.NoEncryptedStreams == other.NoEncryptedStreams
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for DECRYPTION_STATUS_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for DECRYPTION_STATUS_BUFFER {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DEDICATED_MEMORY_CACHE_ELIGIBLE: u32 = 1u32;
pub const DELETE: u32 = 65536u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct DETECTION_TYPE(pub i32);
pub const DetectNone: DETECTION_TYPE = DETECTION_TYPE(0i32);
pub const DetectInt13: DETECTION_TYPE = DETECTION_TYPE(1i32);
pub const DetectExInt13: DETECTION_TYPE = DETECTION_TYPE(2i32);
impl ::std::convert::From<i32> for DETECTION_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for DETECTION_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DEVHTADJF_ADDITIVE_DEVICE: u32 = 2u32;
pub const DEVHTADJF_COLOR_DEVICE: u32 = 1u32;
pub const DEVICEDUMP_CAP_PRIVATE_SECTION: u32 = 1u32;
pub const DEVICEDUMP_CAP_RESTRICTED_SECTION: u32 = 2u32;
pub const DEVICEDUMP_MAX_IDSTRING: u32 = 32u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct DEVICEDUMP_PRIVATE_SUBSECTION {
    pub dwFlags: u32,
    pub GPLogId: GP_LOG_PAGE_DESCRIPTOR,
    pub bData: [u8; 1],
}
impl DEVICEDUMP_PRIVATE_SUBSECTION {}
impl ::std::default::Default for DEVICEDUMP_PRIVATE_SUBSECTION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICEDUMP_PRIVATE_SUBSECTION {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICEDUMP_PRIVATE_SUBSECTION {}
unsafe impl ::windows::runtime::Abi for DEVICEDUMP_PRIVATE_SUBSECTION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct DEVICEDUMP_PUBLIC_SUBSECTION {
    pub dwFlags: u32,
    pub GPLogTable: [GP_LOG_PAGE_DESCRIPTOR; 16],
    pub szDescription: [CHAR; 16],
    pub bData: [u8; 1],
}
impl DEVICEDUMP_PUBLIC_SUBSECTION {}
impl ::std::default::Default for DEVICEDUMP_PUBLIC_SUBSECTION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICEDUMP_PUBLIC_SUBSECTION {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICEDUMP_PUBLIC_SUBSECTION {}
unsafe impl ::windows::runtime::Abi for DEVICEDUMP_PUBLIC_SUBSECTION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICEDUMP_RESTRICTED_SUBSECTION {
    pub bData: [u8; 1],
}
impl DEVICEDUMP_RESTRICTED_SUBSECTION {}
impl ::std::default::Default for DEVICEDUMP_RESTRICTED_SUBSECTION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICEDUMP_RESTRICTED_SUBSECTION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICEDUMP_RESTRICTED_SUBSECTION")
            .field("bData", &self.bData)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICEDUMP_RESTRICTED_SUBSECTION {
    fn eq(&self, other: &Self) -> bool {
        self.bData == other.bData
    }
}
impl ::std::cmp::Eq for DEVICEDUMP_RESTRICTED_SUBSECTION {}
unsafe impl ::windows::runtime::Abi for DEVICEDUMP_RESTRICTED_SUBSECTION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct DEVICEDUMP_SECTION_HEADER {
    pub guidDeviceDataId: ::windows::runtime::GUID,
    pub sOrganizationID: [u8; 16],
    pub dwFirmwareRevision: u32,
    pub sModelNumber: [u8; 32],
    pub szDeviceManufacturingID: [u8; 32],
    pub dwFlags: u32,
    pub bRestrictedPrivateDataVersion: u32,
    pub dwFirmwareIssueId: u32,
    pub szIssueDescriptionString: [u8; 132],
}
impl DEVICEDUMP_SECTION_HEADER {}
impl ::std::default::Default for DEVICEDUMP_SECTION_HEADER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICEDUMP_SECTION_HEADER {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICEDUMP_SECTION_HEADER {}
unsafe impl ::windows::runtime::Abi for DEVICEDUMP_SECTION_HEADER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct DEVICEDUMP_STORAGEDEVICE_DATA {
    pub Descriptor: DEVICEDUMP_STRUCTURE_VERSION,
    pub SectionHeader: DEVICEDUMP_SECTION_HEADER,
    pub dwBufferSize: u32,
    pub dwReasonForCollection: u32,
    pub PublicData: DEVICEDUMP_SUBSECTION_POINTER,
    pub RestrictedData: DEVICEDUMP_SUBSECTION_POINTER,
    pub PrivateData: DEVICEDUMP_SUBSECTION_POINTER,
}
impl DEVICEDUMP_STORAGEDEVICE_DATA {}
impl ::std::default::Default for DEVICEDUMP_STORAGEDEVICE_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICEDUMP_STORAGEDEVICE_DATA {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICEDUMP_STORAGEDEVICE_DATA {}
unsafe impl ::windows::runtime::Abi for DEVICEDUMP_STORAGEDEVICE_DATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP {
    pub Descriptor: DEVICEDUMP_STRUCTURE_VERSION,
    pub dwReasonForCollection: u32,
    pub cDriverName: [u8; 16],
    pub uiNumRecords: u32,
    pub RecordArray: [DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD; 1],
}
impl DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP {}
impl ::std::default::Default for DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP {}
unsafe impl ::windows::runtime::Abi for DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD {
    pub Cdb: [u8; 16],
    pub Command: [u8; 16],
    pub StartTime: u64,
    pub EndTime: u64,
    pub OperationStatus: u32,
    pub OperationError: u32,
    pub StackSpecific: DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0,
}
impl DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD {}
impl ::std::default::Default for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD {}
unsafe impl ::windows::runtime::Abi for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0 {
    pub ExternalStack: DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_1,
    pub AtaPort: DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_0,
    pub StorPort: DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_2,
}
impl DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0 {}
impl ::std::default::Default for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0 {}
unsafe impl ::windows::runtime::Abi for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_0 {
    pub dwAtaPortSpecific: u32,
}
impl DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_0 {}
impl ::std::default::Default for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_0 {}
unsafe impl ::windows::runtime::Abi for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_1 {
    pub dwReserved: u32,
}
impl DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_1 {}
impl ::std::default::Default for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_1 {}
unsafe impl ::windows::runtime::Abi for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_2 {
    pub SrbTag: u32,
}
impl DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_2 {}
impl ::std::default::Default for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_2 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_2 {}
unsafe impl ::windows::runtime::Abi for DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD_0_2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct DEVICEDUMP_STRUCTURE_VERSION {
    pub dwSignature: u32,
    pub dwVersion: u32,
    pub dwSize: u32,
}
impl DEVICEDUMP_STRUCTURE_VERSION {}
impl ::std::default::Default for DEVICEDUMP_STRUCTURE_VERSION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICEDUMP_STRUCTURE_VERSION {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICEDUMP_STRUCTURE_VERSION {}
unsafe impl ::windows::runtime::Abi for DEVICEDUMP_STRUCTURE_VERSION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DEVICEDUMP_STRUCTURE_VERSION_V1: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct DEVICEDUMP_SUBSECTION_POINTER {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub dwOffset: u32,
}
impl DEVICEDUMP_SUBSECTION_POINTER {}
impl ::std::default::Default for DEVICEDUMP_SUBSECTION_POINTER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICEDUMP_SUBSECTION_POINTER {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICEDUMP_SUBSECTION_POINTER {}
unsafe impl ::windows::runtime::Abi for DEVICEDUMP_SUBSECTION_POINTER {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DEVICEFAMILYDEVICEFORM_ALLINONE: u32 = 7u32;
pub const DEVICEFAMILYDEVICEFORM_BANKING: u32 = 14u32;
pub const DEVICEFAMILYDEVICEFORM_BUILDING_AUTOMATION: u32 = 15u32;
pub const DEVICEFAMILYDEVICEFORM_CONVERTIBLE: u32 = 5u32;
pub const DEVICEFAMILYDEVICEFORM_DESKTOP: u32 = 3u32;
pub const DEVICEFAMILYDEVICEFORM_DETACHABLE: u32 = 6u32;
pub const DEVICEFAMILYDEVICEFORM_DIGITAL_SIGNAGE: u32 = 16u32;
pub const DEVICEFAMILYDEVICEFORM_GAMING: u32 = 17u32;
pub const DEVICEFAMILYDEVICEFORM_HMD: u32 = 11u32;
pub const DEVICEFAMILYDEVICEFORM_HOME_AUTOMATION: u32 = 18u32;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRIAL_AUTOMATION: u32 = 19u32;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_HANDHELD: u32 = 12u32;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_OTHER: u32 = 29u32;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_TABLET: u32 = 13u32;
pub const DEVICEFAMILYDEVICEFORM_KIOSK: u32 = 20u32;
pub const DEVICEFAMILYDEVICEFORM_LARGESCREEN: u32 = 10u32;
pub const DEVICEFAMILYDEVICEFORM_MAKER_BOARD: u32 = 21u32;
pub const DEVICEFAMILYDEVICEFORM_MAX: u32 = 45u32;
pub const DEVICEFAMILYDEVICEFORM_MEDICAL: u32 = 22u32;
pub const DEVICEFAMILYDEVICEFORM_NETWORKING: u32 = 23u32;
pub const DEVICEFAMILYDEVICEFORM_NOTEBOOK: u32 = 4u32;
pub const DEVICEFAMILYDEVICEFORM_PHONE: u32 = 1u32;
pub const DEVICEFAMILYDEVICEFORM_POINT_OF_SERVICE: u32 = 24u32;
pub const DEVICEFAMILYDEVICEFORM_PRINTING: u32 = 25u32;
pub const DEVICEFAMILYDEVICEFORM_PUCK: u32 = 9u32;
pub const DEVICEFAMILYDEVICEFORM_STICKPC: u32 = 8u32;
pub const DEVICEFAMILYDEVICEFORM_TABLET: u32 = 2u32;
pub const DEVICEFAMILYDEVICEFORM_THIN_CLIENT: u32 = 26u32;
pub const DEVICEFAMILYDEVICEFORM_TOY: u32 = 27u32;
pub const DEVICEFAMILYDEVICEFORM_UNKNOWN: u32 = 0u32;
pub const DEVICEFAMILYDEVICEFORM_VENDING: u32 = 28u32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE: u32 = 30u32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_S: u32 = 31u32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_X: u32 = 32u32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_X_DEVKIT: u32 = 33u32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_00: u32 = 36u32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_01: u32 = 37u32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_02: u32 = 38u32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_03: u32 = 39u32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_04: u32 = 40u32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_05: u32 = 41u32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_06: u32 = 42u32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_07: u32 = 43u32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_08: u32 = 44u32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_09: u32 = 45u32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_SERIES_X: u32 = 34u32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_SERIES_X_DEVKIT: u32 = 35u32;
pub const DEVICEFAMILYINFOENUM_7067329: u32 = 15u32;
pub const DEVICEFAMILYINFOENUM_8828080: u32 = 14u32;
pub const DEVICEFAMILYINFOENUM_DESKTOP: u32 = 3u32;
pub const DEVICEFAMILYINFOENUM_HOLOGRAPHIC: u32 = 10u32;
pub const DEVICEFAMILYINFOENUM_IOT: u32 = 7u32;
pub const DEVICEFAMILYINFOENUM_IOT_HEADLESS: u32 = 8u32;
pub const DEVICEFAMILYINFOENUM_MAX: u32 = 17u32;
pub const DEVICEFAMILYINFOENUM_MOBILE: u32 = 4u32;
pub const DEVICEFAMILYINFOENUM_SERVER: u32 = 9u32;
pub const DEVICEFAMILYINFOENUM_SERVER_NANO: u32 = 13u32;
pub const DEVICEFAMILYINFOENUM_TEAM: u32 = 6u32;
pub const DEVICEFAMILYINFOENUM_UAP: u32 = 0u32;
pub const DEVICEFAMILYINFOENUM_WINDOWS_8X: u32 = 1u32;
pub const DEVICEFAMILYINFOENUM_WINDOWS_CORE: u32 = 16u32;
pub const DEVICEFAMILYINFOENUM_WINDOWS_CORE_HEADLESS: u32 = 17u32;
pub const DEVICEFAMILYINFOENUM_WINDOWS_PHONE_8X: u32 = 2u32;
pub const DEVICEFAMILYINFOENUM_XBOX: u32 = 5u32;
pub const DEVICEFAMILYINFOENUM_XBOXERA: u32 = 12u32;
pub const DEVICEFAMILYINFOENUM_XBOXSRA: u32 = 11u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DATA_SET_LBP_STATE_PARAMETERS {
    pub Version: u32,
    pub Size: u32,
    pub Flags: u32,
    pub OutputVersion: u32,
}
impl DEVICE_DATA_SET_LBP_STATE_PARAMETERS {}
impl ::std::default::Default for DEVICE_DATA_SET_LBP_STATE_PARAMETERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DATA_SET_LBP_STATE_PARAMETERS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DATA_SET_LBP_STATE_PARAMETERS")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("OutputVersion", &self.OutputVersion)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DATA_SET_LBP_STATE_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.Flags == other.Flags
            && self.OutputVersion == other.OutputVersion
    }
}
impl ::std::cmp::Eq for DEVICE_DATA_SET_LBP_STATE_PARAMETERS {}
unsafe impl ::windows::runtime::Abi for DEVICE_DATA_SET_LBP_STATE_PARAMETERS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DEVICE_DATA_SET_LBP_STATE_PARAMETERS_VERSION_V1: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DATA_SET_LB_PROVISIONING_STATE {
    pub Size: u32,
    pub Version: u32,
    pub SlabSizeInBytes: u64,
    pub SlabOffsetDeltaInBytes: u32,
    pub SlabAllocationBitMapBitCount: u32,
    pub SlabAllocationBitMapLength: u32,
    pub SlabAllocationBitMap: [u32; 1],
}
impl DEVICE_DATA_SET_LB_PROVISIONING_STATE {}
impl ::std::default::Default for DEVICE_DATA_SET_LB_PROVISIONING_STATE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DATA_SET_LB_PROVISIONING_STATE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DATA_SET_LB_PROVISIONING_STATE")
            .field("Size", &self.Size)
            .field("Version", &self.Version)
            .field("SlabSizeInBytes", &self.SlabSizeInBytes)
            .field("SlabOffsetDeltaInBytes", &self.SlabOffsetDeltaInBytes)
            .field(
                "SlabAllocationBitMapBitCount",
                &self.SlabAllocationBitMapBitCount,
            )
            .field(
                "SlabAllocationBitMapLength",
                &self.SlabAllocationBitMapLength,
            )
            .field("SlabAllocationBitMap", &self.SlabAllocationBitMap)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DATA_SET_LB_PROVISIONING_STATE {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.Version == other.Version
            && self.SlabSizeInBytes == other.SlabSizeInBytes
            && self.SlabOffsetDeltaInBytes == other.SlabOffsetDeltaInBytes
            && self.SlabAllocationBitMapBitCount == other.SlabAllocationBitMapBitCount
            && self.SlabAllocationBitMapLength == other.SlabAllocationBitMapLength
            && self.SlabAllocationBitMap == other.SlabAllocationBitMap
    }
}
impl ::std::cmp::Eq for DEVICE_DATA_SET_LB_PROVISIONING_STATE {}
unsafe impl ::windows::runtime::Abi for DEVICE_DATA_SET_LB_PROVISIONING_STATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 {
    pub Size: u32,
    pub Version: u32,
    pub SlabSizeInBytes: u64,
    pub SlabOffsetDeltaInBytes: u64,
    pub SlabAllocationBitMapBitCount: u32,
    pub SlabAllocationBitMapLength: u32,
    pub SlabAllocationBitMap: [u32; 1],
}
impl DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 {}
impl ::std::default::Default for DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2")
            .field("Size", &self.Size)
            .field("Version", &self.Version)
            .field("SlabSizeInBytes", &self.SlabSizeInBytes)
            .field("SlabOffsetDeltaInBytes", &self.SlabOffsetDeltaInBytes)
            .field(
                "SlabAllocationBitMapBitCount",
                &self.SlabAllocationBitMapBitCount,
            )
            .field(
                "SlabAllocationBitMapLength",
                &self.SlabAllocationBitMapLength,
            )
            .field("SlabAllocationBitMap", &self.SlabAllocationBitMap)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.Version == other.Version
            && self.SlabSizeInBytes == other.SlabSizeInBytes
            && self.SlabOffsetDeltaInBytes == other.SlabOffsetDeltaInBytes
            && self.SlabAllocationBitMapBitCount == other.SlabAllocationBitMapBitCount
            && self.SlabAllocationBitMapLength == other.SlabAllocationBitMapLength
            && self.SlabAllocationBitMap == other.SlabAllocationBitMap
    }
}
impl ::std::cmp::Eq for DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 {}
unsafe impl ::windows::runtime::Abi for DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DATA_SET_RANGE {
    pub StartingOffset: i64,
    pub LengthInBytes: u64,
}
impl DEVICE_DATA_SET_RANGE {}
impl ::std::default::Default for DEVICE_DATA_SET_RANGE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DATA_SET_RANGE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DATA_SET_RANGE")
            .field("StartingOffset", &self.StartingOffset)
            .field("LengthInBytes", &self.LengthInBytes)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DATA_SET_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.StartingOffset == other.StartingOffset && self.LengthInBytes == other.LengthInBytes
    }
}
impl ::std::cmp::Eq for DEVICE_DATA_SET_RANGE {}
unsafe impl ::windows::runtime::Abi for DEVICE_DATA_SET_RANGE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DATA_SET_REPAIR_OUTPUT {
    pub ParityExtent: DEVICE_DATA_SET_RANGE,
}
impl DEVICE_DATA_SET_REPAIR_OUTPUT {}
impl ::std::default::Default for DEVICE_DATA_SET_REPAIR_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DATA_SET_REPAIR_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DATA_SET_REPAIR_OUTPUT")
            .field("ParityExtent", &self.ParityExtent)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DATA_SET_REPAIR_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.ParityExtent == other.ParityExtent
    }
}
impl ::std::cmp::Eq for DEVICE_DATA_SET_REPAIR_OUTPUT {}
unsafe impl ::windows::runtime::Abi for DEVICE_DATA_SET_REPAIR_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DATA_SET_REPAIR_PARAMETERS {
    pub NumberOfRepairCopies: u32,
    pub SourceCopy: u32,
    pub RepairCopies: [u32; 1],
}
impl DEVICE_DATA_SET_REPAIR_PARAMETERS {}
impl ::std::default::Default for DEVICE_DATA_SET_REPAIR_PARAMETERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DATA_SET_REPAIR_PARAMETERS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DATA_SET_REPAIR_PARAMETERS")
            .field("NumberOfRepairCopies", &self.NumberOfRepairCopies)
            .field("SourceCopy", &self.SourceCopy)
            .field("RepairCopies", &self.RepairCopies)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DATA_SET_REPAIR_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.NumberOfRepairCopies == other.NumberOfRepairCopies
            && self.SourceCopy == other.SourceCopy
            && self.RepairCopies == other.RepairCopies
    }
}
impl ::std::cmp::Eq for DEVICE_DATA_SET_REPAIR_PARAMETERS {}
unsafe impl ::windows::runtime::Abi for DEVICE_DATA_SET_REPAIR_PARAMETERS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DATA_SET_SCRUB_EX_OUTPUT {
    pub BytesProcessed: u64,
    pub BytesRepaired: u64,
    pub BytesFailed: u64,
    pub ParityExtent: DEVICE_DATA_SET_RANGE,
    pub BytesScrubbed: u64,
}
impl DEVICE_DATA_SET_SCRUB_EX_OUTPUT {}
impl ::std::default::Default for DEVICE_DATA_SET_SCRUB_EX_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DATA_SET_SCRUB_EX_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DATA_SET_SCRUB_EX_OUTPUT")
            .field("BytesProcessed", &self.BytesProcessed)
            .field("BytesRepaired", &self.BytesRepaired)
            .field("BytesFailed", &self.BytesFailed)
            .field("ParityExtent", &self.ParityExtent)
            .field("BytesScrubbed", &self.BytesScrubbed)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DATA_SET_SCRUB_EX_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.BytesProcessed == other.BytesProcessed
            && self.BytesRepaired == other.BytesRepaired
            && self.BytesFailed == other.BytesFailed
            && self.ParityExtent == other.ParityExtent
            && self.BytesScrubbed == other.BytesScrubbed
    }
}
impl ::std::cmp::Eq for DEVICE_DATA_SET_SCRUB_EX_OUTPUT {}
unsafe impl ::windows::runtime::Abi for DEVICE_DATA_SET_SCRUB_EX_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DATA_SET_SCRUB_OUTPUT {
    pub BytesProcessed: u64,
    pub BytesRepaired: u64,
    pub BytesFailed: u64,
}
impl DEVICE_DATA_SET_SCRUB_OUTPUT {}
impl ::std::default::Default for DEVICE_DATA_SET_SCRUB_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DATA_SET_SCRUB_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DATA_SET_SCRUB_OUTPUT")
            .field("BytesProcessed", &self.BytesProcessed)
            .field("BytesRepaired", &self.BytesRepaired)
            .field("BytesFailed", &self.BytesFailed)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DATA_SET_SCRUB_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.BytesProcessed == other.BytesProcessed
            && self.BytesRepaired == other.BytesRepaired
            && self.BytesFailed == other.BytesFailed
    }
}
impl ::std::cmp::Eq for DEVICE_DATA_SET_SCRUB_OUTPUT {}
unsafe impl ::windows::runtime::Abi for DEVICE_DATA_SET_SCRUB_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT {
    pub TopologyRangeBytes: u64,
    pub TopologyId: [u8; 16],
}
impl DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT {}
impl ::std::default::Default for DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT")
            .field("TopologyRangeBytes", &self.TopologyRangeBytes)
            .field("TopologyId", &self.TopologyId)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.TopologyRangeBytes == other.TopologyRangeBytes && self.TopologyId == other.TopologyId
    }
}
impl ::std::cmp::Eq for DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT {}
unsafe impl ::windows::runtime::Abi for DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DSM_CONVERSION_OUTPUT {
    pub Version: u32,
    pub Source: ::windows::runtime::GUID,
}
impl DEVICE_DSM_CONVERSION_OUTPUT {}
impl ::std::default::Default for DEVICE_DSM_CONVERSION_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DSM_CONVERSION_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DSM_CONVERSION_OUTPUT")
            .field("Version", &self.Version)
            .field("Source", &self.Source)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DSM_CONVERSION_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Source == other.Source
    }
}
impl ::std::cmp::Eq for DEVICE_DSM_CONVERSION_OUTPUT {}
unsafe impl ::windows::runtime::Abi for DEVICE_DSM_CONVERSION_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct DEVICE_DSM_DEFINITION {
    pub Action: u32,
    pub SingleRange: super::super::Foundation::BOOLEAN,
    pub ParameterBlockAlignment: u32,
    pub ParameterBlockLength: u32,
    pub HasOutput: super::super::Foundation::BOOLEAN,
    pub OutputBlockAlignment: u32,
    pub OutputBlockLength: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl DEVICE_DSM_DEFINITION {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for DEVICE_DSM_DEFINITION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for DEVICE_DSM_DEFINITION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DSM_DEFINITION")
            .field("Action", &self.Action)
            .field("SingleRange", &self.SingleRange)
            .field("ParameterBlockAlignment", &self.ParameterBlockAlignment)
            .field("ParameterBlockLength", &self.ParameterBlockLength)
            .field("HasOutput", &self.HasOutput)
            .field("OutputBlockAlignment", &self.OutputBlockAlignment)
            .field("OutputBlockLength", &self.OutputBlockLength)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for DEVICE_DSM_DEFINITION {
    fn eq(&self, other: &Self) -> bool {
        self.Action == other.Action
            && self.SingleRange == other.SingleRange
            && self.ParameterBlockAlignment == other.ParameterBlockAlignment
            && self.ParameterBlockLength == other.ParameterBlockLength
            && self.HasOutput == other.HasOutput
            && self.OutputBlockAlignment == other.OutputBlockAlignment
            && self.OutputBlockLength == other.OutputBlockLength
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for DEVICE_DSM_DEFINITION {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for DEVICE_DSM_DEFINITION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DEVICE_DSM_FLAG_ALLOCATION_CONSOLIDATEABLE_ONLY: u32 = 1073741824u32;
pub const DEVICE_DSM_FLAG_ENTIRE_DATA_SET_RANGE: u32 = 1u32;
pub const DEVICE_DSM_FLAG_PHYSICAL_ADDRESSES_OMIT_TOTAL_RANGES: u32 = 268435456u32;
pub const DEVICE_DSM_FLAG_REPAIR_INPUT_TOPOLOGY_ID_PRESENT: u32 = 1073741824u32;
pub const DEVICE_DSM_FLAG_REPAIR_OUTPUT_PARITY_EXTENT: u32 = 536870912u32;
pub const DEVICE_DSM_FLAG_SCRUB_OUTPUT_PARITY_EXTENT: u32 = 536870912u32;
pub const DEVICE_DSM_FLAG_SCRUB_SKIP_IN_SYNC: u32 = 268435456u32;
pub const DEVICE_DSM_FLAG_TRIM_BYPASS_RZAT: u32 = 1073741824u32;
pub const DEVICE_DSM_FLAG_TRIM_NOT_FS_ALLOCATED: u32 = 2147483648u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DSM_FREE_SPACE_OUTPUT {
    pub Version: u32,
    pub FreeSpace: u64,
}
impl DEVICE_DSM_FREE_SPACE_OUTPUT {}
impl ::std::default::Default for DEVICE_DSM_FREE_SPACE_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DSM_FREE_SPACE_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DSM_FREE_SPACE_OUTPUT")
            .field("Version", &self.Version)
            .field("FreeSpace", &self.FreeSpace)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DSM_FREE_SPACE_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.FreeSpace == other.FreeSpace
    }
}
impl ::std::cmp::Eq for DEVICE_DSM_FREE_SPACE_OUTPUT {}
unsafe impl ::windows::runtime::Abi for DEVICE_DSM_FREE_SPACE_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DSM_LOST_QUERY_OUTPUT {
    pub Version: u32,
    pub Size: u32,
    pub Alignment: u64,
    pub NumberOfBits: u32,
    pub BitMap: [u32; 1],
}
impl DEVICE_DSM_LOST_QUERY_OUTPUT {}
impl ::std::default::Default for DEVICE_DSM_LOST_QUERY_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DSM_LOST_QUERY_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DSM_LOST_QUERY_OUTPUT")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Alignment", &self.Alignment)
            .field("NumberOfBits", &self.NumberOfBits)
            .field("BitMap", &self.BitMap)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DSM_LOST_QUERY_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.Alignment == other.Alignment
            && self.NumberOfBits == other.NumberOfBits
            && self.BitMap == other.BitMap
    }
}
impl ::std::cmp::Eq for DEVICE_DSM_LOST_QUERY_OUTPUT {}
unsafe impl ::windows::runtime::Abi for DEVICE_DSM_LOST_QUERY_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DSM_LOST_QUERY_PARAMETERS {
    pub Version: u32,
    pub Granularity: u64,
}
impl DEVICE_DSM_LOST_QUERY_PARAMETERS {}
impl ::std::default::Default for DEVICE_DSM_LOST_QUERY_PARAMETERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DSM_LOST_QUERY_PARAMETERS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DSM_LOST_QUERY_PARAMETERS")
            .field("Version", &self.Version)
            .field("Granularity", &self.Granularity)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DSM_LOST_QUERY_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Granularity == other.Granularity
    }
}
impl ::std::cmp::Eq for DEVICE_DSM_LOST_QUERY_PARAMETERS {}
unsafe impl ::windows::runtime::Abi for DEVICE_DSM_LOST_QUERY_PARAMETERS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DSM_NOTIFICATION_PARAMETERS {
    pub Size: u32,
    pub Flags: u32,
    pub NumFileTypeIDs: u32,
    pub FileTypeID: [::windows::runtime::GUID; 1],
}
impl DEVICE_DSM_NOTIFICATION_PARAMETERS {}
impl ::std::default::Default for DEVICE_DSM_NOTIFICATION_PARAMETERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DSM_NOTIFICATION_PARAMETERS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DSM_NOTIFICATION_PARAMETERS")
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("NumFileTypeIDs", &self.NumFileTypeIDs)
            .field("FileTypeID", &self.FileTypeID)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DSM_NOTIFICATION_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.Flags == other.Flags
            && self.NumFileTypeIDs == other.NumFileTypeIDs
            && self.FileTypeID == other.FileTypeID
    }
}
impl ::std::cmp::Eq for DEVICE_DSM_NOTIFICATION_PARAMETERS {}
unsafe impl ::windows::runtime::Abi for DEVICE_DSM_NOTIFICATION_PARAMETERS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DEVICE_DSM_NOTIFY_FLAG_BEGIN: u32 = 1u32;
pub const DEVICE_DSM_NOTIFY_FLAG_END: u32 = 2u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS {
    pub Size: u32,
    pub TargetPriority: u8,
    pub Reserved: [u8; 3],
}
impl DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS {}
impl ::std::default::Default for DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS")
            .field("Size", &self.Size)
            .field("TargetPriority", &self.TargetPriority)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.TargetPriority == other.TargetPriority
            && self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS {}
unsafe impl ::windows::runtime::Abi for DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DSM_OFFLOAD_READ_PARAMETERS {
    pub Flags: u32,
    pub TimeToLive: u32,
    pub Reserved: [u32; 2],
}
impl DEVICE_DSM_OFFLOAD_READ_PARAMETERS {}
impl ::std::default::Default for DEVICE_DSM_OFFLOAD_READ_PARAMETERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DSM_OFFLOAD_READ_PARAMETERS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DSM_OFFLOAD_READ_PARAMETERS")
            .field("Flags", &self.Flags)
            .field("TimeToLive", &self.TimeToLive)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DSM_OFFLOAD_READ_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
            && self.TimeToLive == other.TimeToLive
            && self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for DEVICE_DSM_OFFLOAD_READ_PARAMETERS {}
unsafe impl ::windows::runtime::Abi for DEVICE_DSM_OFFLOAD_READ_PARAMETERS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS {
    pub Flags: u32,
    pub Reserved: u32,
    pub TokenOffset: u64,
    pub Token: STORAGE_OFFLOAD_TOKEN,
}
impl DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS {}
impl ::std::default::Default for DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS {}
unsafe impl ::windows::runtime::Abi for DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DEVICE_DSM_PARAMETERS_V1: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT {
    pub Version: u32,
    pub Flags: u32,
    pub TotalNumberOfRanges: u32,
    pub NumberOfRangesReturned: u32,
    pub Ranges: [DEVICE_STORAGE_ADDRESS_RANGE; 1],
}
impl DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT {}
impl ::std::default::Default for DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT")
            .field("Version", &self.Version)
            .field("Flags", &self.Flags)
            .field("TotalNumberOfRanges", &self.TotalNumberOfRanges)
            .field("NumberOfRangesReturned", &self.NumberOfRangesReturned)
            .field("Ranges", &self.Ranges)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Flags == other.Flags
            && self.TotalNumberOfRanges == other.TotalNumberOfRanges
            && self.NumberOfRangesReturned == other.NumberOfRangesReturned
            && self.Ranges == other.Ranges
    }
}
impl ::std::cmp::Eq for DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT {}
unsafe impl ::windows::runtime::Abi for DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT_V1: u32 = 1u32;
pub const DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT_VERSION_V1: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DSM_RANGE_ERROR_INFO {
    pub Version: u32,
    pub Flags: u32,
    pub TotalNumberOfRanges: u32,
    pub NumberOfRangesReturned: u32,
    pub Ranges: [DEVICE_STORAGE_RANGE_ATTRIBUTES; 1],
}
impl DEVICE_DSM_RANGE_ERROR_INFO {}
impl ::std::default::Default for DEVICE_DSM_RANGE_ERROR_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICE_DSM_RANGE_ERROR_INFO {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICE_DSM_RANGE_ERROR_INFO {}
unsafe impl ::windows::runtime::Abi for DEVICE_DSM_RANGE_ERROR_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DEVICE_DSM_RANGE_ERROR_INFO_VERSION_V1: u32 = 1u32;
pub const DEVICE_DSM_RANGE_ERROR_OUTPUT_V1: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct DEVICE_DSM_REPORT_ZONES_DATA {
    pub Size: u32,
    pub ZoneCount: u32,
    pub Attributes: STORAGE_ZONES_ATTRIBUTES,
    pub Reserved0: u32,
    pub ZoneDescriptors: [STORAGE_ZONE_DESCRIPTOR; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl DEVICE_DSM_REPORT_ZONES_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for DEVICE_DSM_REPORT_ZONES_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for DEVICE_DSM_REPORT_ZONES_DATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DSM_REPORT_ZONES_DATA")
            .field("Size", &self.Size)
            .field("ZoneCount", &self.ZoneCount)
            .field("Attributes", &self.Attributes)
            .field("Reserved0", &self.Reserved0)
            .field("ZoneDescriptors", &self.ZoneDescriptors)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for DEVICE_DSM_REPORT_ZONES_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.ZoneCount == other.ZoneCount
            && self.Attributes == other.Attributes
            && self.Reserved0 == other.Reserved0
            && self.ZoneDescriptors == other.ZoneDescriptors
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for DEVICE_DSM_REPORT_ZONES_DATA {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for DEVICE_DSM_REPORT_ZONES_DATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DSM_REPORT_ZONES_PARAMETERS {
    pub Size: u32,
    pub ReportOption: u8,
    pub Partial: u8,
    pub Reserved: [u8; 2],
}
impl DEVICE_DSM_REPORT_ZONES_PARAMETERS {}
impl ::std::default::Default for DEVICE_DSM_REPORT_ZONES_PARAMETERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DSM_REPORT_ZONES_PARAMETERS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DSM_REPORT_ZONES_PARAMETERS")
            .field("Size", &self.Size)
            .field("ReportOption", &self.ReportOption)
            .field("Partial", &self.Partial)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DSM_REPORT_ZONES_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.ReportOption == other.ReportOption
            && self.Partial == other.Partial
            && self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for DEVICE_DSM_REPORT_ZONES_PARAMETERS {}
unsafe impl ::windows::runtime::Abi for DEVICE_DSM_REPORT_ZONES_PARAMETERS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DSM_TIERING_QUERY_INPUT {
    pub Version: u32,
    pub Size: u32,
    pub Flags: u32,
    pub NumberOfTierIds: u32,
    pub TierIds: [::windows::runtime::GUID; 1],
}
impl DEVICE_DSM_TIERING_QUERY_INPUT {}
impl ::std::default::Default for DEVICE_DSM_TIERING_QUERY_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DSM_TIERING_QUERY_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DSM_TIERING_QUERY_INPUT")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("NumberOfTierIds", &self.NumberOfTierIds)
            .field("TierIds", &self.TierIds)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DSM_TIERING_QUERY_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.Flags == other.Flags
            && self.NumberOfTierIds == other.NumberOfTierIds
            && self.TierIds == other.TierIds
    }
}
impl ::std::cmp::Eq for DEVICE_DSM_TIERING_QUERY_INPUT {}
unsafe impl ::windows::runtime::Abi for DEVICE_DSM_TIERING_QUERY_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_DSM_TIERING_QUERY_OUTPUT {
    pub Version: u32,
    pub Size: u32,
    pub Flags: u32,
    pub Reserved: u32,
    pub Alignment: u64,
    pub TotalNumberOfRegions: u32,
    pub NumberOfRegionsReturned: u32,
    pub Regions: [STORAGE_TIER_REGION; 1],
}
impl DEVICE_DSM_TIERING_QUERY_OUTPUT {}
impl ::std::default::Default for DEVICE_DSM_TIERING_QUERY_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_DSM_TIERING_QUERY_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_DSM_TIERING_QUERY_OUTPUT")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("Reserved", &self.Reserved)
            .field("Alignment", &self.Alignment)
            .field("TotalNumberOfRegions", &self.TotalNumberOfRegions)
            .field("NumberOfRegionsReturned", &self.NumberOfRegionsReturned)
            .field("Regions", &self.Regions)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_DSM_TIERING_QUERY_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.Flags == other.Flags
            && self.Reserved == other.Reserved
            && self.Alignment == other.Alignment
            && self.TotalNumberOfRegions == other.TotalNumberOfRegions
            && self.NumberOfRegionsReturned == other.NumberOfRegionsReturned
            && self.Regions == other.Regions
    }
}
impl ::std::cmp::Eq for DEVICE_DSM_TIERING_QUERY_OUTPUT {}
unsafe impl ::windows::runtime::Abi for DEVICE_DSM_TIERING_QUERY_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_EVENT_BECOMING_READY {
    pub Version: u32,
    pub Reason: u32,
    pub Estimated100msToReady: u32,
}
impl DEVICE_EVENT_BECOMING_READY {}
impl ::std::default::Default for DEVICE_EVENT_BECOMING_READY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_EVENT_BECOMING_READY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_EVENT_BECOMING_READY")
            .field("Version", &self.Version)
            .field("Reason", &self.Reason)
            .field("Estimated100msToReady", &self.Estimated100msToReady)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_EVENT_BECOMING_READY {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Reason == other.Reason
            && self.Estimated100msToReady == other.Estimated100msToReady
    }
}
impl ::std::cmp::Eq for DEVICE_EVENT_BECOMING_READY {}
unsafe impl ::windows::runtime::Abi for DEVICE_EVENT_BECOMING_READY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_EVENT_EXTERNAL_REQUEST {
    pub Version: u32,
    pub DeviceClass: u32,
    pub ButtonStatus: u16,
    pub Request: u16,
    pub SystemTime: i64,
}
impl DEVICE_EVENT_EXTERNAL_REQUEST {}
impl ::std::default::Default for DEVICE_EVENT_EXTERNAL_REQUEST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_EVENT_EXTERNAL_REQUEST {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_EVENT_EXTERNAL_REQUEST")
            .field("Version", &self.Version)
            .field("DeviceClass", &self.DeviceClass)
            .field("ButtonStatus", &self.ButtonStatus)
            .field("Request", &self.Request)
            .field("SystemTime", &self.SystemTime)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_EVENT_EXTERNAL_REQUEST {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.DeviceClass == other.DeviceClass
            && self.ButtonStatus == other.ButtonStatus
            && self.Request == other.Request
            && self.SystemTime == other.SystemTime
    }
}
impl ::std::cmp::Eq for DEVICE_EVENT_EXTERNAL_REQUEST {}
unsafe impl ::windows::runtime::Abi for DEVICE_EVENT_EXTERNAL_REQUEST {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_EVENT_GENERIC_DATA {
    pub EventNumber: u32,
}
impl DEVICE_EVENT_GENERIC_DATA {}
impl ::std::default::Default for DEVICE_EVENT_GENERIC_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_EVENT_GENERIC_DATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_EVENT_GENERIC_DATA")
            .field("EventNumber", &self.EventNumber)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_EVENT_GENERIC_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.EventNumber == other.EventNumber
    }
}
impl ::std::cmp::Eq for DEVICE_EVENT_GENERIC_DATA {}
unsafe impl ::windows::runtime::Abi for DEVICE_EVENT_GENERIC_DATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_EVENT_MOUNT {
    pub Version: u32,
    pub Flags: u32,
    pub FileSystemNameLength: u32,
    pub FileSystemNameOffset: u32,
}
impl DEVICE_EVENT_MOUNT {}
impl ::std::default::Default for DEVICE_EVENT_MOUNT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_EVENT_MOUNT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_EVENT_MOUNT")
            .field("Version", &self.Version)
            .field("Flags", &self.Flags)
            .field("FileSystemNameLength", &self.FileSystemNameLength)
            .field("FileSystemNameOffset", &self.FileSystemNameOffset)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_EVENT_MOUNT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Flags == other.Flags
            && self.FileSystemNameLength == other.FileSystemNameLength
            && self.FileSystemNameOffset == other.FileSystemNameOffset
    }
}
impl ::std::cmp::Eq for DEVICE_EVENT_MOUNT {}
unsafe impl ::windows::runtime::Abi for DEVICE_EVENT_MOUNT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_EVENT_RBC_DATA {
    pub EventNumber: u32,
    pub SenseQualifier: u8,
    pub SenseCode: u8,
    pub SenseKey: u8,
    pub Reserved: u8,
    pub Information: u32,
}
impl DEVICE_EVENT_RBC_DATA {}
impl ::std::default::Default for DEVICE_EVENT_RBC_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_EVENT_RBC_DATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_EVENT_RBC_DATA")
            .field("EventNumber", &self.EventNumber)
            .field("SenseQualifier", &self.SenseQualifier)
            .field("SenseCode", &self.SenseCode)
            .field("SenseKey", &self.SenseKey)
            .field("Reserved", &self.Reserved)
            .field("Information", &self.Information)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_EVENT_RBC_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.EventNumber == other.EventNumber
            && self.SenseQualifier == other.SenseQualifier
            && self.SenseCode == other.SenseCode
            && self.SenseKey == other.SenseKey
            && self.Reserved == other.Reserved
            && self.Information == other.Information
    }
}
impl ::std::cmp::Eq for DEVICE_EVENT_RBC_DATA {}
unsafe impl ::windows::runtime::Abi for DEVICE_EVENT_RBC_DATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_INTERNAL_STATUS_DATA {
    pub Version: u32,
    pub Size: u32,
    pub T10VendorId: u64,
    pub DataSet1Length: u32,
    pub DataSet2Length: u32,
    pub DataSet3Length: u32,
    pub DataSet4Length: u32,
    pub StatusDataVersion: u8,
    pub Reserved: [u8; 3],
    pub ReasonIdentifier: [u8; 128],
    pub StatusDataLength: u32,
    pub StatusData: [u8; 1],
}
impl DEVICE_INTERNAL_STATUS_DATA {}
impl ::std::default::Default for DEVICE_INTERNAL_STATUS_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_INTERNAL_STATUS_DATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_INTERNAL_STATUS_DATA")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("T10VendorId", &self.T10VendorId)
            .field("DataSet1Length", &self.DataSet1Length)
            .field("DataSet2Length", &self.DataSet2Length)
            .field("DataSet3Length", &self.DataSet3Length)
            .field("DataSet4Length", &self.DataSet4Length)
            .field("StatusDataVersion", &self.StatusDataVersion)
            .field("Reserved", &self.Reserved)
            .field("ReasonIdentifier", &self.ReasonIdentifier)
            .field("StatusDataLength", &self.StatusDataLength)
            .field("StatusData", &self.StatusData)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_INTERNAL_STATUS_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.T10VendorId == other.T10VendorId
            && self.DataSet1Length == other.DataSet1Length
            && self.DataSet2Length == other.DataSet2Length
            && self.DataSet3Length == other.DataSet3Length
            && self.DataSet4Length == other.DataSet4Length
            && self.StatusDataVersion == other.StatusDataVersion
            && self.Reserved == other.Reserved
            && self.ReasonIdentifier == other.ReasonIdentifier
            && self.StatusDataLength == other.StatusDataLength
            && self.StatusData == other.StatusData
    }
}
impl ::std::cmp::Eq for DEVICE_INTERNAL_STATUS_DATA {}
unsafe impl ::windows::runtime::Abi for DEVICE_INTERNAL_STATUS_DATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE(pub i32);
pub const DeviceInternalStatusDataRequestTypeUndefined: DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE =
    DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE(0i32);
pub const DeviceCurrentInternalStatusDataHeader: DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE =
    DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE(1i32);
pub const DeviceCurrentInternalStatusData: DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE =
    DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE(2i32);
pub const DeviceSavedInternalStatusDataHeader: DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE =
    DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE(3i32);
pub const DeviceSavedInternalStatusData: DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE =
    DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE(4i32);
impl ::std::convert::From<i32> for DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct DEVICE_INTERNAL_STATUS_DATA_SET(pub i32);
pub const DeviceStatusDataSetUndefined: DEVICE_INTERNAL_STATUS_DATA_SET =
    DEVICE_INTERNAL_STATUS_DATA_SET(0i32);
pub const DeviceStatusDataSet1: DEVICE_INTERNAL_STATUS_DATA_SET =
    DEVICE_INTERNAL_STATUS_DATA_SET(1i32);
pub const DeviceStatusDataSet2: DEVICE_INTERNAL_STATUS_DATA_SET =
    DEVICE_INTERNAL_STATUS_DATA_SET(2i32);
pub const DeviceStatusDataSet3: DEVICE_INTERNAL_STATUS_DATA_SET =
    DEVICE_INTERNAL_STATUS_DATA_SET(3i32);
pub const DeviceStatusDataSet4: DEVICE_INTERNAL_STATUS_DATA_SET =
    DEVICE_INTERNAL_STATUS_DATA_SET(4i32);
pub const DeviceStatusDataSetMax: DEVICE_INTERNAL_STATUS_DATA_SET =
    DEVICE_INTERNAL_STATUS_DATA_SET(5i32);
impl ::std::convert::From<i32> for DEVICE_INTERNAL_STATUS_DATA_SET {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for DEVICE_INTERNAL_STATUS_DATA_SET {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_LOCATION {
    pub Socket: u32,
    pub Slot: u32,
    pub Adapter: u32,
    pub Port: u32,
    pub Anonymous: DEVICE_LOCATION_0,
}
impl DEVICE_LOCATION {}
impl ::std::default::Default for DEVICE_LOCATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICE_LOCATION {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICE_LOCATION {}
unsafe impl ::windows::runtime::Abi for DEVICE_LOCATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union DEVICE_LOCATION_0 {
    pub Anonymous1: DEVICE_LOCATION_0_0,
    pub Anonymous2: DEVICE_LOCATION_0_1,
}
impl DEVICE_LOCATION_0 {}
impl ::std::default::Default for DEVICE_LOCATION_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICE_LOCATION_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICE_LOCATION_0 {}
unsafe impl ::windows::runtime::Abi for DEVICE_LOCATION_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_LOCATION_0_0 {
    pub Channel: u32,
    pub Device: u32,
}
impl DEVICE_LOCATION_0_0 {}
impl ::std::default::Default for DEVICE_LOCATION_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_LOCATION_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous1_e__Struct")
            .field("Channel", &self.Channel)
            .field("Device", &self.Device)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_LOCATION_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Channel == other.Channel && self.Device == other.Device
    }
}
impl ::std::cmp::Eq for DEVICE_LOCATION_0_0 {}
unsafe impl ::windows::runtime::Abi for DEVICE_LOCATION_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_LOCATION_0_1 {
    pub Target: u32,
    pub Lun: u32,
}
impl DEVICE_LOCATION_0_1 {}
impl ::std::default::Default for DEVICE_LOCATION_0_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_LOCATION_0_1 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous2_e__Struct")
            .field("Target", &self.Target)
            .field("Lun", &self.Lun)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_LOCATION_0_1 {
    fn eq(&self, other: &Self) -> bool {
        self.Target == other.Target && self.Lun == other.Lun
    }
}
impl ::std::cmp::Eq for DEVICE_LOCATION_0_1 {}
unsafe impl ::windows::runtime::Abi for DEVICE_LOCATION_0_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_MANAGE_DATA_SET_ATTRIBUTES {
    pub Size: u32,
    pub Action: u32,
    pub Flags: u32,
    pub ParameterBlockOffset: u32,
    pub ParameterBlockLength: u32,
    pub DataSetRangesOffset: u32,
    pub DataSetRangesLength: u32,
}
impl DEVICE_MANAGE_DATA_SET_ATTRIBUTES {}
impl ::std::default::Default for DEVICE_MANAGE_DATA_SET_ATTRIBUTES {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_MANAGE_DATA_SET_ATTRIBUTES {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_MANAGE_DATA_SET_ATTRIBUTES")
            .field("Size", &self.Size)
            .field("Action", &self.Action)
            .field("Flags", &self.Flags)
            .field("ParameterBlockOffset", &self.ParameterBlockOffset)
            .field("ParameterBlockLength", &self.ParameterBlockLength)
            .field("DataSetRangesOffset", &self.DataSetRangesOffset)
            .field("DataSetRangesLength", &self.DataSetRangesLength)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_MANAGE_DATA_SET_ATTRIBUTES {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.Action == other.Action
            && self.Flags == other.Flags
            && self.ParameterBlockOffset == other.ParameterBlockOffset
            && self.ParameterBlockLength == other.ParameterBlockLength
            && self.DataSetRangesOffset == other.DataSetRangesOffset
            && self.DataSetRangesLength == other.DataSetRangesLength
    }
}
impl ::std::cmp::Eq for DEVICE_MANAGE_DATA_SET_ATTRIBUTES {}
unsafe impl ::windows::runtime::Abi for DEVICE_MANAGE_DATA_SET_ATTRIBUTES {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT {
    pub Size: u32,
    pub Action: u32,
    pub Flags: u32,
    pub OperationStatus: u32,
    pub ExtendedError: u32,
    pub TargetDetailedError: u32,
    pub ReservedStatus: u32,
    pub OutputBlockOffset: u32,
    pub OutputBlockLength: u32,
}
impl DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT {}
impl ::std::default::Default for DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT")
            .field("Size", &self.Size)
            .field("Action", &self.Action)
            .field("Flags", &self.Flags)
            .field("OperationStatus", &self.OperationStatus)
            .field("ExtendedError", &self.ExtendedError)
            .field("TargetDetailedError", &self.TargetDetailedError)
            .field("ReservedStatus", &self.ReservedStatus)
            .field("OutputBlockOffset", &self.OutputBlockOffset)
            .field("OutputBlockLength", &self.OutputBlockLength)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.Action == other.Action
            && self.Flags == other.Flags
            && self.OperationStatus == other.OperationStatus
            && self.ExtendedError == other.ExtendedError
            && self.TargetDetailedError == other.TargetDetailedError
            && self.ReservedStatus == other.ReservedStatus
            && self.OutputBlockOffset == other.OutputBlockOffset
            && self.OutputBlockLength == other.OutputBlockLength
    }
}
impl ::std::cmp::Eq for DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT {}
unsafe impl ::windows::runtime::Abi for DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_MEDIA_INFO {
    pub DeviceSpecific: DEVICE_MEDIA_INFO_0,
}
impl DEVICE_MEDIA_INFO {}
impl ::std::default::Default for DEVICE_MEDIA_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICE_MEDIA_INFO {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICE_MEDIA_INFO {}
unsafe impl ::windows::runtime::Abi for DEVICE_MEDIA_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union DEVICE_MEDIA_INFO_0 {
    pub DiskInfo: DEVICE_MEDIA_INFO_0_0,
    pub RemovableDiskInfo: DEVICE_MEDIA_INFO_0_1,
    pub TapeInfo: DEVICE_MEDIA_INFO_0_2,
}
impl DEVICE_MEDIA_INFO_0 {}
impl ::std::default::Default for DEVICE_MEDIA_INFO_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICE_MEDIA_INFO_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICE_MEDIA_INFO_0 {}
unsafe impl ::windows::runtime::Abi for DEVICE_MEDIA_INFO_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_MEDIA_INFO_0_0 {
    pub Cylinders: i64,
    pub MediaType: STORAGE_MEDIA_TYPE,
    pub TracksPerCylinder: u32,
    pub SectorsPerTrack: u32,
    pub BytesPerSector: u32,
    pub NumberMediaSides: u32,
    pub MediaCharacteristics: u32,
}
impl DEVICE_MEDIA_INFO_0_0 {}
impl ::std::default::Default for DEVICE_MEDIA_INFO_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_MEDIA_INFO_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_DiskInfo_e__Struct")
            .field("Cylinders", &self.Cylinders)
            .field("MediaType", &self.MediaType)
            .field("TracksPerCylinder", &self.TracksPerCylinder)
            .field("SectorsPerTrack", &self.SectorsPerTrack)
            .field("BytesPerSector", &self.BytesPerSector)
            .field("NumberMediaSides", &self.NumberMediaSides)
            .field("MediaCharacteristics", &self.MediaCharacteristics)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_MEDIA_INFO_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Cylinders == other.Cylinders
            && self.MediaType == other.MediaType
            && self.TracksPerCylinder == other.TracksPerCylinder
            && self.SectorsPerTrack == other.SectorsPerTrack
            && self.BytesPerSector == other.BytesPerSector
            && self.NumberMediaSides == other.NumberMediaSides
            && self.MediaCharacteristics == other.MediaCharacteristics
    }
}
impl ::std::cmp::Eq for DEVICE_MEDIA_INFO_0_0 {}
unsafe impl ::windows::runtime::Abi for DEVICE_MEDIA_INFO_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_MEDIA_INFO_0_1 {
    pub Cylinders: i64,
    pub MediaType: STORAGE_MEDIA_TYPE,
    pub TracksPerCylinder: u32,
    pub SectorsPerTrack: u32,
    pub BytesPerSector: u32,
    pub NumberMediaSides: u32,
    pub MediaCharacteristics: u32,
}
impl DEVICE_MEDIA_INFO_0_1 {}
impl ::std::default::Default for DEVICE_MEDIA_INFO_0_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_MEDIA_INFO_0_1 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_RemovableDiskInfo_e__Struct")
            .field("Cylinders", &self.Cylinders)
            .field("MediaType", &self.MediaType)
            .field("TracksPerCylinder", &self.TracksPerCylinder)
            .field("SectorsPerTrack", &self.SectorsPerTrack)
            .field("BytesPerSector", &self.BytesPerSector)
            .field("NumberMediaSides", &self.NumberMediaSides)
            .field("MediaCharacteristics", &self.MediaCharacteristics)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_MEDIA_INFO_0_1 {
    fn eq(&self, other: &Self) -> bool {
        self.Cylinders == other.Cylinders
            && self.MediaType == other.MediaType
            && self.TracksPerCylinder == other.TracksPerCylinder
            && self.SectorsPerTrack == other.SectorsPerTrack
            && self.BytesPerSector == other.BytesPerSector
            && self.NumberMediaSides == other.NumberMediaSides
            && self.MediaCharacteristics == other.MediaCharacteristics
    }
}
impl ::std::cmp::Eq for DEVICE_MEDIA_INFO_0_1 {}
unsafe impl ::windows::runtime::Abi for DEVICE_MEDIA_INFO_0_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_MEDIA_INFO_0_2 {
    pub MediaType: STORAGE_MEDIA_TYPE,
    pub MediaCharacteristics: u32,
    pub CurrentBlockSize: u32,
    pub BusType: STORAGE_BUS_TYPE,
    pub BusSpecificData: DEVICE_MEDIA_INFO_0_2_0,
}
impl DEVICE_MEDIA_INFO_0_2 {}
impl ::std::default::Default for DEVICE_MEDIA_INFO_0_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICE_MEDIA_INFO_0_2 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICE_MEDIA_INFO_0_2 {}
unsafe impl ::windows::runtime::Abi for DEVICE_MEDIA_INFO_0_2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union DEVICE_MEDIA_INFO_0_2_0 {
    pub ScsiInformation: DEVICE_MEDIA_INFO_0_2_0_0,
}
impl DEVICE_MEDIA_INFO_0_2_0 {}
impl ::std::default::Default for DEVICE_MEDIA_INFO_0_2_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICE_MEDIA_INFO_0_2_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICE_MEDIA_INFO_0_2_0 {}
unsafe impl ::windows::runtime::Abi for DEVICE_MEDIA_INFO_0_2_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_MEDIA_INFO_0_2_0_0 {
    pub MediumType: u8,
    pub DensityCode: u8,
}
impl DEVICE_MEDIA_INFO_0_2_0_0 {}
impl ::std::default::Default for DEVICE_MEDIA_INFO_0_2_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_MEDIA_INFO_0_2_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_ScsiInformation_e__Struct")
            .field("MediumType", &self.MediumType)
            .field("DensityCode", &self.DensityCode)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_MEDIA_INFO_0_2_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.MediumType == other.MediumType && self.DensityCode == other.DensityCode
    }
}
impl ::std::cmp::Eq for DEVICE_MEDIA_INFO_0_2_0_0 {}
unsafe impl ::windows::runtime::Abi for DEVICE_MEDIA_INFO_0_2_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct DEVICE_POWER_STATE(pub i32);
pub const PowerDeviceUnspecified: DEVICE_POWER_STATE = DEVICE_POWER_STATE(0i32);
pub const PowerDeviceD0: DEVICE_POWER_STATE = DEVICE_POWER_STATE(1i32);
pub const PowerDeviceD1: DEVICE_POWER_STATE = DEVICE_POWER_STATE(2i32);
pub const PowerDeviceD2: DEVICE_POWER_STATE = DEVICE_POWER_STATE(3i32);
pub const PowerDeviceD3: DEVICE_POWER_STATE = DEVICE_POWER_STATE(4i32);
pub const PowerDeviceMaximum: DEVICE_POWER_STATE = DEVICE_POWER_STATE(5i32);
impl ::std::convert::From<i32> for DEVICE_POWER_STATE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for DEVICE_POWER_STATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_STORAGE_ADDRESS_RANGE {
    pub StartAddress: i64,
    pub LengthInBytes: u64,
}
impl DEVICE_STORAGE_ADDRESS_RANGE {}
impl ::std::default::Default for DEVICE_STORAGE_ADDRESS_RANGE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_STORAGE_ADDRESS_RANGE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVICE_STORAGE_ADDRESS_RANGE")
            .field("StartAddress", &self.StartAddress)
            .field("LengthInBytes", &self.LengthInBytes)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_STORAGE_ADDRESS_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.StartAddress == other.StartAddress && self.LengthInBytes == other.LengthInBytes
    }
}
impl ::std::cmp::Eq for DEVICE_STORAGE_ADDRESS_RANGE {}
unsafe impl ::windows::runtime::Abi for DEVICE_STORAGE_ADDRESS_RANGE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DEVICE_STORAGE_NO_ERRORS: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_STORAGE_RANGE_ATTRIBUTES {
    pub LengthInBytes: u64,
    pub Anonymous: DEVICE_STORAGE_RANGE_ATTRIBUTES_0,
    pub Reserved: u32,
}
impl DEVICE_STORAGE_RANGE_ATTRIBUTES {}
impl ::std::default::Default for DEVICE_STORAGE_RANGE_ATTRIBUTES {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICE_STORAGE_RANGE_ATTRIBUTES {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICE_STORAGE_RANGE_ATTRIBUTES {}
unsafe impl ::windows::runtime::Abi for DEVICE_STORAGE_RANGE_ATTRIBUTES {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union DEVICE_STORAGE_RANGE_ATTRIBUTES_0 {
    pub AllFlags: u32,
    pub Anonymous: DEVICE_STORAGE_RANGE_ATTRIBUTES_0_0,
}
impl DEVICE_STORAGE_RANGE_ATTRIBUTES_0 {}
impl ::std::default::Default for DEVICE_STORAGE_RANGE_ATTRIBUTES_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DEVICE_STORAGE_RANGE_ATTRIBUTES_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DEVICE_STORAGE_RANGE_ATTRIBUTES_0 {}
unsafe impl ::windows::runtime::Abi for DEVICE_STORAGE_RANGE_ATTRIBUTES_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVICE_STORAGE_RANGE_ATTRIBUTES_0_0 {
    pub _bitfield: u32,
}
impl DEVICE_STORAGE_RANGE_ATTRIBUTES_0_0 {}
impl ::std::default::Default for DEVICE_STORAGE_RANGE_ATTRIBUTES_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVICE_STORAGE_RANGE_ATTRIBUTES_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVICE_STORAGE_RANGE_ATTRIBUTES_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for DEVICE_STORAGE_RANGE_ATTRIBUTES_0_0 {}
unsafe impl ::windows::runtime::Abi for DEVICE_STORAGE_RANGE_ATTRIBUTES_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DevQuery_ObjectType: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            325533506,
            41942,
            18934,
            [180, 218, 174, 70, 224, 197, 35, 124],
        ),
        pid: 2u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_Characteristics: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1126273419,
            63134,
            18189,
            [165, 222, 77, 136, 199, 90, 210, 75],
        ),
        pid: 29u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_ClassCoInstallers: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1899828995,
            41698,
            18933,
            [146, 20, 86, 71, 46, 243, 218, 92],
        ),
        pid: 2u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_ClassInstaller: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            630898684,
            20647,
            18382,
            [175, 8, 104, 201, 167, 215, 51, 102],
        ),
        pid: 5u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_ClassName: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            630898684,
            20647,
            18382,
            [175, 8, 104, 201, 167, 215, 51, 102],
        ),
        pid: 3u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_DHPRebalanceOptOut: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            3511500531,
            26319,
            19362,
            [157, 56, 13, 219, 55, 171, 71, 1],
        ),
        pid: 2u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_DefaultService: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            630898684,
            20647,
            18382,
            [175, 8, 104, 201, 167, 215, 51, 102],
        ),
        pid: 11u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_DevType: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1126273419,
            63134,
            18189,
            [165, 222, 77, 136, 199, 90, 210, 75],
        ),
        pid: 27u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_Exclusive: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1126273419,
            63134,
            18189,
            [165, 222, 77, 136, 199, 90, 210, 75],
        ),
        pid: 28u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_Icon: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            630898684,
            20647,
            18382,
            [175, 8, 104, 201, 167, 215, 51, 102],
        ),
        pid: 4u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_IconPath: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            630898684,
            20647,
            18382,
            [175, 8, 104, 201, 167, 215, 51, 102],
        ),
        pid: 12u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_LowerFilters: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1126273419,
            63134,
            18189,
            [165, 222, 77, 136, 199, 90, 210, 75],
        ),
        pid: 20u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_Name: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            630898684,
            20647,
            18382,
            [175, 8, 104, 201, 167, 215, 51, 102],
        ),
        pid: 2u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_NoDisplayClass: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            630898684,
            20647,
            18382,
            [175, 8, 104, 201, 167, 215, 51, 102],
        ),
        pid: 8u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_NoInstallClass: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            630898684,
            20647,
            18382,
            [175, 8, 104, 201, 167, 215, 51, 102],
        ),
        pid: 7u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_NoUseClass: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            630898684,
            20647,
            18382,
            [175, 8, 104, 201, 167, 215, 51, 102],
        ),
        pid: 10u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_PropPageProvider: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            630898684,
            20647,
            18382,
            [175, 8, 104, 201, 167, 215, 51, 102],
        ),
        pid: 6u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_Security: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1126273419,
            63134,
            18189,
            [165, 222, 77, 136, 199, 90, 210, 75],
        ),
        pid: 25u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_SecuritySDS: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1126273419,
            63134,
            18189,
            [165, 222, 77, 136, 199, 90, 210, 75],
        ),
        pid: 26u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_SilentInstall: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            630898684,
            20647,
            18382,
            [175, 8, 104, 201, 167, 215, 51, 102],
        ),
        pid: 9u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceClass_UpperFilters: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1126273419,
            63134,
            18189,
            [165, 222, 77, 136, 199, 90, 210, 75],
        ),
        pid: 19u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_Address: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 51u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_AlwaysShowDeviceAsConnected:
    super::PropertiesSystem::PROPERTYKEY = super::PropertiesSystem::PROPERTYKEY {
    fmtid: ::windows::runtime::GUID::from_values(
        2026065864,
        4170,
        19146,
        [158, 164, 82, 77, 82, 153, 110, 87],
    ),
    pid: 101u32,
};
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_AssociationArray: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 80u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_BaselineExperienceId: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 78u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_Category: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 90u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_CategoryGroup_Desc: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 94u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_CategoryGroup_Icon: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 95u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_Category_Desc_Plural: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 92u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_Category_Desc_Singular: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 91u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_Category_Icon: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 93u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_ConfigFlags: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 105u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_CustomPrivilegedPackageFamilyNames:
    super::PropertiesSystem::PROPERTYKEY = super::PropertiesSystem::PROPERTYKEY {
    fmtid: ::windows::runtime::GUID::from_values(
        2026065864,
        4170,
        19146,
        [158, 164, 82, 77, 82, 153, 110, 87],
    ),
    pid: 107u32,
};
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_DeviceDescription1: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 81u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_DeviceDescription2: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 82u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_DeviceFunctionSubRank: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 100u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_DiscoveryMethod: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 52u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_ExperienceId: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 89u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_FriendlyName: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1701460915,
            60608,
            17405,
            [132, 119, 74, 224, 64, 74, 150, 205],
        ),
        pid: 12288u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_HasProblem: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 83u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_Icon: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 57u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_InstallInProgress: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2212127526,
            38822,
            16520,
            [148, 83, 161, 146, 63, 87, 59, 41],
        ),
        pid: 9u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_IsAuthenticated: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 54u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_IsConnected: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 55u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_IsDefaultDevice: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 86u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_IsDeviceUniquelyIdentifiable:
    super::PropertiesSystem::PROPERTYKEY = super::PropertiesSystem::PROPERTYKEY {
    fmtid: ::windows::runtime::GUID::from_values(
        2026065864,
        4170,
        19146,
        [158, 164, 82, 77, 82, 153, 110, 87],
    ),
    pid: 79u32,
};
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_IsEncrypted: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 53u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_IsLocalMachine: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 70u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_IsMetadataSearchInProgress: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 72u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_IsNetworkDevice: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 85u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_IsNotInterestingForDisplay: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 74u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_IsPaired: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 56u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_IsRebootRequired: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 108u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_IsSharedDevice: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 84u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_IsShowInDisconnectedState: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 68u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_Last_Connected: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 67u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_Last_Seen: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 66u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_LaunchDeviceStageFromExplorer:
    super::PropertiesSystem::PROPERTYKEY = super::PropertiesSystem::PROPERTYKEY {
    fmtid: ::windows::runtime::GUID::from_values(
        2026065864,
        4170,
        19146,
        [158, 164, 82, 77, 82, 153, 110, 87],
    ),
    pid: 77u32,
};
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_LaunchDeviceStageOnDeviceConnect:
    super::PropertiesSystem::PROPERTYKEY = super::PropertiesSystem::PROPERTYKEY {
    fmtid: ::windows::runtime::GUID::from_values(
        2026065864,
        4170,
        19146,
        [158, 164, 82, 77, 82, 153, 110, 87],
    ),
    pid: 76u32,
};
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_Manufacturer: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1701460915,
            60608,
            17405,
            [132, 119, 74, 224, 64, 74, 150, 205],
        ),
        pid: 8192u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_MetadataCabinet: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 87u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_MetadataChecksum: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 73u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_MetadataPath: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 71u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_ModelName: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1701460915,
            60608,
            17405,
            [132, 119, 74, 224, 64, 74, 150, 205],
        ),
        pid: 8194u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_ModelNumber: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1701460915,
            60608,
            17405,
            [132, 119, 74, 224, 64, 74, 150, 205],
        ),
        pid: 8195u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_PrimaryCategory: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 97u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_PrivilegedPackageFamilyNames:
    super::PropertiesSystem::PROPERTYKEY = super::PropertiesSystem::PROPERTYKEY {
    fmtid: ::windows::runtime::GUID::from_values(
        2026065864,
        4170,
        19146,
        [158, 164, 82, 77, 82, 153, 110, 87],
    ),
    pid: 106u32,
};
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_RequiresPairingElevation: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 88u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_RequiresUninstallElevation: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 99u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_UnpairUninstall: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 98u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceContainer_Version: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 65u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceInterfaceClass_DefaultInterface: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            348666521,
            2879,
            17591,
            [190, 76, 161, 120, 211, 153, 5, 100],
        ),
        pid: 2u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceInterfaceClass_Name: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            348666521,
            2879,
            17591,
            [190, 76, 161, 120, 211, 153, 5, 100],
        ),
        pid: 3u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceInterface_Autoplay_Silent: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1129173647,
            40565,
            17674,
            [154, 185, 255, 97, 230, 24, 186, 208],
        ),
        pid: 2u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceInterface_ClassGuid: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            40784238,
            47124,
            16715,
            [131, 205, 133, 109, 111, 239, 72, 34],
        ),
        pid: 4u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceInterface_Enabled: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            40784238,
            47124,
            16715,
            [131, 205, 133, 109, 111, 239, 72, 34],
        ),
        pid: 3u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceInterface_FriendlyName: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            40784238,
            47124,
            16715,
            [131, 205, 133, 109, 111, 239, 72, 34],
        ),
        pid: 2u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceInterface_ReferenceString: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            40784238,
            47124,
            16715,
            [131, 205, 133, 109, 111, 239, 72, 34],
        ),
        pid: 5u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceInterface_Restricted: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            40784238,
            47124,
            16715,
            [131, 205, 133, 109, 111, 239, 72, 34],
        ),
        pid: 6u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceInterface_SchematicName: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            40784238,
            47124,
            16715,
            [131, 205, 133, 109, 111, 239, 72, 34],
        ),
        pid: 9u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DeviceInterface_UnrestrictedAppCapabilities:
    super::PropertiesSystem::PROPERTYKEY = super::PropertiesSystem::PROPERTYKEY {
    fmtid: ::windows::runtime::GUID::from_values(
        40784238,
        47124,
        16715,
        [131, 205, 133, 109, 111, 239, 72, 34],
    ),
    pid: 8u32,
};
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_AdditionalSoftwareRequested: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2830656989,
            11837,
            16532,
            [173, 151, 229, 147, 167, 12, 117, 214],
        ),
        pid: 19u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Address: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 30u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_AssignedToGuest: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 24u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_BaseContainerId: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 38u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_BiosDeviceName: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 10u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_BusNumber: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 23u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_BusRelations: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1128310469,
            37882,
            18182,
            [151, 44, 123, 100, 128, 8, 165, 167],
        ),
        pid: 7u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_BusReportedDeviceDesc: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 4u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_BusTypeGuid: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 21u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Capabilities: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 17u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Characteristics: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 29u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Children: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1128310469,
            37882,
            18182,
            [151, 44, 123, 100, 128, 8, 165, 167],
        ),
        pid: 9u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Class: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 9u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_ClassGuid: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 10u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_CompatibleIds: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 4u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_ConfigFlags: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 12u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_ConfigurationId: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 7u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_ContainerId: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2357121542,
            16266,
            18471,
            [179, 171, 174, 158, 31, 174, 252, 108],
        ),
        pid: 2u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_CreatorProcessId: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 25u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DHP_Rebalance_Policy: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 2u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DebuggerSafe: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 12u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DependencyDependents: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 21u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DependencyProviders: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 20u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DevNodeStatus: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1128310469,
            37882,
            18182,
            [151, 44, 123, 100, 128, 8, 165, 167],
        ),
        pid: 2u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DevType: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 27u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DeviceDesc: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 2u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Driver: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 11u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DriverCoInstallers: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2830656989,
            11837,
            16532,
            [173, 151, 229, 147, 167, 12, 117, 214],
        ),
        pid: 11u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DriverDate: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2830656989,
            11837,
            16532,
            [173, 151, 229, 147, 167, 12, 117, 214],
        ),
        pid: 2u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DriverDesc: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2830656989,
            11837,
            16532,
            [173, 151, 229, 147, 167, 12, 117, 214],
        ),
        pid: 4u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DriverInfPath: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2830656989,
            11837,
            16532,
            [173, 151, 229, 147, 167, 12, 117, 214],
        ),
        pid: 5u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DriverInfSection: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2830656989,
            11837,
            16532,
            [173, 151, 229, 147, 167, 12, 117, 214],
        ),
        pid: 6u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DriverInfSectionExt: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2830656989,
            11837,
            16532,
            [173, 151, 229, 147, 167, 12, 117, 214],
        ),
        pid: 7u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DriverLogoLevel: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2830656989,
            11837,
            16532,
            [173, 151, 229, 147, 167, 12, 117, 214],
        ),
        pid: 15u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DriverProblemDesc: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 11u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DriverPropPageProvider: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2830656989,
            11837,
            16532,
            [173, 151, 229, 147, 167, 12, 117, 214],
        ),
        pid: 10u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DriverProvider: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2830656989,
            11837,
            16532,
            [173, 151, 229, 147, 167, 12, 117, 214],
        ),
        pid: 9u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DriverRank: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2830656989,
            11837,
            16532,
            [173, 151, 229, 147, 167, 12, 117, 214],
        ),
        pid: 14u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_DriverVersion: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2830656989,
            11837,
            16532,
            [173, 151, 229, 147, 167, 12, 117, 214],
        ),
        pid: 3u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_EjectionRelations: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1128310469,
            37882,
            18182,
            [151, 44, 123, 100, 128, 8, 165, 167],
        ),
        pid: 4u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_EnumeratorName: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 24u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Exclusive: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 28u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_ExtendedAddress: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 23u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_ExtendedConfigurationIds: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 15u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_FirmwareDate: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 17u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_FirmwareRevision: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 19u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_FirmwareVersion: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 18u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_FirstInstallDate: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2212127526,
            38822,
            16520,
            [148, 83, 161, 146, 63, 87, 59, 41],
        ),
        pid: 101u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_FriendlyName: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 14u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_FriendlyNameAttributes: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2161647270,
            29811,
            19212,
            [130, 22, 239, 193, 26, 44, 76, 139],
        ),
        pid: 3u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_GenericDriverInstalled: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2830656989,
            11837,
            16532,
            [173, 151, 229, 147, 167, 12, 117, 214],
        ),
        pid: 18u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_HardwareIds: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 3u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_HasProblem: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 6u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_InLocalMachineContainer: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2357121542,
            16266,
            18471,
            [179, 171, 174, 158, 31, 174, 252, 108],
        ),
        pid: 4u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_InstallDate: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2212127526,
            38822,
            16520,
            [148, 83, 161, 146, 63, 87, 59, 41],
        ),
        pid: 100u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_InstallState: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 36u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_InstanceId: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 256u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_IsAssociateableByUserAction: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2161647270,
            29811,
            19212,
            [130, 22, 239, 193, 26, 44, 76, 139],
        ),
        pid: 7u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_IsPresent: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 5u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_IsRebootRequired: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 16u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_LastArrivalDate: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2212127526,
            38822,
            16520,
            [148, 83, 161, 146, 63, 87, 59, 41],
        ),
        pid: 102u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_LastRemovalDate: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2212127526,
            38822,
            16520,
            [148, 83, 161, 146, 63, 87, 59, 41],
        ),
        pid: 103u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Legacy: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2152296704,
            35955,
            18617,
            [170, 217, 206, 56, 126, 25, 197, 110],
        ),
        pid: 3u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_LegacyBusType: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 22u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_LocationInfo: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 15u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_LocationPaths: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 37u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_LowerFilters: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 20u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Manufacturer: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 13u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_ManufacturerAttributes: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2161647270,
            29811,
            19212,
            [130, 22, 239, 193, 26, 44, 76, 139],
        ),
        pid: 4u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_MatchingDeviceId: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2830656989,
            11837,
            16532,
            [173, 151, 229, 147, 167, 12, 117, 214],
        ),
        pid: 8u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Model: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2026065864,
            4170,
            19146,
            [158, 164, 82, 77, 82, 153, 110, 87],
        ),
        pid: 39u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_ModelId: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2161647270,
            29811,
            19212,
            [130, 22, 239, 193, 26, 44, 76, 139],
        ),
        pid: 2u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_NoConnectSound: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2830656989,
            11837,
            16532,
            [173, 151, 229, 147, 167, 12, 117, 214],
        ),
        pid: 17u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Numa_Node: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 3u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Numa_Proximity_Domain: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 1u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_PDOName: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 16u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Parent: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1128310469,
            37882,
            18182,
            [151, 44, 123, 100, 128, 8, 165, 167],
        ),
        pid: 8u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_PhysicalDeviceLocation: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 9u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_PostInstallInProgress: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 13u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_PowerData: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 32u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_PowerRelations: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1128310469,
            37882,
            18182,
            [151, 44, 123, 100, 128, 8, 165, 167],
        ),
        pid: 6u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_PresenceNotForDevice: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2161647270,
            29811,
            19212,
            [130, 22, 239, 193, 26, 44, 76, 139],
        ),
        pid: 5u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_ProblemCode: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1128310469,
            37882,
            18182,
            [151, 44, 123, 100, 128, 8, 165, 167],
        ),
        pid: 3u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_ProblemStatus: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1128310469,
            37882,
            18182,
            [151, 44, 123, 100, 128, 8, 165, 167],
        ),
        pid: 12u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_RemovalPolicy: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 33u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_RemovalPolicyDefault: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 34u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_RemovalPolicyOverride: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 35u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_RemovalRelations: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1128310469,
            37882,
            18182,
            [151, 44, 123, 100, 128, 8, 165, 167],
        ),
        pid: 5u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Reported: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2152296704,
            35955,
            18617,
            [170, 217, 206, 56, 126, 25, 197, 110],
        ),
        pid: 2u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_ReportedDeviceIdsHash: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 8u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_ResourcePickerExceptions: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2830656989,
            11837,
            16532,
            [173, 151, 229, 147, 167, 12, 117, 214],
        ),
        pid: 13u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_ResourcePickerTags: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2830656989,
            11837,
            16532,
            [173, 151, 229, 147, 167, 12, 117, 214],
        ),
        pid: 12u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_SafeRemovalRequired: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2950264384,
            34467,
            16912,
            [182, 124, 40, 156, 65, 170, 190, 85],
        ),
        pid: 2u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_SafeRemovalRequiredOverride: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2950264384,
            34467,
            16912,
            [182, 124, 40, 156, 65, 170, 190, 85],
        ),
        pid: 3u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Security: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 25u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_SecuritySDS: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 26u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Service: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 6u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_SessionId: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2212127526,
            38822,
            16520,
            [148, 83, 161, 146, 63, 87, 59, 41],
        ),
        pid: 6u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_ShowInUninstallUI: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2161647270,
            29811,
            19212,
            [130, 22, 239, 193, 26, 44, 76, 139],
        ),
        pid: 8u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Siblings: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1128310469,
            37882,
            18182,
            [151, 44, 123, 100, 128, 8, 165, 167],
        ),
        pid: 10u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_SignalStrength: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2161647270,
            29811,
            19212,
            [130, 22, 239, 193, 26, 44, 76, 139],
        ),
        pid: 6u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_SoftRestartSupported: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 22u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_Stack: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1410045054,
            35648,
            17852,
            [168, 162, 106, 11, 137, 76, 189, 162],
        ),
        pid: 14u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_TransportRelations: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1128310469,
            37882,
            18182,
            [151, 44, 123, 100, 128, 8, 165, 167],
        ),
        pid: 11u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_UINumber: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 18u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_UINumberDescFormat: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 31u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Device_UpperFilters: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            2757502286,
            57116,
            20221,
            [128, 32, 103, 209, 70, 168, 80, 224],
        ),
        pid: 19u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DrvPkg_BrandingIcon: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            3480468305,
            15039,
            17570,
            [133, 224, 154, 61, 199, 161, 33, 50],
        ),
        pid: 7u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DrvPkg_DetailedDescription: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            3480468305,
            15039,
            17570,
            [133, 224, 154, 61, 199, 161, 33, 50],
        ),
        pid: 4u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DrvPkg_DocumentationLink: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            3480468305,
            15039,
            17570,
            [133, 224, 154, 61, 199, 161, 33, 50],
        ),
        pid: 5u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DrvPkg_Icon: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            3480468305,
            15039,
            17570,
            [133, 224, 154, 61, 199, 161, 33, 50],
        ),
        pid: 6u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DrvPkg_Model: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            3480468305,
            15039,
            17570,
            [133, 224, 154, 61, 199, 161, 33, 50],
        ),
        pid: 2u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_DrvPkg_VendorWebSite: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            3480468305,
            15039,
            17570,
            [133, 224, 154, 61, 199, 161, 33, 50],
        ),
        pid: 3u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_NAME: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            3072717104,
            18415,
            4122,
            [165, 241, 2, 96, 140, 158, 235, 172],
        ),
        pid: 10u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Storage_Disk_Number: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1293860584,
            2051,
            18292,
            [152, 66, 183, 125, 181, 2, 101, 233],
        ),
        pid: 5u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Storage_Gpt_Name: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1293860584,
            2051,
            18292,
            [152, 66, 183, 125, 181, 2, 101, 233],
        ),
        pid: 9u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Storage_Gpt_Type: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1293860584,
            2051,
            18292,
            [152, 66, 183, 125, 181, 2, 101, 233],
        ),
        pid: 8u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Storage_Mbr_Type: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1293860584,
            2051,
            18292,
            [152, 66, 183, 125, 181, 2, 101, 233],
        ),
        pid: 7u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Storage_Partition_Number: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1293860584,
            2051,
            18292,
            [152, 66, 183, 125, 181, 2, 101, 233],
        ),
        pid: 6u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Storage_Portable: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1293860584,
            2051,
            18292,
            [152, 66, 183, 125, 181, 2, 101, 233],
        ),
        pid: 2u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Storage_Removable_Media: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1293860584,
            2051,
            18292,
            [152, 66, 183, 125, 181, 2, 101, 233],
        ),
        pid: 3u32,
    };
#[cfg(feature = "Win32_System_PropertiesSystem")]
pub const DEVPKEY_Storage_System_Critical: super::PropertiesSystem::PROPERTYKEY =
    super::PropertiesSystem::PROPERTYKEY {
        fmtid: ::windows::runtime::GUID::from_values(
            1293860584,
            2051,
            18292,
            [152, 66, 183, 125, 181, 2, 101, 233],
        ),
        pid: 4u32,
    };
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct DEVPROPCOMPKEY {
    pub Key: DEVPROPKEY,
    pub Store: DEVPROPSTORE,
    pub LocaleName: super::super::Foundation::PWSTR,
}
#[cfg(feature = "Win32_Foundation")]
impl DEVPROPCOMPKEY {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for DEVPROPCOMPKEY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for DEVPROPCOMPKEY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVPROPCOMPKEY")
            .field("Key", &self.Key)
            .field("Store", &self.Store)
            .field("LocaleName", &self.LocaleName)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for DEVPROPCOMPKEY {
    fn eq(&self, other: &Self) -> bool {
        self.Key == other.Key && self.Store == other.Store && self.LocaleName == other.LocaleName
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for DEVPROPCOMPKEY {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for DEVPROPCOMPKEY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct DEVPROPERTY {
    pub CompKey: DEVPROPCOMPKEY,
    pub Type: u32,
    pub BufferSize: u32,
    pub Buffer: *mut ::std::ffi::c_void,
}
#[cfg(feature = "Win32_Foundation")]
impl DEVPROPERTY {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for DEVPROPERTY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for DEVPROPERTY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVPROPERTY")
            .field("CompKey", &self.CompKey)
            .field("Type", &self.Type)
            .field("BufferSize", &self.BufferSize)
            .field("Buffer", &self.Buffer)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for DEVPROPERTY {
    fn eq(&self, other: &Self) -> bool {
        self.CompKey == other.CompKey
            && self.Type == other.Type
            && self.BufferSize == other.BufferSize
            && self.Buffer == other.Buffer
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for DEVPROPERTY {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for DEVPROPERTY {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DEVPROPID_FIRST_USABLE: u32 = 2u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEVPROPKEY {
    pub fmtid: ::windows::runtime::GUID,
    pub pid: u32,
}
impl DEVPROPKEY {}
impl ::std::default::Default for DEVPROPKEY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEVPROPKEY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEVPROPKEY")
            .field("fmtid", &self.fmtid)
            .field("pid", &self.pid)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEVPROPKEY {
    fn eq(&self, other: &Self) -> bool {
        self.fmtid == other.fmtid && self.pid == other.pid
    }
}
impl ::std::cmp::Eq for DEVPROPKEY {}
unsafe impl ::windows::runtime::Abi for DEVPROPKEY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct DEVPROPSTORE(pub i32);
pub const DEVPROP_STORE_SYSTEM: DEVPROPSTORE = DEVPROPSTORE(0i32);
pub const DEVPROP_STORE_USER: DEVPROPSTORE = DEVPROPSTORE(1i32);
impl ::std::convert::From<i32> for DEVPROPSTORE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for DEVPROPSTORE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DEVPROP_MASK_TYPE: u32 = 4095u32;
pub const DEVPROP_MASK_TYPEMOD: u32 = 61440u32;
pub const DEVPROP_TYPEMOD_ARRAY: u32 = 4096u32;
pub const DEVPROP_TYPEMOD_LIST: u32 = 8192u32;
pub const DEVPROP_TYPE_BOOLEAN: u32 = 17u32;
pub const DEVPROP_TYPE_BYTE: u32 = 3u32;
pub const DEVPROP_TYPE_CURRENCY: u32 = 14u32;
pub const DEVPROP_TYPE_DATE: u32 = 15u32;
pub const DEVPROP_TYPE_DECIMAL: u32 = 12u32;
pub const DEVPROP_TYPE_DEVPROPKEY: u32 = 21u32;
pub const DEVPROP_TYPE_DEVPROPTYPE: u32 = 22u32;
pub const DEVPROP_TYPE_DOUBLE: u32 = 11u32;
pub const DEVPROP_TYPE_EMPTY: u32 = 0u32;
pub const DEVPROP_TYPE_ERROR: u32 = 23u32;
pub const DEVPROP_TYPE_FILETIME: u32 = 16u32;
pub const DEVPROP_TYPE_FLOAT: u32 = 10u32;
pub const DEVPROP_TYPE_GUID: u32 = 13u32;
pub const DEVPROP_TYPE_INT16: u32 = 4u32;
pub const DEVPROP_TYPE_INT32: u32 = 6u32;
pub const DEVPROP_TYPE_INT64: u32 = 8u32;
pub const DEVPROP_TYPE_NTSTATUS: u32 = 24u32;
pub const DEVPROP_TYPE_NULL: u32 = 1u32;
pub const DEVPROP_TYPE_SBYTE: u32 = 2u32;
pub const DEVPROP_TYPE_SECURITY_DESCRIPTOR: u32 = 19u32;
pub const DEVPROP_TYPE_SECURITY_DESCRIPTOR_STRING: u32 = 20u32;
pub const DEVPROP_TYPE_STRING: u32 = 18u32;
pub const DEVPROP_TYPE_STRING_INDIRECT: u32 = 25u32;
pub const DEVPROP_TYPE_UINT16: u32 = 5u32;
pub const DEVPROP_TYPE_UINT32: u32 = 7u32;
pub const DEVPROP_TYPE_UINT64: u32 = 9u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEV_BROADCAST_DEVICEINTERFACE_A {
    pub dbcc_size: u32,
    pub dbcc_devicetype: u32,
    pub dbcc_reserved: u32,
    pub dbcc_classguid: ::windows::runtime::GUID,
    pub dbcc_name: [CHAR; 1],
}
impl DEV_BROADCAST_DEVICEINTERFACE_A {}
impl ::std::default::Default for DEV_BROADCAST_DEVICEINTERFACE_A {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEV_BROADCAST_DEVICEINTERFACE_A {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEV_BROADCAST_DEVICEINTERFACE_A")
            .field("dbcc_size", &self.dbcc_size)
            .field("dbcc_devicetype", &self.dbcc_devicetype)
            .field("dbcc_reserved", &self.dbcc_reserved)
            .field("dbcc_classguid", &self.dbcc_classguid)
            .field("dbcc_name", &self.dbcc_name)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEV_BROADCAST_DEVICEINTERFACE_A {
    fn eq(&self, other: &Self) -> bool {
        self.dbcc_size == other.dbcc_size
            && self.dbcc_devicetype == other.dbcc_devicetype
            && self.dbcc_reserved == other.dbcc_reserved
            && self.dbcc_classguid == other.dbcc_classguid
            && self.dbcc_name == other.dbcc_name
    }
}
impl ::std::cmp::Eq for DEV_BROADCAST_DEVICEINTERFACE_A {}
unsafe impl ::windows::runtime::Abi for DEV_BROADCAST_DEVICEINTERFACE_A {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEV_BROADCAST_DEVICEINTERFACE_W {
    pub dbcc_size: u32,
    pub dbcc_devicetype: u32,
    pub dbcc_reserved: u32,
    pub dbcc_classguid: ::windows::runtime::GUID,
    pub dbcc_name: [u16; 1],
}
impl DEV_BROADCAST_DEVICEINTERFACE_W {}
impl ::std::default::Default for DEV_BROADCAST_DEVICEINTERFACE_W {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEV_BROADCAST_DEVICEINTERFACE_W {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEV_BROADCAST_DEVICEINTERFACE_W")
            .field("dbcc_size", &self.dbcc_size)
            .field("dbcc_devicetype", &self.dbcc_devicetype)
            .field("dbcc_reserved", &self.dbcc_reserved)
            .field("dbcc_classguid", &self.dbcc_classguid)
            .field("dbcc_name", &self.dbcc_name)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEV_BROADCAST_DEVICEINTERFACE_W {
    fn eq(&self, other: &Self) -> bool {
        self.dbcc_size == other.dbcc_size
            && self.dbcc_devicetype == other.dbcc_devicetype
            && self.dbcc_reserved == other.dbcc_reserved
            && self.dbcc_classguid == other.dbcc_classguid
            && self.dbcc_name == other.dbcc_name
    }
}
impl ::std::cmp::Eq for DEV_BROADCAST_DEVICEINTERFACE_W {}
unsafe impl ::windows::runtime::Abi for DEV_BROADCAST_DEVICEINTERFACE_W {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEV_BROADCAST_DEVNODE {
    pub dbcd_size: u32,
    pub dbcd_devicetype: u32,
    pub dbcd_reserved: u32,
    pub dbcd_devnode: u32,
}
impl DEV_BROADCAST_DEVNODE {}
impl ::std::default::Default for DEV_BROADCAST_DEVNODE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEV_BROADCAST_DEVNODE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEV_BROADCAST_DEVNODE")
            .field("dbcd_size", &self.dbcd_size)
            .field("dbcd_devicetype", &self.dbcd_devicetype)
            .field("dbcd_reserved", &self.dbcd_reserved)
            .field("dbcd_devnode", &self.dbcd_devnode)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEV_BROADCAST_DEVNODE {
    fn eq(&self, other: &Self) -> bool {
        self.dbcd_size == other.dbcd_size
            && self.dbcd_devicetype == other.dbcd_devicetype
            && self.dbcd_reserved == other.dbcd_reserved
            && self.dbcd_devnode == other.dbcd_devnode
    }
}
impl ::std::cmp::Eq for DEV_BROADCAST_DEVNODE {}
unsafe impl ::windows::runtime::Abi for DEV_BROADCAST_DEVNODE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct DEV_BROADCAST_HANDLE {
    pub dbch_size: u32,
    pub dbch_devicetype: u32,
    pub dbch_reserved: u32,
    pub dbch_handle: super::super::Foundation::HANDLE,
    pub dbch_hdevnotify: *mut ::std::ffi::c_void,
    pub dbch_eventguid: ::windows::runtime::GUID,
    pub dbch_nameoffset: i32,
    pub dbch_data: [u8; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl DEV_BROADCAST_HANDLE {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for DEV_BROADCAST_HANDLE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for DEV_BROADCAST_HANDLE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEV_BROADCAST_HANDLE")
            .field("dbch_size", &self.dbch_size)
            .field("dbch_devicetype", &self.dbch_devicetype)
            .field("dbch_reserved", &self.dbch_reserved)
            .field("dbch_handle", &self.dbch_handle)
            .field("dbch_hdevnotify", &self.dbch_hdevnotify)
            .field("dbch_eventguid", &self.dbch_eventguid)
            .field("dbch_nameoffset", &self.dbch_nameoffset)
            .field("dbch_data", &self.dbch_data)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for DEV_BROADCAST_HANDLE {
    fn eq(&self, other: &Self) -> bool {
        self.dbch_size == other.dbch_size
            && self.dbch_devicetype == other.dbch_devicetype
            && self.dbch_reserved == other.dbch_reserved
            && self.dbch_handle == other.dbch_handle
            && self.dbch_hdevnotify == other.dbch_hdevnotify
            && self.dbch_eventguid == other.dbch_eventguid
            && self.dbch_nameoffset == other.dbch_nameoffset
            && self.dbch_data == other.dbch_data
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for DEV_BROADCAST_HANDLE {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for DEV_BROADCAST_HANDLE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEV_BROADCAST_HANDLE32 {
    pub dbch_size: u32,
    pub dbch_devicetype: u32,
    pub dbch_reserved: u32,
    pub dbch_handle: u32,
    pub dbch_hdevnotify: u32,
    pub dbch_eventguid: ::windows::runtime::GUID,
    pub dbch_nameoffset: i32,
    pub dbch_data: [u8; 1],
}
impl DEV_BROADCAST_HANDLE32 {}
impl ::std::default::Default for DEV_BROADCAST_HANDLE32 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEV_BROADCAST_HANDLE32 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEV_BROADCAST_HANDLE32")
            .field("dbch_size", &self.dbch_size)
            .field("dbch_devicetype", &self.dbch_devicetype)
            .field("dbch_reserved", &self.dbch_reserved)
            .field("dbch_handle", &self.dbch_handle)
            .field("dbch_hdevnotify", &self.dbch_hdevnotify)
            .field("dbch_eventguid", &self.dbch_eventguid)
            .field("dbch_nameoffset", &self.dbch_nameoffset)
            .field("dbch_data", &self.dbch_data)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEV_BROADCAST_HANDLE32 {
    fn eq(&self, other: &Self) -> bool {
        self.dbch_size == other.dbch_size
            && self.dbch_devicetype == other.dbch_devicetype
            && self.dbch_reserved == other.dbch_reserved
            && self.dbch_handle == other.dbch_handle
            && self.dbch_hdevnotify == other.dbch_hdevnotify
            && self.dbch_eventguid == other.dbch_eventguid
            && self.dbch_nameoffset == other.dbch_nameoffset
            && self.dbch_data == other.dbch_data
    }
}
impl ::std::cmp::Eq for DEV_BROADCAST_HANDLE32 {}
unsafe impl ::windows::runtime::Abi for DEV_BROADCAST_HANDLE32 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEV_BROADCAST_HANDLE64 {
    pub dbch_size: u32,
    pub dbch_devicetype: u32,
    pub dbch_reserved: u32,
    pub dbch_handle: u64,
    pub dbch_hdevnotify: u64,
    pub dbch_eventguid: ::windows::runtime::GUID,
    pub dbch_nameoffset: i32,
    pub dbch_data: [u8; 1],
}
impl DEV_BROADCAST_HANDLE64 {}
impl ::std::default::Default for DEV_BROADCAST_HANDLE64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEV_BROADCAST_HANDLE64 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEV_BROADCAST_HANDLE64")
            .field("dbch_size", &self.dbch_size)
            .field("dbch_devicetype", &self.dbch_devicetype)
            .field("dbch_reserved", &self.dbch_reserved)
            .field("dbch_handle", &self.dbch_handle)
            .field("dbch_hdevnotify", &self.dbch_hdevnotify)
            .field("dbch_eventguid", &self.dbch_eventguid)
            .field("dbch_nameoffset", &self.dbch_nameoffset)
            .field("dbch_data", &self.dbch_data)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEV_BROADCAST_HANDLE64 {
    fn eq(&self, other: &Self) -> bool {
        self.dbch_size == other.dbch_size
            && self.dbch_devicetype == other.dbch_devicetype
            && self.dbch_reserved == other.dbch_reserved
            && self.dbch_handle == other.dbch_handle
            && self.dbch_hdevnotify == other.dbch_hdevnotify
            && self.dbch_eventguid == other.dbch_eventguid
            && self.dbch_nameoffset == other.dbch_nameoffset
            && self.dbch_data == other.dbch_data
    }
}
impl ::std::cmp::Eq for DEV_BROADCAST_HANDLE64 {}
unsafe impl ::windows::runtime::Abi for DEV_BROADCAST_HANDLE64 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEV_BROADCAST_HDR {
    pub dbch_size: u32,
    pub dbch_devicetype: DEV_BROADCAST_HDR_DEVICE_TYPE,
    pub dbch_reserved: u32,
}
impl DEV_BROADCAST_HDR {}
impl ::std::default::Default for DEV_BROADCAST_HDR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEV_BROADCAST_HDR {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEV_BROADCAST_HDR")
            .field("dbch_size", &self.dbch_size)
            .field("dbch_devicetype", &self.dbch_devicetype)
            .field("dbch_reserved", &self.dbch_reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEV_BROADCAST_HDR {
    fn eq(&self, other: &Self) -> bool {
        self.dbch_size == other.dbch_size
            && self.dbch_devicetype == other.dbch_devicetype
            && self.dbch_reserved == other.dbch_reserved
    }
}
impl ::std::cmp::Eq for DEV_BROADCAST_HDR {}
unsafe impl ::windows::runtime::Abi for DEV_BROADCAST_HDR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct DEV_BROADCAST_HDR_DEVICE_TYPE(pub u32);
pub const DBT_DEVTYP_DEVICEINTERFACE: DEV_BROADCAST_HDR_DEVICE_TYPE =
    DEV_BROADCAST_HDR_DEVICE_TYPE(5u32);
pub const DBT_DEVTYP_HANDLE: DEV_BROADCAST_HDR_DEVICE_TYPE = DEV_BROADCAST_HDR_DEVICE_TYPE(6u32);
pub const DBT_DEVTYP_OEM: DEV_BROADCAST_HDR_DEVICE_TYPE = DEV_BROADCAST_HDR_DEVICE_TYPE(0u32);
pub const DBT_DEVTYP_PORT: DEV_BROADCAST_HDR_DEVICE_TYPE = DEV_BROADCAST_HDR_DEVICE_TYPE(3u32);
pub const DBT_DEVTYP_VOLUME: DEV_BROADCAST_HDR_DEVICE_TYPE = DEV_BROADCAST_HDR_DEVICE_TYPE(2u32);
impl ::std::convert::From<u32> for DEV_BROADCAST_HDR_DEVICE_TYPE {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for DEV_BROADCAST_HDR_DEVICE_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for DEV_BROADCAST_HDR_DEVICE_TYPE {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for DEV_BROADCAST_HDR_DEVICE_TYPE {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for DEV_BROADCAST_HDR_DEVICE_TYPE {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for DEV_BROADCAST_HDR_DEVICE_TYPE {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for DEV_BROADCAST_HDR_DEVICE_TYPE {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEV_BROADCAST_NET {
    pub dbcn_size: u32,
    pub dbcn_devicetype: u32,
    pub dbcn_reserved: u32,
    pub dbcn_resource: u32,
    pub dbcn_flags: u32,
}
impl DEV_BROADCAST_NET {}
impl ::std::default::Default for DEV_BROADCAST_NET {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEV_BROADCAST_NET {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEV_BROADCAST_NET")
            .field("dbcn_size", &self.dbcn_size)
            .field("dbcn_devicetype", &self.dbcn_devicetype)
            .field("dbcn_reserved", &self.dbcn_reserved)
            .field("dbcn_resource", &self.dbcn_resource)
            .field("dbcn_flags", &self.dbcn_flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEV_BROADCAST_NET {
    fn eq(&self, other: &Self) -> bool {
        self.dbcn_size == other.dbcn_size
            && self.dbcn_devicetype == other.dbcn_devicetype
            && self.dbcn_reserved == other.dbcn_reserved
            && self.dbcn_resource == other.dbcn_resource
            && self.dbcn_flags == other.dbcn_flags
    }
}
impl ::std::cmp::Eq for DEV_BROADCAST_NET {}
unsafe impl ::windows::runtime::Abi for DEV_BROADCAST_NET {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEV_BROADCAST_OEM {
    pub dbco_size: u32,
    pub dbco_devicetype: u32,
    pub dbco_reserved: u32,
    pub dbco_identifier: u32,
    pub dbco_suppfunc: u32,
}
impl DEV_BROADCAST_OEM {}
impl ::std::default::Default for DEV_BROADCAST_OEM {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEV_BROADCAST_OEM {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEV_BROADCAST_OEM")
            .field("dbco_size", &self.dbco_size)
            .field("dbco_devicetype", &self.dbco_devicetype)
            .field("dbco_reserved", &self.dbco_reserved)
            .field("dbco_identifier", &self.dbco_identifier)
            .field("dbco_suppfunc", &self.dbco_suppfunc)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEV_BROADCAST_OEM {
    fn eq(&self, other: &Self) -> bool {
        self.dbco_size == other.dbco_size
            && self.dbco_devicetype == other.dbco_devicetype
            && self.dbco_reserved == other.dbco_reserved
            && self.dbco_identifier == other.dbco_identifier
            && self.dbco_suppfunc == other.dbco_suppfunc
    }
}
impl ::std::cmp::Eq for DEV_BROADCAST_OEM {}
unsafe impl ::windows::runtime::Abi for DEV_BROADCAST_OEM {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEV_BROADCAST_PORT_A {
    pub dbcp_size: u32,
    pub dbcp_devicetype: u32,
    pub dbcp_reserved: u32,
    pub dbcp_name: [CHAR; 1],
}
impl DEV_BROADCAST_PORT_A {}
impl ::std::default::Default for DEV_BROADCAST_PORT_A {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEV_BROADCAST_PORT_A {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEV_BROADCAST_PORT_A")
            .field("dbcp_size", &self.dbcp_size)
            .field("dbcp_devicetype", &self.dbcp_devicetype)
            .field("dbcp_reserved", &self.dbcp_reserved)
            .field("dbcp_name", &self.dbcp_name)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEV_BROADCAST_PORT_A {
    fn eq(&self, other: &Self) -> bool {
        self.dbcp_size == other.dbcp_size
            && self.dbcp_devicetype == other.dbcp_devicetype
            && self.dbcp_reserved == other.dbcp_reserved
            && self.dbcp_name == other.dbcp_name
    }
}
impl ::std::cmp::Eq for DEV_BROADCAST_PORT_A {}
unsafe impl ::windows::runtime::Abi for DEV_BROADCAST_PORT_A {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEV_BROADCAST_PORT_W {
    pub dbcp_size: u32,
    pub dbcp_devicetype: u32,
    pub dbcp_reserved: u32,
    pub dbcp_name: [u16; 1],
}
impl DEV_BROADCAST_PORT_W {}
impl ::std::default::Default for DEV_BROADCAST_PORT_W {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEV_BROADCAST_PORT_W {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEV_BROADCAST_PORT_W")
            .field("dbcp_size", &self.dbcp_size)
            .field("dbcp_devicetype", &self.dbcp_devicetype)
            .field("dbcp_reserved", &self.dbcp_reserved)
            .field("dbcp_name", &self.dbcp_name)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEV_BROADCAST_PORT_W {
    fn eq(&self, other: &Self) -> bool {
        self.dbcp_size == other.dbcp_size
            && self.dbcp_devicetype == other.dbcp_devicetype
            && self.dbcp_reserved == other.dbcp_reserved
            && self.dbcp_name == other.dbcp_name
    }
}
impl ::std::cmp::Eq for DEV_BROADCAST_PORT_W {}
unsafe impl ::windows::runtime::Abi for DEV_BROADCAST_PORT_W {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DEV_BROADCAST_VOLUME {
    pub dbcv_size: u32,
    pub dbcv_devicetype: u32,
    pub dbcv_reserved: u32,
    pub dbcv_unitmask: u32,
    pub dbcv_flags: DEV_BROADCAST_VOLUME_FLAGS,
}
impl DEV_BROADCAST_VOLUME {}
impl ::std::default::Default for DEV_BROADCAST_VOLUME {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DEV_BROADCAST_VOLUME {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DEV_BROADCAST_VOLUME")
            .field("dbcv_size", &self.dbcv_size)
            .field("dbcv_devicetype", &self.dbcv_devicetype)
            .field("dbcv_reserved", &self.dbcv_reserved)
            .field("dbcv_unitmask", &self.dbcv_unitmask)
            .field("dbcv_flags", &self.dbcv_flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DEV_BROADCAST_VOLUME {
    fn eq(&self, other: &Self) -> bool {
        self.dbcv_size == other.dbcv_size
            && self.dbcv_devicetype == other.dbcv_devicetype
            && self.dbcv_reserved == other.dbcv_reserved
            && self.dbcv_unitmask == other.dbcv_unitmask
            && self.dbcv_flags == other.dbcv_flags
    }
}
impl ::std::cmp::Eq for DEV_BROADCAST_VOLUME {}
unsafe impl ::windows::runtime::Abi for DEV_BROADCAST_VOLUME {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct DEV_BROADCAST_VOLUME_FLAGS(pub u16);
pub const DBTF_MEDIA: DEV_BROADCAST_VOLUME_FLAGS = DEV_BROADCAST_VOLUME_FLAGS(1u16);
pub const DBTF_NET: DEV_BROADCAST_VOLUME_FLAGS = DEV_BROADCAST_VOLUME_FLAGS(2u16);
impl ::std::convert::From<u16> for DEV_BROADCAST_VOLUME_FLAGS {
    fn from(value: u16) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for DEV_BROADCAST_VOLUME_FLAGS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: clone :: Clone,
    :: std :: marker :: Copy,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
)]
#[repr(transparent)]
pub struct DHPDEV(pub isize);
impl ::std::default::Default for DHPDEV {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
unsafe impl ::windows::runtime::Handle for DHPDEV {}
unsafe impl ::windows::runtime::Abi for DHPDEV {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: clone :: Clone,
    :: std :: marker :: Copy,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
)]
#[repr(transparent)]
pub struct DHSURF(pub isize);
impl ::std::default::Default for DHSURF {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
unsafe impl ::windows::runtime::Handle for DHSURF {}
unsafe impl ::windows::runtime::Abi for DHSURF {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DIAGNOSTIC_REASON_DETAILED_STRING: u32 = 2u32;
pub const DIAGNOSTIC_REASON_NOT_SPECIFIED: u32 = 2147483648u32;
pub const DIAGNOSTIC_REASON_SIMPLE_STRING: u32 = 1u32;
pub const DIAGNOSTIC_REASON_VERSION: u32 = 0u32;
pub const DIRECT3D_VERSION: u32 = 1792u32;
pub const DISABLE_SMART: u32 = 217u32;
pub const DISCHARGE_POLICY_CRITICAL: u32 = 0u32;
pub const DISCHARGE_POLICY_LOW: u32 = 1u32;
pub const DISK_ATTRIBUTE_OFFLINE: u64 = 1u64;
pub const DISK_ATTRIBUTE_READ_ONLY: u64 = 2u64;
pub const DISK_BINNING: u32 = 3u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct DISK_CACHE_RETENTION_PRIORITY(pub i32);
pub const EqualPriority: DISK_CACHE_RETENTION_PRIORITY = DISK_CACHE_RETENTION_PRIORITY(0i32);
pub const KeepPrefetchedData: DISK_CACHE_RETENTION_PRIORITY = DISK_CACHE_RETENTION_PRIORITY(1i32);
pub const KeepReadData: DISK_CACHE_RETENTION_PRIORITY = DISK_CACHE_RETENTION_PRIORITY(2i32);
impl ::std::convert::From<i32> for DISK_CACHE_RETENTION_PRIORITY {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for DISK_CACHE_RETENTION_PRIORITY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DISK_CONTROLLER_NUMBER {
    pub ControllerNumber: u32,
    pub DiskNumber: u32,
}
impl DISK_CONTROLLER_NUMBER {}
impl ::std::default::Default for DISK_CONTROLLER_NUMBER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DISK_CONTROLLER_NUMBER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DISK_CONTROLLER_NUMBER")
            .field("ControllerNumber", &self.ControllerNumber)
            .field("DiskNumber", &self.DiskNumber)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DISK_CONTROLLER_NUMBER {
    fn eq(&self, other: &Self) -> bool {
        self.ControllerNumber == other.ControllerNumber && self.DiskNumber == other.DiskNumber
    }
}
impl ::std::cmp::Eq for DISK_CONTROLLER_NUMBER {}
unsafe impl ::windows::runtime::Abi for DISK_CONTROLLER_NUMBER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DISK_HEALTH_NOTIFICATION_DATA {
    pub DeviceGuid: ::windows::runtime::GUID,
}
impl DISK_HEALTH_NOTIFICATION_DATA {}
impl ::std::default::Default for DISK_HEALTH_NOTIFICATION_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DISK_HEALTH_NOTIFICATION_DATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DISK_HEALTH_NOTIFICATION_DATA")
            .field("DeviceGuid", &self.DeviceGuid)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DISK_HEALTH_NOTIFICATION_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.DeviceGuid == other.DeviceGuid
    }
}
impl ::std::cmp::Eq for DISK_HEALTH_NOTIFICATION_DATA {}
unsafe impl ::windows::runtime::Abi for DISK_HEALTH_NOTIFICATION_DATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DISK_HISTOGRAM {
    pub DiskSize: i64,
    pub Start: i64,
    pub End: i64,
    pub Average: i64,
    pub AverageRead: i64,
    pub AverageWrite: i64,
    pub Granularity: u32,
    pub Size: u32,
    pub ReadCount: u32,
    pub WriteCount: u32,
    pub Histogram: *mut HISTOGRAM_BUCKET,
}
impl DISK_HISTOGRAM {}
impl ::std::default::Default for DISK_HISTOGRAM {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DISK_HISTOGRAM {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DISK_HISTOGRAM")
            .field("DiskSize", &self.DiskSize)
            .field("Start", &self.Start)
            .field("End", &self.End)
            .field("Average", &self.Average)
            .field("AverageRead", &self.AverageRead)
            .field("AverageWrite", &self.AverageWrite)
            .field("Granularity", &self.Granularity)
            .field("Size", &self.Size)
            .field("ReadCount", &self.ReadCount)
            .field("WriteCount", &self.WriteCount)
            .field("Histogram", &self.Histogram)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DISK_HISTOGRAM {
    fn eq(&self, other: &Self) -> bool {
        self.DiskSize == other.DiskSize
            && self.Start == other.Start
            && self.End == other.End
            && self.Average == other.Average
            && self.AverageRead == other.AverageRead
            && self.AverageWrite == other.AverageWrite
            && self.Granularity == other.Granularity
            && self.Size == other.Size
            && self.ReadCount == other.ReadCount
            && self.WriteCount == other.WriteCount
            && self.Histogram == other.Histogram
    }
}
impl ::std::cmp::Eq for DISK_HISTOGRAM {}
unsafe impl ::windows::runtime::Abi for DISK_HISTOGRAM {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DISK_LOGGING {
    pub Function: u8,
    pub BufferAddress: *mut ::std::ffi::c_void,
    pub BufferSize: u32,
}
impl DISK_LOGGING {}
impl ::std::default::Default for DISK_LOGGING {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DISK_LOGGING {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DISK_LOGGING")
            .field("Function", &self.Function)
            .field("BufferAddress", &self.BufferAddress)
            .field("BufferSize", &self.BufferSize)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DISK_LOGGING {
    fn eq(&self, other: &Self) -> bool {
        self.Function == other.Function
            && self.BufferAddress == other.BufferAddress
            && self.BufferSize == other.BufferSize
    }
}
impl ::std::cmp::Eq for DISK_LOGGING {}
unsafe impl ::windows::runtime::Abi for DISK_LOGGING {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DISK_LOGGING_DUMP: u32 = 2u32;
pub const DISK_LOGGING_START: u32 = 0u32;
pub const DISK_LOGGING_STOP: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct DISK_RECORD {
    pub ByteOffset: i64,
    pub StartTime: i64,
    pub EndTime: i64,
    pub VirtualAddress: *mut ::std::ffi::c_void,
    pub NumberOfBytes: u32,
    pub DeviceNumber: u8,
    pub ReadRequest: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl DISK_RECORD {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for DISK_RECORD {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for DISK_RECORD {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DISK_RECORD")
            .field("ByteOffset", &self.ByteOffset)
            .field("StartTime", &self.StartTime)
            .field("EndTime", &self.EndTime)
            .field("VirtualAddress", &self.VirtualAddress)
            .field("NumberOfBytes", &self.NumberOfBytes)
            .field("DeviceNumber", &self.DeviceNumber)
            .field("ReadRequest", &self.ReadRequest)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for DISK_RECORD {
    fn eq(&self, other: &Self) -> bool {
        self.ByteOffset == other.ByteOffset
            && self.StartTime == other.StartTime
            && self.EndTime == other.EndTime
            && self.VirtualAddress == other.VirtualAddress
            && self.NumberOfBytes == other.NumberOfBytes
            && self.DeviceNumber == other.DeviceNumber
            && self.ReadRequest == other.ReadRequest
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for DISK_RECORD {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for DISK_RECORD {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone)]
#[repr(C)]
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
pub struct DISPATCHER_CONTEXT {
    pub ControlPc: usize,
    pub ImageBase: usize,
    pub FunctionEntry: *mut IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
    pub EstablisherFrame: usize,
    pub TargetPc: usize,
    pub ContextRecord: *mut super::Diagnostics::Debug::CONTEXT,
    pub LanguageHandler: ::std::option::Option<super::Kernel::EXCEPTION_ROUTINE>,
    pub HandlerData: *mut ::std::ffi::c_void,
    pub HistoryTable: *mut UNWIND_HISTORY_TABLE,
    pub ScopeIndex: u32,
    pub ControlPcIsUnwound: super::super::Foundation::BOOLEAN,
    pub NonVolatileRegisters: *mut u8,
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl DISPATCHER_CONTEXT {}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl ::std::default::Default for DISPATCHER_CONTEXT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl ::std::fmt::Debug for DISPATCHER_CONTEXT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DISPATCHER_CONTEXT")
            .field("ControlPc", &self.ControlPc)
            .field("ImageBase", &self.ImageBase)
            .field("FunctionEntry", &self.FunctionEntry)
            .field("EstablisherFrame", &self.EstablisherFrame)
            .field("TargetPc", &self.TargetPc)
            .field("ContextRecord", &self.ContextRecord)
            .field("HandlerData", &self.HandlerData)
            .field("HistoryTable", &self.HistoryTable)
            .field("ScopeIndex", &self.ScopeIndex)
            .field("ControlPcIsUnwound", &self.ControlPcIsUnwound)
            .field("NonVolatileRegisters", &self.NonVolatileRegisters)
            .finish()
    }
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl ::std::cmp::PartialEq for DISPATCHER_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.ControlPc == other.ControlPc
            && self.ImageBase == other.ImageBase
            && self.FunctionEntry == other.FunctionEntry
            && self.EstablisherFrame == other.EstablisherFrame
            && self.TargetPc == other.TargetPc
            && self.ContextRecord == other.ContextRecord
            && self.LanguageHandler.map(|f| f as usize) == other.LanguageHandler.map(|f| f as usize)
            && self.HandlerData == other.HandlerData
            && self.HistoryTable == other.HistoryTable
            && self.ScopeIndex == other.ScopeIndex
            && self.ControlPcIsUnwound == other.ControlPcIsUnwound
            && self.NonVolatileRegisters == other.NonVolatileRegisters
    }
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl ::std::cmp::Eq for DISPATCHER_CONTEXT {}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
unsafe impl ::windows::runtime::Abi for DISPATCHER_CONTEXT {
    type Abi = ::std::mem::ManuallyDrop<Self>;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone)]
#[repr(C)]
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
pub struct DISPATCHER_CONTEXT_ARM64 {
    pub ControlPc: usize,
    pub ImageBase: usize,
    pub FunctionEntry: *mut IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
    pub EstablisherFrame: usize,
    pub TargetPc: usize,
    pub ContextRecord: *mut ARM64_NT_CONTEXT,
    pub LanguageHandler: ::std::option::Option<super::Kernel::EXCEPTION_ROUTINE>,
    pub HandlerData: *mut ::std::ffi::c_void,
    pub HistoryTable: *mut UNWIND_HISTORY_TABLE,
    pub ScopeIndex: u32,
    pub ControlPcIsUnwound: super::super::Foundation::BOOLEAN,
    pub NonVolatileRegisters: *mut u8,
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl DISPATCHER_CONTEXT_ARM64 {}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl ::std::default::Default for DISPATCHER_CONTEXT_ARM64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl ::std::fmt::Debug for DISPATCHER_CONTEXT_ARM64 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DISPATCHER_CONTEXT_ARM64")
            .field("ControlPc", &self.ControlPc)
            .field("ImageBase", &self.ImageBase)
            .field("FunctionEntry", &self.FunctionEntry)
            .field("EstablisherFrame", &self.EstablisherFrame)
            .field("TargetPc", &self.TargetPc)
            .field("ContextRecord", &self.ContextRecord)
            .field("HandlerData", &self.HandlerData)
            .field("HistoryTable", &self.HistoryTable)
            .field("ScopeIndex", &self.ScopeIndex)
            .field("ControlPcIsUnwound", &self.ControlPcIsUnwound)
            .field("NonVolatileRegisters", &self.NonVolatileRegisters)
            .finish()
    }
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl ::std::cmp::PartialEq for DISPATCHER_CONTEXT_ARM64 {
    fn eq(&self, other: &Self) -> bool {
        self.ControlPc == other.ControlPc
            && self.ImageBase == other.ImageBase
            && self.FunctionEntry == other.FunctionEntry
            && self.EstablisherFrame == other.EstablisherFrame
            && self.TargetPc == other.TargetPc
            && self.ContextRecord == other.ContextRecord
            && self.LanguageHandler.map(|f| f as usize) == other.LanguageHandler.map(|f| f as usize)
            && self.HandlerData == other.HandlerData
            && self.HistoryTable == other.HistoryTable
            && self.ScopeIndex == other.ScopeIndex
            && self.ControlPcIsUnwound == other.ControlPcIsUnwound
            && self.NonVolatileRegisters == other.NonVolatileRegisters
    }
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl ::std::cmp::Eq for DISPATCHER_CONTEXT_ARM64 {}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
unsafe impl ::windows::runtime::Abi for DISPATCHER_CONTEXT_ARM64 {
    type Abi = ::std::mem::ManuallyDrop<Self>;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union DISPATCHER_CONTEXT_NONVOLREG_ARM64 {
    pub Buffer: [u8; 152],
    pub Anonymous: DISPATCHER_CONTEXT_NONVOLREG_ARM64_0,
}
impl DISPATCHER_CONTEXT_NONVOLREG_ARM64 {}
impl ::std::default::Default for DISPATCHER_CONTEXT_NONVOLREG_ARM64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DISPATCHER_CONTEXT_NONVOLREG_ARM64 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DISPATCHER_CONTEXT_NONVOLREG_ARM64 {}
unsafe impl ::windows::runtime::Abi for DISPATCHER_CONTEXT_NONVOLREG_ARM64 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DISPATCHER_CONTEXT_NONVOLREG_ARM64_0 {
    pub GpNvRegs: [u64; 11],
    pub FpNvRegs: [f64; 8],
}
impl DISPATCHER_CONTEXT_NONVOLREG_ARM64_0 {}
impl ::std::default::Default for DISPATCHER_CONTEXT_NONVOLREG_ARM64_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DISPATCHER_CONTEXT_NONVOLREG_ARM64_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("GpNvRegs", &self.GpNvRegs)
            .field("FpNvRegs", &self.FpNvRegs)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DISPATCHER_CONTEXT_NONVOLREG_ARM64_0 {
    fn eq(&self, other: &Self) -> bool {
        self.GpNvRegs == other.GpNvRegs && self.FpNvRegs == other.FpNvRegs
    }
}
impl ::std::cmp::Eq for DISPATCHER_CONTEXT_NONVOLREG_ARM64_0 {}
unsafe impl ::windows::runtime::Abi for DISPATCHER_CONTEXT_NONVOLREG_ARM64_0 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DLL_PROCESS_ATTACH: u32 = 1u32;
pub const DLL_PROCESS_DETACH: u32 = 0u32;
pub const DLL_THREAD_ATTACH: u32 = 2u32;
pub const DLL_THREAD_DETACH: u32 = 3u32;
pub const DM_DEFAULT: u32 = 1u32;
pub const DM_MONOCHROME: u32 = 2u32;
pub const DN_ACCELERATION_LEVEL: u32 = 1u32;
pub const DN_ASSOCIATE_WINDOW: u32 = 5u32;
pub const DN_COMPOSITION_CHANGED: u32 = 6u32;
pub const DN_DEVICE_ORIGIN: u32 = 2u32;
pub const DN_DRAWING_BEGIN: u32 = 4u32;
pub const DN_DRAWING_BEGIN_APIBITMAP: u32 = 7u32;
pub const DN_SLEEP_MODE: u32 = 3u32;
pub const DN_SURFOBJ_DESTRUCTION: u32 = 8u32;
pub const DOMAIN_ALIAS_RID_ACCESS_CONTROL_ASSISTANCE_OPS: i32 = 579i32;
pub const DOMAIN_ALIAS_RID_ACCOUNT_OPS: i32 = 548i32;
pub const DOMAIN_ALIAS_RID_ADMINS: i32 = 544i32;
pub const DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS: i32 = 560i32;
pub const DOMAIN_ALIAS_RID_BACKUP_OPS: i32 = 551i32;
pub const DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP: i32 = 571i32;
pub const DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP: i32 = 574i32;
pub const DOMAIN_ALIAS_RID_CRYPTO_OPERATORS: i32 = 569i32;
pub const DOMAIN_ALIAS_RID_DCOM_USERS: i32 = 562i32;
pub const DOMAIN_ALIAS_RID_DEFAULT_ACCOUNT: i32 = 581i32;
pub const DOMAIN_ALIAS_RID_DEVICE_OWNERS: i32 = 583i32;
pub const DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP: i32 = 573i32;
pub const DOMAIN_ALIAS_RID_GUESTS: i32 = 546i32;
pub const DOMAIN_ALIAS_RID_HYPER_V_ADMINS: i32 = 578i32;
pub const DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS: i32 = 557i32;
pub const DOMAIN_ALIAS_RID_IUSERS: i32 = 568i32;
pub const DOMAIN_ALIAS_RID_LOGGING_USERS: i32 = 559i32;
pub const DOMAIN_ALIAS_RID_MONITORING_USERS: i32 = 558i32;
pub const DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS: i32 = 556i32;
pub const DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP: i32 = 572i32;
pub const DOMAIN_ALIAS_RID_POWER_USERS: i32 = 547i32;
pub const DOMAIN_ALIAS_RID_PREW2KCOMPACCESS: i32 = 554i32;
pub const DOMAIN_ALIAS_RID_PRINT_OPS: i32 = 550i32;
pub const DOMAIN_ALIAS_RID_RAS_SERVERS: i32 = 553i32;
pub const DOMAIN_ALIAS_RID_RDS_ENDPOINT_SERVERS: i32 = 576i32;
pub const DOMAIN_ALIAS_RID_RDS_MANAGEMENT_SERVERS: i32 = 577i32;
pub const DOMAIN_ALIAS_RID_RDS_REMOTE_ACCESS_SERVERS: i32 = 575i32;
pub const DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS: i32 = 555i32;
pub const DOMAIN_ALIAS_RID_REMOTE_MANAGEMENT_USERS: i32 = 580i32;
pub const DOMAIN_ALIAS_RID_REPLICATOR: i32 = 552i32;
pub const DOMAIN_ALIAS_RID_STORAGE_REPLICA_ADMINS: i32 = 582i32;
pub const DOMAIN_ALIAS_RID_SYSTEM_OPS: i32 = 549i32;
pub const DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS: i32 = 561i32;
pub const DOMAIN_ALIAS_RID_USERS: i32 = 545i32;
pub const DOMAIN_GROUP_RID_ADMINS: i32 = 512i32;
pub const DOMAIN_GROUP_RID_AUTHORIZATION_DATA_CONTAINS_CLAIMS: i32 = 497i32;
pub const DOMAIN_GROUP_RID_AUTHORIZATION_DATA_IS_COMPOUNDED: i32 = 496i32;
pub const DOMAIN_GROUP_RID_CDC_RESERVED: i32 = 524i32;
pub const DOMAIN_GROUP_RID_CERT_ADMINS: i32 = 517i32;
pub const DOMAIN_GROUP_RID_CLONEABLE_CONTROLLERS: i32 = 522i32;
pub const DOMAIN_GROUP_RID_COMPUTERS: i32 = 515i32;
pub const DOMAIN_GROUP_RID_CONTROLLERS: i32 = 516i32;
pub const DOMAIN_GROUP_RID_ENTERPRISE_ADMINS: i32 = 519i32;
pub const DOMAIN_GROUP_RID_ENTERPRISE_KEY_ADMINS: i32 = 527i32;
pub const DOMAIN_GROUP_RID_ENTERPRISE_READONLY_DOMAIN_CONTROLLERS: i32 = 498i32;
pub const DOMAIN_GROUP_RID_GUESTS: i32 = 514i32;
pub const DOMAIN_GROUP_RID_KEY_ADMINS: i32 = 526i32;
pub const DOMAIN_GROUP_RID_POLICY_ADMINS: i32 = 520i32;
pub const DOMAIN_GROUP_RID_PROTECTED_USERS: i32 = 525i32;
pub const DOMAIN_GROUP_RID_READONLY_CONTROLLERS: i32 = 521i32;
pub const DOMAIN_GROUP_RID_SCHEMA_ADMINS: i32 = 518i32;
pub const DOMAIN_GROUP_RID_USERS: i32 = 513i32;
pub const DOMAIN_USER_RID_ADMIN: i32 = 500i32;
pub const DOMAIN_USER_RID_DEFAULT_ACCOUNT: i32 = 503i32;
pub const DOMAIN_USER_RID_GUEST: i32 = 501i32;
pub const DOMAIN_USER_RID_KRBTGT: i32 = 502i32;
pub const DOMAIN_USER_RID_MAX: i32 = 999i32;
pub const DOMAIN_USER_RID_WDAG_ACCOUNT: i32 = 504i32;
pub const DP2BLT_LINEAR: i32 = 2i32;
pub const DP2BLT_POINT: i32 = 1i32;
#[derive(
    :: std :: clone :: Clone,
    :: std :: marker :: Copy,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
)]
#[repr(transparent)]
pub struct DPI_AWARENESS_CONTEXT(pub isize);
impl ::std::default::Default for DPI_AWARENESS_CONTEXT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
unsafe impl ::windows::runtime::Handle for DPI_AWARENESS_CONTEXT {}
unsafe impl ::windows::runtime::Abi for DPI_AWARENESS_CONTEXT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DRD_ERROR: u32 = 1u32;
pub const DRD_SUCCESS: u32 = 0u32;
pub const DRH_APIBITMAP: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub struct DRH_APIBITMAPDATA {
    pub pso: *mut super::super::UI::DisplayDevices::SURFOBJ,
    pub b: super::super::Foundation::BOOL,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
impl DRH_APIBITMAPDATA {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
impl ::std::default::Default for DRH_APIBITMAPDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
impl ::std::fmt::Debug for DRH_APIBITMAPDATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DRH_APIBITMAPDATA")
            .field("pso", &self.pso)
            .field("b", &self.b)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
impl ::std::cmp::PartialEq for DRH_APIBITMAPDATA {
    fn eq(&self, other: &Self) -> bool {
        self.pso == other.pso && self.b == other.b
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
impl ::std::cmp::Eq for DRH_APIBITMAPDATA {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
unsafe impl ::windows::runtime::Abi for DRH_APIBITMAPDATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct DRIVERSTATUS {
    pub bDriverError: u8,
    pub bIDEError: u8,
    pub bReserved: [u8; 2],
    pub dwReserved: [u32; 2],
}
impl DRIVERSTATUS {}
impl ::std::default::Default for DRIVERSTATUS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for DRIVERSTATUS {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for DRIVERSTATUS {}
unsafe impl ::windows::runtime::Abi for DRIVERSTATUS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DRVQUERY_USERMODE: u32 = 1u32;
pub const DSS_FLUSH_EVENT: u32 = 2u32;
pub const DSS_RESERVED: u32 = 4u32;
pub const DSS_RESERVED1: u32 = 8u32;
pub const DSS_RESERVED2: u32 = 16u32;
pub const DSS_TIMER_EVENT: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DUPLICATE_EXTENTS_DATA32 {
    pub FileHandle: u32,
    pub SourceFileOffset: i64,
    pub TargetFileOffset: i64,
    pub ByteCount: i64,
}
impl DUPLICATE_EXTENTS_DATA32 {}
impl ::std::default::Default for DUPLICATE_EXTENTS_DATA32 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DUPLICATE_EXTENTS_DATA32 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DUPLICATE_EXTENTS_DATA32")
            .field("FileHandle", &self.FileHandle)
            .field("SourceFileOffset", &self.SourceFileOffset)
            .field("TargetFileOffset", &self.TargetFileOffset)
            .field("ByteCount", &self.ByteCount)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DUPLICATE_EXTENTS_DATA32 {
    fn eq(&self, other: &Self) -> bool {
        self.FileHandle == other.FileHandle
            && self.SourceFileOffset == other.SourceFileOffset
            && self.TargetFileOffset == other.TargetFileOffset
            && self.ByteCount == other.ByteCount
    }
}
impl ::std::cmp::Eq for DUPLICATE_EXTENTS_DATA32 {}
unsafe impl ::windows::runtime::Abi for DUPLICATE_EXTENTS_DATA32 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct DUPLICATE_EXTENTS_DATA_EX {
    pub Size: usize,
    pub FileHandle: super::super::Foundation::HANDLE,
    pub SourceFileOffset: i64,
    pub TargetFileOffset: i64,
    pub ByteCount: i64,
    pub Flags: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl DUPLICATE_EXTENTS_DATA_EX {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for DUPLICATE_EXTENTS_DATA_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for DUPLICATE_EXTENTS_DATA_EX {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DUPLICATE_EXTENTS_DATA_EX")
            .field("Size", &self.Size)
            .field("FileHandle", &self.FileHandle)
            .field("SourceFileOffset", &self.SourceFileOffset)
            .field("TargetFileOffset", &self.TargetFileOffset)
            .field("ByteCount", &self.ByteCount)
            .field("Flags", &self.Flags)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for DUPLICATE_EXTENTS_DATA_EX {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.FileHandle == other.FileHandle
            && self.SourceFileOffset == other.SourceFileOffset
            && self.TargetFileOffset == other.TargetFileOffset
            && self.ByteCount == other.ByteCount
            && self.Flags == other.Flags
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for DUPLICATE_EXTENTS_DATA_EX {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for DUPLICATE_EXTENTS_DATA_EX {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct DUPLICATE_EXTENTS_DATA_EX32 {
    pub Size: u32,
    pub FileHandle: u32,
    pub SourceFileOffset: i64,
    pub TargetFileOffset: i64,
    pub ByteCount: i64,
    pub Flags: u32,
}
impl DUPLICATE_EXTENTS_DATA_EX32 {}
impl ::std::default::Default for DUPLICATE_EXTENTS_DATA_EX32 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for DUPLICATE_EXTENTS_DATA_EX32 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("DUPLICATE_EXTENTS_DATA_EX32")
            .field("Size", &self.Size)
            .field("FileHandle", &self.FileHandle)
            .field("SourceFileOffset", &self.SourceFileOffset)
            .field("TargetFileOffset", &self.TargetFileOffset)
            .field("ByteCount", &self.ByteCount)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for DUPLICATE_EXTENTS_DATA_EX32 {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.FileHandle == other.FileHandle
            && self.SourceFileOffset == other.SourceFileOffset
            && self.TargetFileOffset == other.TargetFileOffset
            && self.ByteCount == other.ByteCount
            && self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for DUPLICATE_EXTENTS_DATA_EX32 {}
unsafe impl ::windows::runtime::Abi for DUPLICATE_EXTENTS_DATA_EX32 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DUPLICATE_EXTENTS_DATA_EX_ASYNC: u32 = 2u32;
pub const DUPLICATE_EXTENTS_DATA_EX_SOURCE_ATOMIC: u32 = 1u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct DUPLICATE_EXTENTS_STATE(pub i32);
pub const FileSnapStateInactive: DUPLICATE_EXTENTS_STATE = DUPLICATE_EXTENTS_STATE(0i32);
pub const FileSnapStateSource: DUPLICATE_EXTENTS_STATE = DUPLICATE_EXTENTS_STATE(1i32);
pub const FileSnapStateTarget: DUPLICATE_EXTENTS_STATE = DUPLICATE_EXTENTS_STATE(2i32);
impl ::std::convert::From<i32> for DUPLICATE_EXTENTS_STATE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for DUPLICATE_EXTENTS_STATE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const DX9_DDI_VERSION: u32 = 4u32;
pub const DYNAMIC_EH_CONTINUATION_TARGET_ADD: u32 = 1u32;
pub const DYNAMIC_EH_CONTINUATION_TARGET_PROCESSED: u32 = 2u32;
pub const DYNAMIC_ENFORCED_ADDRESS_RANGE_ADD: u32 = 1u32;
pub const DYNAMIC_ENFORCED_ADDRESS_RANGE_PROCESSED: u32 = 2u32;
pub const DeviceDsmActionFlag_NonDestructive: u32 = 2147483648u32;
#[cfg(feature = "Win32_Foundation")]
pub unsafe fn DeviceIoControl<
    'a,
    Param0: ::windows::runtime::IntoParam<'a, super::super::Foundation::HANDLE>,
>(
    hdevice: Param0,
    dwiocontrolcode: u32,
    lpinbuffer: *const ::std::ffi::c_void,
    ninbuffersize: u32,
    lpoutbuffer: *mut ::std::ffi::c_void,
    noutbuffersize: u32,
    lpbytesreturned: *mut u32,
    lpoverlapped: *mut OVERLAPPED,
) -> super::super::Foundation::BOOL {
    #[cfg(windows)]
    {
        #[link(name = "kernel32")]
        extern "system" {
            fn DeviceIoControl(
                hdevice: super::super::Foundation::HANDLE,
                dwiocontrolcode: u32,
                lpinbuffer: *const ::std::ffi::c_void,
                ninbuffersize: u32,
                lpoutbuffer: *mut ::std::ffi::c_void,
                noutbuffersize: u32,
                lpbytesreturned: *mut u32,
                lpoverlapped: *mut OVERLAPPED,
            ) -> super::super::Foundation::BOOL;
        }
        ::std::mem::transmute(DeviceIoControl(
            hdevice.into_param().abi(),
            ::std::mem::transmute(dwiocontrolcode),
            ::std::mem::transmute(lpinbuffer),
            ::std::mem::transmute(ninbuffersize),
            ::std::mem::transmute(lpoutbuffer),
            ::std::mem::transmute(noutbuffersize),
            ::std::mem::transmute(lpbytesreturned),
            ::std::mem::transmute(lpoverlapped),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub const ECS_REDRAW: u32 = 2u32;
pub const ECS_TEARDOWN: u32 = 1u32;
pub const ED_ABORTDOC: u32 = 1u32;
pub const EFS_TRACKED_OFFSET_HEADER_FLAG: u32 = 1u32;
pub const EHN_ERROR: u32 = 1u32;
pub const EHN_RESTORED: u32 = 0u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct ELEMENT_TYPE(pub i32);
pub const AllElements: ELEMENT_TYPE = ELEMENT_TYPE(0i32);
pub const ChangerTransport: ELEMENT_TYPE = ELEMENT_TYPE(1i32);
pub const ChangerSlot: ELEMENT_TYPE = ELEMENT_TYPE(2i32);
pub const ChangerIEPort: ELEMENT_TYPE = ELEMENT_TYPE(3i32);
pub const ChangerDrive: ELEMENT_TYPE = ELEMENT_TYPE(4i32);
pub const ChangerDoor: ELEMENT_TYPE = ELEMENT_TYPE(5i32);
pub const ChangerKeypad: ELEMENT_TYPE = ELEMENT_TYPE(6i32);
pub const ChangerMaxElement: ELEMENT_TYPE = ELEMENT_TYPE(7i32);
impl ::std::convert::From<i32> for ELEMENT_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for ELEMENT_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const EMARCH_ENC_I17_IC_INST_WORD_POS_X: u32 = 12u32;
pub const EMARCH_ENC_I17_IC_INST_WORD_X: u32 = 3u32;
pub const EMARCH_ENC_I17_IC_SIZE_X: u32 = 1u32;
pub const EMARCH_ENC_I17_IC_VAL_POS_X: u32 = 21u32;
pub const EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X: u32 = 14u32;
pub const EMARCH_ENC_I17_IMM41a_INST_WORD_X: u32 = 1u32;
pub const EMARCH_ENC_I17_IMM41a_SIZE_X: u32 = 10u32;
pub const EMARCH_ENC_I17_IMM41a_VAL_POS_X: u32 = 22u32;
pub const EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X: u32 = 24u32;
pub const EMARCH_ENC_I17_IMM41b_INST_WORD_X: u32 = 1u32;
pub const EMARCH_ENC_I17_IMM41b_SIZE_X: u32 = 8u32;
pub const EMARCH_ENC_I17_IMM41b_VAL_POS_X: u32 = 32u32;
pub const EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X: u32 = 0u32;
pub const EMARCH_ENC_I17_IMM41c_INST_WORD_X: u32 = 2u32;
pub const EMARCH_ENC_I17_IMM41c_SIZE_X: u32 = 23u32;
pub const EMARCH_ENC_I17_IMM41c_VAL_POS_X: u32 = 40u32;
pub const EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X: u32 = 13u32;
pub const EMARCH_ENC_I17_IMM5C_INST_WORD_X: u32 = 3u32;
pub const EMARCH_ENC_I17_IMM5C_SIZE_X: u32 = 5u32;
pub const EMARCH_ENC_I17_IMM5C_VAL_POS_X: u32 = 16u32;
pub const EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X: u32 = 4u32;
pub const EMARCH_ENC_I17_IMM7B_INST_WORD_X: u32 = 3u32;
pub const EMARCH_ENC_I17_IMM7B_SIZE_X: u32 = 7u32;
pub const EMARCH_ENC_I17_IMM7B_VAL_POS_X: u32 = 0u32;
pub const EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X: u32 = 18u32;
pub const EMARCH_ENC_I17_IMM9D_INST_WORD_X: u32 = 3u32;
pub const EMARCH_ENC_I17_IMM9D_SIZE_X: u32 = 9u32;
pub const EMARCH_ENC_I17_IMM9D_VAL_POS_X: u32 = 7u32;
pub const EMARCH_ENC_I17_SIGN_INST_WORD_POS_X: u32 = 27u32;
pub const EMARCH_ENC_I17_SIGN_INST_WORD_X: u32 = 3u32;
pub const EMARCH_ENC_I17_SIGN_SIZE_X: u32 = 1u32;
pub const EMARCH_ENC_I17_SIGN_VAL_POS_X: u32 = 63u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Gdi")]
pub struct EMFINFO {
    pub nSize: u32,
    pub hdc: super::super::Graphics::Gdi::HDC,
    pub pvEMF: *mut u8,
    pub pvCurrentRecord: *mut u8,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl EMFINFO {}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::std::default::Default for EMFINFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::std::fmt::Debug for EMFINFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("EMFINFO")
            .field("nSize", &self.nSize)
            .field("hdc", &self.hdc)
            .field("pvEMF", &self.pvEMF)
            .field("pvCurrentRecord", &self.pvCurrentRecord)
            .finish()
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::std::cmp::PartialEq for EMFINFO {
    fn eq(&self, other: &Self) -> bool {
        self.nSize == other.nSize
            && self.hdc == other.hdc
            && self.pvEMF == other.pvEMF
            && self.pvCurrentRecord == other.pvCurrentRecord
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::std::cmp::Eq for EMFINFO {}
#[cfg(feature = "Win32_Graphics_Gdi")]
unsafe impl ::windows::runtime::Abi for EMFINFO {
    type Abi = Self;
    type DefaultType = Self;
}
pub const ENABLE_DISABLE_AUTOSAVE: u32 = 210u32;
pub const ENABLE_DISABLE_AUTO_OFFLINE: u32 = 219u32;
pub const ENABLE_SMART: u32 = 216u32;
pub const ENCLAVE_LONG_ID_LENGTH: u32 = 32u32;
pub const ENCLAVE_SHORT_ID_LENGTH: u32 = 16u32;
pub const ENCLAVE_TYPE_SGX: u32 = 1u32;
pub const ENCLAVE_TYPE_SGX2: u32 = 2u32;
pub const ENCLAVE_TYPE_VBS: u32 = 16u32;
pub const ENCLAVE_TYPE_VBS_BASIC: u32 = 17u32;
pub const ENCLAVE_VBS_FLAG_DEBUG: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct ENCRYPTED_DATA_INFO {
    pub StartingFileOffset: u64,
    pub OutputBufferOffset: u32,
    pub BytesWithinFileSize: u32,
    pub BytesWithinValidDataLength: u32,
    pub CompressionFormat: u16,
    pub DataUnitShift: u8,
    pub ChunkShift: u8,
    pub ClusterShift: u8,
    pub EncryptionFormat: u8,
    pub NumberOfDataBlocks: u16,
    pub DataBlockSize: [u32; 1],
}
impl ENCRYPTED_DATA_INFO {}
impl ::std::default::Default for ENCRYPTED_DATA_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for ENCRYPTED_DATA_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("ENCRYPTED_DATA_INFO")
            .field("StartingFileOffset", &self.StartingFileOffset)
            .field("OutputBufferOffset", &self.OutputBufferOffset)
            .field("BytesWithinFileSize", &self.BytesWithinFileSize)
            .field(
                "BytesWithinValidDataLength",
                &self.BytesWithinValidDataLength,
            )
            .field("CompressionFormat", &self.CompressionFormat)
            .field("DataUnitShift", &self.DataUnitShift)
            .field("ChunkShift", &self.ChunkShift)
            .field("ClusterShift", &self.ClusterShift)
            .field("EncryptionFormat", &self.EncryptionFormat)
            .field("NumberOfDataBlocks", &self.NumberOfDataBlocks)
            .field("DataBlockSize", &self.DataBlockSize)
            .finish()
    }
}
impl ::std::cmp::PartialEq for ENCRYPTED_DATA_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.StartingFileOffset == other.StartingFileOffset
            && self.OutputBufferOffset == other.OutputBufferOffset
            && self.BytesWithinFileSize == other.BytesWithinFileSize
            && self.BytesWithinValidDataLength == other.BytesWithinValidDataLength
            && self.CompressionFormat == other.CompressionFormat
            && self.DataUnitShift == other.DataUnitShift
            && self.ChunkShift == other.ChunkShift
            && self.ClusterShift == other.ClusterShift
            && self.EncryptionFormat == other.EncryptionFormat
            && self.NumberOfDataBlocks == other.NumberOfDataBlocks
            && self.DataBlockSize == other.DataBlockSize
    }
}
impl ::std::cmp::Eq for ENCRYPTED_DATA_INFO {}
unsafe impl ::windows::runtime::Abi for ENCRYPTED_DATA_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
pub const ENCRYPTED_DATA_INFO_SPARSE_FILE: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct ENCRYPTION_BUFFER {
    pub EncryptionOperation: u32,
    pub Private: [u8; 1],
}
impl ENCRYPTION_BUFFER {}
impl ::std::default::Default for ENCRYPTION_BUFFER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for ENCRYPTION_BUFFER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("ENCRYPTION_BUFFER")
            .field("EncryptionOperation", &self.EncryptionOperation)
            .field("Private", &self.Private)
            .finish()
    }
}
impl ::std::cmp::PartialEq for ENCRYPTION_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.EncryptionOperation == other.EncryptionOperation && self.Private == other.Private
    }
}
impl ::std::cmp::Eq for ENCRYPTION_BUFFER {}
unsafe impl ::windows::runtime::Abi for ENCRYPTION_BUFFER {
    type Abi = Self;
    type DefaultType = Self;
}
pub const ENCRYPTION_FORMAT_DEFAULT: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct ENCRYPTION_KEY_CTRL_INPUT {
    pub HeaderSize: u32,
    pub StructureSize: u32,
    pub KeyOffset: u16,
    pub KeySize: u16,
    pub DplLock: u32,
    pub DplUserId: u64,
    pub DplCredentialId: u64,
}
impl ENCRYPTION_KEY_CTRL_INPUT {}
impl ::std::default::Default for ENCRYPTION_KEY_CTRL_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for ENCRYPTION_KEY_CTRL_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("ENCRYPTION_KEY_CTRL_INPUT")
            .field("HeaderSize", &self.HeaderSize)
            .field("StructureSize", &self.StructureSize)
            .field("KeyOffset", &self.KeyOffset)
            .field("KeySize", &self.KeySize)
            .field("DplLock", &self.DplLock)
            .field("DplUserId", &self.DplUserId)
            .field("DplCredentialId", &self.DplCredentialId)
            .finish()
    }
}
impl ::std::cmp::PartialEq for ENCRYPTION_KEY_CTRL_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.HeaderSize == other.HeaderSize
            && self.StructureSize == other.StructureSize
            && self.KeyOffset == other.KeyOffset
            && self.KeySize == other.KeySize
            && self.DplLock == other.DplLock
            && self.DplUserId == other.DplUserId
            && self.DplCredentialId == other.DplCredentialId
    }
}
impl ::std::cmp::Eq for ENCRYPTION_KEY_CTRL_INPUT {}
unsafe impl ::windows::runtime::Abi for ENCRYPTION_KEY_CTRL_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const ENDCAP_BUTT: i32 = 2i32;
pub const ENDCAP_ROUND: i32 = 0i32;
pub const ENDCAP_SQUARE: i32 = 1i32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct ENG_DEVICE_ATTRIBUTE(pub i32);
pub const QDA_RESERVED: ENG_DEVICE_ATTRIBUTE = ENG_DEVICE_ATTRIBUTE(0i32);
pub const QDA_ACCELERATION_LEVEL: ENG_DEVICE_ATTRIBUTE = ENG_DEVICE_ATTRIBUTE(1i32);
impl ::std::convert::From<i32> for ENG_DEVICE_ATTRIBUTE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for ENG_DEVICE_ATTRIBUTE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const ENG_FNT_CACHE_READ_FAULT: u32 = 1u32;
pub const ENG_FNT_CACHE_WRITE_FAULT: u32 = 2u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct ENG_SYSTEM_ATTRIBUTE(pub i32);
pub const EngProcessorFeature: ENG_SYSTEM_ATTRIBUTE = ENG_SYSTEM_ATTRIBUTE(1i32);
pub const EngNumberOfProcessors: ENG_SYSTEM_ATTRIBUTE = ENG_SYSTEM_ATTRIBUTE(2i32);
pub const EngOptimumAvailableUserMemory: ENG_SYSTEM_ATTRIBUTE = ENG_SYSTEM_ATTRIBUTE(3i32);
pub const EngOptimumAvailableSystemMemory: ENG_SYSTEM_ATTRIBUTE = ENG_SYSTEM_ATTRIBUTE(4i32);
impl ::std::convert::From<i32> for ENG_SYSTEM_ATTRIBUTE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for ENG_SYSTEM_ATTRIBUTE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct ENLISTMENT_BASIC_INFORMATION {
    pub EnlistmentId: ::windows::runtime::GUID,
    pub TransactionId: ::windows::runtime::GUID,
    pub ResourceManagerId: ::windows::runtime::GUID,
}
impl ENLISTMENT_BASIC_INFORMATION {}
impl ::std::default::Default for ENLISTMENT_BASIC_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for ENLISTMENT_BASIC_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("ENLISTMENT_BASIC_INFORMATION")
            .field("EnlistmentId", &self.EnlistmentId)
            .field("TransactionId", &self.TransactionId)
            .field("ResourceManagerId", &self.ResourceManagerId)
            .finish()
    }
}
impl ::std::cmp::PartialEq for ENLISTMENT_BASIC_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.EnlistmentId == other.EnlistmentId
            && self.TransactionId == other.TransactionId
            && self.ResourceManagerId == other.ResourceManagerId
    }
}
impl ::std::cmp::Eq for ENLISTMENT_BASIC_INFORMATION {}
unsafe impl ::windows::runtime::Abi for ENLISTMENT_BASIC_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct ENLISTMENT_CRM_INFORMATION {
    pub CrmTransactionManagerId: ::windows::runtime::GUID,
    pub CrmResourceManagerId: ::windows::runtime::GUID,
    pub CrmEnlistmentId: ::windows::runtime::GUID,
}
impl ENLISTMENT_CRM_INFORMATION {}
impl ::std::default::Default for ENLISTMENT_CRM_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for ENLISTMENT_CRM_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("ENLISTMENT_CRM_INFORMATION")
            .field("CrmTransactionManagerId", &self.CrmTransactionManagerId)
            .field("CrmResourceManagerId", &self.CrmResourceManagerId)
            .field("CrmEnlistmentId", &self.CrmEnlistmentId)
            .finish()
    }
}
impl ::std::cmp::PartialEq for ENLISTMENT_CRM_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.CrmTransactionManagerId == other.CrmTransactionManagerId
            && self.CrmResourceManagerId == other.CrmResourceManagerId
            && self.CrmEnlistmentId == other.CrmEnlistmentId
    }
}
impl ::std::cmp::Eq for ENLISTMENT_CRM_INFORMATION {}
unsafe impl ::windows::runtime::Abi for ENLISTMENT_CRM_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct ENLISTMENT_INFORMATION_CLASS(pub i32);
pub const EnlistmentBasicInformation: ENLISTMENT_INFORMATION_CLASS =
    ENLISTMENT_INFORMATION_CLASS(0i32);
pub const EnlistmentRecoveryInformation: ENLISTMENT_INFORMATION_CLASS =
    ENLISTMENT_INFORMATION_CLASS(1i32);
pub const EnlistmentCrmInformation: ENLISTMENT_INFORMATION_CLASS =
    ENLISTMENT_INFORMATION_CLASS(2i32);
impl ::std::convert::From<i32> for ENLISTMENT_INFORMATION_CLASS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for ENLISTMENT_INFORMATION_CLASS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const ENLISTMENT_QUERY_INFORMATION: u32 = 1u32;
pub const ENLISTMENT_RECOVER: u32 = 4u32;
pub const ENLISTMENT_SET_INFORMATION: u32 = 2u32;
pub const ENLISTMENT_SUBORDINATE_RIGHTS: u32 = 8u32;
pub const ENLISTMENT_SUPERIOR_RIGHTS: u32 = 16u32;
pub const ERROR_DRIVE_NOT_INSTALLED: u32 = 8u32;
pub const ERROR_HISTORY_DIRECTORY_ENTRY_DEFAULT_COUNT: u32 = 8u32;
pub const ERROR_INIT_STATUS_NEEDED: u32 = 17u32;
pub const ERROR_LABEL_QUESTIONABLE: u32 = 2u32;
pub const ERROR_LABEL_UNREADABLE: u32 = 1u32;
pub const ERROR_SEVERITY_ERROR: u32 = 3221225472u32;
pub const ERROR_SEVERITY_INFORMATIONAL: u32 = 1073741824u32;
pub const ERROR_SEVERITY_SUCCESS: u32 = 0u32;
pub const ERROR_SEVERITY_WARNING: u32 = 2147483648u32;
pub const ERROR_SLOT_NOT_PRESENT: u32 = 4u32;
pub const ERROR_TRAY_MALFUNCTION: u32 = 16u32;
pub const ERROR_UNHANDLED_ERROR: u32 = 4294967295u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_EventLog")]
pub struct EVENTLOGRECORD {
    pub Length: u32,
    pub Reserved: u32,
    pub RecordNumber: u32,
    pub TimeGenerated: u32,
    pub TimeWritten: u32,
    pub EventID: u32,
    pub EventType: super::EventLog::REPORT_EVENT_TYPE,
    pub NumStrings: u16,
    pub EventCategory: u16,
    pub ReservedFlags: u16,
    pub ClosingRecordNumber: u32,
    pub StringOffset: u32,
    pub UserSidLength: u32,
    pub UserSidOffset: u32,
    pub DataLength: u32,
    pub DataOffset: u32,
}
#[cfg(feature = "Win32_System_EventLog")]
impl EVENTLOGRECORD {}
#[cfg(feature = "Win32_System_EventLog")]
impl ::std::default::Default for EVENTLOGRECORD {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_EventLog")]
impl ::std::fmt::Debug for EVENTLOGRECORD {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("EVENTLOGRECORD")
            .field("Length", &self.Length)
            .field("Reserved", &self.Reserved)
            .field("RecordNumber", &self.RecordNumber)
            .field("TimeGenerated", &self.TimeGenerated)
            .field("TimeWritten", &self.TimeWritten)
            .field("EventID", &self.EventID)
            .field("EventType", &self.EventType)
            .field("NumStrings", &self.NumStrings)
            .field("EventCategory", &self.EventCategory)
            .field("ReservedFlags", &self.ReservedFlags)
            .field("ClosingRecordNumber", &self.ClosingRecordNumber)
            .field("StringOffset", &self.StringOffset)
            .field("UserSidLength", &self.UserSidLength)
            .field("UserSidOffset", &self.UserSidOffset)
            .field("DataLength", &self.DataLength)
            .field("DataOffset", &self.DataOffset)
            .finish()
    }
}
#[cfg(feature = "Win32_System_EventLog")]
impl ::std::cmp::PartialEq for EVENTLOGRECORD {
    fn eq(&self, other: &Self) -> bool {
        self.Length == other.Length
            && self.Reserved == other.Reserved
            && self.RecordNumber == other.RecordNumber
            && self.TimeGenerated == other.TimeGenerated
            && self.TimeWritten == other.TimeWritten
            && self.EventID == other.EventID
            && self.EventType == other.EventType
            && self.NumStrings == other.NumStrings
            && self.EventCategory == other.EventCategory
            && self.ReservedFlags == other.ReservedFlags
            && self.ClosingRecordNumber == other.ClosingRecordNumber
            && self.StringOffset == other.StringOffset
            && self.UserSidLength == other.UserSidLength
            && self.UserSidOffset == other.UserSidOffset
            && self.DataLength == other.DataLength
            && self.DataOffset == other.DataOffset
    }
}
#[cfg(feature = "Win32_System_EventLog")]
impl ::std::cmp::Eq for EVENTLOGRECORD {}
#[cfg(feature = "Win32_System_EventLog")]
unsafe impl ::windows::runtime::Abi for EVENTLOGRECORD {
    type Abi = Self;
    type DefaultType = Self;
}
pub const EVENTLOG_BACKWARDS_READ: u32 = 8u32;
pub const EVENTLOG_END_ALL_PAIRED_EVENTS: u32 = 4u32;
pub const EVENTLOG_END_PAIRED_EVENT: u32 = 2u32;
pub const EVENTLOG_FORWARDS_READ: u32 = 4u32;
pub const EVENTLOG_PAIRED_EVENT_ACTIVE: u32 = 8u32;
pub const EVENTLOG_PAIRED_EVENT_INACTIVE: u32 = 16u32;
pub const EVENTLOG_START_PAIRED_EVENT: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_EventLog")]
pub struct EVENTSFORLOGFILE {
    pub ulSize: u32,
    pub szLogicalLogFile: [u16; 256],
    pub ulNumRecords: u32,
    pub pEventLogRecords: [EVENTLOGRECORD; 1],
}
#[cfg(feature = "Win32_System_EventLog")]
impl EVENTSFORLOGFILE {}
#[cfg(feature = "Win32_System_EventLog")]
impl ::std::default::Default for EVENTSFORLOGFILE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_EventLog")]
impl ::std::fmt::Debug for EVENTSFORLOGFILE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("EVENTSFORLOGFILE")
            .field("ulSize", &self.ulSize)
            .field("szLogicalLogFile", &self.szLogicalLogFile)
            .field("ulNumRecords", &self.ulNumRecords)
            .field("pEventLogRecords", &self.pEventLogRecords)
            .finish()
    }
}
#[cfg(feature = "Win32_System_EventLog")]
impl ::std::cmp::PartialEq for EVENTSFORLOGFILE {
    fn eq(&self, other: &Self) -> bool {
        self.ulSize == other.ulSize
            && self.szLogicalLogFile == other.szLogicalLogFile
            && self.ulNumRecords == other.ulNumRecords
            && self.pEventLogRecords == other.pEventLogRecords
    }
}
#[cfg(feature = "Win32_System_EventLog")]
impl ::std::cmp::Eq for EVENTSFORLOGFILE {}
#[cfg(feature = "Win32_System_EventLog")]
unsafe impl ::windows::runtime::Abi for EVENTSFORLOGFILE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const EVENT_MODIFY_STATE: u32 = 2u32;
pub const EXCEPTION_COLLIDED_UNWIND: u32 = 64u32;
pub const EXCEPTION_EXECUTE_FAULT: u32 = 8u32;
pub const EXCEPTION_EXIT_UNWIND: u32 = 4u32;
pub const EXCEPTION_MAXIMUM_PARAMETERS: u32 = 15u32;
pub const EXCEPTION_NESTED_CALL: u32 = 16u32;
pub const EXCEPTION_NONCONTINUABLE: u32 = 1u32;
pub const EXCEPTION_READ_FAULT: u32 = 0u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct EXCEPTION_RECORD32 {
    pub ExceptionCode: super::super::Foundation::NTSTATUS,
    pub ExceptionFlags: u32,
    pub ExceptionRecord: u32,
    pub ExceptionAddress: u32,
    pub NumberParameters: u32,
    pub ExceptionInformation: [u32; 15],
}
#[cfg(feature = "Win32_Foundation")]
impl EXCEPTION_RECORD32 {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for EXCEPTION_RECORD32 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for EXCEPTION_RECORD32 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("EXCEPTION_RECORD32")
            .field("ExceptionCode", &self.ExceptionCode)
            .field("ExceptionFlags", &self.ExceptionFlags)
            .field("ExceptionRecord", &self.ExceptionRecord)
            .field("ExceptionAddress", &self.ExceptionAddress)
            .field("NumberParameters", &self.NumberParameters)
            .field("ExceptionInformation", &self.ExceptionInformation)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for EXCEPTION_RECORD32 {
    fn eq(&self, other: &Self) -> bool {
        self.ExceptionCode == other.ExceptionCode
            && self.ExceptionFlags == other.ExceptionFlags
            && self.ExceptionRecord == other.ExceptionRecord
            && self.ExceptionAddress == other.ExceptionAddress
            && self.NumberParameters == other.NumberParameters
            && self.ExceptionInformation == other.ExceptionInformation
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for EXCEPTION_RECORD32 {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for EXCEPTION_RECORD32 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone)]
#[repr(C)]
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
pub struct EXCEPTION_REGISTRATION_RECORD {
    pub Next: *mut EXCEPTION_REGISTRATION_RECORD,
    pub Handler: ::std::option::Option<super::Kernel::EXCEPTION_ROUTINE>,
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl EXCEPTION_REGISTRATION_RECORD {}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl ::std::default::Default for EXCEPTION_REGISTRATION_RECORD {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl ::std::fmt::Debug for EXCEPTION_REGISTRATION_RECORD {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("EXCEPTION_REGISTRATION_RECORD")
            .field("Next", &self.Next)
            .finish()
    }
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl ::std::cmp::PartialEq for EXCEPTION_REGISTRATION_RECORD {
    fn eq(&self, other: &Self) -> bool {
        self.Next == other.Next
            && self.Handler.map(|f| f as usize) == other.Handler.map(|f| f as usize)
    }
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl ::std::cmp::Eq for EXCEPTION_REGISTRATION_RECORD {}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
unsafe impl ::windows::runtime::Abi for EXCEPTION_REGISTRATION_RECORD {
    type Abi = ::std::mem::ManuallyDrop<Self>;
    type DefaultType = Self;
}
pub const EXCEPTION_SOFTWARE_ORIGINATE: u32 = 128u32;
pub const EXCEPTION_STACK_INVALID: u32 = 8u32;
pub const EXCEPTION_TARGET_UNWIND: u32 = 32u32;
pub const EXCEPTION_UNWINDING: u32 = 2u32;
pub const EXCEPTION_WRITE_FAULT: u32 = 1u32;
pub const EXECUTE_OFFLINE_DIAGS: u32 = 212u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct EXTENDED_ENCRYPTED_DATA_INFO {
    pub ExtendedCode: u32,
    pub Length: u32,
    pub Flags: u32,
    pub Reserved: u32,
}
impl EXTENDED_ENCRYPTED_DATA_INFO {}
impl ::std::default::Default for EXTENDED_ENCRYPTED_DATA_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for EXTENDED_ENCRYPTED_DATA_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("EXTENDED_ENCRYPTED_DATA_INFO")
            .field("ExtendedCode", &self.ExtendedCode)
            .field("Length", &self.Length)
            .field("Flags", &self.Flags)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for EXTENDED_ENCRYPTED_DATA_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.ExtendedCode == other.ExtendedCode
            && self.Length == other.Length
            && self.Flags == other.Flags
            && self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for EXTENDED_ENCRYPTED_DATA_INFO {}
unsafe impl ::windows::runtime::Abi for EXTENDED_ENCRYPTED_DATA_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
pub const EXTEND_IEPORT: u32 = 2u32;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub unsafe fn EngQueryEMFInfo<'a, Param0: ::windows::runtime::IntoParam<'a, HDEV>>(
    hdev: Param0,
    pemfinfo: *mut EMFINFO,
) -> super::super::Foundation::BOOL {
    #[cfg(windows)]
    {
        #[link(name = "gdi32")]
        extern "system" {
            fn EngQueryEMFInfo(
                hdev: HDEV,
                pemfinfo: *mut EMFINFO,
            ) -> super::super::Foundation::BOOL;
        }
        ::std::mem::transmute(EngQueryEMFInfo(
            hdev.into_param().abi(),
            ::std::mem::transmute(pemfinfo),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub const FACILITY_MCA_ERROR_CODE: u32 = 5u32;
pub const FAST_FAIL_ADMINLESS_ACCESS_DENIED: u32 = 55u32;
pub const FAST_FAIL_APCS_DISABLED: u32 = 32u32;
pub const FAST_FAIL_CAST_GUARD: u32 = 65u32;
pub const FAST_FAIL_CERTIFICATION_FAILURE: u32 = 20u32;
pub const FAST_FAIL_CONTROL_INVALID_RETURN_ADDRESS: u32 = 57u32;
pub const FAST_FAIL_CORRUPT_LIST_ENTRY: u32 = 3u32;
pub const FAST_FAIL_CRYPTO_LIBRARY: u32 = 22u32;
pub const FAST_FAIL_DEPRECATED_SERVICE_INVOKED: u32 = 27u32;
pub const FAST_FAIL_DLOAD_PROTECTION_FAILURE: u32 = 25u32;
pub const FAST_FAIL_ENCLAVE_CALL_FAILURE: u32 = 53u32;
pub const FAST_FAIL_ETW_CORRUPTION: u32 = 61u32;
pub const FAST_FAIL_FATAL_APP_EXIT: u32 = 7u32;
pub const FAST_FAIL_FLAGS_CORRUPTION: u32 = 59u32;
pub const FAST_FAIL_GS_COOKIE_INIT: u32 = 6u32;
pub const FAST_FAIL_GUARD_EXPORT_SUPPRESSION_FAILURE: u32 = 46u32;
pub const FAST_FAIL_GUARD_ICALL_CHECK_FAILURE: u32 = 10u32;
pub const FAST_FAIL_GUARD_ICALL_CHECK_FAILURE_XFG: u32 = 64u32;
pub const FAST_FAIL_GUARD_ICALL_CHECK_SUPPRESSED: u32 = 31u32;
pub const FAST_FAIL_GUARD_JUMPTABLE: u32 = 37u32;
pub const FAST_FAIL_GUARD_SS_FAILURE: u32 = 44u32;
pub const FAST_FAIL_GUARD_WRITE_CHECK_FAILURE: u32 = 11u32;
pub const FAST_FAIL_HEAP_METADATA_CORRUPTION: u32 = 50u32;
pub const FAST_FAIL_HOST_VISIBILITY_CHANGE: u32 = 66u32;
pub const FAST_FAIL_INCORRECT_STACK: u32 = 4u32;
pub const FAST_FAIL_INVALID_ARG: u32 = 5u32;
pub const FAST_FAIL_INVALID_BALANCED_TREE: u32 = 29u32;
pub const FAST_FAIL_INVALID_BUFFER_ACCESS: u32 = 28u32;
pub const FAST_FAIL_INVALID_CALL_IN_DLL_CALLOUT: u32 = 23u32;
pub const FAST_FAIL_INVALID_CONTROL_STACK: u32 = 47u32;
pub const FAST_FAIL_INVALID_DISPATCH_CONTEXT: u32 = 39u32;
pub const FAST_FAIL_INVALID_EXCEPTION_CHAIN: u32 = 21u32;
pub const FAST_FAIL_INVALID_FAST_FAIL_CODE: u32 = 4294967295u32;
pub const FAST_FAIL_INVALID_FIBER_SWITCH: u32 = 12u32;
pub const FAST_FAIL_INVALID_FILE_OPERATION: u32 = 42u32;
pub const FAST_FAIL_INVALID_FLS_DATA: u32 = 70u32;
pub const FAST_FAIL_INVALID_IAT: u32 = 49u32;
pub const FAST_FAIL_INVALID_IDLE_STATE: u32 = 33u32;
pub const FAST_FAIL_INVALID_IMAGE_BASE: u32 = 24u32;
pub const FAST_FAIL_INVALID_JUMP_BUFFER: u32 = 18u32;
pub const FAST_FAIL_INVALID_LOCK_STATE: u32 = 36u32;
pub const FAST_FAIL_INVALID_LONGJUMP_TARGET: u32 = 38u32;
pub const FAST_FAIL_INVALID_NEXT_THREAD: u32 = 30u32;
pub const FAST_FAIL_INVALID_PFN: u32 = 63u32;
pub const FAST_FAIL_INVALID_REFERENCE_COUNT: u32 = 14u32;
pub const FAST_FAIL_INVALID_SET_OF_CONTEXT: u32 = 13u32;
pub const FAST_FAIL_INVALID_SYSCALL_NUMBER: u32 = 41u32;
pub const FAST_FAIL_INVALID_THREAD: u32 = 40u32;
pub const FAST_FAIL_KERNEL_CET_SHADOW_STACK_ASSIST: u32 = 67u32;
pub const FAST_FAIL_LEGACY_GS_VIOLATION: u32 = 0u32;
pub const FAST_FAIL_LOADER_CONTINUITY_FAILURE: u32 = 45u32;
pub const FAST_FAIL_LOW_LABEL_ACCESS_DENIED: u32 = 52u32;
pub const FAST_FAIL_LPAC_ACCESS_DENIED: u32 = 43u32;
pub const FAST_FAIL_MRDATA_MODIFIED: u32 = 19u32;
pub const FAST_FAIL_MRDATA_PROTECTION_FAILURE: u32 = 34u32;
pub const FAST_FAIL_NTDLL_PATCH_FAILED: u32 = 69u32;
pub const FAST_FAIL_PATCH_CALLBACK_FAILED: u32 = 68u32;
pub const FAST_FAIL_PAYLOAD_RESTRICTION_VIOLATION: u32 = 51u32;
pub const FAST_FAIL_RANGE_CHECK_FAILURE: u32 = 8u32;
pub const FAST_FAIL_RIO_ABORT: u32 = 62u32;
pub const FAST_FAIL_SET_CONTEXT_DENIED: u32 = 48u32;
pub const FAST_FAIL_STACK_COOKIE_CHECK_FAILURE: u32 = 2u32;
pub const FAST_FAIL_UNEXPECTED_CALL: u32 = 56u32;
pub const FAST_FAIL_UNEXPECTED_HEAP_EXCEPTION: u32 = 35u32;
pub const FAST_FAIL_UNEXPECTED_HOST_BEHAVIOR: u32 = 58u32;
pub const FAST_FAIL_UNHANDLED_LSS_EXCEPTON: u32 = 54u32;
pub const FAST_FAIL_UNSAFE_EXTENSION_CALL: u32 = 26u32;
pub const FAST_FAIL_UNSAFE_REGISTRY_ACCESS: u32 = 9u32;
pub const FAST_FAIL_VEH_CORRUPTION: u32 = 60u32;
pub const FAST_FAIL_VTGUARD_CHECK_FAILURE: u32 = 1u32;
pub const FC_COMPLEX: u32 = 3u32;
pub const FC_RECT: u32 = 1u32;
pub const FC_RECT4: u32 = 2u32;
pub const FDM_TYPE_BM_SIDE_CONST: u32 = 1u32;
pub const FDM_TYPE_CHAR_INC_EQUAL_BM_BASE: u32 = 4u32;
pub const FDM_TYPE_CONST_BEARINGS: u32 = 16u32;
pub const FDM_TYPE_MAXEXT_EQUAL_BM_SIDE: u32 = 2u32;
pub const FDM_TYPE_ZERO_BEARINGS: u32 = 8u32;
pub const FD_ERROR: u32 = 4294967295u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct FD_LIGATURE {
    pub culThis: u32,
    pub ulType: u32,
    pub cLigatures: u32,
    pub alig: [LIGATURE; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl FD_LIGATURE {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for FD_LIGATURE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for FD_LIGATURE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FD_LIGATURE")
            .field("culThis", &self.culThis)
            .field("ulType", &self.ulType)
            .field("cLigatures", &self.cLigatures)
            .field("alig", &self.alig)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for FD_LIGATURE {
    fn eq(&self, other: &Self) -> bool {
        self.culThis == other.culThis
            && self.ulType == other.ulType
            && self.cLigatures == other.cLigatures
            && self.alig == other.alig
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for FD_LIGATURE {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for FD_LIGATURE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const FD_NEGATIVE_FONT: i32 = 1i32;
pub const FF_IGNORED_SIGNATURE: u32 = 2u32;
pub const FF_SIGNATURE_VERIFIED: u32 = 1u32;
pub const FILESYSTEM_STATISTICS_TYPE_REFS: u32 = 4u32;
pub const FILE_ANY_ACCESS: u32 = 0u32;
pub const FILE_ATTRIBUTE_STRICTLY_SEQUENTIAL: u32 = 536870912u32;
pub const FILE_CASE_PRESERVED_NAMES: u32 = 2u32;
pub const FILE_CASE_SENSITIVE_SEARCH: u32 = 1u32;
pub const FILE_CLEAR_ENCRYPTION: u32 = 2u32;
pub const FILE_CS_FLAG_CASE_SENSITIVE_DIR: u32 = 1u32;
pub const FILE_DAX_VOLUME: u32 = 536870912u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FILE_DESIRED_STORAGE_CLASS_INFORMATION {
    pub Class: FILE_STORAGE_TIER_CLASS,
    pub Flags: u32,
}
impl FILE_DESIRED_STORAGE_CLASS_INFORMATION {}
impl ::std::default::Default for FILE_DESIRED_STORAGE_CLASS_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FILE_DESIRED_STORAGE_CLASS_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FILE_DESIRED_STORAGE_CLASS_INFORMATION")
            .field("Class", &self.Class)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FILE_DESIRED_STORAGE_CLASS_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.Class == other.Class && self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for FILE_DESIRED_STORAGE_CLASS_INFORMATION {}
unsafe impl ::windows::runtime::Abi for FILE_DESIRED_STORAGE_CLASS_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const FILE_DEVICE_8042_PORT: u32 = 39u32;
pub const FILE_DEVICE_ACPI: u32 = 50u32;
pub const FILE_DEVICE_BATTERY: u32 = 41u32;
pub const FILE_DEVICE_BEEP: u32 = 1u32;
pub const FILE_DEVICE_BIOMETRIC: u32 = 68u32;
pub const FILE_DEVICE_BLUETOOTH: u32 = 65u32;
pub const FILE_DEVICE_BUS_EXTENDER: u32 = 42u32;
pub const FILE_DEVICE_CD_ROM_FILE_SYSTEM: u32 = 3u32;
pub const FILE_DEVICE_CHANGER: u32 = 48u32;
pub const FILE_DEVICE_CONSOLE: u32 = 80u32;
pub const FILE_DEVICE_CONTROLLER: u32 = 4u32;
pub const FILE_DEVICE_CRYPT_PROVIDER: u32 = 63u32;
pub const FILE_DEVICE_DATALINK: u32 = 5u32;
pub const FILE_DEVICE_DEVAPI: u32 = 71u32;
pub const FILE_DEVICE_DFS: u32 = 6u32;
pub const FILE_DEVICE_DFS_FILE_SYSTEM: u32 = 53u32;
pub const FILE_DEVICE_DFS_VOLUME: u32 = 54u32;
pub const FILE_DEVICE_DISK_FILE_SYSTEM: u32 = 8u32;
pub const FILE_DEVICE_EHSTOR: u32 = 70u32;
pub const FILE_DEVICE_EVENT_COLLECTOR: u32 = 95u32;
pub const FILE_DEVICE_FILE_SYSTEM: u32 = 9u32;
pub const FILE_DEVICE_FIPS: u32 = 58u32;
pub const FILE_DEVICE_FULLSCREEN_VIDEO: u32 = 52u32;
pub const FILE_DEVICE_GPIO: u32 = 72u32;
pub const FILE_DEVICE_HOLOGRAPHIC: u32 = 91u32;
pub const FILE_DEVICE_INFINIBAND: u32 = 59u32;
pub const FILE_DEVICE_INPORT_PORT: u32 = 10u32;
pub const FILE_DEVICE_KEYBOARD: u32 = 11u32;
pub const FILE_DEVICE_KS: u32 = 47u32;
pub const FILE_DEVICE_KSEC: u32 = 57u32;
pub const FILE_DEVICE_MAILSLOT: u32 = 12u32;
pub const FILE_DEVICE_MASS_STORAGE: u32 = 45u32;
pub const FILE_DEVICE_MIDI_IN: u32 = 13u32;
pub const FILE_DEVICE_MIDI_OUT: u32 = 14u32;
pub const FILE_DEVICE_MODEM: u32 = 43u32;
pub const FILE_DEVICE_MOUSE: u32 = 15u32;
pub const FILE_DEVICE_MT_COMPOSITE: u32 = 66u32;
pub const FILE_DEVICE_MT_TRANSPORT: u32 = 67u32;
pub const FILE_DEVICE_MULTI_UNC_PROVIDER: u32 = 16u32;
pub const FILE_DEVICE_NAMED_PIPE: u32 = 17u32;
pub const FILE_DEVICE_NETWORK: u32 = 18u32;
pub const FILE_DEVICE_NETWORK_BROWSER: u32 = 19u32;
pub const FILE_DEVICE_NETWORK_FILE_SYSTEM: u32 = 20u32;
pub const FILE_DEVICE_NETWORK_REDIRECTOR: u32 = 40u32;
pub const FILE_DEVICE_NFP: u32 = 81u32;
pub const FILE_DEVICE_NULL: u32 = 21u32;
pub const FILE_DEVICE_NVDIMM: u32 = 90u32;
pub const FILE_DEVICE_PARALLEL_PORT: u32 = 22u32;
pub const FILE_DEVICE_PERSISTENT_MEMORY: u32 = 89u32;
pub const FILE_DEVICE_PHYSICAL_NETCARD: u32 = 23u32;
pub const FILE_DEVICE_PMI: u32 = 69u32;
pub const FILE_DEVICE_POINT_OF_SERVICE: u32 = 84u32;
pub const FILE_DEVICE_PRINTER: u32 = 24u32;
pub const FILE_DEVICE_PRM: u32 = 94u32;
pub const FILE_DEVICE_SCANNER: u32 = 25u32;
pub const FILE_DEVICE_SCREEN: u32 = 28u32;
pub const FILE_DEVICE_SDFXHCI: u32 = 92u32;
pub const FILE_DEVICE_SERENUM: u32 = 55u32;
pub const FILE_DEVICE_SERIAL_MOUSE_PORT: u32 = 26u32;
pub const FILE_DEVICE_SERIAL_PORT: u32 = 27u32;
pub const FILE_DEVICE_SMARTCARD: u32 = 49u32;
pub const FILE_DEVICE_SMB: u32 = 46u32;
pub const FILE_DEVICE_SOUND: u32 = 29u32;
pub const FILE_DEVICE_SOUNDWIRE: u32 = 97u32;
pub const FILE_DEVICE_STORAGE_REPLICATION: u32 = 85u32;
pub const FILE_DEVICE_STREAMS: u32 = 30u32;
pub const FILE_DEVICE_SYSENV: u32 = 82u32;
pub const FILE_DEVICE_TAPE_FILE_SYSTEM: u32 = 32u32;
pub const FILE_DEVICE_TERMSRV: u32 = 56u32;
pub const FILE_DEVICE_TRANSPORT: u32 = 33u32;
pub const FILE_DEVICE_TRUST_ENV: u32 = 86u32;
pub const FILE_DEVICE_UCM: u32 = 87u32;
pub const FILE_DEVICE_UCMTCPCI: u32 = 88u32;
pub const FILE_DEVICE_UCMUCSI: u32 = 93u32;
pub const FILE_DEVICE_UNKNOWN: u32 = 34u32;
pub const FILE_DEVICE_USB4: u32 = 96u32;
pub const FILE_DEVICE_USBEX: u32 = 73u32;
pub const FILE_DEVICE_VDM: u32 = 44u32;
pub const FILE_DEVICE_VIDEO: u32 = 35u32;
pub const FILE_DEVICE_VIRTUAL_BLOCK: u32 = 83u32;
pub const FILE_DEVICE_VIRTUAL_DISK: u32 = 36u32;
pub const FILE_DEVICE_VMBUS: u32 = 62u32;
pub const FILE_DEVICE_WAVE_IN: u32 = 37u32;
pub const FILE_DEVICE_WAVE_OUT: u32 = 38u32;
pub const FILE_DEVICE_WPD: u32 = 64u32;
pub const FILE_FILE_COMPRESSION: u32 = 16u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FILE_FS_PERSISTENT_VOLUME_INFORMATION {
    pub VolumeFlags: u32,
    pub FlagMask: u32,
    pub Version: u32,
    pub Reserved: u32,
}
impl FILE_FS_PERSISTENT_VOLUME_INFORMATION {}
impl ::std::default::Default for FILE_FS_PERSISTENT_VOLUME_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FILE_FS_PERSISTENT_VOLUME_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FILE_FS_PERSISTENT_VOLUME_INFORMATION")
            .field("VolumeFlags", &self.VolumeFlags)
            .field("FlagMask", &self.FlagMask)
            .field("Version", &self.Version)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FILE_FS_PERSISTENT_VOLUME_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.VolumeFlags == other.VolumeFlags
            && self.FlagMask == other.FlagMask
            && self.Version == other.Version
            && self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for FILE_FS_PERSISTENT_VOLUME_INFORMATION {}
unsafe impl ::windows::runtime::Abi for FILE_FS_PERSISTENT_VOLUME_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NON_RESIDENT: u64 = 137438953472u64;
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NOT_FOUND: u64 = 4096u64;
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_TOO_SMALL: u64 = 68719476736u64;
pub const FILE_INITIATE_REPAIR_HINT1_CLUSTERS_ALREADY_IN_USE: u64 = 32768u64;
pub const FILE_INITIATE_REPAIR_HINT1_DENY_DEFRAG: u64 = 274877906944u64;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_IS_BASE_RECORD: u64 = 524288u64;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_BASE_RECORD: u64 = 8u64;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_EXIST: u64 = 4u64;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_IN_USE: u64 = 1u64;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_ORPHAN: u64 = 262144u64;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_REUSED: u64 = 2u64;
pub const FILE_INITIATE_REPAIR_HINT1_INDEX_ENTRY_MISMATCH: u64 = 1099511627776u64;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_ARRAY_LENGTH_COUNT: u64 = 1048576u64;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_LCN: u64 = 4294967296u64;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_ORPHAN_RECOVERY_NAME: u64 = 2199023255552u64;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_PARENT: u64 = 8388608u64;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_RUN_LENGTH: u64 = 131072u64;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_VCN: u64 = 8589934592u64;
pub const FILE_INITIATE_REPAIR_HINT1_LCN_NOT_EXIST: u64 = 65536u64;
pub const FILE_INITIATE_REPAIR_HINT1_MULTIPLE_FILE_NAME_ATTRIBUTES: u64 = 4398046511104u64;
pub const FILE_INITIATE_REPAIR_HINT1_NAME_CONFLICT: u64 = 17179869184u64;
pub const FILE_INITIATE_REPAIR_HINT1_NOTHING_WRONG: u64 = 2048u64;
pub const FILE_INITIATE_REPAIR_HINT1_NOT_IMPLEMENTED: u64 = 32u64;
pub const FILE_INITIATE_REPAIR_HINT1_ORPHAN: u64 = 34359738368u64;
pub const FILE_INITIATE_REPAIR_HINT1_ORPHAN_GENERATED: u64 = 512u64;
pub const FILE_INITIATE_REPAIR_HINT1_OUT_OF_GENERIC_NAMES: u64 = 1073741824u64;
pub const FILE_INITIATE_REPAIR_HINT1_OUT_OF_RESOURCE: u64 = 2147483648u64;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_BASE_RECORD: u64 = 134217728u64;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_EXIST: u64 = 67108864u64;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_INDEX: u64 = 268435456u64;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_IN_USE: u64 = 16777216u64;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_REUSED: u64 = 33554432u64;
pub const FILE_INITIATE_REPAIR_HINT1_POTENTIAL_CROSSLINK: u64 = 8192u64;
pub const FILE_INITIATE_REPAIR_HINT1_PREVIOUS_PARENT_STILL_VALID: u64 = 549755813888u64;
pub const FILE_INITIATE_REPAIR_HINT1_RECURSIVELY_CORRUPTED: u64 = 256u64;
pub const FILE_INITIATE_REPAIR_HINT1_REPAIRED: u64 = 1024u64;
pub const FILE_INITIATE_REPAIR_HINT1_REPAIR_DISABLED: u64 = 128u64;
pub const FILE_INITIATE_REPAIR_HINT1_SID_MISMATCH: u64 = 4194304u64;
pub const FILE_INITIATE_REPAIR_HINT1_SID_VALID: u64 = 2097152u64;
pub const FILE_INITIATE_REPAIR_HINT1_STALE_INFORMATION: u64 = 16384u64;
pub const FILE_INITIATE_REPAIR_HINT1_SYSTEM_FILE: u64 = 16u64;
pub const FILE_INITIATE_REPAIR_HINT1_UNABLE_TO_REPAIR: u64 = 64u64;
pub const FILE_INITIATE_REPAIR_HINT1_VALID_INDEX_ENTRY: u64 = 536870912u64;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FILE_INITIATE_REPAIR_OUTPUT_BUFFER {
    pub Hint1: u64,
    pub Hint2: u64,
    pub Clsn: u64,
    pub Status: u32,
}
impl FILE_INITIATE_REPAIR_OUTPUT_BUFFER {}
impl ::std::default::Default for FILE_INITIATE_REPAIR_OUTPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FILE_INITIATE_REPAIR_OUTPUT_BUFFER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FILE_INITIATE_REPAIR_OUTPUT_BUFFER")
            .field("Hint1", &self.Hint1)
            .field("Hint2", &self.Hint2)
            .field("Clsn", &self.Clsn)
            .field("Status", &self.Status)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FILE_INITIATE_REPAIR_OUTPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.Hint1 == other.Hint1
            && self.Hint2 == other.Hint2
            && self.Clsn == other.Clsn
            && self.Status == other.Status
    }
}
impl ::std::cmp::Eq for FILE_INITIATE_REPAIR_OUTPUT_BUFFER {}
unsafe impl ::windows::runtime::Abi for FILE_INITIATE_REPAIR_OUTPUT_BUFFER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FILE_LAYOUT_ENTRY {
    pub Version: u32,
    pub NextFileOffset: u32,
    pub Flags: u32,
    pub FileAttributes: u32,
    pub FileReferenceNumber: u64,
    pub FirstNameOffset: u32,
    pub FirstStreamOffset: u32,
    pub ExtraInfoOffset: u32,
    pub ExtraInfoLength: u32,
}
impl FILE_LAYOUT_ENTRY {}
impl ::std::default::Default for FILE_LAYOUT_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FILE_LAYOUT_ENTRY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FILE_LAYOUT_ENTRY")
            .field("Version", &self.Version)
            .field("NextFileOffset", &self.NextFileOffset)
            .field("Flags", &self.Flags)
            .field("FileAttributes", &self.FileAttributes)
            .field("FileReferenceNumber", &self.FileReferenceNumber)
            .field("FirstNameOffset", &self.FirstNameOffset)
            .field("FirstStreamOffset", &self.FirstStreamOffset)
            .field("ExtraInfoOffset", &self.ExtraInfoOffset)
            .field("ExtraInfoLength", &self.ExtraInfoLength)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FILE_LAYOUT_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.NextFileOffset == other.NextFileOffset
            && self.Flags == other.Flags
            && self.FileAttributes == other.FileAttributes
            && self.FileReferenceNumber == other.FileReferenceNumber
            && self.FirstNameOffset == other.FirstNameOffset
            && self.FirstStreamOffset == other.FirstStreamOffset
            && self.ExtraInfoOffset == other.ExtraInfoOffset
            && self.ExtraInfoLength == other.ExtraInfoLength
    }
}
impl ::std::cmp::Eq for FILE_LAYOUT_ENTRY {}
unsafe impl ::windows::runtime::Abi for FILE_LAYOUT_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FILE_LAYOUT_INFO_ENTRY {
    pub BasicInformation: FILE_LAYOUT_INFO_ENTRY_0,
    pub OwnerId: u32,
    pub SecurityId: u32,
    pub Usn: i64,
    pub StorageReserveId: STORAGE_RESERVE_ID,
}
impl FILE_LAYOUT_INFO_ENTRY {}
impl ::std::default::Default for FILE_LAYOUT_INFO_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FILE_LAYOUT_INFO_ENTRY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FILE_LAYOUT_INFO_ENTRY")
            .field("BasicInformation", &self.BasicInformation)
            .field("OwnerId", &self.OwnerId)
            .field("SecurityId", &self.SecurityId)
            .field("Usn", &self.Usn)
            .field("StorageReserveId", &self.StorageReserveId)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FILE_LAYOUT_INFO_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.BasicInformation == other.BasicInformation
            && self.OwnerId == other.OwnerId
            && self.SecurityId == other.SecurityId
            && self.Usn == other.Usn
            && self.StorageReserveId == other.StorageReserveId
    }
}
impl ::std::cmp::Eq for FILE_LAYOUT_INFO_ENTRY {}
unsafe impl ::windows::runtime::Abi for FILE_LAYOUT_INFO_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FILE_LAYOUT_INFO_ENTRY_0 {
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
    pub FileAttributes: u32,
}
impl FILE_LAYOUT_INFO_ENTRY_0 {}
impl ::std::default::Default for FILE_LAYOUT_INFO_ENTRY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FILE_LAYOUT_INFO_ENTRY_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_BasicInformation_e__Struct")
            .field("CreationTime", &self.CreationTime)
            .field("LastAccessTime", &self.LastAccessTime)
            .field("LastWriteTime", &self.LastWriteTime)
            .field("ChangeTime", &self.ChangeTime)
            .field("FileAttributes", &self.FileAttributes)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FILE_LAYOUT_INFO_ENTRY_0 {
    fn eq(&self, other: &Self) -> bool {
        self.CreationTime == other.CreationTime
            && self.LastAccessTime == other.LastAccessTime
            && self.LastWriteTime == other.LastWriteTime
            && self.ChangeTime == other.ChangeTime
            && self.FileAttributes == other.FileAttributes
    }
}
impl ::std::cmp::Eq for FILE_LAYOUT_INFO_ENTRY_0 {}
unsafe impl ::windows::runtime::Abi for FILE_LAYOUT_INFO_ENTRY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FILE_LAYOUT_NAME_ENTRY {
    pub NextNameOffset: u32,
    pub Flags: u32,
    pub ParentFileReferenceNumber: u64,
    pub FileNameLength: u32,
    pub Reserved: u32,
    pub FileName: [u16; 1],
}
impl FILE_LAYOUT_NAME_ENTRY {}
impl ::std::default::Default for FILE_LAYOUT_NAME_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FILE_LAYOUT_NAME_ENTRY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FILE_LAYOUT_NAME_ENTRY")
            .field("NextNameOffset", &self.NextNameOffset)
            .field("Flags", &self.Flags)
            .field("ParentFileReferenceNumber", &self.ParentFileReferenceNumber)
            .field("FileNameLength", &self.FileNameLength)
            .field("Reserved", &self.Reserved)
            .field("FileName", &self.FileName)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FILE_LAYOUT_NAME_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.NextNameOffset == other.NextNameOffset
            && self.Flags == other.Flags
            && self.ParentFileReferenceNumber == other.ParentFileReferenceNumber
            && self.FileNameLength == other.FileNameLength
            && self.Reserved == other.Reserved
            && self.FileName == other.FileName
    }
}
impl ::std::cmp::Eq for FILE_LAYOUT_NAME_ENTRY {}
unsafe impl ::windows::runtime::Abi for FILE_LAYOUT_NAME_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
pub const FILE_LAYOUT_NAME_ENTRY_DOS: u32 = 2u32;
pub const FILE_LAYOUT_NAME_ENTRY_PRIMARY: u32 = 1u32;
pub const FILE_NAMED_STREAMS: u32 = 262144u32;
pub const FILE_PERSISTENT_ACLS: u32 = 8u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FILE_PREFETCH {
    pub Type: u32,
    pub Count: u32,
    pub Prefetch: [u64; 1],
}
impl FILE_PREFETCH {}
impl ::std::default::Default for FILE_PREFETCH {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FILE_PREFETCH {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FILE_PREFETCH")
            .field("Type", &self.Type)
            .field("Count", &self.Count)
            .field("Prefetch", &self.Prefetch)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FILE_PREFETCH {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type && self.Count == other.Count && self.Prefetch == other.Prefetch
    }
}
impl ::std::cmp::Eq for FILE_PREFETCH {}
unsafe impl ::windows::runtime::Abi for FILE_PREFETCH {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FILE_PREFETCH_EX {
    pub Type: u32,
    pub Count: u32,
    pub Context: *mut ::std::ffi::c_void,
    pub Prefetch: [u64; 1],
}
impl FILE_PREFETCH_EX {}
impl ::std::default::Default for FILE_PREFETCH_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FILE_PREFETCH_EX {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FILE_PREFETCH_EX")
            .field("Type", &self.Type)
            .field("Count", &self.Count)
            .field("Context", &self.Context)
            .field("Prefetch", &self.Prefetch)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FILE_PREFETCH_EX {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type
            && self.Count == other.Count
            && self.Context == other.Context
            && self.Prefetch == other.Prefetch
    }
}
impl ::std::cmp::Eq for FILE_PREFETCH_EX {}
unsafe impl ::windows::runtime::Abi for FILE_PREFETCH_EX {
    type Abi = Self;
    type DefaultType = Self;
}
pub const FILE_PREFETCH_TYPE_FOR_CREATE: u32 = 1u32;
pub const FILE_PREFETCH_TYPE_FOR_CREATE_EX: u32 = 3u32;
pub const FILE_PREFETCH_TYPE_FOR_DIRENUM: u32 = 2u32;
pub const FILE_PREFETCH_TYPE_FOR_DIRENUM_EX: u32 = 4u32;
pub const FILE_PREFETCH_TYPE_MAX: u32 = 4u32;
pub const FILE_PROVIDER_COMPRESSION_LZX: u32 = 1u32;
pub const FILE_PROVIDER_COMPRESSION_MAXIMUM: u32 = 4u32;
pub const FILE_PROVIDER_COMPRESSION_XPRESS16K: u32 = 3u32;
pub const FILE_PROVIDER_COMPRESSION_XPRESS4K: u32 = 0u32;
pub const FILE_PROVIDER_COMPRESSION_XPRESS8K: u32 = 2u32;
pub const FILE_PROVIDER_CURRENT_VERSION: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FILE_PROVIDER_EXTERNAL_INFO_V0 {
    pub Version: u32,
    pub Algorithm: u32,
}
impl FILE_PROVIDER_EXTERNAL_INFO_V0 {}
impl ::std::default::Default for FILE_PROVIDER_EXTERNAL_INFO_V0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FILE_PROVIDER_EXTERNAL_INFO_V0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FILE_PROVIDER_EXTERNAL_INFO_V0")
            .field("Version", &self.Version)
            .field("Algorithm", &self.Algorithm)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FILE_PROVIDER_EXTERNAL_INFO_V0 {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Algorithm == other.Algorithm
    }
}
impl ::std::cmp::Eq for FILE_PROVIDER_EXTERNAL_INFO_V0 {}
unsafe impl ::windows::runtime::Abi for FILE_PROVIDER_EXTERNAL_INFO_V0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FILE_PROVIDER_EXTERNAL_INFO_V1 {
    pub Version: u32,
    pub Algorithm: u32,
    pub Flags: u32,
}
impl FILE_PROVIDER_EXTERNAL_INFO_V1 {}
impl ::std::default::Default for FILE_PROVIDER_EXTERNAL_INFO_V1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FILE_PROVIDER_EXTERNAL_INFO_V1 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FILE_PROVIDER_EXTERNAL_INFO_V1")
            .field("Version", &self.Version)
            .field("Algorithm", &self.Algorithm)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FILE_PROVIDER_EXTERNAL_INFO_V1 {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Algorithm == other.Algorithm
            && self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for FILE_PROVIDER_EXTERNAL_INFO_V1 {}
unsafe impl ::windows::runtime::Abi for FILE_PROVIDER_EXTERNAL_INFO_V1 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const FILE_PROVIDER_FLAG_COMPRESS_ON_WRITE: u32 = 1u32;
pub const FILE_PROVIDER_SINGLE_FILE: u32 = 1u32;
pub const FILE_READ_ACCESS: u32 = 1u32;
pub const FILE_READ_ONLY_VOLUME: u32 = 524288u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FILE_REFERENCE_RANGE {
    pub StartingFileReferenceNumber: u64,
    pub EndingFileReferenceNumber: u64,
}
impl FILE_REFERENCE_RANGE {}
impl ::std::default::Default for FILE_REFERENCE_RANGE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FILE_REFERENCE_RANGE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FILE_REFERENCE_RANGE")
            .field(
                "StartingFileReferenceNumber",
                &self.StartingFileReferenceNumber,
            )
            .field("EndingFileReferenceNumber", &self.EndingFileReferenceNumber)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FILE_REFERENCE_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.StartingFileReferenceNumber == other.StartingFileReferenceNumber
            && self.EndingFileReferenceNumber == other.EndingFileReferenceNumber
    }
}
impl ::std::cmp::Eq for FILE_REFERENCE_RANGE {}
unsafe impl ::windows::runtime::Abi for FILE_REFERENCE_RANGE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FILE_REGION_INFO {
    pub FileOffset: i64,
    pub Length: i64,
    pub Usage: u32,
    pub Reserved: u32,
}
impl FILE_REGION_INFO {}
impl ::std::default::Default for FILE_REGION_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FILE_REGION_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FILE_REGION_INFO")
            .field("FileOffset", &self.FileOffset)
            .field("Length", &self.Length)
            .field("Usage", &self.Usage)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FILE_REGION_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.FileOffset == other.FileOffset
            && self.Length == other.Length
            && self.Usage == other.Usage
            && self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for FILE_REGION_INFO {}
unsafe impl ::windows::runtime::Abi for FILE_REGION_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FILE_REGION_INPUT {
    pub FileOffset: i64,
    pub Length: i64,
    pub DesiredUsage: u32,
}
impl FILE_REGION_INPUT {}
impl ::std::default::Default for FILE_REGION_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FILE_REGION_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FILE_REGION_INPUT")
            .field("FileOffset", &self.FileOffset)
            .field("Length", &self.Length)
            .field("DesiredUsage", &self.DesiredUsage)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FILE_REGION_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.FileOffset == other.FileOffset
            && self.Length == other.Length
            && self.DesiredUsage == other.DesiredUsage
    }
}
impl ::std::cmp::Eq for FILE_REGION_INPUT {}
unsafe impl ::windows::runtime::Abi for FILE_REGION_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FILE_REGION_OUTPUT {
    pub Flags: u32,
    pub TotalRegionEntryCount: u32,
    pub RegionEntryCount: u32,
    pub Reserved: u32,
    pub Region: [FILE_REGION_INFO; 1],
}
impl FILE_REGION_OUTPUT {}
impl ::std::default::Default for FILE_REGION_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FILE_REGION_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FILE_REGION_OUTPUT")
            .field("Flags", &self.Flags)
            .field("TotalRegionEntryCount", &self.TotalRegionEntryCount)
            .field("RegionEntryCount", &self.RegionEntryCount)
            .field("Reserved", &self.Reserved)
            .field("Region", &self.Region)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FILE_REGION_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
            && self.TotalRegionEntryCount == other.TotalRegionEntryCount
            && self.RegionEntryCount == other.RegionEntryCount
            && self.Reserved == other.Reserved
            && self.Region == other.Region
    }
}
impl ::std::cmp::Eq for FILE_REGION_OUTPUT {}
unsafe impl ::windows::runtime::Abi for FILE_REGION_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const FILE_REGION_USAGE_HUGE_PAGE_ALIGNMENT: u32 = 16u32;
pub const FILE_REGION_USAGE_LARGE_PAGE_ALIGNMENT: u32 = 8u32;
pub const FILE_REGION_USAGE_OTHER_PAGE_ALIGNMENT: u32 = 4u32;
pub const FILE_REGION_USAGE_QUERY_ALIGNMENT: u32 = 8u32;
pub const FILE_REGION_USAGE_VALID_CACHED_DATA: u32 = 1u32;
pub const FILE_REGION_USAGE_VALID_NONCACHED_DATA: u32 = 2u32;
pub const FILE_RETURNS_CLEANUP_RESULT_INFO: u32 = 512u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union FILE_SEGMENT_ELEMENT {
    pub Buffer: *mut ::std::ffi::c_void,
    pub Alignment: u64,
}
impl FILE_SEGMENT_ELEMENT {}
impl ::std::default::Default for FILE_SEGMENT_ELEMENT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for FILE_SEGMENT_ELEMENT {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for FILE_SEGMENT_ELEMENT {}
unsafe impl ::windows::runtime::Abi for FILE_SEGMENT_ELEMENT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const FILE_SEQUENTIAL_WRITE_ONCE: u32 = 1048576u32;
pub const FILE_SET_ENCRYPTION: u32 = 1u32;
pub const FILE_SPECIAL_ACCESS: u32 = 0u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct FILE_STORAGE_TIER_CLASS(pub i32);
pub const FileStorageTierClassUnspecified: FILE_STORAGE_TIER_CLASS = FILE_STORAGE_TIER_CLASS(0i32);
pub const FileStorageTierClassCapacity: FILE_STORAGE_TIER_CLASS = FILE_STORAGE_TIER_CLASS(1i32);
pub const FileStorageTierClassPerformance: FILE_STORAGE_TIER_CLASS = FILE_STORAGE_TIER_CLASS(2i32);
pub const FileStorageTierClassMax: FILE_STORAGE_TIER_CLASS = FILE_STORAGE_TIER_CLASS(3i32);
impl ::std::convert::From<i32> for FILE_STORAGE_TIER_CLASS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for FILE_STORAGE_TIER_CLASS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const FILE_STORAGE_TIER_DESCRIPTION_LENGTH: u32 = 512u32;
pub const FILE_STORAGE_TIER_FLAG_PARITY: u32 = 8388608u32;
pub const FILE_STORAGE_TIER_FLAG_READ_CACHE: u32 = 4194304u32;
pub const FILE_STORAGE_TIER_FLAG_SMR: u32 = 16777216u32;
pub const FILE_STORAGE_TIER_FLAG_WRITE_BACK_CACHE: u32 = 2097152u32;
pub const FILE_STORAGE_TIER_NAME_LENGTH: u32 = 256u32;
pub const FILE_SUPPORTS_BLOCK_REFCOUNTING: u32 = 134217728u32;
pub const FILE_SUPPORTS_BYPASS_IO: u32 = 2048u32;
pub const FILE_SUPPORTS_ENCRYPTION: u32 = 131072u32;
pub const FILE_SUPPORTS_EXTENDED_ATTRIBUTES: u32 = 8388608u32;
pub const FILE_SUPPORTS_GHOSTING: u32 = 1073741824u32;
pub const FILE_SUPPORTS_HARD_LINKS: u32 = 4194304u32;
pub const FILE_SUPPORTS_INTEGRITY_STREAMS: u32 = 67108864u32;
pub const FILE_SUPPORTS_OBJECT_IDS: u32 = 65536u32;
pub const FILE_SUPPORTS_OPEN_BY_FILE_ID: u32 = 16777216u32;
pub const FILE_SUPPORTS_POSIX_UNLINK_RENAME: u32 = 1024u32;
pub const FILE_SUPPORTS_REMOTE_STORAGE: u32 = 256u32;
pub const FILE_SUPPORTS_REPARSE_POINTS: u32 = 128u32;
pub const FILE_SUPPORTS_SPARSE_FILES: u32 = 64u32;
pub const FILE_SUPPORTS_SPARSE_VDL: u32 = 268435456u32;
pub const FILE_SUPPORTS_TRANSACTIONS: u32 = 2097152u32;
pub const FILE_SUPPORTS_USN_JOURNAL: u32 = 33554432u32;
pub const FILE_TYPE_NOTIFICATION_FLAG_USAGE_BEGIN: u32 = 1u32;
pub const FILE_TYPE_NOTIFICATION_FLAG_USAGE_END: u32 = 2u32;
pub const FILE_TYPE_NOTIFICATION_GUID_CRASHDUMP_FILE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2638560951,
        53926,
        19901,
        [162, 227, 251, 208, 237, 145, 9, 169],
    );
pub const FILE_TYPE_NOTIFICATION_GUID_HIBERNATION_FILE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3076672868,
        47523,
        19704,
        [128, 17, 91, 134, 201, 64, 231, 183],
    );
pub const FILE_TYPE_NOTIFICATION_GUID_PAGE_FILE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        218784929,
        14588,
        19896,
        [159, 231, 63, 67, 82, 205, 124, 92],
    );
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FILE_TYPE_NOTIFICATION_INPUT {
    pub Flags: u32,
    pub NumFileTypeIDs: u32,
    pub FileTypeID: [::windows::runtime::GUID; 1],
}
impl FILE_TYPE_NOTIFICATION_INPUT {}
impl ::std::default::Default for FILE_TYPE_NOTIFICATION_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FILE_TYPE_NOTIFICATION_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FILE_TYPE_NOTIFICATION_INPUT")
            .field("Flags", &self.Flags)
            .field("NumFileTypeIDs", &self.NumFileTypeIDs)
            .field("FileTypeID", &self.FileTypeID)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FILE_TYPE_NOTIFICATION_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
            && self.NumFileTypeIDs == other.NumFileTypeIDs
            && self.FileTypeID == other.FileTypeID
    }
}
impl ::std::cmp::Eq for FILE_TYPE_NOTIFICATION_INPUT {}
unsafe impl ::windows::runtime::Abi for FILE_TYPE_NOTIFICATION_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const FILE_UNICODE_ON_DISK: u32 = 4u32;
pub const FILE_VOLUME_IS_COMPRESSED: u32 = 32768u32;
pub const FILE_VOLUME_QUOTAS: u32 = 32u32;
pub const FILE_WRITE_ACCESS: u32 = 2u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FILE_ZERO_DATA_INFORMATION_EX {
    pub FileOffset: i64,
    pub BeyondFinalZero: i64,
    pub Flags: u32,
}
impl FILE_ZERO_DATA_INFORMATION_EX {}
impl ::std::default::Default for FILE_ZERO_DATA_INFORMATION_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FILE_ZERO_DATA_INFORMATION_EX {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FILE_ZERO_DATA_INFORMATION_EX")
            .field("FileOffset", &self.FileOffset)
            .field("BeyondFinalZero", &self.BeyondFinalZero)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FILE_ZERO_DATA_INFORMATION_EX {
    fn eq(&self, other: &Self) -> bool {
        self.FileOffset == other.FileOffset
            && self.BeyondFinalZero == other.BeyondFinalZero
            && self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for FILE_ZERO_DATA_INFORMATION_EX {}
unsafe impl ::windows::runtime::Abi for FILE_ZERO_DATA_INFORMATION_EX {
    type Abi = Self;
    type DefaultType = Self;
}
pub const FILE_ZERO_DATA_INFORMATION_FLAG_PRESERVE_CACHED_DATA: u32 = 1u32;
pub const FILL_NV_MEMORY_FLAG_FLUSH: u32 = 1u32;
pub const FILL_NV_MEMORY_FLAG_NON_TEMPORAL: u32 = 2u32;
pub const FILL_NV_MEMORY_FLAG_NO_DRAIN: u32 = 256u32;
pub const FLAG_USN_TRACK_MODIFIED_RANGES_ENABLE: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FLOAT128 {
    pub LowPart: i64,
    pub HighPart: i64,
}
impl FLOAT128 {}
impl ::std::default::Default for FLOAT128 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FLOAT128 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FLOAT128")
            .field("LowPart", &self.LowPart)
            .field("HighPart", &self.HighPart)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FLOAT128 {
    fn eq(&self, other: &Self) -> bool {
        self.LowPart == other.LowPart && self.HighPart == other.HighPart
    }
}
impl ::std::cmp::Eq for FLOAT128 {}
unsafe impl ::windows::runtime::Abi for FLOAT128 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union FLOAT_LONG {
    pub e: f32,
    pub l: i32,
}
impl FLOAT_LONG {}
impl ::std::default::Default for FLOAT_LONG {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for FLOAT_LONG {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for FLOAT_LONG {}
unsafe impl ::windows::runtime::Abi for FLOAT_LONG {
    type Abi = Self;
    type DefaultType = Self;
}
pub const FLS_MAXIMUM_AVAILABLE: u32 = 4080u32;
pub const FLUSH_FLAGS_FILE_DATA_ONLY: u32 = 1u32;
pub const FLUSH_FLAGS_FILE_DATA_SYNC_ONLY: u32 = 4u32;
pub const FLUSH_FLAGS_NO_SYNC: u32 = 2u32;
pub const FLUSH_NV_MEMORY_IN_FLAG_NO_DRAIN: u32 = 1u32;
pub const FL_NONPAGED_MEMORY: u32 = 2u32;
pub const FL_NON_SESSION: u32 = 4u32;
pub const FL_ZERO_MEMORY: u32 = 1u32;
pub const FM_EDITABLE_EMBED: u32 = 8u32;
pub const FM_INFO_16BPP: u32 = 256u32;
pub const FM_INFO_1BPP: u32 = 32u32;
pub const FM_INFO_24BPP: u32 = 512u32;
pub const FM_INFO_32BPP: u32 = 1024u32;
pub const FM_INFO_4BPP: u32 = 64u32;
pub const FM_INFO_8BPP: u32 = 128u32;
pub const FM_INFO_90DEGREE_ROTATIONS: u32 = 2097152u32;
pub const FM_INFO_ANISOTROPIC_SCALING_ONLY: u32 = 33554432u32;
pub const FM_INFO_ARB_XFORMS: u32 = 16u32;
pub const FM_INFO_CONSTANT_WIDTH: u32 = 4096u32;
pub const FM_INFO_DBCS_FIXED_PITCH: u32 = 268435456u32;
pub const FM_INFO_DO_NOT_ENUMERATE: u32 = 8388608u32;
pub const FM_INFO_DSIG: u32 = 262144u32;
pub const FM_INFO_FAMILY_EQUIV: u32 = 134217728u32;
pub const FM_INFO_IGNORE_TC_RA_ABLE: u32 = 1073741824u32;
pub const FM_INFO_INTEGER_WIDTH: u32 = 2048u32;
pub const FM_INFO_INTEGRAL_SCALING: u32 = 1048576u32;
pub const FM_INFO_ISOTROPIC_SCALING_ONLY: u32 = 16777216u32;
pub const FM_INFO_NONNEGATIVE_AC: u32 = 536870912u32;
pub const FM_INFO_NOT_CONTIGUOUS: u32 = 8192u32;
pub const FM_INFO_OPTICALLY_FIXED_PITCH: u32 = 4194304u32;
pub const FM_INFO_RETURNS_BITMAPS: u32 = 131072u32;
pub const FM_INFO_RETURNS_OUTLINES: u32 = 32768u32;
pub const FM_INFO_RETURNS_STROKES: u32 = 65536u32;
pub const FM_INFO_RIGHT_HANDED: u32 = 524288u32;
pub const FM_INFO_TECH_BITMAP: u32 = 2u32;
pub const FM_INFO_TECH_CFF: u32 = 67108864u32;
pub const FM_INFO_TECH_MM: u32 = 16384u32;
pub const FM_INFO_TECH_OUTLINE_NOT_TRUETYPE: u32 = 8u32;
pub const FM_INFO_TECH_STROKE: u32 = 4u32;
pub const FM_INFO_TECH_TRUETYPE: u32 = 1u32;
pub const FM_INFO_TECH_TYPE1: u32 = 2147483648u32;
pub const FM_NO_EMBEDDING: u32 = 2u32;
pub const FM_PANOSE_CULTURE_LATIN: u32 = 0u32;
pub const FM_READONLY_EMBED: u32 = 4u32;
pub const FM_SEL_BOLD: u32 = 32u32;
pub const FM_SEL_ITALIC: u32 = 1u32;
pub const FM_SEL_NEGATIVE: u32 = 4u32;
pub const FM_SEL_OUTLINED: u32 = 8u32;
pub const FM_SEL_REGULAR: u32 = 64u32;
pub const FM_SEL_STRIKEOUT: u32 = 16u32;
pub const FM_SEL_UNDERSCORE: u32 = 2u32;
pub const FM_TYPE_LICENSED: u32 = 2u32;
pub const FM_VERSION_NUMBER: u32 = 0u32;
pub const FOREST_USER_RID_MAX: i32 = 499i32;
pub const FO_ATTR_MODE_ROTATE: u32 = 1u32;
pub const FO_CFF: u32 = 1048576u32;
pub const FO_CLEARTYPENATURAL_X: u32 = 1073741824u32;
pub const FO_CLEARTYPE_X: u32 = 268435456u32;
pub const FO_CLEARTYPE_Y: u32 = 536870912u32;
pub const FO_DBCS_FONT: u32 = 16777216u32;
pub const FO_DEVICE_FONT: i32 = 1i32;
pub const FO_EM_HEIGHT: u32 = 32768u32;
pub const FO_GLYPHBITS: i32 = 1i32;
pub const FO_GRAY16: u32 = 65536u32;
pub const FO_HGLYPHS: i32 = 0i32;
pub const FO_MULTIPLEMASTER: u32 = 4194304u32;
pub const FO_NOCLEARTYPE: u32 = 33554432u32;
pub const FO_NOGRAY16: u32 = 131072u32;
pub const FO_NOHINTS: u32 = 262144u32;
pub const FO_NO_CHOICE: u32 = 524288u32;
pub const FO_OUTLINE_CAPABLE: i32 = 2i32;
pub const FO_PATHOBJ: i32 = 2i32;
pub const FO_POSTSCRIPT: u32 = 2097152u32;
pub const FO_SIM_BOLD: u32 = 8192u32;
pub const FO_SIM_ITALIC: u32 = 16384u32;
pub const FO_VERT_FACE: u32 = 8388608u32;
pub const FP_ALTERNATEMODE: i32 = 1i32;
pub const FP_WINDINGMODE: i32 = 2i32;
pub const FRAME_FPO: u32 = 0u32;
pub const FRAME_NONFPO: u32 = 3u32;
pub const FRAME_TRAP: u32 = 1u32;
pub const FRAME_TSS: u32 = 2u32;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type FREEOBJPROC = unsafe extern "system" fn(
    pdriverobj: *mut ::std::mem::ManuallyDrop<super::super::UI::DisplayDevices::DRIVEROBJ>,
) -> super::super::Foundation::BOOL;
pub const FSCTL_ADD_OVERLAY: u32 = 623408u32;
pub const FSCTL_ADVANCE_FILE_ID: u32 = 590532u32;
pub const FSCTL_ALLOW_EXTENDED_DASD_IO: u32 = 589955u32;
pub const FSCTL_CLEAN_VOLUME_METADATA: u32 = 590716u32;
pub const FSCTL_CORRUPTION_HANDLING: u32 = 590432u32;
pub const FSCTL_CREATE_OR_GET_OBJECT_ID: u32 = 590016u32;
pub const FSCTL_CREATE_USN_JOURNAL: u32 = 590055u32;
pub const FSCTL_CSC_INTERNAL: u32 = 590255u32;
pub const FSCTL_CSV_CONTROL: u32 = 590548u32;
pub const FSCTL_CSV_GET_VOLUME_NAME_FOR_VOLUME_MOUNT_POINT: u32 = 590420u32;
pub const FSCTL_CSV_GET_VOLUME_PATH_NAME: u32 = 590416u32;
pub const FSCTL_CSV_GET_VOLUME_PATH_NAMES_FOR_VOLUME_NAME: u32 = 590424u32;
pub const FSCTL_CSV_H_BREAKING_SYNC_TUNNEL_REQUEST: u32 = 590564u32;
pub const FSCTL_CSV_INTERNAL: u32 = 590444u32;
pub const FSCTL_CSV_MGMT_LOCK: u32 = 590524u32;
pub const FSCTL_CSV_QUERY_DOWN_LEVEL_FILE_SYSTEM_CHARACTERISTICS: u32 = 590528u32;
pub const FSCTL_CSV_QUERY_VETO_FILE_DIRECT_IO: u32 = 590540u32;
pub const FSCTL_CSV_SYNC_TUNNEL_REQUEST: u32 = 590536u32;
pub const FSCTL_CSV_TUNNEL_REQUEST: u32 = 590404u32;
pub const FSCTL_DELETE_CORRUPTED_REFS_CONTAINER: u32 = 590836u32;
pub const FSCTL_DELETE_EXTERNAL_BACKING: u32 = 590612u32;
pub const FSCTL_DELETE_OBJECT_ID: u32 = 589984u32;
pub const FSCTL_DELETE_REPARSE_POINT: u32 = 589996u32;
pub const FSCTL_DELETE_USN_JOURNAL: u32 = 590072u32;
pub const FSCTL_DFSR_SET_GHOST_HANDLE_STATE: u32 = 590264u32;
pub const FSCTL_DISABLE_LOCAL_BUFFERING: u32 = 590520u32;
pub const FSCTL_DISMOUNT_VOLUME: u32 = 589856u32;
pub const FSCTL_DUPLICATE_EXTENTS_TO_FILE: u32 = 623428u32;
pub const FSCTL_DUPLICATE_EXTENTS_TO_FILE_EX: u32 = 623592u32;
pub const FSCTL_ENABLE_PER_IO_FLAGS: u32 = 590892u32;
pub const FSCTL_ENABLE_UPGRADE: u32 = 622800u32;
pub const FSCTL_ENCRYPTION_FSCTL_IO: u32 = 590043u32;
pub const FSCTL_ENCRYPTION_KEY_CONTROL: u32 = 590852u32;
pub const FSCTL_ENUM_EXTERNAL_BACKING: u32 = 590616u32;
pub const FSCTL_ENUM_OVERLAY: u32 = 590623u32;
pub const FSCTL_ENUM_USN_DATA: u32 = 590003u32;
pub const FSCTL_EXTEND_VOLUME: u32 = 590064u32;
pub const FSCTL_FILESYSTEM_GET_STATISTICS: u32 = 589920u32;
pub const FSCTL_FILESYSTEM_GET_STATISTICS_EX: u32 = 590732u32;
pub const FSCTL_FILE_LEVEL_TRIM: u32 = 623112u32;
pub const FSCTL_FILE_PREFETCH: u32 = 590112u32;
pub const FSCTL_FILE_TYPE_NOTIFICATION: u32 = 590340u32;
pub const FSCTL_FIND_FILES_BY_SID: u32 = 589967u32;
pub const FSCTL_GET_BOOT_AREA_INFO: u32 = 590384u32;
pub const FSCTL_GET_COMPRESSION: u32 = 589884u32;
pub const FSCTL_GET_EXTERNAL_BACKING: u32 = 590608u32;
pub const FSCTL_GET_FILTER_FILE_IDENTIFIER: u32 = 590788u32;
pub const FSCTL_GET_INTEGRITY_INFORMATION: u32 = 590460u32;
pub const FSCTL_GET_NTFS_FILE_RECORD: u32 = 589928u32;
pub const FSCTL_GET_NTFS_VOLUME_DATA: u32 = 589924u32;
pub const FSCTL_GET_OBJECT_ID: u32 = 589980u32;
pub const FSCTL_GET_REFS_VOLUME_DATA: u32 = 590552u32;
pub const FSCTL_GET_REPAIR: u32 = 590236u32;
pub const FSCTL_GET_REPARSE_POINT: u32 = 589992u32;
pub const FSCTL_GET_RETRIEVAL_POINTERS: u32 = 589939u32;
pub const FSCTL_GET_RETRIEVAL_POINTERS_AND_REFCOUNT: u32 = 590803u32;
pub const FSCTL_GET_RETRIEVAL_POINTER_BASE: u32 = 590388u32;
pub const FSCTL_GET_RETRIEVAL_POINTER_COUNT: u32 = 590891u32;
pub const FSCTL_GET_VOLUME_BITMAP: u32 = 589935u32;
pub const FSCTL_GET_WOF_VERSION: u32 = 590696u32;
pub const FSCTL_GHOST_FILE_EXTENTS: u32 = 623532u32;
pub const FSCTL_HCS_ASYNC_TUNNEL_REQUEST: u32 = 590704u32;
pub const FSCTL_HCS_SYNC_NO_WRITE_TUNNEL_REQUEST: u32 = 590776u32;
pub const FSCTL_HCS_SYNC_TUNNEL_REQUEST: u32 = 590700u32;
pub const FSCTL_INITIATE_FILE_METADATA_OPTIMIZATION: u32 = 590684u32;
pub const FSCTL_INITIATE_REPAIR: u32 = 590248u32;
pub const FSCTL_INTEGRITY_FLAG_CHECKSUM_ENFORCEMENT_OFF: u32 = 1u32;
pub const FSCTL_INVALIDATE_VOLUMES: u32 = 589908u32;
pub const FSCTL_IS_CSV_FILE: u32 = 590408u32;
pub const FSCTL_IS_FILE_ON_CSV_VOLUME: u32 = 590428u32;
pub const FSCTL_IS_PATHNAME_VALID: u32 = 589868u32;
pub const FSCTL_IS_VOLUME_DIRTY: u32 = 589944u32;
pub const FSCTL_IS_VOLUME_MOUNTED: u32 = 589864u32;
pub const FSCTL_IS_VOLUME_OWNED_BYCSVFS: u32 = 590456u32;
pub const FSCTL_LOCK_VOLUME: u32 = 589848u32;
pub const FSCTL_LOOKUP_STREAM_FROM_CLUSTER: u32 = 590332u32;
pub const FSCTL_MAKE_MEDIA_COMPATIBLE: u32 = 622896u32;
pub const FSCTL_MANAGE_BYPASS_IO: u32 = 590920u32;
pub const FSCTL_MARK_AS_SYSTEM_HIVE: u32 = 589903u32;
pub const FSCTL_MARK_HANDLE: u32 = 590076u32;
pub const FSCTL_MARK_VOLUME_DIRTY: u32 = 589872u32;
pub const FSCTL_MOVE_FILE: u32 = 589940u32;
pub const FSCTL_NOTIFY_DATA_CHANGE: u32 = 590844u32;
pub const FSCTL_NOTIFY_STORAGE_SPACE_ALLOCATION: u32 = 590748u32;
pub const FSCTL_OFFLOAD_READ: u32 = 606820u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FSCTL_OFFLOAD_READ_INPUT {
    pub Size: u32,
    pub Flags: u32,
    pub TokenTimeToLive: u32,
    pub Reserved: u32,
    pub FileOffset: u64,
    pub CopyLength: u64,
}
impl FSCTL_OFFLOAD_READ_INPUT {}
impl ::std::default::Default for FSCTL_OFFLOAD_READ_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FSCTL_OFFLOAD_READ_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FSCTL_OFFLOAD_READ_INPUT")
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("TokenTimeToLive", &self.TokenTimeToLive)
            .field("Reserved", &self.Reserved)
            .field("FileOffset", &self.FileOffset)
            .field("CopyLength", &self.CopyLength)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FSCTL_OFFLOAD_READ_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.Flags == other.Flags
            && self.TokenTimeToLive == other.TokenTimeToLive
            && self.Reserved == other.Reserved
            && self.FileOffset == other.FileOffset
            && self.CopyLength == other.CopyLength
    }
}
impl ::std::cmp::Eq for FSCTL_OFFLOAD_READ_INPUT {}
unsafe impl ::windows::runtime::Abi for FSCTL_OFFLOAD_READ_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FSCTL_OFFLOAD_READ_OUTPUT {
    pub Size: u32,
    pub Flags: u32,
    pub TransferLength: u64,
    pub Token: [u8; 512],
}
impl FSCTL_OFFLOAD_READ_OUTPUT {}
impl ::std::default::Default for FSCTL_OFFLOAD_READ_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FSCTL_OFFLOAD_READ_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FSCTL_OFFLOAD_READ_OUTPUT")
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("TransferLength", &self.TransferLength)
            .field("Token", &self.Token)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FSCTL_OFFLOAD_READ_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.Flags == other.Flags
            && self.TransferLength == other.TransferLength
            && self.Token == other.Token
    }
}
impl ::std::cmp::Eq for FSCTL_OFFLOAD_READ_OUTPUT {}
unsafe impl ::windows::runtime::Abi for FSCTL_OFFLOAD_READ_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const FSCTL_OFFLOAD_WRITE: u32 = 623208u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FSCTL_OFFLOAD_WRITE_INPUT {
    pub Size: u32,
    pub Flags: u32,
    pub FileOffset: u64,
    pub CopyLength: u64,
    pub TransferOffset: u64,
    pub Token: [u8; 512],
}
impl FSCTL_OFFLOAD_WRITE_INPUT {}
impl ::std::default::Default for FSCTL_OFFLOAD_WRITE_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FSCTL_OFFLOAD_WRITE_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FSCTL_OFFLOAD_WRITE_INPUT")
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("FileOffset", &self.FileOffset)
            .field("CopyLength", &self.CopyLength)
            .field("TransferOffset", &self.TransferOffset)
            .field("Token", &self.Token)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FSCTL_OFFLOAD_WRITE_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.Flags == other.Flags
            && self.FileOffset == other.FileOffset
            && self.CopyLength == other.CopyLength
            && self.TransferOffset == other.TransferOffset
            && self.Token == other.Token
    }
}
impl ::std::cmp::Eq for FSCTL_OFFLOAD_WRITE_INPUT {}
unsafe impl ::windows::runtime::Abi for FSCTL_OFFLOAD_WRITE_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FSCTL_OFFLOAD_WRITE_OUTPUT {
    pub Size: u32,
    pub Flags: u32,
    pub LengthWritten: u64,
}
impl FSCTL_OFFLOAD_WRITE_OUTPUT {}
impl ::std::default::Default for FSCTL_OFFLOAD_WRITE_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FSCTL_OFFLOAD_WRITE_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FSCTL_OFFLOAD_WRITE_OUTPUT")
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("LengthWritten", &self.LengthWritten)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FSCTL_OFFLOAD_WRITE_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.Flags == other.Flags
            && self.LengthWritten == other.LengthWritten
    }
}
impl ::std::cmp::Eq for FSCTL_OFFLOAD_WRITE_OUTPUT {}
unsafe impl ::windows::runtime::Abi for FSCTL_OFFLOAD_WRITE_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const FSCTL_OPBATCH_ACK_CLOSE_PENDING: u32 = 589840u32;
pub const FSCTL_OPLOCK_BREAK_ACKNOWLEDGE: u32 = 589836u32;
pub const FSCTL_OPLOCK_BREAK_ACK_NO_2: u32 = 589904u32;
pub const FSCTL_OPLOCK_BREAK_NOTIFY: u32 = 589844u32;
pub const FSCTL_QUERY_ALLOCATED_RANGES: u32 = 606415u32;
pub const FSCTL_QUERY_ASYNC_DUPLICATE_EXTENTS_STATUS: u32 = 590896u32;
pub const FSCTL_QUERY_BAD_RANGES: u32 = 590828u32;
pub const FSCTL_QUERY_DEPENDENT_VOLUME: u32 = 590320u32;
pub const FSCTL_QUERY_DIRECT_ACCESS_EXTENTS: u32 = 590747u32;
pub const FSCTL_QUERY_DIRECT_IMAGE_ORIGINAL_BASE: u32 = 590756u32;
pub const FSCTL_QUERY_EXTENT_READ_CACHE_INFO: u32 = 590711u32;
pub const FSCTL_QUERY_FAT_BPB: u32 = 589912u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FSCTL_QUERY_FAT_BPB_BUFFER {
    pub First0x24BytesOfBootSector: [u8; 36],
}
impl FSCTL_QUERY_FAT_BPB_BUFFER {}
impl ::std::default::Default for FSCTL_QUERY_FAT_BPB_BUFFER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FSCTL_QUERY_FAT_BPB_BUFFER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FSCTL_QUERY_FAT_BPB_BUFFER")
            .field(
                "First0x24BytesOfBootSector",
                &self.First0x24BytesOfBootSector,
            )
            .finish()
    }
}
impl ::std::cmp::PartialEq for FSCTL_QUERY_FAT_BPB_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.First0x24BytesOfBootSector == other.First0x24BytesOfBootSector
    }
}
impl ::std::cmp::Eq for FSCTL_QUERY_FAT_BPB_BUFFER {}
unsafe impl ::windows::runtime::Abi for FSCTL_QUERY_FAT_BPB_BUFFER {
    type Abi = Self;
    type DefaultType = Self;
}
pub const FSCTL_QUERY_FILE_LAYOUT: u32 = 590455u32;
pub const FSCTL_QUERY_FILE_METADATA_OPTIMIZATION: u32 = 590688u32;
pub const FSCTL_QUERY_FILE_REGIONS: u32 = 590468u32;
pub const FSCTL_QUERY_FILE_SYSTEM_RECOGNITION: u32 = 590412u32;
pub const FSCTL_QUERY_GHOSTED_FILE_EXTENTS: u32 = 590768u32;
pub const FSCTL_QUERY_ON_DISK_VOLUME_INFO: u32 = 590140u32;
pub const FSCTL_QUERY_PAGEFILE_ENCRYPTION: u32 = 590312u32;
pub const FSCTL_QUERY_PERSISTENT_VOLUME_STATE: u32 = 590396u32;
pub const FSCTL_QUERY_REFS_SMR_VOLUME_INFO: u32 = 590812u32;
pub const FSCTL_QUERY_REFS_VOLUME_COUNTER_INFO: u32 = 590715u32;
pub const FSCTL_QUERY_REGION_INFO: u32 = 590576u32;
pub const FSCTL_QUERY_RETRIEVAL_POINTERS: u32 = 589883u32;
pub const FSCTL_QUERY_SHARED_VIRTUAL_DISK_SUPPORT: u32 = 590592u32;
pub const FSCTL_QUERY_SPARING_INFO: u32 = 590136u32;
pub const FSCTL_QUERY_STORAGE_CLASSES: u32 = 590572u32;
pub const FSCTL_QUERY_USN_JOURNAL: u32 = 590068u32;
pub const FSCTL_QUERY_VOLUME_CONTAINER_STATE: u32 = 590736u32;
pub const FSCTL_QUERY_VOLUME_NUMA_INFO: u32 = 590804u32;
pub const FSCTL_READ_FILE_USN_DATA: u32 = 590059u32;
pub const FSCTL_READ_FROM_PLEX: u32 = 606494u32;
pub const FSCTL_READ_RAW_ENCRYPTED: u32 = 590051u32;
pub const FSCTL_READ_UNPRIVILEGED_USN_JOURNAL: u32 = 590763u32;
pub const FSCTL_READ_USN_JOURNAL: u32 = 590011u32;
pub const FSCTL_REARRANGE_FILE: u32 = 640032u32;
pub const FSCTL_RECALL_FILE: u32 = 590103u32;
pub const FSCTL_REFS_DEALLOCATE_RANGES: u32 = 590808u32;
pub const FSCTL_REFS_STREAM_SNAPSHOT_MANAGEMENT: u32 = 590912u32;
pub const FSCTL_REMOVE_OVERLAY: u32 = 623412u32;
pub const FSCTL_REPAIR_COPIES: u32 = 639668u32;
pub const FSCTL_REQUEST_BATCH_OPLOCK: u32 = 589832u32;
pub const FSCTL_REQUEST_FILTER_OPLOCK: u32 = 589916u32;
pub const FSCTL_REQUEST_OPLOCK: u32 = 590400u32;
pub const FSCTL_REQUEST_OPLOCK_LEVEL_1: u32 = 589824u32;
pub const FSCTL_REQUEST_OPLOCK_LEVEL_2: u32 = 589828u32;
pub const FSCTL_RESET_VOLUME_ALLOCATION_HINTS: u32 = 590316u32;
pub const FSCTL_RKF_INTERNAL: u32 = 590511u32;
pub const FSCTL_SCRUB_DATA: u32 = 590512u32;
pub const FSCTL_SCRUB_UNDISCOVERABLE_ID: u32 = 590840u32;
pub const FSCTL_SD_GLOBAL_CHANGE: u32 = 590324u32;
pub const FSCTL_SECURITY_ID_CHECK: u32 = 606391u32;
pub const FSCTL_SET_BOOTLOADER_ACCESSED: u32 = 589903u32;
pub const FSCTL_SET_COMPRESSION: u32 = 639040u32;
pub const FSCTL_SET_DAX_ALLOC_ALIGNMENT_HINT: u32 = 590832u32;
pub const FSCTL_SET_DEFECT_MANAGEMENT: u32 = 622900u32;
pub const FSCTL_SET_ENCRYPTION: u32 = 590039u32;
pub const FSCTL_SET_EXTERNAL_BACKING: u32 = 590604u32;
pub const FSCTL_SET_INTEGRITY_INFORMATION: u32 = 639616u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {
    pub EnableIntegrity: u8,
    pub KeepIntegrityStateUnchanged: u8,
    pub Reserved: u16,
    pub Flags: u32,
    pub Version: u8,
    pub Reserved2: [u8; 7],
}
impl FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {}
impl ::std::default::Default for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX")
            .field("EnableIntegrity", &self.EnableIntegrity)
            .field(
                "KeepIntegrityStateUnchanged",
                &self.KeepIntegrityStateUnchanged,
            )
            .field("Reserved", &self.Reserved)
            .field("Flags", &self.Flags)
            .field("Version", &self.Version)
            .field("Reserved2", &self.Reserved2)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {
    fn eq(&self, other: &Self) -> bool {
        self.EnableIntegrity == other.EnableIntegrity
            && self.KeepIntegrityStateUnchanged == other.KeepIntegrityStateUnchanged
            && self.Reserved == other.Reserved
            && self.Flags == other.Flags
            && self.Version == other.Version
            && self.Reserved2 == other.Reserved2
    }
}
impl ::std::cmp::Eq for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {}
unsafe impl ::windows::runtime::Abi for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {
    type Abi = Self;
    type DefaultType = Self;
}
pub const FSCTL_SET_INTEGRITY_INFORMATION_EX: u32 = 590720u32;
pub const FSCTL_SET_LAYER_ROOT: u32 = 590740u32;
pub const FSCTL_SET_OBJECT_ID: u32 = 589976u32;
pub const FSCTL_SET_OBJECT_ID_EXTENDED: u32 = 590012u32;
pub const FSCTL_SET_PERSISTENT_VOLUME_STATE: u32 = 590392u32;
pub const FSCTL_SET_PURGE_FAILURE_MODE: u32 = 590448u32;
pub const FSCTL_SET_REFS_FILE_STRICTLY_SEQUENTIAL: u32 = 590820u32;
pub const FSCTL_SET_REFS_SMR_VOLUME_GC_PARAMETERS: u32 = 590816u32;
pub const FSCTL_SET_REPAIR: u32 = 590232u32;
pub const FSCTL_SET_REPARSE_POINT: u32 = 589988u32;
pub const FSCTL_SET_REPARSE_POINT_EX: u32 = 590860u32;
pub const FSCTL_SET_SHORT_NAME_BEHAVIOR: u32 = 590260u32;
pub const FSCTL_SET_SPARSE: u32 = 590020u32;
pub const FSCTL_SET_VOLUME_COMPRESSION_STATE: u32 = 590144u32;
pub const FSCTL_SET_ZERO_DATA: u32 = 622792u32;
pub const FSCTL_SET_ZERO_ON_DEALLOCATION: u32 = 590228u32;
pub const FSCTL_SHRINK_VOLUME: u32 = 590256u32;
pub const FSCTL_SHUFFLE_FILE: u32 = 639808u32;
pub const FSCTL_SIS_COPYFILE: u32 = 590080u32;
pub const FSCTL_SIS_LINK_FILES: u32 = 639236u32;
pub const FSCTL_SMB_SHARE_FLUSH_AND_PURGE: u32 = 590908u32;
pub const FSCTL_SPARSE_OVERALLOCATE: u32 = 590668u32;
pub const FSCTL_SSDI_STORAGE_REQUEST: u32 = 590752u32;
pub const FSCTL_START_VIRTUALIZATION_INSTANCE: u32 = 590784u32;
pub const FSCTL_START_VIRTUALIZATION_INSTANCE_EX: u32 = 590848u32;
pub const FSCTL_STORAGE_QOS_CONTROL: u32 = 590672u32;
pub const FSCTL_STREAMS_ASSOCIATE_ID: u32 = 590792u32;
pub const FSCTL_STREAMS_QUERY_ID: u32 = 590796u32;
pub const FSCTL_STREAMS_QUERY_PARAMETERS: u32 = 590788u32;
pub const FSCTL_SUSPEND_OVERLAY: u32 = 590724u32;
pub const FSCTL_SVHDX_ASYNC_TUNNEL_REQUEST: u32 = 590692u32;
pub const FSCTL_SVHDX_SET_INITIATOR_INFORMATION: u32 = 590600u32;
pub const FSCTL_SVHDX_SYNC_TUNNEL_REQUEST: u32 = 590596u32;
pub const FSCTL_TXFS_CREATE_MINIVERSION: u32 = 622972u32;
pub const FSCTL_TXFS_CREATE_SECONDARY_RM: u32 = 622952u32;
pub const FSCTL_TXFS_GET_METADATA_INFO: u32 = 606572u32;
pub const FSCTL_TXFS_GET_TRANSACTED_VERSION: u32 = 606576u32;
pub const FSCTL_TXFS_LIST_TRANSACTIONS: u32 = 606692u32;
pub const FSCTL_TXFS_LIST_TRANSACTION_LOCKED_FILES: u32 = 606688u32;
pub const FSCTL_TXFS_MODIFY_RM: u32 = 622916u32;
pub const FSCTL_TXFS_QUERY_RM_INFORMATION: u32 = 606536u32;
pub const FSCTL_TXFS_READ_BACKUP_INFORMATION: u32 = 606560u32;
pub const FSCTL_TXFS_READ_BACKUP_INFORMATION2: u32 = 590328u32;
pub const FSCTL_TXFS_ROLLFORWARD_REDO: u32 = 622928u32;
pub const FSCTL_TXFS_ROLLFORWARD_UNDO: u32 = 622932u32;
pub const FSCTL_TXFS_SAVEPOINT_INFORMATION: u32 = 622968u32;
pub const FSCTL_TXFS_SHUTDOWN_RM: u32 = 622940u32;
pub const FSCTL_TXFS_START_RM: u32 = 622936u32;
pub const FSCTL_TXFS_TRANSACTION_ACTIVE: u32 = 606604u32;
pub const FSCTL_TXFS_WRITE_BACKUP_INFORMATION: u32 = 622948u32;
pub const FSCTL_TXFS_WRITE_BACKUP_INFORMATION2: u32 = 590336u32;
pub const FSCTL_UNLOCK_VOLUME: u32 = 589852u32;
pub const FSCTL_UNMAP_SPACE: u32 = 590772u32;
pub const FSCTL_UPDATE_OVERLAY: u32 = 623416u32;
pub const FSCTL_USN_TRACK_MODIFIED_RANGES: u32 = 590580u32;
pub const FSCTL_VIRTUAL_STORAGE_PASSTHROUGH: u32 = 590884u32;
pub const FSCTL_VIRTUAL_STORAGE_QUERY_PROPERTY: u32 = 590728u32;
pub const FSCTL_VIRTUAL_STORAGE_SET_BEHAVIOR: u32 = 590856u32;
pub const FSCTL_WAIT_FOR_REPAIR: u32 = 590240u32;
pub const FSCTL_WRITE_RAW_ENCRYPTED: u32 = 590047u32;
pub const FSCTL_WRITE_USN_CLOSE_RECORD: u32 = 590063u32;
pub const FSCTL_WRITE_USN_REASON: u32 = 590544u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct FS_BPIO_INFLAGS(pub i32);
pub const FSBPIO_INFL_None: FS_BPIO_INFLAGS = FS_BPIO_INFLAGS(0i32);
pub const FSBPIO_INFL_SKIP_STORAGE_STACK_QUERY: FS_BPIO_INFLAGS = FS_BPIO_INFLAGS(1i32);
impl ::std::convert::From<i32> for FS_BPIO_INFLAGS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for FS_BPIO_INFLAGS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FS_BPIO_INFO {
    pub ActiveBypassIoCount: u32,
    pub StorageDriverNameLen: u16,
    pub StorageDriverName: [u16; 32],
}
impl FS_BPIO_INFO {}
impl ::std::default::Default for FS_BPIO_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FS_BPIO_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FS_BPIO_INFO")
            .field("ActiveBypassIoCount", &self.ActiveBypassIoCount)
            .field("StorageDriverNameLen", &self.StorageDriverNameLen)
            .field("StorageDriverName", &self.StorageDriverName)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FS_BPIO_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.ActiveBypassIoCount == other.ActiveBypassIoCount
            && self.StorageDriverNameLen == other.StorageDriverNameLen
            && self.StorageDriverName == other.StorageDriverName
    }
}
impl ::std::cmp::Eq for FS_BPIO_INFO {}
unsafe impl ::windows::runtime::Abi for FS_BPIO_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FS_BPIO_INPUT {
    pub Operation: FS_BPIO_OPERATIONS,
    pub InFlags: FS_BPIO_INFLAGS,
    pub Reserved1: u64,
    pub Reserved2: u64,
}
impl FS_BPIO_INPUT {}
impl ::std::default::Default for FS_BPIO_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FS_BPIO_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FS_BPIO_INPUT")
            .field("Operation", &self.Operation)
            .field("InFlags", &self.InFlags)
            .field("Reserved1", &self.Reserved1)
            .field("Reserved2", &self.Reserved2)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FS_BPIO_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Operation == other.Operation
            && self.InFlags == other.InFlags
            && self.Reserved1 == other.Reserved1
            && self.Reserved2 == other.Reserved2
    }
}
impl ::std::cmp::Eq for FS_BPIO_INPUT {}
unsafe impl ::windows::runtime::Abi for FS_BPIO_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct FS_BPIO_OPERATIONS(pub i32);
pub const FS_BPIO_OP_ENABLE: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(1i32);
pub const FS_BPIO_OP_DISABLE: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(2i32);
pub const FS_BPIO_OP_QUERY: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(3i32);
pub const FS_BPIO_OP_VOLUME_STACK_PAUSE: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(4i32);
pub const FS_BPIO_OP_VOLUME_STACK_RESUME: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(5i32);
pub const FS_BPIO_OP_STREAM_PAUSE: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(6i32);
pub const FS_BPIO_OP_STREAM_RESUME: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(7i32);
pub const FS_BPIO_OP_GET_INFO: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(8i32);
pub const FS_BPIO_OP_MAX_OPERATION: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(9i32);
impl ::std::convert::From<i32> for FS_BPIO_OPERATIONS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for FS_BPIO_OPERATIONS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct FS_BPIO_OUTFLAGS(pub i32);
pub const FSBPIO_OUTFL_None: FS_BPIO_OUTFLAGS = FS_BPIO_OUTFLAGS(0i32);
pub const FSBPIO_OUTFL_VOLUME_STACK_BYPASS_PAUSED: FS_BPIO_OUTFLAGS = FS_BPIO_OUTFLAGS(1i32);
pub const FSBPIO_OUTFL_STREAM_BYPASS_PAUSED: FS_BPIO_OUTFLAGS = FS_BPIO_OUTFLAGS(2i32);
pub const FSBPIO_OUTFL_FILTER_ATTACH_BLOCKED: FS_BPIO_OUTFLAGS = FS_BPIO_OUTFLAGS(4i32);
pub const FSBPIO_OUTFL_COMPATIBLE_STORAGE_DRIVER: FS_BPIO_OUTFLAGS = FS_BPIO_OUTFLAGS(8i32);
impl ::std::convert::From<i32> for FS_BPIO_OUTFLAGS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for FS_BPIO_OUTFLAGS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FS_BPIO_OUTPUT {
    pub Operation: FS_BPIO_OPERATIONS,
    pub OutFlags: FS_BPIO_OUTFLAGS,
    pub Reserved1: u64,
    pub Reserved2: u64,
    pub Anonymous: FS_BPIO_OUTPUT_0,
}
impl FS_BPIO_OUTPUT {}
impl ::std::default::Default for FS_BPIO_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for FS_BPIO_OUTPUT {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for FS_BPIO_OUTPUT {}
unsafe impl ::windows::runtime::Abi for FS_BPIO_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union FS_BPIO_OUTPUT_0 {
    pub Enable: FS_BPIO_RESULTS,
    pub Query: FS_BPIO_RESULTS,
    pub VolumeStackResume: FS_BPIO_RESULTS,
    pub StreamResume: FS_BPIO_RESULTS,
    pub GetInfo: FS_BPIO_INFO,
}
impl FS_BPIO_OUTPUT_0 {}
impl ::std::default::Default for FS_BPIO_OUTPUT_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for FS_BPIO_OUTPUT_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for FS_BPIO_OUTPUT_0 {}
unsafe impl ::windows::runtime::Abi for FS_BPIO_OUTPUT_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct FS_BPIO_RESULTS {
    pub OpStatus: u32,
    pub FailingDriverNameLen: u16,
    pub FailingDriverName: [u16; 32],
    pub FailureReasonLen: u16,
    pub FailureReason: [u16; 128],
}
impl FS_BPIO_RESULTS {}
impl ::std::default::Default for FS_BPIO_RESULTS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for FS_BPIO_RESULTS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("FS_BPIO_RESULTS")
            .field("OpStatus", &self.OpStatus)
            .field("FailingDriverNameLen", &self.FailingDriverNameLen)
            .field("FailingDriverName", &self.FailingDriverName)
            .field("FailureReasonLen", &self.FailureReasonLen)
            .field("FailureReason", &self.FailureReason)
            .finish()
    }
}
impl ::std::cmp::PartialEq for FS_BPIO_RESULTS {
    fn eq(&self, other: &Self) -> bool {
        self.OpStatus == other.OpStatus
            && self.FailingDriverNameLen == other.FailingDriverNameLen
            && self.FailingDriverName == other.FailingDriverName
            && self.FailureReasonLen == other.FailureReasonLen
            && self.FailureReason == other.FailureReason
    }
}
impl ::std::cmp::Eq for FS_BPIO_RESULTS {}
unsafe impl ::windows::runtime::Abi for FS_BPIO_RESULTS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const FW_ISSUEID_NO_ISSUE: u32 = 0u32;
pub const FW_ISSUEID_UNKNOWN: u32 = 4294967295u32;
pub const GCAPS2_ACC_DRIVER: u32 = 32768u32;
pub const GCAPS2_ALPHACURSOR: u32 = 32u32;
pub const GCAPS2_BITMAPEXREUSE: u32 = 65536u32;
pub const GCAPS2_CHANGEGAMMARAMP: u32 = 16u32;
pub const GCAPS2_CLEARTYPE: u32 = 16384u32;
pub const GCAPS2_EXCLUDELAYERED: u32 = 2048u32;
pub const GCAPS2_ICD_MULTIMON: u32 = 256u32;
pub const GCAPS2_INCLUDEAPIBITMAPS: u32 = 4096u32;
pub const GCAPS2_JPEGSRC: u32 = 1u32;
pub const GCAPS2_MOUSETRAILS: u32 = 512u32;
pub const GCAPS2_PNGSRC: u32 = 8u32;
pub const GCAPS2_REMOTEDRIVER: u32 = 1024u32;
pub const GCAPS2_RESERVED1: u32 = 1024u32;
pub const GCAPS2_SHOWHIDDENPOINTER: u32 = 8192u32;
pub const GCAPS2_SYNCFLUSH: u32 = 64u32;
pub const GCAPS2_SYNCTIMER: u32 = 128u32;
pub const GCAPS2_xxxx: u32 = 2u32;
pub const GCAPS_ALTERNATEFILL: u32 = 4u32;
pub const GCAPS_ARBRUSHOPAQUE: u32 = 32768u32;
pub const GCAPS_ARBRUSHTEXT: u32 = 268435456u32;
pub const GCAPS_ASYNCCHANGE: u32 = 2048u32;
pub const GCAPS_ASYNCMOVE: u32 = 4096u32;
pub const GCAPS_BEZIERS: u32 = 1u32;
pub const GCAPS_CMYKCOLOR: u32 = 67108864u32;
pub const GCAPS_COLOR_DITHER: u32 = 32u32;
pub const GCAPS_DIRECTDRAW: u32 = 16384u32;
pub const GCAPS_DITHERONREALIZE: u32 = 2097152u32;
pub const GCAPS_DONTJOURNAL: u32 = 8192u32;
pub const GCAPS_FONT_RASTERIZER: u32 = 1073741824u32;
pub const GCAPS_FORCEDITHER: u32 = 8388608u32;
pub const GCAPS_GEOMETRICWIDE: u32 = 2u32;
pub const GCAPS_GRAY16: u32 = 16777216u32;
pub const GCAPS_HALFTONE: u32 = 16u32;
pub const GCAPS_HIGHRESTEXT: u32 = 262144u32;
pub const GCAPS_HORIZSTRIKE: u32 = 64u32;
pub const GCAPS_ICM: u32 = 33554432u32;
pub const GCAPS_LAYERED: u32 = 134217728u32;
pub const GCAPS_MONO_DITHER: u32 = 1024u32;
pub const GCAPS_NO64BITMEMACCESS: u32 = 4194304u32;
pub const GCAPS_NUP: u32 = 2147483648u32;
pub const GCAPS_OPAQUERECT: u32 = 256u32;
pub const GCAPS_PALMANAGED: u32 = 524288u32;
pub const GCAPS_PANNING: u32 = 65536u32;
pub const GCAPS_SCREENPRECISION: u32 = 536870912u32;
pub const GCAPS_VECTORFONT: u32 = 512u32;
pub const GCAPS_VERTSTRIKE: u32 = 128u32;
pub const GCAPS_WINDINGFILL: u32 = 8u32;
pub const GDI_DRIVER_VERSION: u32 = 16384u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Com")]
pub struct GDI_NONREMOTE {
    pub fContext: i32,
    pub u: GDI_NONREMOTE_0,
}
#[cfg(feature = "Win32_System_Com")]
impl GDI_NONREMOTE {}
#[cfg(feature = "Win32_System_Com")]
impl ::std::default::Default for GDI_NONREMOTE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::PartialEq for GDI_NONREMOTE {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::Eq for GDI_NONREMOTE {}
#[cfg(feature = "Win32_System_Com")]
unsafe impl ::windows::runtime::Abi for GDI_NONREMOTE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Com")]
pub union GDI_NONREMOTE_0 {
    pub hInproc: i32,
    pub hRemote: *mut super::Com::DWORD_BLOB,
}
#[cfg(feature = "Win32_System_Com")]
impl GDI_NONREMOTE_0 {}
#[cfg(feature = "Win32_System_Com")]
impl ::std::default::Default for GDI_NONREMOTE_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::PartialEq for GDI_NONREMOTE_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::Eq for GDI_NONREMOTE_0 {}
#[cfg(feature = "Win32_System_Com")]
unsafe impl ::windows::runtime::Abi for GDI_NONREMOTE_0 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const GENERIC_ALL: u32 = 268435456u32;
pub const GENERIC_EXECUTE: u32 = 536870912u32;
pub const GENERIC_READ: u32 = 2147483648u32;
pub const GENERIC_WRITE: u32 = 1073741824u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct GESTURECONFIG_FLAGS(pub u32);
pub const GC_ALLGESTURES: GESTURECONFIG_FLAGS = GESTURECONFIG_FLAGS(1u32);
pub const GC_ZOOM: GESTURECONFIG_FLAGS = GESTURECONFIG_FLAGS(1u32);
pub const GC_PAN: GESTURECONFIG_FLAGS = GESTURECONFIG_FLAGS(1u32);
pub const GC_PAN_WITH_SINGLE_FINGER_VERTICALLY: GESTURECONFIG_FLAGS = GESTURECONFIG_FLAGS(2u32);
pub const GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY: GESTURECONFIG_FLAGS = GESTURECONFIG_FLAGS(4u32);
pub const GC_PAN_WITH_GUTTER: GESTURECONFIG_FLAGS = GESTURECONFIG_FLAGS(8u32);
pub const GC_PAN_WITH_INERTIA: GESTURECONFIG_FLAGS = GESTURECONFIG_FLAGS(16u32);
pub const GC_ROTATE: GESTURECONFIG_FLAGS = GESTURECONFIG_FLAGS(1u32);
pub const GC_TWOFINGERTAP: GESTURECONFIG_FLAGS = GESTURECONFIG_FLAGS(1u32);
pub const GC_PRESSANDTAP: GESTURECONFIG_FLAGS = GESTURECONFIG_FLAGS(1u32);
pub const GC_ROLLOVER: GESTURECONFIG_FLAGS = GESTURECONFIG_FLAGS(1u32);
impl ::std::convert::From<u32> for GESTURECONFIG_FLAGS {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for GESTURECONFIG_FLAGS {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for GESTURECONFIG_FLAGS {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for GESTURECONFIG_FLAGS {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for GESTURECONFIG_FLAGS {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for GESTURECONFIG_FLAGS {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for GESTURECONFIG_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct GETVERSIONINPARAMS {
    pub bVersion: u8,
    pub bRevision: u8,
    pub bReserved: u8,
    pub bIDEDeviceMap: u8,
    pub fCapabilities: u32,
    pub dwReserved: [u32; 4],
}
impl GETVERSIONINPARAMS {}
impl ::std::default::Default for GETVERSIONINPARAMS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for GETVERSIONINPARAMS {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for GETVERSIONINPARAMS {}
unsafe impl ::windows::runtime::Abi for GETVERSIONINPARAMS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct GET_CHANGER_PARAMETERS {
    pub Size: u32,
    pub NumberTransportElements: u16,
    pub NumberStorageElements: u16,
    pub NumberCleanerSlots: u16,
    pub NumberIEElements: u16,
    pub NumberDataTransferElements: u16,
    pub NumberOfDoors: u16,
    pub FirstSlotNumber: u16,
    pub FirstDriveNumber: u16,
    pub FirstTransportNumber: u16,
    pub FirstIEPortNumber: u16,
    pub FirstCleanerSlotAddress: u16,
    pub MagazineSize: u16,
    pub DriveCleanTimeout: u32,
    pub Features0: CHANGER_FEATURES,
    pub Features1: GET_CHANGER_PARAMETERS_FEATURES1,
    pub MoveFromTransport: u8,
    pub MoveFromSlot: u8,
    pub MoveFromIePort: u8,
    pub MoveFromDrive: u8,
    pub ExchangeFromTransport: u8,
    pub ExchangeFromSlot: u8,
    pub ExchangeFromIePort: u8,
    pub ExchangeFromDrive: u8,
    pub LockUnlockCapabilities: u8,
    pub PositionCapabilities: u8,
    pub Reserved1: [u8; 2],
    pub Reserved2: [u32; 2],
}
impl GET_CHANGER_PARAMETERS {}
impl ::std::default::Default for GET_CHANGER_PARAMETERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for GET_CHANGER_PARAMETERS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("GET_CHANGER_PARAMETERS")
            .field("Size", &self.Size)
            .field("NumberTransportElements", &self.NumberTransportElements)
            .field("NumberStorageElements", &self.NumberStorageElements)
            .field("NumberCleanerSlots", &self.NumberCleanerSlots)
            .field("NumberIEElements", &self.NumberIEElements)
            .field(
                "NumberDataTransferElements",
                &self.NumberDataTransferElements,
            )
            .field("NumberOfDoors", &self.NumberOfDoors)
            .field("FirstSlotNumber", &self.FirstSlotNumber)
            .field("FirstDriveNumber", &self.FirstDriveNumber)
            .field("FirstTransportNumber", &self.FirstTransportNumber)
            .field("FirstIEPortNumber", &self.FirstIEPortNumber)
            .field("FirstCleanerSlotAddress", &self.FirstCleanerSlotAddress)
            .field("MagazineSize", &self.MagazineSize)
            .field("DriveCleanTimeout", &self.DriveCleanTimeout)
            .field("Features0", &self.Features0)
            .field("Features1", &self.Features1)
            .field("MoveFromTransport", &self.MoveFromTransport)
            .field("MoveFromSlot", &self.MoveFromSlot)
            .field("MoveFromIePort", &self.MoveFromIePort)
            .field("MoveFromDrive", &self.MoveFromDrive)
            .field("ExchangeFromTransport", &self.ExchangeFromTransport)
            .field("ExchangeFromSlot", &self.ExchangeFromSlot)
            .field("ExchangeFromIePort", &self.ExchangeFromIePort)
            .field("ExchangeFromDrive", &self.ExchangeFromDrive)
            .field("LockUnlockCapabilities", &self.LockUnlockCapabilities)
            .field("PositionCapabilities", &self.PositionCapabilities)
            .field("Reserved1", &self.Reserved1)
            .field("Reserved2", &self.Reserved2)
            .finish()
    }
}
impl ::std::cmp::PartialEq for GET_CHANGER_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.NumberTransportElements == other.NumberTransportElements
            && self.NumberStorageElements == other.NumberStorageElements
            && self.NumberCleanerSlots == other.NumberCleanerSlots
            && self.NumberIEElements == other.NumberIEElements
            && self.NumberDataTransferElements == other.NumberDataTransferElements
            && self.NumberOfDoors == other.NumberOfDoors
            && self.FirstSlotNumber == other.FirstSlotNumber
            && self.FirstDriveNumber == other.FirstDriveNumber
            && self.FirstTransportNumber == other.FirstTransportNumber
            && self.FirstIEPortNumber == other.FirstIEPortNumber
            && self.FirstCleanerSlotAddress == other.FirstCleanerSlotAddress
            && self.MagazineSize == other.MagazineSize
            && self.DriveCleanTimeout == other.DriveCleanTimeout
            && self.Features0 == other.Features0
            && self.Features1 == other.Features1
            && self.MoveFromTransport == other.MoveFromTransport
            && self.MoveFromSlot == other.MoveFromSlot
            && self.MoveFromIePort == other.MoveFromIePort
            && self.MoveFromDrive == other.MoveFromDrive
            && self.ExchangeFromTransport == other.ExchangeFromTransport
            && self.ExchangeFromSlot == other.ExchangeFromSlot
            && self.ExchangeFromIePort == other.ExchangeFromIePort
            && self.ExchangeFromDrive == other.ExchangeFromDrive
            && self.LockUnlockCapabilities == other.LockUnlockCapabilities
            && self.PositionCapabilities == other.PositionCapabilities
            && self.Reserved1 == other.Reserved1
            && self.Reserved2 == other.Reserved2
    }
}
impl ::std::cmp::Eq for GET_CHANGER_PARAMETERS {}
unsafe impl ::windows::runtime::Abi for GET_CHANGER_PARAMETERS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct GET_CHANGER_PARAMETERS_FEATURES1(pub u32);
pub const CHANGER_CLEANER_AUTODISMOUNT: GET_CHANGER_PARAMETERS_FEATURES1 =
    GET_CHANGER_PARAMETERS_FEATURES1(2147483652u32);
pub const CHANGER_CLEANER_OPS_NOT_SUPPORTED: GET_CHANGER_PARAMETERS_FEATURES1 =
    GET_CHANGER_PARAMETERS_FEATURES1(2147483712u32);
pub const CHANGER_IEPORT_USER_CONTROL_CLOSE: GET_CHANGER_PARAMETERS_FEATURES1 =
    GET_CHANGER_PARAMETERS_FEATURES1(2147483904u32);
pub const CHANGER_IEPORT_USER_CONTROL_OPEN: GET_CHANGER_PARAMETERS_FEATURES1 =
    GET_CHANGER_PARAMETERS_FEATURES1(2147483776u32);
pub const CHANGER_MOVE_EXTENDS_IEPORT: GET_CHANGER_PARAMETERS_FEATURES1 =
    GET_CHANGER_PARAMETERS_FEATURES1(2147484160u32);
pub const CHANGER_MOVE_RETRACTS_IEPORT: GET_CHANGER_PARAMETERS_FEATURES1 =
    GET_CHANGER_PARAMETERS_FEATURES1(2147484672u32);
pub const CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE: GET_CHANGER_PARAMETERS_FEATURES1 =
    GET_CHANGER_PARAMETERS_FEATURES1(2147483650u32);
pub const CHANGER_PREDISMOUNT_ALIGN_TO_SLOT: GET_CHANGER_PARAMETERS_FEATURES1 =
    GET_CHANGER_PARAMETERS_FEATURES1(2147483649u32);
pub const CHANGER_RTN_MEDIA_TO_ORIGINAL_ADDR: GET_CHANGER_PARAMETERS_FEATURES1 =
    GET_CHANGER_PARAMETERS_FEATURES1(2147483680u32);
pub const CHANGER_SLOTS_USE_TRAYS: GET_CHANGER_PARAMETERS_FEATURES1 =
    GET_CHANGER_PARAMETERS_FEATURES1(2147483664u32);
pub const CHANGER_TRUE_EXCHANGE_CAPABLE: GET_CHANGER_PARAMETERS_FEATURES1 =
    GET_CHANGER_PARAMETERS_FEATURES1(2147483656u32);
impl ::std::convert::From<u32> for GET_CHANGER_PARAMETERS_FEATURES1 {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for GET_CHANGER_PARAMETERS_FEATURES1 {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for GET_CHANGER_PARAMETERS_FEATURES1 {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for GET_CHANGER_PARAMETERS_FEATURES1 {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for GET_CHANGER_PARAMETERS_FEATURES1 {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for GET_CHANGER_PARAMETERS_FEATURES1 {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for GET_CHANGER_PARAMETERS_FEATURES1 {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST {
    pub Version: u32,
    pub Size: u32,
    pub RequestDataType: DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE,
    pub RequestDataSet: DEVICE_INTERNAL_STATUS_DATA_SET,
}
impl GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST {}
impl ::std::default::Default for GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("RequestDataType", &self.RequestDataType)
            .field("RequestDataSet", &self.RequestDataSet)
            .finish()
    }
}
impl ::std::cmp::PartialEq for GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.RequestDataType == other.RequestDataType
            && self.RequestDataSet == other.RequestDataSet
    }
}
impl ::std::cmp::Eq for GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST {}
unsafe impl ::windows::runtime::Abi for GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct GET_FILTER_FILE_IDENTIFIER_INPUT {
    pub AltitudeLength: u16,
    pub Altitude: [u16; 1],
}
impl GET_FILTER_FILE_IDENTIFIER_INPUT {}
impl ::std::default::Default for GET_FILTER_FILE_IDENTIFIER_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for GET_FILTER_FILE_IDENTIFIER_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("GET_FILTER_FILE_IDENTIFIER_INPUT")
            .field("AltitudeLength", &self.AltitudeLength)
            .field("Altitude", &self.Altitude)
            .finish()
    }
}
impl ::std::cmp::PartialEq for GET_FILTER_FILE_IDENTIFIER_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.AltitudeLength == other.AltitudeLength && self.Altitude == other.Altitude
    }
}
impl ::std::cmp::Eq for GET_FILTER_FILE_IDENTIFIER_INPUT {}
unsafe impl ::windows::runtime::Abi for GET_FILTER_FILE_IDENTIFIER_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct GET_FILTER_FILE_IDENTIFIER_OUTPUT {
    pub FilterFileIdentifierLength: u16,
    pub FilterFileIdentifier: [u8; 1],
}
impl GET_FILTER_FILE_IDENTIFIER_OUTPUT {}
impl ::std::default::Default for GET_FILTER_FILE_IDENTIFIER_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for GET_FILTER_FILE_IDENTIFIER_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("GET_FILTER_FILE_IDENTIFIER_OUTPUT")
            .field(
                "FilterFileIdentifierLength",
                &self.FilterFileIdentifierLength,
            )
            .field("FilterFileIdentifier", &self.FilterFileIdentifier)
            .finish()
    }
}
impl ::std::cmp::PartialEq for GET_FILTER_FILE_IDENTIFIER_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.FilterFileIdentifierLength == other.FilterFileIdentifierLength
            && self.FilterFileIdentifier == other.FilterFileIdentifier
    }
}
impl ::std::cmp::Eq for GET_FILTER_FILE_IDENTIFIER_OUTPUT {}
unsafe impl ::windows::runtime::Abi for GET_FILTER_FILE_IDENTIFIER_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct GET_MEDIA_TYPES {
    pub DeviceType: u32,
    pub MediaInfoCount: u32,
    pub MediaInfo: [DEVICE_MEDIA_INFO; 1],
}
impl GET_MEDIA_TYPES {}
impl ::std::default::Default for GET_MEDIA_TYPES {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for GET_MEDIA_TYPES {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for GET_MEDIA_TYPES {}
unsafe impl ::windows::runtime::Abi for GET_MEDIA_TYPES {
    type Abi = Self;
    type DefaultType = Self;
}
pub const GET_VOLUME_BITMAP_FLAG_MASK_METADATA: u32 = 1u32;
pub const GPT_ATTRIBUTE_LEGACY_BIOS_BOOTABLE: u64 = 4u64;
pub const GPT_ATTRIBUTE_NO_BLOCK_IO_PROTOCOL: u64 = 2u64;
pub const GPT_BASIC_DATA_ATTRIBUTE_DAX: u64 = 288230376151711744u64;
pub const GPT_BASIC_DATA_ATTRIBUTE_OFFLINE: u64 = 576460752303423488u64;
pub const GPT_BASIC_DATA_ATTRIBUTE_SERVICE: u64 = 144115188075855872u64;
pub const GPT_SPACES_ATTRIBUTE_NO_METADATA: u64 = 9223372036854775808u64;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct GP_LOG_PAGE_DESCRIPTOR {
    pub LogAddress: u16,
    pub LogSectors: u16,
}
impl GP_LOG_PAGE_DESCRIPTOR {}
impl ::std::default::Default for GP_LOG_PAGE_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for GP_LOG_PAGE_DESCRIPTOR {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for GP_LOG_PAGE_DESCRIPTOR {}
unsafe impl ::windows::runtime::Abi for GP_LOG_PAGE_DESCRIPTOR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct GROUP_RELATIONSHIP {
    pub MaximumGroupCount: u16,
    pub ActiveGroupCount: u16,
    pub Reserved: [u8; 20],
    pub GroupInfo: [PROCESSOR_GROUP_INFO; 1],
}
impl GROUP_RELATIONSHIP {}
impl ::std::default::Default for GROUP_RELATIONSHIP {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for GROUP_RELATIONSHIP {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("GROUP_RELATIONSHIP")
            .field("MaximumGroupCount", &self.MaximumGroupCount)
            .field("ActiveGroupCount", &self.ActiveGroupCount)
            .field("Reserved", &self.Reserved)
            .field("GroupInfo", &self.GroupInfo)
            .finish()
    }
}
impl ::std::cmp::PartialEq for GROUP_RELATIONSHIP {
    fn eq(&self, other: &Self) -> bool {
        self.MaximumGroupCount == other.MaximumGroupCount
            && self.ActiveGroupCount == other.ActiveGroupCount
            && self.Reserved == other.Reserved
            && self.GroupInfo == other.GroupInfo
    }
}
impl ::std::cmp::Eq for GROUP_RELATIONSHIP {}
unsafe impl ::windows::runtime::Abi for GROUP_RELATIONSHIP {
    type Abi = Self;
    type DefaultType = Self;
}
pub const GS_16BIT_HANDLES: u32 = 4u32;
pub const GS_8BIT_HANDLES: u32 = 2u32;
pub const GS_UNICODE_HANDLES: u32 = 1u32;
pub const GUID_ACDC_POWER_SOURCE: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    1564383833,
    59861,
    19200,
    [166, 189, 255, 52, 255, 81, 101, 72],
);
pub const GUID_ACTIVE_POWERSCHEME: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    838464134,
    20612,
    17150,
    [183, 32, 43, 2, 100, 153, 55, 99],
);
pub const GUID_ADAPTIVE_INPUT_CONTROLLER_STATE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        244906729,
        62554,
        19937,
        [167, 87, 96, 49, 241, 151, 246, 234],
    );
pub const GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2249832726,
        57348,
        19928,
        [155, 102, 218, 232, 111, 128, 102, 152],
    );
pub const GUID_ADVANCED_COLOR_QUALITY_BIAS: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1749827177,
        42231,
        16404,
        [135, 84, 212, 81, 121, 165, 97, 103],
    );
pub const GUID_ALLOW_AWAYMODE: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    635412809,
    24017,
    18230,
    [181, 171, 232, 163, 123, 91, 129, 135],
);
pub const GUID_ALLOW_DISPLAY_REQUIRED: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2848897242,
        52550,
        17659,
        [169, 139, 2, 175, 105, 222, 70, 35],
    );
pub const GUID_ALLOW_RTC_WAKE: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    3174789514,
    1664,
    19869,
    [138, 178, 225, 210, 180, 172, 128, 109],
);
pub const GUID_ALLOW_STANDBY_STATES: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2885428505,
        13832,
        19498,
        [148, 234, 23, 27, 14, 213, 70, 171],
    );
pub const GUID_ALLOW_SYSTEM_REQUIRED: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2763101685,
        33317,
        18392,
        [128, 18, 157, 65, 54, 151, 134, 226],
    );
pub const GUID_APPLAUNCH_BUTTON: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    443060785,
    29593,
    20122,
    [143, 153, 183, 31, 153, 157, 179, 250],
);
pub const GUID_BACKGROUND_TASK_NOTIFICATION: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3475239488,
        10836,
        18648,
        [177, 20, 222, 21, 24, 255, 5, 46],
    );
pub const GUID_BATTERY_COUNT: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    2099658517,
    64676,
    18917,
    [133, 75, 169, 242, 191, 189, 92, 36],
);
pub const GUID_BATTERY_DISCHARGE_ACTION_0: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1669242927,
        48075,
        16405,
        [142, 44, 161, 199, 185, 192, 181, 70],
    );
pub const GUID_BATTERY_DISCHARGE_ACTION_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3631492555,
        15978,
        19260,
        [179, 254, 55, 70, 35, 205, 207, 6],
    );
pub const GUID_BATTERY_DISCHARGE_ACTION_2: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1109178936,
        6798,
        18561,
        [172, 137, 227, 58, 139, 4, 236, 228],
    );
pub const GUID_BATTERY_DISCHARGE_ACTION_3: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2152146451,
        38784,
        17758,
        [179, 8, 114, 211, 0, 60, 242, 248],
    );
pub const GUID_BATTERY_DISCHARGE_FLAGS_0: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1572568223,
        14569,
        16594,
        [151, 73, 79, 138, 14, 159, 100, 15],
    );
pub const GUID_BATTERY_DISCHARGE_FLAGS_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3168721233,
        6267,
        19717,
        [188, 204, 247, 229, 25, 96, 194, 88],
    );
pub const GUID_BATTERY_DISCHARGE_FLAGS_2: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2144530628,
        65207,
        19875,
        [129, 23, 227, 251, 237, 196, 101, 130],
    );
pub const GUID_BATTERY_DISCHARGE_FLAGS_3: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1935752399,
        56314,
        17017,
        [131, 86, 73, 53, 246, 191, 98, 243],
    );
pub const GUID_BATTERY_DISCHARGE_LEVEL_0: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2590431447,
        20471,
        20217,
        [181, 162, 90, 50, 108, 162, 164, 105],
    );
pub const GUID_BATTERY_DISCHARGE_LEVEL_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2172893850,
        59664,
        18650,
        [135, 105, 20, 174, 109, 193, 23, 10],
    );
pub const GUID_BATTERY_DISCHARGE_LEVEL_2: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        127958178,
        44463,
        16599,
        [176, 119, 83, 58, 173, 237, 27, 250],
    );
pub const GUID_BATTERY_DISCHARGE_LEVEL_3: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1487918502,
        49885,
        18386,
        [159, 191, 239, 112, 204, 92, 89, 101],
    );
pub const GUID_BATTERY_PERCENTAGE_REMAINING: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2813165633,
        46170,
        19630,
        [135, 163, 238, 203, 180, 104, 169, 225],
    );
pub const GUID_BATTERY_SUBGROUP: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    3879339149,
    48935,
    20242,
    [151, 49, 139, 32, 118, 232, 137, 31],
);
pub const GUID_CONNECTIVITY_IN_STANDBY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        4048910056,
        39095,
        16774,
        [185, 68, 234, 250, 102, 68, 2, 217],
    );
pub const GUID_CONSOLE_DISPLAY_STATE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1877382486,
        28746,
        18336,
        [143, 36, 194, 141, 147, 111, 218, 71],
    );
pub const GUID_CRITICAL_POWER_TRANSITION: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3080876069,
        58729,
        18114,
        [165, 4, 43, 150, 202, 210, 37, 161],
    );
pub const GUID_DEEP_SLEEP_ENABLED: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    3573741550,
    7623,
    20221,
    [165, 93, 240, 75, 111, 92, 5, 69],
);
pub const GUID_DEEP_SLEEP_PLATFORM_STATE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3527356344,
        38198,
        16440,
        [156, 148, 28, 224, 46, 92, 33, 82],
    );
pub const GUID_DEVICEDUMP_DRIVER_STORAGE_PORT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3665970205,
        28994,
        19393,
        [184, 68, 8, 7, 197, 164, 182, 127],
    );
pub const GUID_DEVICEDUMP_STORAGE_DEVICE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3638712623,
        6827,
        19798,
        [167, 70, 31, 117, 133, 223, 64, 244],
    );
pub const GUID_DEVICE_EVENT_RBC: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    3497281426,
    43406,
    4562,
    [145, 122, 0, 160, 201, 6, 143, 243],
);
pub const GUID_DEVICE_IDLE_POLICY: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    1336588058,
    37605,
    18214,
    [181, 49, 34, 69, 89, 103, 45, 25],
);
pub const GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2918014594,
        47369,
        17945,
        [153, 73, 245, 215, 29, 172, 11, 203],
    );
pub const GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        4059823586,
        43360,
        16741,
        [159, 136, 80, 102, 121, 17, 206, 150],
    );
pub const GUID_DEVINTERFACE_CDCHANGER: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1408590610,
        46783,
        4560,
        [148, 242, 0, 160, 201, 30, 251, 139],
    );
pub const GUID_DEVINTERFACE_CDROM: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    1408590600,
    46783,
    4560,
    [148, 242, 0, 160, 201, 30, 251, 139],
);
pub const GUID_DEVINTERFACE_COMPORT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2262880736,
        32905,
        4560,
        [156, 228, 8, 0, 62, 48, 31, 115],
    );
pub const GUID_DEVINTERFACE_DISK: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    1408590599,
    46783,
    4560,
    [148, 242, 0, 160, 201, 30, 251, 139],
);
pub const GUID_DEVINTERFACE_DMP: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    632611432,
    10757,
    18798,
    [128, 59, 38, 104, 55, 251, 218, 75],
);
pub const GUID_DEVINTERFACE_DMR: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    3498532788,
    8598,
    19578,
    [166, 61, 228, 22, 173, 221, 96, 161],
);
pub const GUID_DEVINTERFACE_DMS: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    3378526126,
    42328,
    17520,
    [180, 50, 17, 90, 49, 184, 85, 83],
);
pub const GUID_DEVINTERFACE_FLOPPY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1408590609,
        46783,
        4560,
        [148, 242, 0, 160, 201, 30, 251, 139],
    );
pub const GUID_DEVINTERFACE_HIDDEN_VOLUME: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2131790376,
        38963,
        19259,
        [183, 128, 44, 107, 95, 165, 192, 98],
    );
pub const GUID_DEVINTERFACE_MEDIUMCHANGER: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1408590608,
        46783,
        4560,
        [148, 242, 0, 160, 201, 30, 251, 139],
    );
pub const GUID_DEVINTERFACE_PARTITION: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1408590602,
        46783,
        4560,
        [148, 242, 0, 160, 201, 30, 251, 139],
    );
pub const GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1115906205,
        19906,
        17342,
        [187, 180, 79, 21, 223, 206, 44, 97],
    );
pub const GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1295444344,
        58149,
        4558,
        [191, 193, 8, 0, 43, 225, 3, 24],
    );
pub const GUID_DEVINTERFACE_SERVICE_VOLUME: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1856847234,
        9708,
        18108,
        [183, 253, 193, 240, 223, 143, 80, 55],
    );
pub const GUID_DEVINTERFACE_SES: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    395364844,
    18389,
    19955,
    [181, 175, 154, 223, 60, 242, 62, 72],
);
pub const GUID_DEVINTERFACE_STORAGEPORT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        718077536,
        49456,
        4562,
        [176, 130, 0, 160, 201, 30, 251, 139],
    );
pub const GUID_DEVINTERFACE_TAPE: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    1408590603,
    46783,
    4560,
    [148, 242, 0, 160, 201, 30, 251, 139],
);
pub const GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        658799649,
        48323,
        19719,
        [160, 91, 163, 57, 91, 180, 238, 231],
    );
pub const GUID_DEVINTERFACE_VMLUN: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    1866556953,
    40745,
    17061,
    [178, 11, 55, 226, 25, 202, 2, 176],
);
pub const GUID_DEVINTERFACE_VOLUME: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1408590605,
        46783,
        4560,
        [148, 242, 0, 160, 201, 30, 251, 139],
    );
pub const GUID_DEVINTERFACE_WRITEONCEDISK: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1408590604,
        46783,
        4560,
        [148, 242, 0, 160, 201, 30, 251, 139],
    );
pub const GUID_DEVINTERFACE_ZNSDISK: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3094954437,
        65499,
        17351,
        [182, 177, 32, 182, 50, 240, 177, 9],
    );
pub const GUID_DISCONNECTED_STANDBY_MODE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1756345049,
        61077,
        18344,
        [143, 80, 65, 21, 8, 128, 115, 177],
    );
pub const GUID_DISK_ADAPTIVE_POWERDOWN: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        963261153,
        18842,
        16562,
        [145, 36, 169, 106, 254, 112, 118, 103],
    );
pub const GUID_DISK_BURST_IGNORE_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2162411022,
        48020,
        19160,
        [187, 224, 13, 49, 149, 239, 198, 99],
    );
pub const GUID_DISK_COALESCING_POWERDOWN_TIMEOUT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3278835380,
        10632,
        19056,
        [142, 238, 8, 132, 252, 44, 36, 51],
    );
pub const GUID_DISK_IDLE_TIMEOUT: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    1491311528,
    47334,
    20214,
    [144, 208, 137, 174, 50, 178, 88, 214],
);
pub const GUID_DISK_MAX_POWER: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    1373545808,
    47928,
    19396,
    [153, 27, 234, 207, 55, 190, 94, 200],
);
pub const GUID_DISK_NVME_NOPPME: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    4235424438,
    43821,
    17390,
    [135, 151, 21, 233, 132, 31, 44, 202],
);
pub const GUID_DISK_POWERDOWN_TIMEOUT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1731781316,
        59557,
        19010,
        [177, 106, 224, 64, 231, 105, 117, 110],
    );
pub const GUID_DISK_SUBGROUP: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    1240647,
    36929,
    19293,
    [155, 119, 83, 95, 186, 139, 20, 66],
);
pub const GUID_ENABLE_SWITCH_FORCED_SHUTDOWN: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2201643874,
        57252,
        18129,
        [130, 248, 224, 158, 52, 208, 41, 214],
    );
pub const GUID_ENERGY_SAVER_BATTERY_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3868611530,
        53119,
        20229,
        [170, 115, 203, 131, 63, 169, 10, 212],
    );
pub const GUID_ENERGY_SAVER_BRIGHTNESS: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        332437636,
        63310,
        18250,
        [168, 82, 182, 189, 232, 173, 3, 168],
    );
pub const GUID_ENERGY_SAVER_POLICY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1549513545,
        44329,
        20194,
        [157, 11, 43, 37, 39, 15, 122, 129],
    );
pub const GUID_ENERGY_SAVER_SUBGROUP: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3733129507,
        42338,
        16815,
        [160, 134, 227, 162, 198, 186, 210, 218],
    );
pub const GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        828816449,
        32408,
        19971,
        [179, 78, 236, 15, 95, 43, 33, 142],
    );
pub const GUID_GLOBAL_USER_PRESENCE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2020510237,
        46119,
        17220,
        [146, 7, 9, 231, 11, 220, 190, 169],
    );
pub const GUID_GPU_PREFERENCE_POLICY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3716451114,
        35421,
        17489,
        [154, 226, 57, 205, 65, 101, 143, 108],
    );
pub const GUID_GRAPHICS_SUBGROUP: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    1605669773,
    7912,
    19215,
    [154, 60, 80, 54, 176, 171, 153, 92],
);
pub const GUID_HIBERNATE_FASTS4_POLICY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2494328105,
        29646,
        16806,
        [128, 159, 99, 99, 186, 33, 180, 126],
    );
pub const GUID_HIBERNATE_TIMEOUT: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    2641892774,
    32484,
    18814,
    [136, 136, 81, 90, 5, 240, 35, 100],
);
pub const GUID_HUPR_ADAPTIVE_DISPLAY_TIMEOUT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        175991478,
        44163,
        19153,
        [130, 130, 236, 165, 181, 131, 8, 243],
    );
pub const GUID_IDLE_BACKGROUND_TASK: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1364996568,
        63284,
        5693,
        [160, 253, 17, 160, 140, 145, 232, 241],
    );
pub const GUID_IDLE_RESILIENCY_PERIOD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3291183530,
        43578,
        18507,
        [169, 143, 44, 243, 42, 169, 10, 40],
    );
pub const GUID_IDLE_RESILIENCY_SUBGROUP: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        778047792,
        21329,
        19869,
        [142, 4, 37, 41, 102, 186, 208, 84],
    );
pub const GUID_INTSTEER_LOAD_PER_PROC_TRIGGER: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1942873677,
        55072,
        19378,
        [168, 96, 199, 85, 175, 231, 126, 242],
    );
pub const GUID_INTSTEER_MODE: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    737944825,
    24226,
    18433,
    [130, 19, 61, 186, 224, 26, 163, 157],
);
pub const GUID_INTSTEER_SUBGROUP: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    1214721848,
    31386,
    19378,
    [139, 248, 61, 133, 190, 25, 222, 78],
);
pub const GUID_INTSTEER_TIME_UNPARK_TRIGGER: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3602532611,
        14447,
        19500,
        [138, 219, 92, 33, 179, 50, 141, 37],
    );
pub const GUID_IO_CDROM_EXCLUSIVE_LOCK: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3159802169,
        31248,
        18414,
        [162, 148, 76, 106, 56, 240, 20, 154],
    );
pub const GUID_IO_CDROM_EXCLUSIVE_UNLOCK: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2746667645,
        24117,
        18565,
        [129, 229, 238, 24, 192, 14, 215, 121],
    );
pub const GUID_IO_DEVICE_BECOMING_READY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3497276400,
        43406,
        4562,
        [145, 122, 0, 160, 201, 6, 143, 243],
    );
pub const GUID_IO_DEVICE_EXTERNAL_REQUEST: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3497276368,
        43406,
        4562,
        [145, 122, 0, 160, 201, 6, 143, 243],
    );
pub const GUID_IO_DISK_CLONE_ARRIVAL: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1784776795,
        31801,
        17373,
        [155, 86, 184, 172, 34, 165, 73, 170],
    );
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION {
    pub DiskNumber: u32,
}
impl GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION {}
impl ::std::default::Default for GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION")
            .field("DiskNumber", &self.DiskNumber)
            .finish()
    }
}
impl ::std::cmp::PartialEq for GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.DiskNumber == other.DiskNumber
    }
}
impl ::std::cmp::Eq for GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION {}
unsafe impl ::windows::runtime::Abi for GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const GUID_IO_DISK_HEALTH_NOTIFICATION: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        253482564,
        14614,
        18885,
        [176, 99, 153, 25, 64, 17, 143, 178],
    );
pub const GUID_IO_DISK_LAYOUT_CHANGE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        299889996,
        33897,
        16889,
        [179, 222, 239, 131, 100, 135, 197, 74],
    );
pub const GUID_IO_DRIVE_REQUIRES_CLEANING: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1913096060,
        37101,
        17637,
        [160, 0, 129, 66, 141, 76, 121, 187],
    );
pub const GUID_IO_MEDIA_ARRIVAL: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    3497276352,
    43406,
    4562,
    [145, 122, 0, 160, 201, 6, 143, 243],
);
pub const GUID_IO_MEDIA_EJECT_REQUEST: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3497276369,
        43406,
        4562,
        [145, 122, 0, 160, 201, 6, 143, 243],
    );
pub const GUID_IO_MEDIA_REMOVAL: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    3497276353,
    43406,
    4562,
    [145, 122, 0, 160, 201, 6, 143, 243],
);
pub const GUID_IO_TAPE_ERASE: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    2234323435,
    19384,
    17671,
    [157, 155, 65, 124, 194, 177, 180, 56],
);
pub const GUID_IO_VOLUME_BACKGROUND_FORMAT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2732981382,
        54733,
        16440,
        [178, 227, 68, 69, 6, 92, 35, 119],
    );
pub const GUID_IO_VOLUME_CHANGE: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    1936942410,
    33066,
    4560,
    [190, 199, 8, 0, 43, 226, 9, 47],
);
pub const GUID_IO_VOLUME_CHANGE_SIZE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        974529982,
        44291,
        18929,
        [142, 248, 107, 186, 193, 130, 209, 253],
    );
pub const GUID_IO_VOLUME_DEVICE_INTERFACE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1408590605,
        46783,
        4560,
        [148, 242, 0, 160, 201, 30, 251, 139],
    );
pub const GUID_IO_VOLUME_DISMOUNT: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    3513406952,
    4185,
    4562,
    [143, 253, 0, 160, 201, 160, 109, 50],
);
pub const GUID_IO_VOLUME_DISMOUNT_FAILED: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3821384056,
        4189,
        4562,
        [143, 253, 0, 160, 201, 160, 109, 50],
    );
pub const GUID_IO_VOLUME_FORCE_CLOSED: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1092278351,
        17214,
        19906,
        [165, 174, 74, 45, 26, 45, 230, 84],
    );
pub const GUID_IO_VOLUME_FVE_STATUS_CHANGE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        103389362,
        60959,
        19306,
        [184, 87, 231, 108, 187, 233, 166, 218],
    );
pub const GUID_IO_VOLUME_INFO_MAKE_COMPAT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        985243858,
        61312,
        17871,
        [140, 220, 203, 224, 42, 33, 41, 6],
    );
pub const GUID_IO_VOLUME_LOCK: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    1349552244,
    51631,
    4561,
    [143, 239, 0, 160, 201, 160, 109, 50],
);
pub const GUID_IO_VOLUME_LOCK_FAILED: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2922310928,
        2984,
        4562,
        [143, 251, 0, 160, 201, 160, 109, 50],
    );
pub const GUID_IO_VOLUME_MOUNT: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    3045083256,
    6806,
    4562,
    [143, 253, 0, 160, 201, 160, 109, 50],
);
pub const GUID_IO_VOLUME_NAME_CHANGE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(770277251, 19462, 4562, [165, 50, 0, 96, 151, 19, 5, 90]);
pub const GUID_IO_VOLUME_NEED_CHKDSK: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2040138080,
        2571,
        19971,
        [173, 136, 47, 167, 198, 206, 116, 138],
    );
pub const GUID_IO_VOLUME_PHYSICAL_CONFIGURATION_CHANGE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(770277252, 19462, 4562, [165, 50, 0, 96, 151, 19, 5, 90]);
pub const GUID_IO_VOLUME_PREPARING_EJECT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3349066094,
        3500,
        20090,
        [168, 108, 178, 92, 238, 170, 136, 246],
    );
pub const GUID_IO_VOLUME_UNIQUE_ID_CHANGE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2939804226,
        26146,
        16885,
        [151, 11, 19, 157, 9, 47, 163, 217],
    );
pub const GUID_IO_VOLUME_UNLOCK: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    2592882024,
    53451,
    4561,
    [143, 239, 0, 160, 201, 160, 109, 50],
);
pub const GUID_IO_VOLUME_WEARING_OUT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2268140490,
        5254,
        17672,
        [130, 172, 195, 178, 229, 41, 122, 170],
    );
pub const GUID_IO_VOLUME_WORM_NEAR_FULL: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        4089446274,
        62430,
        18642,
        [175, 149, 69, 127, 128, 183, 99, 242],
    );
pub const GUID_LEGACY_RTC_MITIGATION: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        439664067,
        32363,
        17454,
        [169, 208, 100, 182, 239, 55, 142, 132],
    );
pub const GUID_LIDCLOSE_ACTION: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    1554527079,
    28229,
    17823,
    [162, 123, 71, 107, 29, 1, 201, 54],
);
pub const GUID_LIDOPEN_POWERSTATE: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    2583630055,
    9137,
    19463,
    [169, 209, 92, 50, 6, 215, 65, 180],
);
pub const GUID_LIDSWITCH_STATE_CHANGE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3124629325,
        47127,
        16532,
        [162, 209, 213, 99, 121, 230, 160, 243],
    );
pub const GUID_LIDSWITCH_STATE_RELIABILITY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2924236785,
        54113,
        17396,
        [128, 170, 187, 182, 235, 3, 222, 148],
    );
pub const GUID_LOCK_CONSOLE_ON_WAKE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        242838491,
        4109,
        18390,
        [162, 213, 247, 210, 218, 165, 31, 81],
    );
pub const GUID_MAX_POWER_SAVINGS: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    2709787400,
    13633,
    20395,
    [188, 129, 247, 21, 86, 242, 11, 74],
);
pub const GUID_MIN_POWER_SAVINGS: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    2355003354,
    59583,
    19094,
    [154, 133, 166, 226, 58, 140, 99, 92],
);
pub const GUID_MIXED_REALITY_MODE: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    509766478,
    52996,
    20365,
    [156, 199, 201, 124, 91, 15, 35, 145],
);
pub const GUID_MONITOR_POWER_ON: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    41095189,
    17680,
    17702,
    [153, 230, 229, 161, 126, 189, 26, 234],
);
pub const GUID_NON_ADAPTIVE_INPUT_TIMEOUT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1524350908,
        1870,
        19873,
        [186, 56, 219, 139, 54, 178, 200, 243],
    );
pub const GUID_PCIEXPRESS_ASPM_POLICY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3994220806,
        53879,
        16459,
        [182, 218, 229, 250, 26, 87, 109, 245],
    );
pub const GUID_PCIEXPRESS_SETTINGS_SUBGROUP: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1343900947,
        17071,
        17449,
        [159, 209, 168, 33, 140, 38, 142, 32],
    );
pub const GUID_POWERBUTTON_ACTION: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    1984491427,
    56732,
    20030,
    [181, 102, 80, 249, 41, 56, 98, 128],
);
pub const GUID_POWERSCHEME_PERSONALITY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        610108737,
        14659,
        17442,
        [176, 37, 19, 167, 132, 246, 121, 183],
    );
pub const GUID_POWER_SAVING_STATUS: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3758708928,
        49683,
        19150,
        [172, 119, 254, 204, 237, 46, 238, 165],
    );
pub const GUID_PROCESSOR_ALLOW_THROTTLING: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        990172413,
        7367,
        20259,
        [171, 28, 209, 51, 120, 25, 196, 187],
    );
pub const GUID_PROCESSOR_CLASS0_FLOOR_PERF: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        4259087403,
        33636,
        20188,
        [148, 207, 193, 127, 96, 222, 28, 128],
    );
pub const GUID_PROCESSOR_CLASS1_INITIAL_PERF: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        531430501,
        43312,
        19397,
        [159, 56, 80, 78, 192, 151, 187, 192],
    );
pub const GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2407220707,
        50067,
        18442,
        [135, 140, 246, 122, 195, 208, 112, 130],
    );
pub const GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1530095995,
        59549,
        19768,
        [170, 70, 158, 125, 251, 124, 210, 249],
    );
pub const GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3876087793,
        64047,
        20302,
        [174, 161, 77, 138, 11, 162, 59, 32],
    );
pub const GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1895963457,
        51017,
        19745,
        [190, 116, 160, 15, 51, 93, 88, 43],
    );
pub const GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1759325991,
        42190,
        19985,
        [132, 135, 55, 148, 228, 19, 93, 250],
    );
pub const GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3755019543,
        54763,
        17885,
        [135, 122, 154, 52, 221, 209, 92, 130],
    );
pub const GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3351119481,
        10263,
        19817,
        [157, 2, 81, 154, 83, 126, 208, 198],
    );
pub const GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3742640449,
        8435,
        20191,
        [154, 74, 156, 131, 211, 215, 23, 209],
    );
pub const GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        769481348,
        23153,
        17278,
        [145, 42, 219, 11, 140, 120, 135, 50],
    );
pub const GUID_PROCESSOR_CORE_PARKING_MAX_CORES: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3926270001,
        3636,
        20465,
        [155, 109, 235, 16, 89, 51, 64, 40],
    );
pub const GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3926270001,
        3636,
        20465,
        [155, 109, 235, 16, 89, 51, 64, 41],
    );
pub const GUID_PROCESSOR_CORE_PARKING_MIN_CORES: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        214283847,
        49631,
        17975,
        [137, 26, 222, 195, 92, 49, 133, 131],
    );
pub const GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        214283847,
        49631,
        17975,
        [137, 26, 222, 195, 92, 49, 133, 132],
    );
pub const GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR:
    ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    312017468,
    48168,
    20234,
    [129, 236, 211, 41, 90, 141, 129, 93],
);
pub const GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2596376210,
        43580,
        20007,
        [179, 7, 1, 174, 55, 48, 113, 41],
    );
pub const GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2486996150,
        28563,
        16935,
        [173, 135, 233, 163, 254, 236, 8, 209],
    );
pub const GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2282341080,
        45397,
        17108,
        [188, 218, 13, 52, 86, 81, 177, 219],
    );
pub const GUID_PROCESSOR_DISTRIBUTE_UTILITY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3758125872,
        62857,
        17133,
        [164, 1, 93, 219, 16, 231, 133, 211],
    );
pub const GUID_PROCESSOR_DUTY_CYCLING: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1313099955,
        24953,
        20113,
        [184, 241, 91, 185, 147, 143, 129, 161],
    );
pub const GUID_PROCESSOR_FREQUENCY_LIMIT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1974513215,
        48352,
        17831,
        [140, 137, 201, 97, 28, 37, 225, 0],
    );
pub const GUID_PROCESSOR_FREQUENCY_LIMIT_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1974513215,
        48352,
        17831,
        [140, 137, 201, 97, 28, 37, 225, 1],
    );
pub const GUID_PROCESSOR_HETEROGENEOUS_POLICY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2133810426,
        61708,
        18467,
        [181, 225, 233, 58, 232, 95, 70, 181],
    );
pub const GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        4169538599,
        38375,
        18268,
        [134, 91, 19, 192, 203, 63, 157, 107],
    );
pub const GUID_PROCESSOR_HETERO_DECREASE_TIME: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2133103286,
        24753,
        17893,
        [174, 85, 119, 63, 140, 213, 202, 236],
    );
pub const GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2952804733,
        39691,
        18493,
        [152, 201, 105, 42, 96, 96, 207, 191],
    );
pub const GUID_PROCESSOR_HETERO_INCREASE_TIME: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1074392999,
        59181,
        19642,
        [158, 223, 145, 8, 78, 168, 203, 195],
    );
pub const GUID_PROCESSOR_IDLESTATE_POLICY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1760715431,
        63009,
        16489,
        [185, 165, 72, 116, 22, 155, 226, 60],
    );
pub const GUID_PROCESSOR_IDLE_ALLOW_SCALING: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1814664112,
        36680,
        18463,
        [188, 198, 0, 221, 39, 66, 170, 6],
    );
pub const GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1267914584,
        23076,
        18513,
        [164, 112, 129, 93, 120, 174, 225, 25],
    );
pub const GUID_PROCESSOR_IDLE_DISABLE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1568056010,
        59584,
        16431,
        [161, 51, 33, 88, 73, 45, 88, 173],
    );
pub const GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2065844355,
        46028,
        19833,
        [129, 159, 131, 116, 21, 44, 190, 124],
    );
pub const GUID_PROCESSOR_IDLE_STATE_MAXIMUM: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2571364613,
        39472,
        20161,
        [155, 153, 68, 221, 59, 118, 247, 162],
    );
pub const GUID_PROCESSOR_IDLE_TIME_CHECK: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3294108721,
        35243,
        17815,
        [142, 43, 156, 156, 171, 68, 14, 107],
    );
pub const GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1634523813,
        26974,
        17733,
        [151, 173, 151, 220, 45, 27, 221, 136],
    );
pub const GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1634523813,
        26974,
        17733,
        [151, 173, 151, 220, 45, 27, 221, 137],
    );
pub const GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        607169391,
        42272,
        17570,
        [150, 1, 247, 242, 59, 81, 52, 177],
    );
pub const GUID_PROCESSOR_PARKING_CORE_OVERRIDE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2773881514,
        63012,
        17094,
        [164, 67, 115, 151, 208, 100, 192, 79],
    );
pub const GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1272640745,
        53507,
        18135,
        [165, 240, 98, 128, 18, 22, 22, 239],
    );
pub const GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        4147488371,
        8294,
        20352,
        [160, 197, 221, 238, 12, 241, 191, 93],
    );
pub const GUID_PROCESSOR_PARKING_PERF_STATE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1148335559,
        27277,
        19648,
        [142, 36, 158, 175, 112, 185, 110, 43],
    );
pub const GUID_PROCESSOR_PARKING_PERF_STATE_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1148335559,
        27277,
        19648,
        [142, 36, 158, 175, 112, 185, 110, 44],
    );
pub const GUID_PROCESSOR_PERFSTATE_POLICY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3151771668,
        6377,
        17507,
        [138, 85, 209, 151, 50, 124, 69, 192],
    );
pub const GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3488457680,
        30359,
        17766,
        [169, 34, 169, 8, 108, 212, 157, 250],
    );
pub const GUID_PROCESSOR_PERF_AUTONOMOUS_MODE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2343193226,
        5318,
        17489,
        [142, 139, 20, 189, 189, 25, 117, 55],
    );
pub const GUID_PROCESSOR_PERF_BOOST_MODE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3191042616,
        3458,
        16710,
        [169, 96, 79, 55, 73, 212, 112, 199],
    );
pub const GUID_PROCESSOR_PERF_BOOST_POLICY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1169997892,
        55429,
        17378,
        [134, 5, 238, 14, 198, 233, 107, 89],
    );
pub const GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2010641026,
        36634,
        17101,
        [133, 55, 69, 69, 10, 131, 155, 232],
    );
pub const GUID_PROCESSOR_PERF_DECREASE_HISTORY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        50394872,
        43990,
        17833,
        [183, 79, 73, 8, 105, 26, 64, 181],
    );
pub const GUID_PROCESSOR_PERF_DECREASE_POLICY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1090252743,
        11933,
        19749,
        [161, 133, 12, 253, 133, 116, 186, 198],
    );
pub const GUID_PROCESSOR_PERF_DECREASE_POLICY_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1090252743,
        11933,
        19749,
        [161, 133, 12, 253, 133, 116, 186, 199],
    );
pub const GUID_PROCESSOR_PERF_DECREASE_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        312519492,
        65064,
        20393,
        [179, 189, 75, 100, 244, 73, 96, 166],
    );
pub const GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        312519492,
        65064,
        20393,
        [179, 189, 75, 100, 244, 73, 96, 167],
    );
pub const GUID_PROCESSOR_PERF_DECREASE_TIME: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3639471003,
        38351,
        20373,
        [167, 60, 176, 97, 151, 54, 147, 200],
    );
pub const GUID_PROCESSOR_PERF_DECREASE_TIME_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3639471003,
        38351,
        20373,
        [167, 60, 176, 97, 151, 54, 147, 201],
    );
pub const GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        912818078,
        58277,
        19903,
        [177, 220, 21, 235, 56, 28, 104, 99],
    );
pub const GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        912818078,
        58277,
        19903,
        [177, 220, 21, 235, 56, 28, 104, 100],
    );
pub const GUID_PROCESSOR_PERF_HISTORY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2099559079,
        2948,
        18447,
        [132, 12, 27, 7, 67, 192, 15, 95],
    );
pub const GUID_PROCESSOR_PERF_HISTORY_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2099559079,
        2948,
        18447,
        [132, 12, 27, 7, 67, 192, 15, 96],
    );
pub const GUID_PROCESSOR_PERF_INCREASE_HISTORY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2578706177,
        29999,
        18081,
        [128, 251, 119, 48, 1, 31, 35, 84],
    );
pub const GUID_PROCESSOR_PERF_INCREASE_POLICY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1180573520,
        46608,
        18234,
        [171, 88, 0, 209, 7, 125, 196, 24],
    );
pub const GUID_PROCESSOR_PERF_INCREASE_POLICY_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1180573520,
        46608,
        18234,
        [171, 88, 0, 209, 7, 125, 196, 25],
    );
pub const GUID_PROCESSOR_PERF_INCREASE_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        113958670,
        25837,
        17546,
        [137, 39, 206, 123, 249, 14, 179, 93],
    );
pub const GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        113958670,
        25837,
        17546,
        [137, 39, 206, 123, 249, 14, 179, 94],
    );
pub const GUID_PROCESSOR_PERF_INCREASE_TIME: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2555180178,
        15341,
        17544,
        [168, 249, 66, 134, 201, 123, 245, 170],
    );
pub const GUID_PROCESSOR_PERF_INCREASE_TIME_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2555180178,
        15341,
        17544,
        [168, 249, 66, 134, 201, 123, 245, 171],
    );
pub const GUID_PROCESSOR_PERF_LATENCY_HINT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        136503089,
        40067,
        17436,
        [160, 121, 13, 228, 207, 0, 156, 123],
    );
pub const GUID_PROCESSOR_PERF_LATENCY_HINT_PERF: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1637577989,
        59,
        20098,
        [183, 166, 77, 210, 156, 48, 9, 113],
    );
pub const GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1637577989,
        59,
        20098,
        [183, 166, 77, 210, 156, 48, 9, 114],
    );
pub const GUID_PROCESSOR_PERF_TIME_CHECK: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1294664018,
        32092,
        18827,
        [136, 226, 52, 52, 83, 146, 162, 197],
    );
pub const GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        951597117,
        52448,
        19577,
        [158, 62, 86, 164, 241, 124, 196, 128],
    );
pub const GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        951597117,
        52448,
        19577,
        [158, 62, 86, 164, 241, 124, 196, 129],
    );
pub const GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        4117076383,
        16304,
        16666,
        [162, 38, 63, 1, 152, 222, 193, 48],
    );
pub const GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        4117076383,
        16304,
        16666,
        [162, 38, 63, 1, 152, 222, 193, 49],
    );
pub const GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1027924566,
        29218,
        17429,
        [169, 237, 156, 69, 250, 61, 216, 48],
    );
pub const GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1027924566,
        29218,
        17429,
        [169, 237, 156, 69, 250, 61, 216, 49],
    );
pub const GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1032933768,
        30768,
        18862,
        [167, 154, 15, 176, 161, 229, 162, 0],
    );
pub const GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1032933768,
        30768,
        18862,
        [167, 154, 15, 176, 161, 229, 162, 1],
    );
pub const GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1143457595,
        38742,
        19036,
        [184, 75, 199, 189, 167, 156, 115, 32],
    );
pub const GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1143457595,
        38742,
        19036,
        [184, 75, 199, 189, 167, 156, 115, 33],
    );
pub const GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3465450222,
        27270,
        17778,
        [191, 224, 32, 194, 29, 3, 205, 64],
    );
pub const GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3465450222,
        27270,
        17778,
        [191, 224, 32, 194, 29, 3, 205, 65],
    );
pub const GUID_PROCESSOR_SETTINGS_SUBGROUP: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1414738513,
        33470,
        18468,
        [150, 193, 71, 182, 11, 116, 13, 0],
    );
pub const GUID_PROCESSOR_SHORT_THREAD_RUNTIME_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3643381954,
        27208,
        18890,
        [133, 212, 140, 206, 236, 41, 69, 112],
    );
pub const GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3135277953,
        11614,
        18056,
        [173, 106, 19, 36, 51, 86, 101, 75],
    );
pub const GUID_PROCESSOR_SOFT_PARKING_LATENCY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2546969665,
        8727,
        18411,
        [153, 45, 97, 139, 25, 119, 201, 7],
    );
pub const GUID_PROCESSOR_THREAD_SCHEDULING_POLICY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2478356188,
        1688,
        19740,
        [158, 228, 6, 68, 233, 0, 200, 93],
    );
pub const GUID_PROCESSOR_THROTTLE_MAXIMUM: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3159374071,
        9184,
        18784,
        [150, 218, 51, 171, 175, 89, 53, 236],
    );
pub const GUID_PROCESSOR_THROTTLE_MAXIMUM_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3159374071,
        9184,
        18784,
        [150, 218, 51, 171, 175, 89, 53, 237],
    );
pub const GUID_PROCESSOR_THROTTLE_MINIMUM: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2302537358,
        11247,
        16864,
        [137, 198, 181, 93, 9, 41, 150, 76],
    );
pub const GUID_PROCESSOR_THROTTLE_MINIMUM_1: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2302537358,
        11247,
        16864,
        [137, 198, 181, 93, 9, 41, 150, 77],
    );
pub const GUID_PROCESSOR_THROTTLE_POLICY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1459778308,
        19190,
        16644,
        [146, 96, 227, 217, 82, 72, 252, 54],
    );
pub const GUID_SCM_PD_HEALTH_NOTIFICATION: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2644693894,
        29429,
        20195,
        [129, 85, 236, 160, 103, 142, 59, 6],
    );
pub const GUID_SCM_PD_PASSTHROUGH_INVDIMM: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1124707376,
        3345,
        4580,
        [145, 145, 8, 0, 32, 12, 154, 102],
    );
pub const GUID_SESSION_DISPLAY_STATUS: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        730120718,
        44323,
        19935,
        [147, 219, 5, 255, 189, 126, 252, 165],
    );
pub const GUID_SESSION_USER_PRESENCE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1007633736,
        49215,
        19533,
        [185, 242, 35, 126, 222, 104, 99, 118],
    );
pub const GUID_SLEEPBUTTON_ACTION: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    2526636992,
    44368,
    18412,
    [146, 59, 111, 65, 135, 77, 217, 235],
);
pub const GUID_SLEEP_IDLE_THRESHOLD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2177708768,
        30771,
        17651,
        [135, 55, 112, 129, 243, 141, 31, 112],
    );
pub const GUID_SLEEP_SUBGROUP: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    596418472,
    2733,
    16877,
    [131, 244, 151, 190, 36, 44, 143, 32],
);
pub const GUID_SPR_ACTIVE_SESSION_CHANGE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        237293112,
        50067,
        18242,
        [189, 177, 116, 79, 75, 158, 224, 142],
    );
pub const GUID_STANDBY_BUDGET_GRACE_PERIOD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1623228385,
        1366,
        17871,
        [153, 3, 213, 110, 50, 33, 2, 66],
    );
pub const GUID_STANDBY_BUDGET_PERCENT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2682595262,
        7024,
        18650,
        [147, 13, 123, 207, 23, 180, 73, 144],
    );
pub const GUID_STANDBY_RESERVE_GRACE_PERIOD: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3345215122,
        29160,
        16679,
        [132, 235, 246, 237, 4, 58, 62, 61],
    );
pub const GUID_STANDBY_RESERVE_TIME: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1183836133,
        4440,
        18156,
        [136, 188, 91, 150, 201, 228, 79, 208],
    );
pub const GUID_STANDBY_RESET_PERCENT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1238045093,
        22242,
        19195,
        [157, 56, 61, 244, 120, 114, 226, 27],
    );
pub const GUID_STANDBY_TIMEOUT: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    704037339,
    34522,
    18629,
    [159, 219, 242, 182, 123, 31, 68, 218],
);
pub const GUID_SYSTEM_AWAYMODE: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    2561144192,
    503,
    18602,
    [156, 15, 68, 53, 44, 41, 229, 192],
);
pub const GUID_SYSTEM_BUTTON_SUBGROUP: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1335303817,
        61117,
        17493,
        [168, 222, 158, 89, 4, 14, 115, 71],
    );
pub const GUID_SYSTEM_COOLING_POLICY: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2496898581,
        43161,
        19141,
        [174, 43, 228, 216, 246, 52, 54, 127],
    );
pub const GUID_TYPICAL_POWER_SAVINGS: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        941310498,
        63124,
        16880,
        [150, 133, 255, 91, 178, 96, 223, 46],
    );
pub const GUID_UNATTEND_SLEEP_TIMEOUT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2076484345,
        55548,
        17513,
        [176, 123, 51, 235, 120, 90, 172, 160],
    );
pub const GUID_USERINTERFACEBUTTON_ACTION: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2802214483,
        36204,
        16552,
        [145, 14, 161, 245, 75, 132, 199, 229],
    );
pub const GUID_USER_PRESENCE_PREDICTION: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2181109509,
        64405,
        19782,
        [141, 53, 64, 66, 177, 210, 13, 239],
    );
pub const GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        4225346150,
        38227,
        16535,
        [186, 68, 237, 110, 157, 101, 234, 184],
    );
pub const GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        4007199967,
        45378,
        16771,
        [177, 11, 90, 17, 151, 163, 120, 100],
    );
pub const GUID_VIDEO_ADAPTIVE_POWERDOWN: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2425724194,
        54945,
        18873,
        [175, 147, 188, 232, 133, 173, 51, 91],
    );
pub const GUID_VIDEO_ANNOYANCE_TIMEOUT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2195443501,
        52583,
        16581,
        [191, 220, 159, 26, 92, 205, 70, 99],
    );
pub const GUID_VIDEO_CONSOLE_LOCK_TIMEOUT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2395255717,
        26728,
        18626,
        [190, 117, 79, 48, 68, 190, 136, 167],
    );
pub const GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2415846086,
        11521,
        18110,
        [173, 185, 57, 138, 221, 197, 180, 255],
    );
pub const GUID_VIDEO_DIM_TIMEOUT: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    397058715,
    35651,
    19348,
    [170, 254, 53, 246, 77, 170, 241, 238],
);
pub const GUID_VIDEO_POWERDOWN_TIMEOUT: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1007403041,
        51368,
        19975,
        [169, 115, 107, 20, 203, 203, 43, 126],
    );
pub const GUID_VIDEO_SUBGROUP: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    1964423519,
    63350,
    17508,
    [140, 83, 6, 22, 127, 64, 204, 153],
);
pub const GX_GENERAL: i32 = 3i32;
pub const GX_IDENTITY: i32 = 0i32;
pub const GX_OFFSET: i32 = 1i32;
pub const GX_SCALE: i32 = 2i32;
#[cfg(feature = "Win32_Foundation")]
pub unsafe fn GetOverlappedResult<
    'a,
    Param0: ::windows::runtime::IntoParam<'a, super::super::Foundation::HANDLE>,
    Param3: ::windows::runtime::IntoParam<'a, super::super::Foundation::BOOL>,
>(
    hfile: Param0,
    lpoverlapped: *const OVERLAPPED,
    lpnumberofbytestransferred: *mut u32,
    bwait: Param3,
) -> super::super::Foundation::BOOL {
    #[cfg(windows)]
    {
        #[link(name = "kernel32")]
        extern "system" {
            fn GetOverlappedResult(
                hfile: super::super::Foundation::HANDLE,
                lpoverlapped: *const OVERLAPPED,
                lpnumberofbytestransferred: *mut u32,
                bwait: super::super::Foundation::BOOL,
            ) -> super::super::Foundation::BOOL;
        }
        ::std::mem::transmute(GetOverlappedResult(
            hfile.into_param().abi(),
            ::std::mem::transmute(lpoverlapped),
            ::std::mem::transmute(lpnumberofbytestransferred),
            bwait.into_param().abi(),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(feature = "Win32_Foundation")]
pub unsafe fn GetOverlappedResultEx<
    'a,
    Param0: ::windows::runtime::IntoParam<'a, super::super::Foundation::HANDLE>,
    Param4: ::windows::runtime::IntoParam<'a, super::super::Foundation::BOOL>,
>(
    hfile: Param0,
    lpoverlapped: *const OVERLAPPED,
    lpnumberofbytestransferred: *mut u32,
    dwmilliseconds: u32,
    balertable: Param4,
) -> super::super::Foundation::BOOL {
    #[cfg(windows)]
    {
        #[link(name = "kernel32")]
        extern "system" {
            fn GetOverlappedResultEx(
                hfile: super::super::Foundation::HANDLE,
                lpoverlapped: *const OVERLAPPED,
                lpnumberofbytestransferred: *mut u32,
                dwmilliseconds: u32,
                balertable: super::super::Foundation::BOOL,
            ) -> super::super::Foundation::BOOL;
        }
        ::std::mem::transmute(GetOverlappedResultEx(
            hfile.into_param().abi(),
            ::std::mem::transmute(lpoverlapped),
            ::std::mem::transmute(lpnumberofbytestransferred),
            ::std::mem::transmute(dwmilliseconds),
            balertable.into_param().abi(),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[derive(
    :: std :: clone :: Clone,
    :: std :: marker :: Copy,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
)]
#[repr(transparent)]
pub struct HANDLE_PTR(pub usize);
impl ::std::default::Default for HANDLE_PTR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
unsafe impl ::windows::runtime::Handle for HANDLE_PTR {}
unsafe impl ::windows::runtime::Abi for HANDLE_PTR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: clone :: Clone,
    :: std :: marker :: Copy,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
)]
#[repr(transparent)]
pub struct HBM(pub isize);
impl ::std::default::Default for HBM {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
unsafe impl ::windows::runtime::Handle for HBM {}
unsafe impl ::windows::runtime::Abi for HBM {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: clone :: Clone,
    :: std :: marker :: Copy,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
)]
#[repr(transparent)]
pub struct HDEV(pub isize);
impl ::std::default::Default for HDEV {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
unsafe impl ::windows::runtime::Handle for HDEV {}
unsafe impl ::windows::runtime::Abi for HDEV {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: clone :: Clone,
    :: std :: marker :: Copy,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
)]
#[repr(transparent)]
pub struct HDRVOBJ(pub isize);
impl ::std::default::Default for HDRVOBJ {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
unsafe impl ::windows::runtime::Handle for HDRVOBJ {}
unsafe impl ::windows::runtime::Abi for HDRVOBJ {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct HEAP_INFORMATION_CLASS(pub i32);
pub const HeapCompatibilityInformation: HEAP_INFORMATION_CLASS = HEAP_INFORMATION_CLASS(0i32);
pub const HeapEnableTerminationOnCorruption: HEAP_INFORMATION_CLASS = HEAP_INFORMATION_CLASS(1i32);
pub const HeapOptimizeResources: HEAP_INFORMATION_CLASS = HEAP_INFORMATION_CLASS(3i32);
pub const HeapTag: HEAP_INFORMATION_CLASS = HEAP_INFORMATION_CLASS(7i32);
impl ::std::convert::From<i32> for HEAP_INFORMATION_CLASS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for HEAP_INFORMATION_CLASS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const HEAP_OPTIMIZE_RESOURCES_CURRENT_VERSION: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct HEAP_OPTIMIZE_RESOURCES_INFORMATION {
    pub Version: u32,
    pub Flags: u32,
}
impl HEAP_OPTIMIZE_RESOURCES_INFORMATION {}
impl ::std::default::Default for HEAP_OPTIMIZE_RESOURCES_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for HEAP_OPTIMIZE_RESOURCES_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("HEAP_OPTIMIZE_RESOURCES_INFORMATION")
            .field("Version", &self.Version)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for HEAP_OPTIMIZE_RESOURCES_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for HEAP_OPTIMIZE_RESOURCES_INFORMATION {}
unsafe impl ::windows::runtime::Abi for HEAP_OPTIMIZE_RESOURCES_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: clone :: Clone,
    :: std :: marker :: Copy,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
)]
#[repr(transparent)]
pub struct HFASTMUTEX(pub isize);
impl ::std::default::Default for HFASTMUTEX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
unsafe impl ::windows::runtime::Handle for HFASTMUTEX {}
unsafe impl ::windows::runtime::Abi for HFASTMUTEX {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct HIBERFILE_BUCKET {
    pub MaxPhysicalMemory: u64,
    pub PhysicalMemoryPercent: [u32; 3],
}
impl HIBERFILE_BUCKET {}
impl ::std::default::Default for HIBERFILE_BUCKET {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for HIBERFILE_BUCKET {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("HIBERFILE_BUCKET")
            .field("MaxPhysicalMemory", &self.MaxPhysicalMemory)
            .field("PhysicalMemoryPercent", &self.PhysicalMemoryPercent)
            .finish()
    }
}
impl ::std::cmp::PartialEq for HIBERFILE_BUCKET {
    fn eq(&self, other: &Self) -> bool {
        self.MaxPhysicalMemory == other.MaxPhysicalMemory
            && self.PhysicalMemoryPercent == other.PhysicalMemoryPercent
    }
}
impl ::std::cmp::Eq for HIBERFILE_BUCKET {}
unsafe impl ::windows::runtime::Abi for HIBERFILE_BUCKET {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct HIBERFILE_BUCKET_SIZE(pub i32);
pub const HiberFileBucket1GB: HIBERFILE_BUCKET_SIZE = HIBERFILE_BUCKET_SIZE(0i32);
pub const HiberFileBucket2GB: HIBERFILE_BUCKET_SIZE = HIBERFILE_BUCKET_SIZE(1i32);
pub const HiberFileBucket4GB: HIBERFILE_BUCKET_SIZE = HIBERFILE_BUCKET_SIZE(2i32);
pub const HiberFileBucket8GB: HIBERFILE_BUCKET_SIZE = HIBERFILE_BUCKET_SIZE(3i32);
pub const HiberFileBucket16GB: HIBERFILE_BUCKET_SIZE = HIBERFILE_BUCKET_SIZE(4i32);
pub const HiberFileBucket32GB: HIBERFILE_BUCKET_SIZE = HIBERFILE_BUCKET_SIZE(5i32);
pub const HiberFileBucketUnlimited: HIBERFILE_BUCKET_SIZE = HIBERFILE_BUCKET_SIZE(6i32);
pub const HiberFileBucketMax: HIBERFILE_BUCKET_SIZE = HIBERFILE_BUCKET_SIZE(7i32);
impl ::std::convert::From<i32> for HIBERFILE_BUCKET_SIZE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for HIBERFILE_BUCKET_SIZE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const HIBERFILE_TYPE_FULL: u32 = 2u32;
pub const HIBERFILE_TYPE_MAX: u32 = 3u32;
pub const HIBERFILE_TYPE_NONE: u32 = 0u32;
pub const HIBERFILE_TYPE_REDUCED: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct HISTOGRAM_BUCKET {
    pub Reads: u32,
    pub Writes: u32,
}
impl HISTOGRAM_BUCKET {}
impl ::std::default::Default for HISTOGRAM_BUCKET {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for HISTOGRAM_BUCKET {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("HISTOGRAM_BUCKET")
            .field("Reads", &self.Reads)
            .field("Writes", &self.Writes)
            .finish()
    }
}
impl ::std::cmp::PartialEq for HISTOGRAM_BUCKET {
    fn eq(&self, other: &Self) -> bool {
        self.Reads == other.Reads && self.Writes == other.Writes
    }
}
impl ::std::cmp::Eq for HISTOGRAM_BUCKET {}
unsafe impl ::windows::runtime::Abi for HISTOGRAM_BUCKET {
    type Abi = Self;
    type DefaultType = Self;
}
pub const HIST_NO_OF_BUCKETS: u32 = 24u32;
#[derive(
    :: std :: clone :: Clone,
    :: std :: marker :: Copy,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
)]
#[repr(transparent)]
pub struct HLSURF(pub isize);
impl ::std::default::Default for HLSURF {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
unsafe impl ::windows::runtime::Handle for HLSURF {}
unsafe impl ::windows::runtime::Abi for HLSURF {
    type Abi = Self;
    type DefaultType = Self;
}
pub const HOOK_ALPHABLEND: u32 = 65536u32;
pub const HOOK_BITBLT: u32 = 1u32;
pub const HOOK_COPYBITS: u32 = 1024u32;
pub const HOOK_FILLPATH: u32 = 64u32;
pub const HOOK_FLAGS: u32 = 243199u32;
pub const HOOK_GRADIENTFILL: u32 = 131072u32;
pub const HOOK_LINETO: u32 = 256u32;
pub const HOOK_MOVEPANNING: u32 = 2048u32;
pub const HOOK_PAINT: u32 = 16u32;
pub const HOOK_PLGBLT: u32 = 4u32;
pub const HOOK_STRETCHBLT: u32 = 2u32;
pub const HOOK_STRETCHBLTROP: u32 = 8192u32;
pub const HOOK_STROKEANDFILLPATH: u32 = 128u32;
pub const HOOK_STROKEPATH: u32 = 32u32;
pub const HOOK_SYNCHRONIZE: u32 = 4096u32;
pub const HOOK_SYNCHRONIZEACCESS: u32 = 16384u32;
pub const HOOK_TEXTOUT: u32 = 8u32;
pub const HOOK_TRANSPARENTBLT: u32 = 32768u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct HSEMAPHORE__ {
    pub unused: i32,
}
impl HSEMAPHORE__ {}
impl ::std::default::Default for HSEMAPHORE__ {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for HSEMAPHORE__ {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("HSEMAPHORE__")
            .field("unused", &self.unused)
            .finish()
    }
}
impl ::std::cmp::PartialEq for HSEMAPHORE__ {
    fn eq(&self, other: &Self) -> bool {
        self.unused == other.unused
    }
}
impl ::std::cmp::Eq for HSEMAPHORE__ {}
unsafe impl ::windows::runtime::Abi for HSEMAPHORE__ {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: clone :: Clone,
    :: std :: marker :: Copy,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
)]
#[repr(transparent)]
pub struct HSPRITE(pub isize);
impl ::std::default::Default for HSPRITE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
unsafe impl ::windows::runtime::Handle for HSPRITE {}
unsafe impl ::windows::runtime::Abi for HSPRITE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: clone :: Clone,
    :: std :: marker :: Copy,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
)]
#[repr(transparent)]
pub struct HSTR(pub isize);
impl ::std::default::Default for HSTR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
unsafe impl ::windows::runtime::Handle for HSTR {}
unsafe impl ::windows::runtime::Abi for HSTR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: clone :: Clone,
    :: std :: marker :: Copy,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
)]
#[repr(transparent)]
pub struct HSURF(pub isize);
impl ::std::default::Default for HSURF {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
unsafe impl ::windows::runtime::Handle for HSURF {}
unsafe impl ::windows::runtime::Abi for HSURF {
    type Abi = Self;
    type DefaultType = Self;
}
pub const HS_DDI_MAX: u32 = 6u32;
pub const HT_FLAG_8BPP_CMY332_MASK: u32 = 4278190080u32;
pub const HT_FLAG_ADDITIVE_PRIMS: u32 = 4u32;
pub const HT_FLAG_DO_DEVCLR_XFORM: u32 = 128u32;
pub const HT_FLAG_HAS_BLACK_DYE: u32 = 2u32;
pub const HT_FLAG_INK_ABSORPTION_IDX0: u32 = 0u32;
pub const HT_FLAG_INK_ABSORPTION_IDX1: u32 = 32u32;
pub const HT_FLAG_INK_ABSORPTION_IDX2: u32 = 64u32;
pub const HT_FLAG_INK_ABSORPTION_IDX3: u32 = 96u32;
pub const HT_FLAG_INK_ABSORPTION_INDICES: u32 = 96u32;
pub const HT_FLAG_INK_HIGH_ABSORPTION: u32 = 16u32;
pub const HT_FLAG_INVERT_8BPP_BITMASK_IDX: u32 = 1024u32;
pub const HT_FLAG_LOWER_INK_ABSORPTION: u32 = 64u32;
pub const HT_FLAG_LOWEST_INK_ABSORPTION: u32 = 96u32;
pub const HT_FLAG_LOW_INK_ABSORPTION: u32 = 32u32;
pub const HT_FLAG_NORMAL_INK_ABSORPTION: u32 = 0u32;
pub const HT_FLAG_OUTPUT_CMY: u32 = 256u32;
pub const HT_FLAG_PRINT_DRAFT_MODE: u32 = 512u32;
pub const HT_FLAG_SQUARE_DEVICE_PEL: u32 = 1u32;
pub const HT_FLAG_USE_8BPP_BITMASK: u32 = 8u32;
pub const HT_FORMAT_16BPP: u32 = 5u32;
pub const HT_FORMAT_1BPP: u32 = 0u32;
pub const HT_FORMAT_24BPP: u32 = 6u32;
pub const HT_FORMAT_32BPP: u32 = 7u32;
pub const HT_FORMAT_4BPP: u32 = 2u32;
pub const HT_FORMAT_4BPP_IRGB: u32 = 3u32;
pub const HT_FORMAT_8BPP: u32 = 4u32;
pub const HT_PATSIZE_10x10: u32 = 8u32;
pub const HT_PATSIZE_10x10_M: u32 = 9u32;
pub const HT_PATSIZE_12x12: u32 = 10u32;
pub const HT_PATSIZE_12x12_M: u32 = 11u32;
pub const HT_PATSIZE_14x14: u32 = 12u32;
pub const HT_PATSIZE_14x14_M: u32 = 13u32;
pub const HT_PATSIZE_16x16: u32 = 14u32;
pub const HT_PATSIZE_16x16_M: u32 = 15u32;
pub const HT_PATSIZE_2x2: u32 = 0u32;
pub const HT_PATSIZE_2x2_M: u32 = 1u32;
pub const HT_PATSIZE_4x4: u32 = 2u32;
pub const HT_PATSIZE_4x4_M: u32 = 3u32;
pub const HT_PATSIZE_6x6: u32 = 4u32;
pub const HT_PATSIZE_6x6_M: u32 = 5u32;
pub const HT_PATSIZE_8x8: u32 = 6u32;
pub const HT_PATSIZE_8x8_M: u32 = 7u32;
pub const HT_PATSIZE_DEFAULT: u32 = 17u32;
pub const HT_PATSIZE_MAX_INDEX: u32 = 18u32;
pub const HT_PATSIZE_SUPERCELL: u32 = 16u32;
pub const HT_PATSIZE_SUPERCELL_M: u32 = 17u32;
pub const HT_PATSIZE_USER: u32 = 18u32;
pub const HT_USERPAT_CX_MAX: u32 = 256u32;
pub const HT_USERPAT_CX_MIN: u32 = 4u32;
pub const HT_USERPAT_CY_MAX: u32 = 256u32;
pub const HT_USERPAT_CY_MIN: u32 = 4u32;
#[derive(
    :: std :: clone :: Clone,
    :: std :: marker :: Copy,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
)]
#[repr(transparent)]
pub struct HUMPD(pub isize);
impl ::std::default::Default for HUMPD {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
unsafe impl ::windows::runtime::Handle for HUMPD {}
unsafe impl ::windows::runtime::Abi for HUMPD {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IDENTIFY_BUFFER_SIZE: u32 = 512u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IDEREGS {
    pub bFeaturesReg: u8,
    pub bSectorCountReg: u8,
    pub bSectorNumberReg: u8,
    pub bCylLowReg: u8,
    pub bCylHighReg: u8,
    pub bDriveHeadReg: u8,
    pub bCommandReg: u8,
    pub bReserved: u8,
}
impl IDEREGS {}
impl ::std::default::Default for IDEREGS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IDEREGS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IDEREGS")
            .field("bFeaturesReg", &self.bFeaturesReg)
            .field("bSectorCountReg", &self.bSectorCountReg)
            .field("bSectorNumberReg", &self.bSectorNumberReg)
            .field("bCylLowReg", &self.bCylLowReg)
            .field("bCylHighReg", &self.bCylHighReg)
            .field("bDriveHeadReg", &self.bDriveHeadReg)
            .field("bCommandReg", &self.bCommandReg)
            .field("bReserved", &self.bReserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IDEREGS {
    fn eq(&self, other: &Self) -> bool {
        self.bFeaturesReg == other.bFeaturesReg
            && self.bSectorCountReg == other.bSectorCountReg
            && self.bSectorNumberReg == other.bSectorNumberReg
            && self.bCylLowReg == other.bCylLowReg
            && self.bCylHighReg == other.bCylHighReg
            && self.bDriveHeadReg == other.bDriveHeadReg
            && self.bCommandReg == other.bCommandReg
            && self.bReserved == other.bReserved
    }
}
impl ::std::cmp::Eq for IDEREGS {}
unsafe impl ::windows::runtime::Abi for IDEREGS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const ID_CMD: u32 = 236u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct IGP_ID(pub u32);
pub const IGP_GETIMEVERSION: IGP_ID = IGP_ID(4294967292u32);
pub const IGP_PROPERTY: IGP_ID = IGP_ID(4u32);
pub const IGP_CONVERSION: IGP_ID = IGP_ID(8u32);
pub const IGP_SENTENCE: IGP_ID = IGP_ID(12u32);
pub const IGP_UI: IGP_ID = IGP_ID(16u32);
pub const IGP_SETCOMPSTR: IGP_ID = IGP_ID(20u32);
pub const IGP_SELECT: IGP_ID = IGP_ID(24u32);
impl ::std::convert::From<u32> for IGP_ID {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for IGP_ID {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for IGP_ID {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for IGP_ID {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for IGP_ID {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for IGP_ID {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for IGP_ID {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const IGRF_RGB_256BYTES: u32 = 0u32;
pub const IGRF_RGB_256WORDS: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(4))]
pub struct IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: u64,
    pub EndAddress: u64,
    pub ExceptionHandler: u64,
    pub HandlerData: u64,
    pub PrologEndAddress: u64,
}
impl IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {}
impl ::std::default::Default for IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {}
unsafe impl ::windows::runtime::Abi for IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: u32,
    pub EndAddress: u32,
    pub ExceptionHandler: u32,
    pub HandlerData: u32,
    pub PrologEndAddress: u32,
}
impl IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {}
impl ::std::default::Default for IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY")
            .field("BeginAddress", &self.BeginAddress)
            .field("EndAddress", &self.EndAddress)
            .field("ExceptionHandler", &self.ExceptionHandler)
            .field("HandlerData", &self.HandlerData)
            .field("PrologEndAddress", &self.PrologEndAddress)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.BeginAddress == other.BeginAddress
            && self.EndAddress == other.EndAddress
            && self.ExceptionHandler == other.ExceptionHandler
            && self.HandlerData == other.HandlerData
            && self.PrologEndAddress == other.PrologEndAddress
    }
}
impl ::std::cmp::Eq for IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {}
unsafe impl ::windows::runtime::Abi for IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_ARCHITECTURE_ENTRY {
    pub FixupInstRVA: u32,
    pub NewInst: u32,
}
impl IMAGE_ARCHITECTURE_ENTRY {}
impl ::std::default::Default for IMAGE_ARCHITECTURE_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_ARCHITECTURE_ENTRY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_ARCHITECTURE_ENTRY")
            .field("FixupInstRVA", &self.FixupInstRVA)
            .field("NewInst", &self.NewInst)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_ARCHITECTURE_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.FixupInstRVA == other.FixupInstRVA && self.NewInst == other.NewInst
    }
}
impl ::std::cmp::Eq for IMAGE_ARCHITECTURE_ENTRY {}
unsafe impl ::windows::runtime::Abi for IMAGE_ARCHITECTURE_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_ARCHITECTURE_HEADER {
    pub _bitfield: u32,
    pub FirstEntryRVA: u32,
}
impl IMAGE_ARCHITECTURE_HEADER {}
impl ::std::default::Default for IMAGE_ARCHITECTURE_HEADER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_ARCHITECTURE_HEADER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_ARCHITECTURE_HEADER")
            .field("_bitfield", &self._bitfield)
            .field("FirstEntryRVA", &self.FirstEntryRVA)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_ARCHITECTURE_HEADER {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield && self.FirstEntryRVA == other.FirstEntryRVA
    }
}
impl ::std::cmp::Eq for IMAGE_ARCHITECTURE_HEADER {}
unsafe impl ::windows::runtime::Abi for IMAGE_ARCHITECTURE_HEADER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_ARCHIVE_MEMBER_HEADER {
    pub Name: [u8; 16],
    pub Date: [u8; 12],
    pub UserID: [u8; 6],
    pub GroupID: [u8; 6],
    pub Mode: [u8; 8],
    pub Size: [u8; 10],
    pub EndHeader: [u8; 2],
}
impl IMAGE_ARCHIVE_MEMBER_HEADER {}
impl ::std::default::Default for IMAGE_ARCHIVE_MEMBER_HEADER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_ARCHIVE_MEMBER_HEADER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_ARCHIVE_MEMBER_HEADER")
            .field("Name", &self.Name)
            .field("Date", &self.Date)
            .field("UserID", &self.UserID)
            .field("GroupID", &self.GroupID)
            .field("Mode", &self.Mode)
            .field("Size", &self.Size)
            .field("EndHeader", &self.EndHeader)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_ARCHIVE_MEMBER_HEADER {
    fn eq(&self, other: &Self) -> bool {
        self.Name == other.Name
            && self.Date == other.Date
            && self.UserID == other.UserID
            && self.GroupID == other.GroupID
            && self.Mode == other.Mode
            && self.Size == other.Size
            && self.EndHeader == other.EndHeader
    }
}
impl ::std::cmp::Eq for IMAGE_ARCHIVE_MEMBER_HEADER {}
unsafe impl ::windows::runtime::Abi for IMAGE_ARCHIVE_MEMBER_HEADER {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_ARCHIVE_START_SIZE: u32 = 8u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: u32,
    pub Anonymous: IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_0,
}
impl IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY {}
impl ::std::default::Default for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY {}
unsafe impl ::windows::runtime::Abi for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_0 {
    pub UnwindData: u32,
    pub Anonymous: IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_0_0,
}
impl IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_0 {}
impl ::std::default::Default for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_0_0 {
    pub _bitfield: u32,
}
impl IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_0_0 {}
impl ::std::default::Default for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_0_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA {
    pub HeaderData: u32,
    pub Anonymous: IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA_0,
}
impl IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA {}
impl ::std::default::Default for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA {}
unsafe impl ::windows::runtime::Abi for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA_0 {
    pub _bitfield: u32,
}
impl IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA_0 {}
impl ::std::default::Default for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_ARM_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: u32,
    pub Anonymous: IMAGE_ARM_RUNTIME_FUNCTION_ENTRY_0,
}
impl IMAGE_ARM_RUNTIME_FUNCTION_ENTRY {}
impl ::std::default::Default for IMAGE_ARM_RUNTIME_FUNCTION_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_ARM_RUNTIME_FUNCTION_ENTRY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_ARM_RUNTIME_FUNCTION_ENTRY {}
unsafe impl ::windows::runtime::Abi for IMAGE_ARM_RUNTIME_FUNCTION_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union IMAGE_ARM_RUNTIME_FUNCTION_ENTRY_0 {
    pub UnwindData: u32,
    pub Anonymous: IMAGE_ARM_RUNTIME_FUNCTION_ENTRY_0_0,
}
impl IMAGE_ARM_RUNTIME_FUNCTION_ENTRY_0 {}
impl ::std::default::Default for IMAGE_ARM_RUNTIME_FUNCTION_ENTRY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_ARM_RUNTIME_FUNCTION_ENTRY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_ARM_RUNTIME_FUNCTION_ENTRY_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_ARM_RUNTIME_FUNCTION_ENTRY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_ARM_RUNTIME_FUNCTION_ENTRY_0_0 {
    pub _bitfield: u32,
}
impl IMAGE_ARM_RUNTIME_FUNCTION_ENTRY_0_0 {}
impl ::std::default::Default for IMAGE_ARM_RUNTIME_FUNCTION_ENTRY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_ARM_RUNTIME_FUNCTION_ENTRY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_ARM_RUNTIME_FUNCTION_ENTRY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for IMAGE_ARM_RUNTIME_FUNCTION_ENTRY_0_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_ARM_RUNTIME_FUNCTION_ENTRY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union IMAGE_AUX_SYMBOL {
    pub Sym: IMAGE_AUX_SYMBOL_3,
    pub File: IMAGE_AUX_SYMBOL_1,
    pub Section: IMAGE_AUX_SYMBOL_2,
    pub TokenDef: IMAGE_AUX_SYMBOL_TOKEN_DEF,
    pub CRC: IMAGE_AUX_SYMBOL_0,
}
impl IMAGE_AUX_SYMBOL {}
impl ::std::default::Default for IMAGE_AUX_SYMBOL {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_AUX_SYMBOL {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_AUX_SYMBOL {}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub struct IMAGE_AUX_SYMBOL_0 {
    pub crc: u32,
    pub rgbReserved: [u8; 14],
}
impl IMAGE_AUX_SYMBOL_0 {}
impl ::std::default::Default for IMAGE_AUX_SYMBOL_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_AUX_SYMBOL_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_AUX_SYMBOL_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_AUX_SYMBOL_1 {
    pub Name: [u8; 18],
}
impl IMAGE_AUX_SYMBOL_1 {}
impl ::std::default::Default for IMAGE_AUX_SYMBOL_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_AUX_SYMBOL_1 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_File_e__Struct")
            .field("Name", &self.Name)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_AUX_SYMBOL_1 {
    fn eq(&self, other: &Self) -> bool {
        self.Name == other.Name
    }
}
impl ::std::cmp::Eq for IMAGE_AUX_SYMBOL_1 {}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub struct IMAGE_AUX_SYMBOL_2 {
    pub Length: u32,
    pub NumberOfRelocations: u16,
    pub NumberOfLinenumbers: u16,
    pub CheckSum: u32,
    pub Number: i16,
    pub Selection: u8,
    pub bReserved: u8,
    pub HighNumber: i16,
}
impl IMAGE_AUX_SYMBOL_2 {}
impl ::std::default::Default for IMAGE_AUX_SYMBOL_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_AUX_SYMBOL_2 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_AUX_SYMBOL_2 {}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL_2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub struct IMAGE_AUX_SYMBOL_3 {
    pub TagIndex: u32,
    pub Misc: IMAGE_AUX_SYMBOL_3_1,
    pub FcnAry: IMAGE_AUX_SYMBOL_3_0,
    pub TvIndex: u16,
}
impl IMAGE_AUX_SYMBOL_3 {}
impl ::std::default::Default for IMAGE_AUX_SYMBOL_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_AUX_SYMBOL_3 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_AUX_SYMBOL_3 {}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL_3 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union IMAGE_AUX_SYMBOL_3_0 {
    pub Function: IMAGE_AUX_SYMBOL_3_0_1,
    pub Array: IMAGE_AUX_SYMBOL_3_0_0,
}
impl IMAGE_AUX_SYMBOL_3_0 {}
impl ::std::default::Default for IMAGE_AUX_SYMBOL_3_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_AUX_SYMBOL_3_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_AUX_SYMBOL_3_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL_3_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_AUX_SYMBOL_3_0_0 {
    pub Dimension: [u16; 4],
}
impl IMAGE_AUX_SYMBOL_3_0_0 {}
impl ::std::default::Default for IMAGE_AUX_SYMBOL_3_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_AUX_SYMBOL_3_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Array_e__Struct")
            .field("Dimension", &self.Dimension)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_AUX_SYMBOL_3_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Dimension == other.Dimension
    }
}
impl ::std::cmp::Eq for IMAGE_AUX_SYMBOL_3_0_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL_3_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub struct IMAGE_AUX_SYMBOL_3_0_1 {
    pub PointerToLinenumber: u32,
    pub PointerToNextFunction: u32,
}
impl IMAGE_AUX_SYMBOL_3_0_1 {}
impl ::std::default::Default for IMAGE_AUX_SYMBOL_3_0_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_AUX_SYMBOL_3_0_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_AUX_SYMBOL_3_0_1 {}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL_3_0_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub union IMAGE_AUX_SYMBOL_3_1 {
    pub LnSz: IMAGE_AUX_SYMBOL_3_1_0,
    pub TotalSize: u32,
}
impl IMAGE_AUX_SYMBOL_3_1 {}
impl ::std::default::Default for IMAGE_AUX_SYMBOL_3_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_AUX_SYMBOL_3_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_AUX_SYMBOL_3_1 {}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL_3_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_AUX_SYMBOL_3_1_0 {
    pub Linenumber: u16,
    pub Size: u16,
}
impl IMAGE_AUX_SYMBOL_3_1_0 {}
impl ::std::default::Default for IMAGE_AUX_SYMBOL_3_1_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_AUX_SYMBOL_3_1_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_LnSz_e__Struct")
            .field("Linenumber", &self.Linenumber)
            .field("Size", &self.Size)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_AUX_SYMBOL_3_1_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Linenumber == other.Linenumber && self.Size == other.Size
    }
}
impl ::std::cmp::Eq for IMAGE_AUX_SYMBOL_3_1_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL_3_1_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union IMAGE_AUX_SYMBOL_EX {
    pub Sym: IMAGE_AUX_SYMBOL_EX_4,
    pub File: IMAGE_AUX_SYMBOL_EX_2,
    pub Section: IMAGE_AUX_SYMBOL_EX_3,
    pub Anonymous: IMAGE_AUX_SYMBOL_EX_0,
    pub CRC: IMAGE_AUX_SYMBOL_EX_1,
}
impl IMAGE_AUX_SYMBOL_EX {}
impl ::std::default::Default for IMAGE_AUX_SYMBOL_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_AUX_SYMBOL_EX {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_AUX_SYMBOL_EX {}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL_EX {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_AUX_SYMBOL_EX_0 {
    pub TokenDef: IMAGE_AUX_SYMBOL_TOKEN_DEF,
    pub rgbReserved: [u8; 2],
}
impl IMAGE_AUX_SYMBOL_EX_0 {}
impl ::std::default::Default for IMAGE_AUX_SYMBOL_EX_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_AUX_SYMBOL_EX_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_AUX_SYMBOL_EX_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL_EX_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub struct IMAGE_AUX_SYMBOL_EX_1 {
    pub crc: u32,
    pub rgbReserved: [u8; 16],
}
impl IMAGE_AUX_SYMBOL_EX_1 {}
impl ::std::default::Default for IMAGE_AUX_SYMBOL_EX_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_AUX_SYMBOL_EX_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_AUX_SYMBOL_EX_1 {}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL_EX_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_AUX_SYMBOL_EX_2 {
    pub Name: [u8; 20],
}
impl IMAGE_AUX_SYMBOL_EX_2 {}
impl ::std::default::Default for IMAGE_AUX_SYMBOL_EX_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_AUX_SYMBOL_EX_2 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_File_e__Struct")
            .field("Name", &self.Name)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_AUX_SYMBOL_EX_2 {
    fn eq(&self, other: &Self) -> bool {
        self.Name == other.Name
    }
}
impl ::std::cmp::Eq for IMAGE_AUX_SYMBOL_EX_2 {}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL_EX_2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub struct IMAGE_AUX_SYMBOL_EX_3 {
    pub Length: u32,
    pub NumberOfRelocations: u16,
    pub NumberOfLinenumbers: u16,
    pub CheckSum: u32,
    pub Number: i16,
    pub Selection: u8,
    pub bReserved: u8,
    pub HighNumber: i16,
    pub rgbReserved: [u8; 2],
}
impl IMAGE_AUX_SYMBOL_EX_3 {}
impl ::std::default::Default for IMAGE_AUX_SYMBOL_EX_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_AUX_SYMBOL_EX_3 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_AUX_SYMBOL_EX_3 {}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL_EX_3 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub struct IMAGE_AUX_SYMBOL_EX_4 {
    pub WeakDefaultSymIndex: u32,
    pub WeakSearchType: u32,
    pub rgbReserved: [u8; 12],
}
impl IMAGE_AUX_SYMBOL_EX_4 {}
impl ::std::default::Default for IMAGE_AUX_SYMBOL_EX_4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_AUX_SYMBOL_EX_4 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_AUX_SYMBOL_EX_4 {}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL_EX_4 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
    pub bAuxType: u8,
    pub bReserved: u8,
    pub SymbolTableIndex: u32,
    pub rgbReserved: [u8; 12],
}
impl IMAGE_AUX_SYMBOL_TOKEN_DEF {}
impl ::std::default::Default for IMAGE_AUX_SYMBOL_TOKEN_DEF {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_AUX_SYMBOL_TOKEN_DEF {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_AUX_SYMBOL_TOKEN_DEF {}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL_TOKEN_DEF {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct IMAGE_AUX_SYMBOL_TYPE(pub i32);
pub const IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF: IMAGE_AUX_SYMBOL_TYPE = IMAGE_AUX_SYMBOL_TYPE(1i32);
impl ::std::convert::From<i32> for IMAGE_AUX_SYMBOL_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for IMAGE_AUX_SYMBOL_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_BASE_RELOCATION {
    pub VirtualAddress: u32,
    pub SizeOfBlock: u32,
}
impl IMAGE_BASE_RELOCATION {}
impl ::std::default::Default for IMAGE_BASE_RELOCATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_BASE_RELOCATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_BASE_RELOCATION")
            .field("VirtualAddress", &self.VirtualAddress)
            .field("SizeOfBlock", &self.SizeOfBlock)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_BASE_RELOCATION {
    fn eq(&self, other: &Self) -> bool {
        self.VirtualAddress == other.VirtualAddress && self.SizeOfBlock == other.SizeOfBlock
    }
}
impl ::std::cmp::Eq for IMAGE_BASE_RELOCATION {}
unsafe impl ::windows::runtime::Abi for IMAGE_BASE_RELOCATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_BOUND_FORWARDER_REF {
    pub TimeDateStamp: u32,
    pub OffsetModuleName: u16,
    pub Reserved: u16,
}
impl IMAGE_BOUND_FORWARDER_REF {}
impl ::std::default::Default for IMAGE_BOUND_FORWARDER_REF {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_BOUND_FORWARDER_REF {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_BOUND_FORWARDER_REF")
            .field("TimeDateStamp", &self.TimeDateStamp)
            .field("OffsetModuleName", &self.OffsetModuleName)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_BOUND_FORWARDER_REF {
    fn eq(&self, other: &Self) -> bool {
        self.TimeDateStamp == other.TimeDateStamp
            && self.OffsetModuleName == other.OffsetModuleName
            && self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for IMAGE_BOUND_FORWARDER_REF {}
unsafe impl ::windows::runtime::Abi for IMAGE_BOUND_FORWARDER_REF {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_BOUND_IMPORT_DESCRIPTOR {
    pub TimeDateStamp: u32,
    pub OffsetModuleName: u16,
    pub NumberOfModuleForwarderRefs: u16,
}
impl IMAGE_BOUND_IMPORT_DESCRIPTOR {}
impl ::std::default::Default for IMAGE_BOUND_IMPORT_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_BOUND_IMPORT_DESCRIPTOR {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_BOUND_IMPORT_DESCRIPTOR")
            .field("TimeDateStamp", &self.TimeDateStamp)
            .field("OffsetModuleName", &self.OffsetModuleName)
            .field(
                "NumberOfModuleForwarderRefs",
                &self.NumberOfModuleForwarderRefs,
            )
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_BOUND_IMPORT_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.TimeDateStamp == other.TimeDateStamp
            && self.OffsetModuleName == other.OffsetModuleName
            && self.NumberOfModuleForwarderRefs == other.NumberOfModuleForwarderRefs
    }
}
impl ::std::cmp::Eq for IMAGE_BOUND_IMPORT_DESCRIPTOR {}
unsafe impl ::windows::runtime::Abi for IMAGE_BOUND_IMPORT_DESCRIPTOR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    pub FuncStart: u32,
    pub _bitfield: u32,
}
impl IMAGE_CE_RUNTIME_FUNCTION_ENTRY {}
impl ::std::default::Default for IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_CE_RUNTIME_FUNCTION_ENTRY")
            .field("FuncStart", &self.FuncStart)
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.FuncStart == other.FuncStart && self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for IMAGE_CE_RUNTIME_FUNCTION_ENTRY {}
unsafe impl ::windows::runtime::Abi for IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_COMDAT_SELECT_ANY: u32 = 2u32;
pub const IMAGE_COMDAT_SELECT_ASSOCIATIVE: u32 = 5u32;
pub const IMAGE_COMDAT_SELECT_EXACT_MATCH: u32 = 4u32;
pub const IMAGE_COMDAT_SELECT_LARGEST: u32 = 6u32;
pub const IMAGE_COMDAT_SELECT_NEWEST: u32 = 7u32;
pub const IMAGE_COMDAT_SELECT_NODUPLICATES: u32 = 1u32;
pub const IMAGE_COMDAT_SELECT_SAME_SIZE: u32 = 3u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Diagnostics_Debug")]
pub struct IMAGE_COR20_HEADER {
    pub cb: u32,
    pub MajorRuntimeVersion: u16,
    pub MinorRuntimeVersion: u16,
    pub MetaData: super::Diagnostics::Debug::IMAGE_DATA_DIRECTORY,
    pub Flags: u32,
    pub Anonymous: IMAGE_COR20_HEADER_0,
    pub Resources: super::Diagnostics::Debug::IMAGE_DATA_DIRECTORY,
    pub StrongNameSignature: super::Diagnostics::Debug::IMAGE_DATA_DIRECTORY,
    pub CodeManagerTable: super::Diagnostics::Debug::IMAGE_DATA_DIRECTORY,
    pub VTableFixups: super::Diagnostics::Debug::IMAGE_DATA_DIRECTORY,
    pub ExportAddressTableJumps: super::Diagnostics::Debug::IMAGE_DATA_DIRECTORY,
    pub ManagedNativeHeader: super::Diagnostics::Debug::IMAGE_DATA_DIRECTORY,
}
#[cfg(feature = "Win32_System_Diagnostics_Debug")]
impl IMAGE_COR20_HEADER {}
#[cfg(feature = "Win32_System_Diagnostics_Debug")]
impl ::std::default::Default for IMAGE_COR20_HEADER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Diagnostics_Debug")]
impl ::std::cmp::PartialEq for IMAGE_COR20_HEADER {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_Diagnostics_Debug")]
impl ::std::cmp::Eq for IMAGE_COR20_HEADER {}
#[cfg(feature = "Win32_System_Diagnostics_Debug")]
unsafe impl ::windows::runtime::Abi for IMAGE_COR20_HEADER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union IMAGE_COR20_HEADER_0 {
    pub EntryPointToken: u32,
    pub EntryPointRVA: u32,
}
impl IMAGE_COR20_HEADER_0 {}
impl ::std::default::Default for IMAGE_COR20_HEADER_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_COR20_HEADER_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_COR20_HEADER_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_COR20_HEADER_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct IMAGE_DEBUG_MISC {
    pub DataType: u32,
    pub Length: u32,
    pub Unicode: super::super::Foundation::BOOLEAN,
    pub Reserved: [u8; 3],
    pub Data: [u8; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl IMAGE_DEBUG_MISC {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for IMAGE_DEBUG_MISC {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for IMAGE_DEBUG_MISC {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_DEBUG_MISC")
            .field("DataType", &self.DataType)
            .field("Length", &self.Length)
            .field("Unicode", &self.Unicode)
            .field("Reserved", &self.Reserved)
            .field("Data", &self.Data)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for IMAGE_DEBUG_MISC {
    fn eq(&self, other: &Self) -> bool {
        self.DataType == other.DataType
            && self.Length == other.Length
            && self.Unicode == other.Unicode
            && self.Reserved == other.Reserved
            && self.Data == other.Data
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for IMAGE_DEBUG_MISC {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for IMAGE_DEBUG_MISC {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_DEBUG_MISC_EXENAME: u32 = 1u32;
pub const IMAGE_DEBUG_TYPE_CLSID: u32 = 11u32;
pub const IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS: u32 = 20u32;
pub const IMAGE_DEBUG_TYPE_ILTCG: u32 = 14u32;
pub const IMAGE_DEBUG_TYPE_MPX: u32 = 15u32;
pub const IMAGE_DEBUG_TYPE_OMAP_FROM_SRC: u32 = 8u32;
pub const IMAGE_DEBUG_TYPE_OMAP_TO_SRC: u32 = 7u32;
pub const IMAGE_DEBUG_TYPE_POGO: u32 = 13u32;
pub const IMAGE_DEBUG_TYPE_REPRO: u32 = 16u32;
pub const IMAGE_DEBUG_TYPE_RESERVED10: u32 = 10u32;
pub const IMAGE_DEBUG_TYPE_VC_FEATURE: u32 = 12u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_DELAYLOAD_DESCRIPTOR {
    pub Attributes: IMAGE_DELAYLOAD_DESCRIPTOR_0,
    pub DllNameRVA: u32,
    pub ModuleHandleRVA: u32,
    pub ImportAddressTableRVA: u32,
    pub ImportNameTableRVA: u32,
    pub BoundImportAddressTableRVA: u32,
    pub UnloadInformationTableRVA: u32,
    pub TimeDateStamp: u32,
}
impl IMAGE_DELAYLOAD_DESCRIPTOR {}
impl ::std::default::Default for IMAGE_DELAYLOAD_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_DELAYLOAD_DESCRIPTOR {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_DELAYLOAD_DESCRIPTOR {}
unsafe impl ::windows::runtime::Abi for IMAGE_DELAYLOAD_DESCRIPTOR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union IMAGE_DELAYLOAD_DESCRIPTOR_0 {
    pub AllAttributes: u32,
    pub Anonymous: IMAGE_DELAYLOAD_DESCRIPTOR_0_0,
}
impl IMAGE_DELAYLOAD_DESCRIPTOR_0 {}
impl ::std::default::Default for IMAGE_DELAYLOAD_DESCRIPTOR_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_DELAYLOAD_DESCRIPTOR_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_DELAYLOAD_DESCRIPTOR_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_DELAYLOAD_DESCRIPTOR_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_DELAYLOAD_DESCRIPTOR_0_0 {
    pub _bitfield: u32,
}
impl IMAGE_DELAYLOAD_DESCRIPTOR_0_0 {}
impl ::std::default::Default for IMAGE_DELAYLOAD_DESCRIPTOR_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_DELAYLOAD_DESCRIPTOR_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_DELAYLOAD_DESCRIPTOR_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for IMAGE_DELAYLOAD_DESCRIPTOR_0_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_DELAYLOAD_DESCRIPTOR_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub struct IMAGE_DOS_HEADER {
    pub e_magic: u16,
    pub e_cblp: u16,
    pub e_cp: u16,
    pub e_crlc: u16,
    pub e_cparhdr: u16,
    pub e_minalloc: u16,
    pub e_maxalloc: u16,
    pub e_ss: u16,
    pub e_sp: u16,
    pub e_csum: u16,
    pub e_ip: u16,
    pub e_cs: u16,
    pub e_lfarlc: u16,
    pub e_ovno: u16,
    pub e_res: [u16; 4],
    pub e_oemid: u16,
    pub e_oeminfo: u16,
    pub e_res2: [u16; 10],
    pub e_lfanew: i32,
}
impl IMAGE_DOS_HEADER {}
impl ::std::default::Default for IMAGE_DOS_HEADER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_DOS_HEADER {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_DOS_HEADER {}
unsafe impl ::windows::runtime::Abi for IMAGE_DOS_HEADER {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_DOS_SIGNATURE: u32 = 23117u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct IMAGE_DYNAMIC_RELOCATION32 {
    pub Symbol: u32,
    pub BaseRelocSize: u32,
}
impl IMAGE_DYNAMIC_RELOCATION32 {}
impl ::std::default::Default for IMAGE_DYNAMIC_RELOCATION32 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_DYNAMIC_RELOCATION32 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_DYNAMIC_RELOCATION32 {}
unsafe impl ::windows::runtime::Abi for IMAGE_DYNAMIC_RELOCATION32 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct IMAGE_DYNAMIC_RELOCATION32_V2 {
    pub HeaderSize: u32,
    pub FixupInfoSize: u32,
    pub Symbol: u32,
    pub SymbolGroup: u32,
    pub Flags: u32,
}
impl IMAGE_DYNAMIC_RELOCATION32_V2 {}
impl ::std::default::Default for IMAGE_DYNAMIC_RELOCATION32_V2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_DYNAMIC_RELOCATION32_V2 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_DYNAMIC_RELOCATION32_V2 {}
unsafe impl ::windows::runtime::Abi for IMAGE_DYNAMIC_RELOCATION32_V2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct IMAGE_DYNAMIC_RELOCATION64 {
    pub Symbol: u64,
    pub BaseRelocSize: u32,
}
impl IMAGE_DYNAMIC_RELOCATION64 {}
impl ::std::default::Default for IMAGE_DYNAMIC_RELOCATION64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_DYNAMIC_RELOCATION64 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_DYNAMIC_RELOCATION64 {}
unsafe impl ::windows::runtime::Abi for IMAGE_DYNAMIC_RELOCATION64 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct IMAGE_DYNAMIC_RELOCATION64_V2 {
    pub HeaderSize: u32,
    pub FixupInfoSize: u32,
    pub Symbol: u64,
    pub SymbolGroup: u32,
    pub Flags: u32,
}
impl IMAGE_DYNAMIC_RELOCATION64_V2 {}
impl ::std::default::Default for IMAGE_DYNAMIC_RELOCATION64_V2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_DYNAMIC_RELOCATION64_V2 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_DYNAMIC_RELOCATION64_V2 {}
unsafe impl ::windows::runtime::Abi for IMAGE_DYNAMIC_RELOCATION64_V2 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_IMPORT_CONTROL_TRANSFER: u32 = 3u32;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_INDIR_CONTROL_TRANSFER: u32 = 4u32;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_RF_EPILOGUE: u32 = 2u32;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_RF_PROLOGUE: u32 = 1u32;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_SWITCHTABLE_BRANCH: u32 = 5u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_DYNAMIC_RELOCATION_TABLE {
    pub Version: u32,
    pub Size: u32,
}
impl IMAGE_DYNAMIC_RELOCATION_TABLE {}
impl ::std::default::Default for IMAGE_DYNAMIC_RELOCATION_TABLE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_DYNAMIC_RELOCATION_TABLE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_DYNAMIC_RELOCATION_TABLE")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_DYNAMIC_RELOCATION_TABLE {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Size == other.Size
    }
}
impl ::std::cmp::Eq for IMAGE_DYNAMIC_RELOCATION_TABLE {}
unsafe impl ::windows::runtime::Abi for IMAGE_DYNAMIC_RELOCATION_TABLE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_ENCLAVE_FLAG_PRIMARY_IMAGE: u32 = 1u32;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_AUTHOR_ID: u32 = 2u32;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_FAMILY_ID: u32 = 3u32;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_IMAGE_ID: u32 = 4u32;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_NONE: u32 = 0u32;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_UNIQUE_ID: u32 = 1u32;
pub const IMAGE_ENCLAVE_LONG_ID_LENGTH: u32 = 32u32;
pub const IMAGE_ENCLAVE_POLICY_DEBUGGABLE: u32 = 1u32;
pub const IMAGE_ENCLAVE_SHORT_ID_LENGTH: u32 = 16u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER {
    pub EpilogueCount: u32,
    pub EpilogueByteCount: u8,
    pub BranchDescriptorElementSize: u8,
    pub BranchDescriptorCount: u16,
}
impl IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER {}
impl ::std::default::Default for IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER {}
unsafe impl ::windows::runtime::Abi for IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_EXPORT_DIRECTORY {
    pub Characteristics: u32,
    pub TimeDateStamp: u32,
    pub MajorVersion: u16,
    pub MinorVersion: u16,
    pub Name: u32,
    pub Base: u32,
    pub NumberOfFunctions: u32,
    pub NumberOfNames: u32,
    pub AddressOfFunctions: u32,
    pub AddressOfNames: u32,
    pub AddressOfNameOrdinals: u32,
}
impl IMAGE_EXPORT_DIRECTORY {}
impl ::std::default::Default for IMAGE_EXPORT_DIRECTORY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_EXPORT_DIRECTORY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_EXPORT_DIRECTORY")
            .field("Characteristics", &self.Characteristics)
            .field("TimeDateStamp", &self.TimeDateStamp)
            .field("MajorVersion", &self.MajorVersion)
            .field("MinorVersion", &self.MinorVersion)
            .field("Name", &self.Name)
            .field("Base", &self.Base)
            .field("NumberOfFunctions", &self.NumberOfFunctions)
            .field("NumberOfNames", &self.NumberOfNames)
            .field("AddressOfFunctions", &self.AddressOfFunctions)
            .field("AddressOfNames", &self.AddressOfNames)
            .field("AddressOfNameOrdinals", &self.AddressOfNameOrdinals)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_EXPORT_DIRECTORY {
    fn eq(&self, other: &Self) -> bool {
        self.Characteristics == other.Characteristics
            && self.TimeDateStamp == other.TimeDateStamp
            && self.MajorVersion == other.MajorVersion
            && self.MinorVersion == other.MinorVersion
            && self.Name == other.Name
            && self.Base == other.Base
            && self.NumberOfFunctions == other.NumberOfFunctions
            && self.NumberOfNames == other.NumberOfNames
            && self.AddressOfFunctions == other.AddressOfFunctions
            && self.AddressOfNames == other.AddressOfNames
            && self.AddressOfNameOrdinals == other.AddressOfNameOrdinals
    }
}
impl ::std::cmp::Eq for IMAGE_EXPORT_DIRECTORY {}
unsafe impl ::windows::runtime::Abi for IMAGE_EXPORT_DIRECTORY {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_GUARD_CFW_INSTRUMENTED: u32 = 512u32;
pub const IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION: u32 = 32768u32;
pub const IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT: u32 = 16384u32;
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT: u32 = 1024u32;
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK: u32 = 4026531840u32;
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT: u32 = 28u32;
pub const IMAGE_GUARD_CF_INSTRUMENTED: u32 = 256u32;
pub const IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT: u32 = 65536u32;
pub const IMAGE_GUARD_DELAYLOAD_IAT_IN_ITS_OWN_SECTION: u32 = 8192u32;
pub const IMAGE_GUARD_EH_CONTINUATION_TABLE_PRESENT: u32 = 4194304u32;
pub const IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED: u32 = 2u32;
pub const IMAGE_GUARD_FLAG_FID_LANGEXCPTHANDLER: u32 = 4u32;
pub const IMAGE_GUARD_FLAG_FID_SUPPRESSED: u32 = 1u32;
pub const IMAGE_GUARD_FLAG_FID_XFG: u32 = 8u32;
pub const IMAGE_GUARD_PROTECT_DELAYLOAD_IAT: u32 = 4096u32;
pub const IMAGE_GUARD_RETPOLINE_PRESENT: u32 = 1048576u32;
pub const IMAGE_GUARD_RF_ENABLE: u32 = 262144u32;
pub const IMAGE_GUARD_RF_INSTRUMENTED: u32 = 131072u32;
pub const IMAGE_GUARD_RF_STRICT: u32 = 524288u32;
pub const IMAGE_GUARD_SECURITY_COOKIE_UNUSED: u32 = 2048u32;
pub const IMAGE_GUARD_XFG_ENABLED: u32 = 8388608u32;
pub const IMAGE_HOT_PATCH_ABSOLUTE: u32 = 180224u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_HOT_PATCH_BASE {
    pub SequenceNumber: u32,
    pub Flags: u32,
    pub OriginalTimeDateStamp: u32,
    pub OriginalCheckSum: u32,
    pub CodeIntegrityInfo: u32,
    pub CodeIntegritySize: u32,
    pub PatchTable: u32,
    pub BufferOffset: u32,
}
impl IMAGE_HOT_PATCH_BASE {}
impl ::std::default::Default for IMAGE_HOT_PATCH_BASE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_HOT_PATCH_BASE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_HOT_PATCH_BASE")
            .field("SequenceNumber", &self.SequenceNumber)
            .field("Flags", &self.Flags)
            .field("OriginalTimeDateStamp", &self.OriginalTimeDateStamp)
            .field("OriginalCheckSum", &self.OriginalCheckSum)
            .field("CodeIntegrityInfo", &self.CodeIntegrityInfo)
            .field("CodeIntegritySize", &self.CodeIntegritySize)
            .field("PatchTable", &self.PatchTable)
            .field("BufferOffset", &self.BufferOffset)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_HOT_PATCH_BASE {
    fn eq(&self, other: &Self) -> bool {
        self.SequenceNumber == other.SequenceNumber
            && self.Flags == other.Flags
            && self.OriginalTimeDateStamp == other.OriginalTimeDateStamp
            && self.OriginalCheckSum == other.OriginalCheckSum
            && self.CodeIntegrityInfo == other.CodeIntegrityInfo
            && self.CodeIntegritySize == other.CodeIntegritySize
            && self.PatchTable == other.PatchTable
            && self.BufferOffset == other.BufferOffset
    }
}
impl ::std::cmp::Eq for IMAGE_HOT_PATCH_BASE {}
unsafe impl ::windows::runtime::Abi for IMAGE_HOT_PATCH_BASE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_HOT_PATCH_BASE_CAN_ROLL_BACK: u32 = 2u32;
pub const IMAGE_HOT_PATCH_BASE_OBLIGATORY: u32 = 1u32;
pub const IMAGE_HOT_PATCH_CALL_TARGET: u32 = 278528u32;
pub const IMAGE_HOT_PATCH_CHUNK_INVERSE: u32 = 2147483648u32;
pub const IMAGE_HOT_PATCH_CHUNK_OBLIGATORY: u32 = 1073741824u32;
pub const IMAGE_HOT_PATCH_CHUNK_RESERVED: u32 = 1072705536u32;
pub const IMAGE_HOT_PATCH_CHUNK_SIZE: u32 = 4095u32;
pub const IMAGE_HOT_PATCH_CHUNK_SOURCE_RVA: u32 = 32768u32;
pub const IMAGE_HOT_PATCH_CHUNK_TARGET_RVA: u32 = 16384u32;
pub const IMAGE_HOT_PATCH_CHUNK_TYPE: u32 = 1032192u32;
pub const IMAGE_HOT_PATCH_DYNAMIC_VALUE: u32 = 491520u32;
pub const IMAGE_HOT_PATCH_FUNCTION: u32 = 114688u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_HOT_PATCH_HASHES {
    pub SHA256: [u8; 32],
    pub SHA1: [u8; 20],
}
impl IMAGE_HOT_PATCH_HASHES {}
impl ::std::default::Default for IMAGE_HOT_PATCH_HASHES {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_HOT_PATCH_HASHES {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_HOT_PATCH_HASHES")
            .field("SHA256", &self.SHA256)
            .field("SHA1", &self.SHA1)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_HOT_PATCH_HASHES {
    fn eq(&self, other: &Self) -> bool {
        self.SHA256 == other.SHA256 && self.SHA1 == other.SHA1
    }
}
impl ::std::cmp::Eq for IMAGE_HOT_PATCH_HASHES {}
unsafe impl ::windows::runtime::Abi for IMAGE_HOT_PATCH_HASHES {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_HOT_PATCH_INDIRECT: u32 = 376832u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_HOT_PATCH_INFO {
    pub Version: u32,
    pub Size: u32,
    pub SequenceNumber: u32,
    pub BaseImageList: u32,
    pub BaseImageCount: u32,
    pub BufferOffset: u32,
    pub ExtraPatchSize: u32,
}
impl IMAGE_HOT_PATCH_INFO {}
impl ::std::default::Default for IMAGE_HOT_PATCH_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_HOT_PATCH_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_HOT_PATCH_INFO")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("SequenceNumber", &self.SequenceNumber)
            .field("BaseImageList", &self.BaseImageList)
            .field("BaseImageCount", &self.BaseImageCount)
            .field("BufferOffset", &self.BufferOffset)
            .field("ExtraPatchSize", &self.ExtraPatchSize)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_HOT_PATCH_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.SequenceNumber == other.SequenceNumber
            && self.BaseImageList == other.BaseImageList
            && self.BaseImageCount == other.BaseImageCount
            && self.BufferOffset == other.BufferOffset
            && self.ExtraPatchSize == other.ExtraPatchSize
    }
}
impl ::std::cmp::Eq for IMAGE_HOT_PATCH_INFO {}
unsafe impl ::windows::runtime::Abi for IMAGE_HOT_PATCH_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_HOT_PATCH_NONE: u32 = 0u32;
pub const IMAGE_HOT_PATCH_NO_CALL_TARGET: u32 = 409600u32;
pub const IMAGE_HOT_PATCH_REL32: u32 = 245760u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_IMPORT_BY_NAME {
    pub Hint: u16,
    pub Name: [CHAR; 1],
}
impl IMAGE_IMPORT_BY_NAME {}
impl ::std::default::Default for IMAGE_IMPORT_BY_NAME {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_IMPORT_BY_NAME {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_IMPORT_BY_NAME")
            .field("Hint", &self.Hint)
            .field("Name", &self.Name)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_IMPORT_BY_NAME {
    fn eq(&self, other: &Self) -> bool {
        self.Hint == other.Hint && self.Name == other.Name
    }
}
impl ::std::cmp::Eq for IMAGE_IMPORT_BY_NAME {}
unsafe impl ::windows::runtime::Abi for IMAGE_IMPORT_BY_NAME {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    pub _bitfield: u32,
}
impl IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION {}
impl ::std::default::Default for IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION {}
unsafe impl ::windows::runtime::Abi for IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_IMPORT_DESCRIPTOR {
    pub Anonymous: IMAGE_IMPORT_DESCRIPTOR_0,
    pub TimeDateStamp: u32,
    pub ForwarderChain: u32,
    pub Name: u32,
    pub FirstThunk: u32,
}
impl IMAGE_IMPORT_DESCRIPTOR {}
impl ::std::default::Default for IMAGE_IMPORT_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_IMPORT_DESCRIPTOR {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_IMPORT_DESCRIPTOR {}
unsafe impl ::windows::runtime::Abi for IMAGE_IMPORT_DESCRIPTOR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union IMAGE_IMPORT_DESCRIPTOR_0 {
    pub Characteristics: u32,
    pub OriginalFirstThunk: u32,
}
impl IMAGE_IMPORT_DESCRIPTOR_0 {}
impl ::std::default::Default for IMAGE_IMPORT_DESCRIPTOR_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_IMPORT_DESCRIPTOR_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_IMPORT_DESCRIPTOR_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_IMPORT_DESCRIPTOR_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    pub _bitfield: u16,
}
impl IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION {}
impl ::std::default::Default for IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION {}
unsafe impl ::windows::runtime::Abi for IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_LINENUMBER {
    pub Type: IMAGE_LINENUMBER_0,
    pub Linenumber: u16,
}
impl IMAGE_LINENUMBER {}
impl ::std::default::Default for IMAGE_LINENUMBER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_LINENUMBER {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_LINENUMBER {}
unsafe impl ::windows::runtime::Abi for IMAGE_LINENUMBER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub union IMAGE_LINENUMBER_0 {
    pub SymbolTableIndex: u32,
    pub VirtualAddress: u32,
}
impl IMAGE_LINENUMBER_0 {}
impl ::std::default::Default for IMAGE_LINENUMBER_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_LINENUMBER_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_LINENUMBER_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_LINENUMBER_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_LOAD_CONFIG_CODE_INTEGRITY {
    pub Flags: u16,
    pub Catalog: u16,
    pub CatalogOffset: u32,
    pub Reserved: u32,
}
impl IMAGE_LOAD_CONFIG_CODE_INTEGRITY {}
impl ::std::default::Default for IMAGE_LOAD_CONFIG_CODE_INTEGRITY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_LOAD_CONFIG_CODE_INTEGRITY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_LOAD_CONFIG_CODE_INTEGRITY")
            .field("Flags", &self.Flags)
            .field("Catalog", &self.Catalog)
            .field("CatalogOffset", &self.CatalogOffset)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_LOAD_CONFIG_CODE_INTEGRITY {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
            && self.Catalog == other.Catalog
            && self.CatalogOffset == other.CatalogOffset
            && self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for IMAGE_LOAD_CONFIG_CODE_INTEGRITY {}
unsafe impl ::windows::runtime::Abi for IMAGE_LOAD_CONFIG_CODE_INTEGRITY {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_NT_SIGNATURE: u32 = 17744u32;
pub const IMAGE_NUMBEROF_DIRECTORY_ENTRIES: u32 = 16u32;
pub const IMAGE_ORDINAL_FLAG: u64 = 9223372036854775808u64;
pub const IMAGE_ORDINAL_FLAG32: u32 = 2147483648u32;
pub const IMAGE_ORDINAL_FLAG64: u64 = 9223372036854775808u64;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub struct IMAGE_OS2_HEADER {
    pub ne_magic: u16,
    pub ne_ver: CHAR,
    pub ne_rev: CHAR,
    pub ne_enttab: u16,
    pub ne_cbenttab: u16,
    pub ne_crc: i32,
    pub ne_flags: u16,
    pub ne_autodata: u16,
    pub ne_heap: u16,
    pub ne_stack: u16,
    pub ne_csip: i32,
    pub ne_sssp: i32,
    pub ne_cseg: u16,
    pub ne_cmod: u16,
    pub ne_cbnrestab: u16,
    pub ne_segtab: u16,
    pub ne_rsrctab: u16,
    pub ne_restab: u16,
    pub ne_modtab: u16,
    pub ne_imptab: u16,
    pub ne_nrestab: i32,
    pub ne_cmovent: u16,
    pub ne_align: u16,
    pub ne_cres: u16,
    pub ne_exetyp: u8,
    pub ne_flagsothers: u8,
    pub ne_pretthunks: u16,
    pub ne_psegrefbytes: u16,
    pub ne_swaparea: u16,
    pub ne_expver: u16,
}
impl IMAGE_OS2_HEADER {}
impl ::std::default::Default for IMAGE_OS2_HEADER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_OS2_HEADER {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_OS2_HEADER {}
unsafe impl ::windows::runtime::Abi for IMAGE_OS2_HEADER {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_OS2_SIGNATURE: u32 = 17742u32;
pub const IMAGE_OS2_SIGNATURE_LE: u32 = 17740u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct IMAGE_POLICY_ENTRY {
    pub Type: IMAGE_POLICY_ENTRY_TYPE,
    pub PolicyId: IMAGE_POLICY_ID,
    pub u: IMAGE_POLICY_ENTRY_0,
}
#[cfg(feature = "Win32_Foundation")]
impl IMAGE_POLICY_ENTRY {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for IMAGE_POLICY_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for IMAGE_POLICY_ENTRY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for IMAGE_POLICY_ENTRY {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for IMAGE_POLICY_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub union IMAGE_POLICY_ENTRY_0 {
    pub None: *mut ::std::ffi::c_void,
    pub BoolValue: super::super::Foundation::BOOLEAN,
    pub Int8Value: i8,
    pub UInt8Value: u8,
    pub Int16Value: i16,
    pub UInt16Value: u16,
    pub Int32Value: i32,
    pub UInt32Value: u32,
    pub Int64Value: i64,
    pub UInt64Value: u64,
    pub AnsiStringValue: super::super::Foundation::PSTR,
    pub UnicodeStringValue: super::super::Foundation::PWSTR,
}
#[cfg(feature = "Win32_Foundation")]
impl IMAGE_POLICY_ENTRY_0 {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for IMAGE_POLICY_ENTRY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for IMAGE_POLICY_ENTRY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for IMAGE_POLICY_ENTRY_0 {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for IMAGE_POLICY_ENTRY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct IMAGE_POLICY_ENTRY_TYPE(pub i32);
pub const ImagePolicyEntryTypeNone: IMAGE_POLICY_ENTRY_TYPE = IMAGE_POLICY_ENTRY_TYPE(0i32);
pub const ImagePolicyEntryTypeBool: IMAGE_POLICY_ENTRY_TYPE = IMAGE_POLICY_ENTRY_TYPE(1i32);
pub const ImagePolicyEntryTypeInt8: IMAGE_POLICY_ENTRY_TYPE = IMAGE_POLICY_ENTRY_TYPE(2i32);
pub const ImagePolicyEntryTypeUInt8: IMAGE_POLICY_ENTRY_TYPE = IMAGE_POLICY_ENTRY_TYPE(3i32);
pub const ImagePolicyEntryTypeInt16: IMAGE_POLICY_ENTRY_TYPE = IMAGE_POLICY_ENTRY_TYPE(4i32);
pub const ImagePolicyEntryTypeUInt16: IMAGE_POLICY_ENTRY_TYPE = IMAGE_POLICY_ENTRY_TYPE(5i32);
pub const ImagePolicyEntryTypeInt32: IMAGE_POLICY_ENTRY_TYPE = IMAGE_POLICY_ENTRY_TYPE(6i32);
pub const ImagePolicyEntryTypeUInt32: IMAGE_POLICY_ENTRY_TYPE = IMAGE_POLICY_ENTRY_TYPE(7i32);
pub const ImagePolicyEntryTypeInt64: IMAGE_POLICY_ENTRY_TYPE = IMAGE_POLICY_ENTRY_TYPE(8i32);
pub const ImagePolicyEntryTypeUInt64: IMAGE_POLICY_ENTRY_TYPE = IMAGE_POLICY_ENTRY_TYPE(9i32);
pub const ImagePolicyEntryTypeAnsiString: IMAGE_POLICY_ENTRY_TYPE = IMAGE_POLICY_ENTRY_TYPE(10i32);
pub const ImagePolicyEntryTypeUnicodeString: IMAGE_POLICY_ENTRY_TYPE =
    IMAGE_POLICY_ENTRY_TYPE(11i32);
pub const ImagePolicyEntryTypeOverride: IMAGE_POLICY_ENTRY_TYPE = IMAGE_POLICY_ENTRY_TYPE(12i32);
pub const ImagePolicyEntryTypeMaximum: IMAGE_POLICY_ENTRY_TYPE = IMAGE_POLICY_ENTRY_TYPE(13i32);
impl ::std::convert::From<i32> for IMAGE_POLICY_ENTRY_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for IMAGE_POLICY_ENTRY_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct IMAGE_POLICY_ID(pub i32);
pub const ImagePolicyIdNone: IMAGE_POLICY_ID = IMAGE_POLICY_ID(0i32);
pub const ImagePolicyIdEtw: IMAGE_POLICY_ID = IMAGE_POLICY_ID(1i32);
pub const ImagePolicyIdDebug: IMAGE_POLICY_ID = IMAGE_POLICY_ID(2i32);
pub const ImagePolicyIdCrashDump: IMAGE_POLICY_ID = IMAGE_POLICY_ID(3i32);
pub const ImagePolicyIdCrashDumpKey: IMAGE_POLICY_ID = IMAGE_POLICY_ID(4i32);
pub const ImagePolicyIdCrashDumpKeyGuid: IMAGE_POLICY_ID = IMAGE_POLICY_ID(5i32);
pub const ImagePolicyIdParentSd: IMAGE_POLICY_ID = IMAGE_POLICY_ID(6i32);
pub const ImagePolicyIdParentSdRev: IMAGE_POLICY_ID = IMAGE_POLICY_ID(7i32);
pub const ImagePolicyIdSvn: IMAGE_POLICY_ID = IMAGE_POLICY_ID(8i32);
pub const ImagePolicyIdDeviceId: IMAGE_POLICY_ID = IMAGE_POLICY_ID(9i32);
pub const ImagePolicyIdCapability: IMAGE_POLICY_ID = IMAGE_POLICY_ID(10i32);
pub const ImagePolicyIdScenarioId: IMAGE_POLICY_ID = IMAGE_POLICY_ID(11i32);
pub const ImagePolicyIdMaximum: IMAGE_POLICY_ID = IMAGE_POLICY_ID(12i32);
impl ::std::convert::From<i32> for IMAGE_POLICY_ID {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for IMAGE_POLICY_ID {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct IMAGE_POLICY_METADATA {
    pub Version: u8,
    pub Reserved0: [u8; 7],
    pub ApplicationId: u64,
    pub Policies: [IMAGE_POLICY_ENTRY; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl IMAGE_POLICY_METADATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for IMAGE_POLICY_METADATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for IMAGE_POLICY_METADATA {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for IMAGE_POLICY_METADATA {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for IMAGE_POLICY_METADATA {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_POLICY_METADATA_VERSION: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER {
    pub PrologueByteCount: u8,
}
impl IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER {}
impl ::std::default::Default for IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER")
            .field("PrologueByteCount", &self.PrologueByteCount)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER {
    fn eq(&self, other: &Self) -> bool {
        self.PrologueByteCount == other.PrologueByteCount
    }
}
impl ::std::cmp::Eq for IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER {}
unsafe impl ::windows::runtime::Abi for IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub struct IMAGE_RELOCATION {
    pub Anonymous: IMAGE_RELOCATION_0,
    pub SymbolTableIndex: u32,
    pub Type: u16,
}
impl IMAGE_RELOCATION {}
impl ::std::default::Default for IMAGE_RELOCATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_RELOCATION {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_RELOCATION {}
unsafe impl ::windows::runtime::Abi for IMAGE_RELOCATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub union IMAGE_RELOCATION_0 {
    pub VirtualAddress: u32,
    pub RelocCount: u32,
}
impl IMAGE_RELOCATION_0 {}
impl ::std::default::Default for IMAGE_RELOCATION_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_RELOCATION_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_RELOCATION_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_RELOCATION_0 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_REL_ALPHA_ABSOLUTE: u32 = 0u32;
pub const IMAGE_REL_ALPHA_BRADDR: u32 = 7u32;
pub const IMAGE_REL_ALPHA_GPDISP: u32 = 6u32;
pub const IMAGE_REL_ALPHA_GPREL32: u32 = 3u32;
pub const IMAGE_REL_ALPHA_GPRELHI: u32 = 23u32;
pub const IMAGE_REL_ALPHA_GPRELLO: u32 = 22u32;
pub const IMAGE_REL_ALPHA_HINT: u32 = 8u32;
pub const IMAGE_REL_ALPHA_INLINE_REFLONG: u32 = 9u32;
pub const IMAGE_REL_ALPHA_LITERAL: u32 = 4u32;
pub const IMAGE_REL_ALPHA_LITUSE: u32 = 5u32;
pub const IMAGE_REL_ALPHA_MATCH: u32 = 13u32;
pub const IMAGE_REL_ALPHA_PAIR: u32 = 12u32;
pub const IMAGE_REL_ALPHA_REFHI: u32 = 10u32;
pub const IMAGE_REL_ALPHA_REFLO: u32 = 11u32;
pub const IMAGE_REL_ALPHA_REFLONG: u32 = 1u32;
pub const IMAGE_REL_ALPHA_REFLONGNB: u32 = 16u32;
pub const IMAGE_REL_ALPHA_REFQ1: u32 = 21u32;
pub const IMAGE_REL_ALPHA_REFQ2: u32 = 20u32;
pub const IMAGE_REL_ALPHA_REFQ3: u32 = 19u32;
pub const IMAGE_REL_ALPHA_REFQUAD: u32 = 2u32;
pub const IMAGE_REL_ALPHA_SECREL: u32 = 15u32;
pub const IMAGE_REL_ALPHA_SECRELHI: u32 = 18u32;
pub const IMAGE_REL_ALPHA_SECRELLO: u32 = 17u32;
pub const IMAGE_REL_ALPHA_SECTION: u32 = 14u32;
pub const IMAGE_REL_AMD64_ABSOLUTE: u32 = 0u32;
pub const IMAGE_REL_AMD64_ADDR32: u32 = 2u32;
pub const IMAGE_REL_AMD64_ADDR32NB: u32 = 3u32;
pub const IMAGE_REL_AMD64_ADDR64: u32 = 1u32;
pub const IMAGE_REL_AMD64_CFG_BR: u32 = 20u32;
pub const IMAGE_REL_AMD64_CFG_BR_REX: u32 = 21u32;
pub const IMAGE_REL_AMD64_CFG_CALL: u32 = 22u32;
pub const IMAGE_REL_AMD64_EHANDLER: u32 = 17u32;
pub const IMAGE_REL_AMD64_IMPORT_BR: u32 = 18u32;
pub const IMAGE_REL_AMD64_IMPORT_CALL: u32 = 19u32;
pub const IMAGE_REL_AMD64_INDIR_BR: u32 = 23u32;
pub const IMAGE_REL_AMD64_INDIR_BR_REX: u32 = 24u32;
pub const IMAGE_REL_AMD64_INDIR_BR_SWITCHTABLE_FIRST: u32 = 32u32;
pub const IMAGE_REL_AMD64_INDIR_BR_SWITCHTABLE_LAST: u32 = 47u32;
pub const IMAGE_REL_AMD64_INDIR_CALL: u32 = 25u32;
pub const IMAGE_REL_AMD64_PAIR: u32 = 15u32;
pub const IMAGE_REL_AMD64_REL32: u32 = 4u32;
pub const IMAGE_REL_AMD64_REL32_1: u32 = 5u32;
pub const IMAGE_REL_AMD64_REL32_2: u32 = 6u32;
pub const IMAGE_REL_AMD64_REL32_3: u32 = 7u32;
pub const IMAGE_REL_AMD64_REL32_4: u32 = 8u32;
pub const IMAGE_REL_AMD64_REL32_5: u32 = 9u32;
pub const IMAGE_REL_AMD64_SECREL: u32 = 11u32;
pub const IMAGE_REL_AMD64_SECREL7: u32 = 12u32;
pub const IMAGE_REL_AMD64_SECTION: u32 = 10u32;
pub const IMAGE_REL_AMD64_SREL32: u32 = 14u32;
pub const IMAGE_REL_AMD64_SSPAN32: u32 = 16u32;
pub const IMAGE_REL_AMD64_TOKEN: u32 = 13u32;
pub const IMAGE_REL_AM_ABSOLUTE: u32 = 0u32;
pub const IMAGE_REL_AM_ADDR32: u32 = 1u32;
pub const IMAGE_REL_AM_ADDR32NB: u32 = 2u32;
pub const IMAGE_REL_AM_CALL32: u32 = 3u32;
pub const IMAGE_REL_AM_FUNCINFO: u32 = 4u32;
pub const IMAGE_REL_AM_REL32_1: u32 = 5u32;
pub const IMAGE_REL_AM_REL32_2: u32 = 6u32;
pub const IMAGE_REL_AM_SECREL: u32 = 7u32;
pub const IMAGE_REL_AM_SECTION: u32 = 8u32;
pub const IMAGE_REL_AM_TOKEN: u32 = 9u32;
pub const IMAGE_REL_ARM64_ABSOLUTE: u32 = 0u32;
pub const IMAGE_REL_ARM64_ADDR32: u32 = 1u32;
pub const IMAGE_REL_ARM64_ADDR32NB: u32 = 2u32;
pub const IMAGE_REL_ARM64_ADDR64: u32 = 14u32;
pub const IMAGE_REL_ARM64_BRANCH19: u32 = 15u32;
pub const IMAGE_REL_ARM64_BRANCH26: u32 = 3u32;
pub const IMAGE_REL_ARM64_PAGEBASE_REL21: u32 = 4u32;
pub const IMAGE_REL_ARM64_PAGEOFFSET_12A: u32 = 6u32;
pub const IMAGE_REL_ARM64_PAGEOFFSET_12L: u32 = 7u32;
pub const IMAGE_REL_ARM64_REL21: u32 = 5u32;
pub const IMAGE_REL_ARM64_SECREL: u32 = 8u32;
pub const IMAGE_REL_ARM64_SECREL_HIGH12A: u32 = 10u32;
pub const IMAGE_REL_ARM64_SECREL_LOW12A: u32 = 9u32;
pub const IMAGE_REL_ARM64_SECREL_LOW12L: u32 = 11u32;
pub const IMAGE_REL_ARM64_SECTION: u32 = 13u32;
pub const IMAGE_REL_ARM64_TOKEN: u32 = 12u32;
pub const IMAGE_REL_ARM_ABSOLUTE: u32 = 0u32;
pub const IMAGE_REL_ARM_ADDR32: u32 = 1u32;
pub const IMAGE_REL_ARM_ADDR32NB: u32 = 2u32;
pub const IMAGE_REL_ARM_BLX11: u32 = 9u32;
pub const IMAGE_REL_ARM_BLX23T: u32 = 21u32;
pub const IMAGE_REL_ARM_BLX24: u32 = 8u32;
pub const IMAGE_REL_ARM_BRANCH11: u32 = 4u32;
pub const IMAGE_REL_ARM_BRANCH20T: u32 = 18u32;
pub const IMAGE_REL_ARM_BRANCH24: u32 = 3u32;
pub const IMAGE_REL_ARM_BRANCH24T: u32 = 20u32;
pub const IMAGE_REL_ARM_GPREL12: u32 = 6u32;
pub const IMAGE_REL_ARM_GPREL7: u32 = 7u32;
pub const IMAGE_REL_ARM_MOV32: u32 = 16u32;
pub const IMAGE_REL_ARM_MOV32A: u32 = 16u32;
pub const IMAGE_REL_ARM_MOV32T: u32 = 17u32;
pub const IMAGE_REL_ARM_SECREL: u32 = 15u32;
pub const IMAGE_REL_ARM_SECTION: u32 = 14u32;
pub const IMAGE_REL_ARM_TOKEN: u32 = 5u32;
pub const IMAGE_REL_BASED_ABSOLUTE: u32 = 0u32;
pub const IMAGE_REL_BASED_ARM_MOV32: u32 = 5u32;
pub const IMAGE_REL_BASED_DIR64: u32 = 10u32;
pub const IMAGE_REL_BASED_HIGH: u32 = 1u32;
pub const IMAGE_REL_BASED_HIGHADJ: u32 = 4u32;
pub const IMAGE_REL_BASED_HIGHLOW: u32 = 3u32;
pub const IMAGE_REL_BASED_IA64_IMM64: u32 = 9u32;
pub const IMAGE_REL_BASED_LOW: u32 = 2u32;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_5: u32 = 5u32;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_7: u32 = 7u32;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_8: u32 = 8u32;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_9: u32 = 9u32;
pub const IMAGE_REL_BASED_MIPS_JMPADDR: u32 = 5u32;
pub const IMAGE_REL_BASED_MIPS_JMPADDR16: u32 = 9u32;
pub const IMAGE_REL_BASED_RESERVED: u32 = 6u32;
pub const IMAGE_REL_BASED_THUMB_MOV32: u32 = 7u32;
pub const IMAGE_REL_CEE_ABSOLUTE: u32 = 0u32;
pub const IMAGE_REL_CEE_ADDR32: u32 = 1u32;
pub const IMAGE_REL_CEE_ADDR32NB: u32 = 3u32;
pub const IMAGE_REL_CEE_ADDR64: u32 = 2u32;
pub const IMAGE_REL_CEE_SECREL: u32 = 5u32;
pub const IMAGE_REL_CEE_SECTION: u32 = 4u32;
pub const IMAGE_REL_CEE_TOKEN: u32 = 6u32;
pub const IMAGE_REL_CEF_ABSOLUTE: u32 = 0u32;
pub const IMAGE_REL_CEF_ADDR32: u32 = 1u32;
pub const IMAGE_REL_CEF_ADDR32NB: u32 = 3u32;
pub const IMAGE_REL_CEF_ADDR64: u32 = 2u32;
pub const IMAGE_REL_CEF_SECREL: u32 = 5u32;
pub const IMAGE_REL_CEF_SECTION: u32 = 4u32;
pub const IMAGE_REL_CEF_TOKEN: u32 = 6u32;
pub const IMAGE_REL_EBC_ABSOLUTE: u32 = 0u32;
pub const IMAGE_REL_EBC_ADDR32NB: u32 = 1u32;
pub const IMAGE_REL_EBC_REL32: u32 = 2u32;
pub const IMAGE_REL_EBC_SECREL: u32 = 4u32;
pub const IMAGE_REL_EBC_SECTION: u32 = 3u32;
pub const IMAGE_REL_I386_ABSOLUTE: u32 = 0u32;
pub const IMAGE_REL_I386_DIR16: u32 = 1u32;
pub const IMAGE_REL_I386_DIR32: u32 = 6u32;
pub const IMAGE_REL_I386_DIR32NB: u32 = 7u32;
pub const IMAGE_REL_I386_REL16: u32 = 2u32;
pub const IMAGE_REL_I386_REL32: u32 = 20u32;
pub const IMAGE_REL_I386_SECREL: u32 = 11u32;
pub const IMAGE_REL_I386_SECREL7: u32 = 13u32;
pub const IMAGE_REL_I386_SECTION: u32 = 10u32;
pub const IMAGE_REL_I386_SEG12: u32 = 9u32;
pub const IMAGE_REL_I386_TOKEN: u32 = 12u32;
pub const IMAGE_REL_IA64_ABSOLUTE: u32 = 0u32;
pub const IMAGE_REL_IA64_ADDEND: u32 = 31u32;
pub const IMAGE_REL_IA64_DIR32: u32 = 4u32;
pub const IMAGE_REL_IA64_DIR32NB: u32 = 16u32;
pub const IMAGE_REL_IA64_DIR64: u32 = 5u32;
pub const IMAGE_REL_IA64_GPREL22: u32 = 9u32;
pub const IMAGE_REL_IA64_GPREL32: u32 = 28u32;
pub const IMAGE_REL_IA64_IMM14: u32 = 1u32;
pub const IMAGE_REL_IA64_IMM22: u32 = 2u32;
pub const IMAGE_REL_IA64_IMM64: u32 = 3u32;
pub const IMAGE_REL_IA64_IMMGPREL64: u32 = 26u32;
pub const IMAGE_REL_IA64_LTOFF22: u32 = 10u32;
pub const IMAGE_REL_IA64_PCREL21B: u32 = 6u32;
pub const IMAGE_REL_IA64_PCREL21F: u32 = 8u32;
pub const IMAGE_REL_IA64_PCREL21M: u32 = 7u32;
pub const IMAGE_REL_IA64_PCREL60B: u32 = 22u32;
pub const IMAGE_REL_IA64_PCREL60F: u32 = 23u32;
pub const IMAGE_REL_IA64_PCREL60I: u32 = 24u32;
pub const IMAGE_REL_IA64_PCREL60M: u32 = 25u32;
pub const IMAGE_REL_IA64_PCREL60X: u32 = 21u32;
pub const IMAGE_REL_IA64_SECREL22: u32 = 12u32;
pub const IMAGE_REL_IA64_SECREL32: u32 = 14u32;
pub const IMAGE_REL_IA64_SECREL64I: u32 = 13u32;
pub const IMAGE_REL_IA64_SECTION: u32 = 11u32;
pub const IMAGE_REL_IA64_SREL14: u32 = 17u32;
pub const IMAGE_REL_IA64_SREL22: u32 = 18u32;
pub const IMAGE_REL_IA64_SREL32: u32 = 19u32;
pub const IMAGE_REL_IA64_TOKEN: u32 = 27u32;
pub const IMAGE_REL_IA64_UREL32: u32 = 20u32;
pub const IMAGE_REL_M32R_ABSOLUTE: u32 = 0u32;
pub const IMAGE_REL_M32R_ADDR24: u32 = 3u32;
pub const IMAGE_REL_M32R_ADDR32: u32 = 1u32;
pub const IMAGE_REL_M32R_ADDR32NB: u32 = 2u32;
pub const IMAGE_REL_M32R_GPREL16: u32 = 4u32;
pub const IMAGE_REL_M32R_PAIR: u32 = 11u32;
pub const IMAGE_REL_M32R_PCREL16: u32 = 6u32;
pub const IMAGE_REL_M32R_PCREL24: u32 = 5u32;
pub const IMAGE_REL_M32R_PCREL8: u32 = 7u32;
pub const IMAGE_REL_M32R_REFHALF: u32 = 8u32;
pub const IMAGE_REL_M32R_REFHI: u32 = 9u32;
pub const IMAGE_REL_M32R_REFLO: u32 = 10u32;
pub const IMAGE_REL_M32R_SECREL32: u32 = 13u32;
pub const IMAGE_REL_M32R_SECTION: u32 = 12u32;
pub const IMAGE_REL_M32R_TOKEN: u32 = 14u32;
pub const IMAGE_REL_MIPS_ABSOLUTE: u32 = 0u32;
pub const IMAGE_REL_MIPS_GPREL: u32 = 6u32;
pub const IMAGE_REL_MIPS_JMPADDR: u32 = 3u32;
pub const IMAGE_REL_MIPS_JMPADDR16: u32 = 16u32;
pub const IMAGE_REL_MIPS_LITERAL: u32 = 7u32;
pub const IMAGE_REL_MIPS_PAIR: u32 = 37u32;
pub const IMAGE_REL_MIPS_REFHALF: u32 = 1u32;
pub const IMAGE_REL_MIPS_REFHI: u32 = 4u32;
pub const IMAGE_REL_MIPS_REFLO: u32 = 5u32;
pub const IMAGE_REL_MIPS_REFWORD: u32 = 2u32;
pub const IMAGE_REL_MIPS_REFWORDNB: u32 = 34u32;
pub const IMAGE_REL_MIPS_SECREL: u32 = 11u32;
pub const IMAGE_REL_MIPS_SECRELHI: u32 = 13u32;
pub const IMAGE_REL_MIPS_SECRELLO: u32 = 12u32;
pub const IMAGE_REL_MIPS_SECTION: u32 = 10u32;
pub const IMAGE_REL_MIPS_TOKEN: u32 = 14u32;
pub const IMAGE_REL_PPC_ABSOLUTE: u32 = 0u32;
pub const IMAGE_REL_PPC_ADDR14: u32 = 5u32;
pub const IMAGE_REL_PPC_ADDR16: u32 = 4u32;
pub const IMAGE_REL_PPC_ADDR24: u32 = 3u32;
pub const IMAGE_REL_PPC_ADDR32: u32 = 2u32;
pub const IMAGE_REL_PPC_ADDR32NB: u32 = 10u32;
pub const IMAGE_REL_PPC_ADDR64: u32 = 1u32;
pub const IMAGE_REL_PPC_BRNTAKEN: u32 = 1024u32;
pub const IMAGE_REL_PPC_BRTAKEN: u32 = 512u32;
pub const IMAGE_REL_PPC_GPREL: u32 = 21u32;
pub const IMAGE_REL_PPC_IFGLUE: u32 = 13u32;
pub const IMAGE_REL_PPC_IMGLUE: u32 = 14u32;
pub const IMAGE_REL_PPC_NEG: u32 = 256u32;
pub const IMAGE_REL_PPC_PAIR: u32 = 18u32;
pub const IMAGE_REL_PPC_REFHI: u32 = 16u32;
pub const IMAGE_REL_PPC_REFLO: u32 = 17u32;
pub const IMAGE_REL_PPC_REL14: u32 = 7u32;
pub const IMAGE_REL_PPC_REL24: u32 = 6u32;
pub const IMAGE_REL_PPC_SECREL: u32 = 11u32;
pub const IMAGE_REL_PPC_SECREL16: u32 = 15u32;
pub const IMAGE_REL_PPC_SECRELHI: u32 = 20u32;
pub const IMAGE_REL_PPC_SECRELLO: u32 = 19u32;
pub const IMAGE_REL_PPC_SECTION: u32 = 12u32;
pub const IMAGE_REL_PPC_TOCDEFN: u32 = 2048u32;
pub const IMAGE_REL_PPC_TOCREL14: u32 = 9u32;
pub const IMAGE_REL_PPC_TOCREL16: u32 = 8u32;
pub const IMAGE_REL_PPC_TOKEN: u32 = 22u32;
pub const IMAGE_REL_PPC_TYPEMASK: u32 = 255u32;
pub const IMAGE_REL_SH3_ABSOLUTE: u32 = 0u32;
pub const IMAGE_REL_SH3_DIRECT16: u32 = 1u32;
pub const IMAGE_REL_SH3_DIRECT32: u32 = 2u32;
pub const IMAGE_REL_SH3_DIRECT32_NB: u32 = 16u32;
pub const IMAGE_REL_SH3_DIRECT4: u32 = 6u32;
pub const IMAGE_REL_SH3_DIRECT4_LONG: u32 = 8u32;
pub const IMAGE_REL_SH3_DIRECT4_WORD: u32 = 7u32;
pub const IMAGE_REL_SH3_DIRECT8: u32 = 3u32;
pub const IMAGE_REL_SH3_DIRECT8_LONG: u32 = 5u32;
pub const IMAGE_REL_SH3_DIRECT8_WORD: u32 = 4u32;
pub const IMAGE_REL_SH3_GPREL4_LONG: u32 = 17u32;
pub const IMAGE_REL_SH3_PCREL12_WORD: u32 = 11u32;
pub const IMAGE_REL_SH3_PCREL8_LONG: u32 = 10u32;
pub const IMAGE_REL_SH3_PCREL8_WORD: u32 = 9u32;
pub const IMAGE_REL_SH3_SECREL: u32 = 15u32;
pub const IMAGE_REL_SH3_SECTION: u32 = 14u32;
pub const IMAGE_REL_SH3_SIZEOF_SECTION: u32 = 13u32;
pub const IMAGE_REL_SH3_STARTOF_SECTION: u32 = 12u32;
pub const IMAGE_REL_SH3_TOKEN: u32 = 18u32;
pub const IMAGE_REL_SHM_PAIR: u32 = 24u32;
pub const IMAGE_REL_SHM_PCRELPT: u32 = 19u32;
pub const IMAGE_REL_SHM_REFHALF: u32 = 21u32;
pub const IMAGE_REL_SHM_REFLO: u32 = 20u32;
pub const IMAGE_REL_SHM_RELHALF: u32 = 23u32;
pub const IMAGE_REL_SHM_RELLO: u32 = 22u32;
pub const IMAGE_REL_SH_NOMODE: u32 = 32768u32;
pub const IMAGE_REL_THUMB_BLX23: u32 = 21u32;
pub const IMAGE_REL_THUMB_BRANCH20: u32 = 18u32;
pub const IMAGE_REL_THUMB_BRANCH24: u32 = 20u32;
pub const IMAGE_REL_THUMB_MOV32: u32 = 17u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_RESOURCE_DATA_ENTRY {
    pub OffsetToData: u32,
    pub Size: u32,
    pub CodePage: u32,
    pub Reserved: u32,
}
impl IMAGE_RESOURCE_DATA_ENTRY {}
impl ::std::default::Default for IMAGE_RESOURCE_DATA_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_RESOURCE_DATA_ENTRY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_RESOURCE_DATA_ENTRY")
            .field("OffsetToData", &self.OffsetToData)
            .field("Size", &self.Size)
            .field("CodePage", &self.CodePage)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_RESOURCE_DATA_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.OffsetToData == other.OffsetToData
            && self.Size == other.Size
            && self.CodePage == other.CodePage
            && self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for IMAGE_RESOURCE_DATA_ENTRY {}
unsafe impl ::windows::runtime::Abi for IMAGE_RESOURCE_DATA_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_RESOURCE_DATA_IS_DIRECTORY: u32 = 2147483648u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_RESOURCE_DIRECTORY {
    pub Characteristics: u32,
    pub TimeDateStamp: u32,
    pub MajorVersion: u16,
    pub MinorVersion: u16,
    pub NumberOfNamedEntries: u16,
    pub NumberOfIdEntries: u16,
}
impl IMAGE_RESOURCE_DIRECTORY {}
impl ::std::default::Default for IMAGE_RESOURCE_DIRECTORY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_RESOURCE_DIRECTORY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_RESOURCE_DIRECTORY")
            .field("Characteristics", &self.Characteristics)
            .field("TimeDateStamp", &self.TimeDateStamp)
            .field("MajorVersion", &self.MajorVersion)
            .field("MinorVersion", &self.MinorVersion)
            .field("NumberOfNamedEntries", &self.NumberOfNamedEntries)
            .field("NumberOfIdEntries", &self.NumberOfIdEntries)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_RESOURCE_DIRECTORY {
    fn eq(&self, other: &Self) -> bool {
        self.Characteristics == other.Characteristics
            && self.TimeDateStamp == other.TimeDateStamp
            && self.MajorVersion == other.MajorVersion
            && self.MinorVersion == other.MinorVersion
            && self.NumberOfNamedEntries == other.NumberOfNamedEntries
            && self.NumberOfIdEntries == other.NumberOfIdEntries
    }
}
impl ::std::cmp::Eq for IMAGE_RESOURCE_DIRECTORY {}
unsafe impl ::windows::runtime::Abi for IMAGE_RESOURCE_DIRECTORY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_RESOURCE_DIRECTORY_ENTRY {
    pub Anonymous1: IMAGE_RESOURCE_DIRECTORY_ENTRY_0,
    pub Anonymous2: IMAGE_RESOURCE_DIRECTORY_ENTRY_1,
}
impl IMAGE_RESOURCE_DIRECTORY_ENTRY {}
impl ::std::default::Default for IMAGE_RESOURCE_DIRECTORY_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_RESOURCE_DIRECTORY_ENTRY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_RESOURCE_DIRECTORY_ENTRY {}
unsafe impl ::windows::runtime::Abi for IMAGE_RESOURCE_DIRECTORY_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union IMAGE_RESOURCE_DIRECTORY_ENTRY_0 {
    pub Anonymous: IMAGE_RESOURCE_DIRECTORY_ENTRY_0_0,
    pub Name: u32,
    pub Id: u16,
}
impl IMAGE_RESOURCE_DIRECTORY_ENTRY_0 {}
impl ::std::default::Default for IMAGE_RESOURCE_DIRECTORY_ENTRY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_RESOURCE_DIRECTORY_ENTRY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_RESOURCE_DIRECTORY_ENTRY_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_RESOURCE_DIRECTORY_ENTRY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_RESOURCE_DIRECTORY_ENTRY_0_0 {
    pub _bitfield: u32,
}
impl IMAGE_RESOURCE_DIRECTORY_ENTRY_0_0 {}
impl ::std::default::Default for IMAGE_RESOURCE_DIRECTORY_ENTRY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_RESOURCE_DIRECTORY_ENTRY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_RESOURCE_DIRECTORY_ENTRY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for IMAGE_RESOURCE_DIRECTORY_ENTRY_0_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_RESOURCE_DIRECTORY_ENTRY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union IMAGE_RESOURCE_DIRECTORY_ENTRY_1 {
    pub OffsetToData: u32,
    pub Anonymous: IMAGE_RESOURCE_DIRECTORY_ENTRY_1_0,
}
impl IMAGE_RESOURCE_DIRECTORY_ENTRY_1 {}
impl ::std::default::Default for IMAGE_RESOURCE_DIRECTORY_ENTRY_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_RESOURCE_DIRECTORY_ENTRY_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_RESOURCE_DIRECTORY_ENTRY_1 {}
unsafe impl ::windows::runtime::Abi for IMAGE_RESOURCE_DIRECTORY_ENTRY_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_RESOURCE_DIRECTORY_ENTRY_1_0 {
    pub _bitfield: u32,
}
impl IMAGE_RESOURCE_DIRECTORY_ENTRY_1_0 {}
impl ::std::default::Default for IMAGE_RESOURCE_DIRECTORY_ENTRY_1_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_RESOURCE_DIRECTORY_ENTRY_1_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_RESOURCE_DIRECTORY_ENTRY_1_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for IMAGE_RESOURCE_DIRECTORY_ENTRY_1_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_RESOURCE_DIRECTORY_ENTRY_1_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_RESOURCE_DIRECTORY_STRING {
    pub Length: u16,
    pub NameString: [CHAR; 1],
}
impl IMAGE_RESOURCE_DIRECTORY_STRING {}
impl ::std::default::Default for IMAGE_RESOURCE_DIRECTORY_STRING {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_RESOURCE_DIRECTORY_STRING {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_RESOURCE_DIRECTORY_STRING")
            .field("Length", &self.Length)
            .field("NameString", &self.NameString)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_RESOURCE_DIRECTORY_STRING {
    fn eq(&self, other: &Self) -> bool {
        self.Length == other.Length && self.NameString == other.NameString
    }
}
impl ::std::cmp::Eq for IMAGE_RESOURCE_DIRECTORY_STRING {}
unsafe impl ::windows::runtime::Abi for IMAGE_RESOURCE_DIRECTORY_STRING {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_RESOURCE_DIR_STRING_U {
    pub Length: u16,
    pub NameString: [u16; 1],
}
impl IMAGE_RESOURCE_DIR_STRING_U {}
impl ::std::default::Default for IMAGE_RESOURCE_DIR_STRING_U {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_RESOURCE_DIR_STRING_U {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_RESOURCE_DIR_STRING_U")
            .field("Length", &self.Length)
            .field("NameString", &self.NameString)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_RESOURCE_DIR_STRING_U {
    fn eq(&self, other: &Self) -> bool {
        self.Length == other.Length && self.NameString == other.NameString
    }
}
impl ::std::cmp::Eq for IMAGE_RESOURCE_DIR_STRING_U {}
unsafe impl ::windows::runtime::Abi for IMAGE_RESOURCE_DIR_STRING_U {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_RESOURCE_NAME_IS_STRING: u32 = 2147483648u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Diagnostics_Debug")]
pub struct IMAGE_ROM_HEADERS {
    pub FileHeader: super::Diagnostics::Debug::IMAGE_FILE_HEADER,
    pub OptionalHeader: IMAGE_ROM_OPTIONAL_HEADER,
}
#[cfg(feature = "Win32_System_Diagnostics_Debug")]
impl IMAGE_ROM_HEADERS {}
#[cfg(feature = "Win32_System_Diagnostics_Debug")]
impl ::std::default::Default for IMAGE_ROM_HEADERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Diagnostics_Debug")]
impl ::std::fmt::Debug for IMAGE_ROM_HEADERS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_ROM_HEADERS")
            .field("FileHeader", &self.FileHeader)
            .field("OptionalHeader", &self.OptionalHeader)
            .finish()
    }
}
#[cfg(feature = "Win32_System_Diagnostics_Debug")]
impl ::std::cmp::PartialEq for IMAGE_ROM_HEADERS {
    fn eq(&self, other: &Self) -> bool {
        self.FileHeader == other.FileHeader && self.OptionalHeader == other.OptionalHeader
    }
}
#[cfg(feature = "Win32_System_Diagnostics_Debug")]
impl ::std::cmp::Eq for IMAGE_ROM_HEADERS {}
#[cfg(feature = "Win32_System_Diagnostics_Debug")]
unsafe impl ::windows::runtime::Abi for IMAGE_ROM_HEADERS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_ROM_OPTIONAL_HEADER {
    pub Magic: u16,
    pub MajorLinkerVersion: u8,
    pub MinorLinkerVersion: u8,
    pub SizeOfCode: u32,
    pub SizeOfInitializedData: u32,
    pub SizeOfUninitializedData: u32,
    pub AddressOfEntryPoint: u32,
    pub BaseOfCode: u32,
    pub BaseOfData: u32,
    pub BaseOfBss: u32,
    pub GprMask: u32,
    pub CprMask: [u32; 4],
    pub GpValue: u32,
}
impl IMAGE_ROM_OPTIONAL_HEADER {}
impl ::std::default::Default for IMAGE_ROM_OPTIONAL_HEADER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_ROM_OPTIONAL_HEADER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_ROM_OPTIONAL_HEADER")
            .field("Magic", &self.Magic)
            .field("MajorLinkerVersion", &self.MajorLinkerVersion)
            .field("MinorLinkerVersion", &self.MinorLinkerVersion)
            .field("SizeOfCode", &self.SizeOfCode)
            .field("SizeOfInitializedData", &self.SizeOfInitializedData)
            .field("SizeOfUninitializedData", &self.SizeOfUninitializedData)
            .field("AddressOfEntryPoint", &self.AddressOfEntryPoint)
            .field("BaseOfCode", &self.BaseOfCode)
            .field("BaseOfData", &self.BaseOfData)
            .field("BaseOfBss", &self.BaseOfBss)
            .field("GprMask", &self.GprMask)
            .field("CprMask", &self.CprMask)
            .field("GpValue", &self.GpValue)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_ROM_OPTIONAL_HEADER {
    fn eq(&self, other: &Self) -> bool {
        self.Magic == other.Magic
            && self.MajorLinkerVersion == other.MajorLinkerVersion
            && self.MinorLinkerVersion == other.MinorLinkerVersion
            && self.SizeOfCode == other.SizeOfCode
            && self.SizeOfInitializedData == other.SizeOfInitializedData
            && self.SizeOfUninitializedData == other.SizeOfUninitializedData
            && self.AddressOfEntryPoint == other.AddressOfEntryPoint
            && self.BaseOfCode == other.BaseOfCode
            && self.BaseOfData == other.BaseOfData
            && self.BaseOfBss == other.BaseOfBss
            && self.GprMask == other.GprMask
            && self.CprMask == other.CprMask
            && self.GpValue == other.GpValue
    }
}
impl ::std::cmp::Eq for IMAGE_ROM_OPTIONAL_HEADER {}
unsafe impl ::windows::runtime::Abi for IMAGE_ROM_OPTIONAL_HEADER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: u32,
    pub EndAddress: u32,
    pub Anonymous: IMAGE_RUNTIME_FUNCTION_ENTRY_0,
}
impl IMAGE_RUNTIME_FUNCTION_ENTRY {}
impl ::std::default::Default for IMAGE_RUNTIME_FUNCTION_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_RUNTIME_FUNCTION_ENTRY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_RUNTIME_FUNCTION_ENTRY {}
unsafe impl ::windows::runtime::Abi for IMAGE_RUNTIME_FUNCTION_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union IMAGE_RUNTIME_FUNCTION_ENTRY_0 {
    pub UnwindInfoAddress: u32,
    pub UnwindData: u32,
}
impl IMAGE_RUNTIME_FUNCTION_ENTRY_0 {}
impl ::std::default::Default for IMAGE_RUNTIME_FUNCTION_ENTRY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_RUNTIME_FUNCTION_ENTRY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_RUNTIME_FUNCTION_ENTRY_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_RUNTIME_FUNCTION_ENTRY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_SEPARATE_DEBUG_FLAGS_MASK: u32 = 32768u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_SEPARATE_DEBUG_HEADER {
    pub Signature: u16,
    pub Flags: u16,
    pub Machine: u16,
    pub Characteristics: u16,
    pub TimeDateStamp: u32,
    pub CheckSum: u32,
    pub ImageBase: u32,
    pub SizeOfImage: u32,
    pub NumberOfSections: u32,
    pub ExportedNamesSize: u32,
    pub DebugDirectorySize: u32,
    pub SectionAlignment: u32,
    pub Reserved: [u32; 2],
}
impl IMAGE_SEPARATE_DEBUG_HEADER {}
impl ::std::default::Default for IMAGE_SEPARATE_DEBUG_HEADER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_SEPARATE_DEBUG_HEADER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IMAGE_SEPARATE_DEBUG_HEADER")
            .field("Signature", &self.Signature)
            .field("Flags", &self.Flags)
            .field("Machine", &self.Machine)
            .field("Characteristics", &self.Characteristics)
            .field("TimeDateStamp", &self.TimeDateStamp)
            .field("CheckSum", &self.CheckSum)
            .field("ImageBase", &self.ImageBase)
            .field("SizeOfImage", &self.SizeOfImage)
            .field("NumberOfSections", &self.NumberOfSections)
            .field("ExportedNamesSize", &self.ExportedNamesSize)
            .field("DebugDirectorySize", &self.DebugDirectorySize)
            .field("SectionAlignment", &self.SectionAlignment)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_SEPARATE_DEBUG_HEADER {
    fn eq(&self, other: &Self) -> bool {
        self.Signature == other.Signature
            && self.Flags == other.Flags
            && self.Machine == other.Machine
            && self.Characteristics == other.Characteristics
            && self.TimeDateStamp == other.TimeDateStamp
            && self.CheckSum == other.CheckSum
            && self.ImageBase == other.ImageBase
            && self.SizeOfImage == other.SizeOfImage
            && self.NumberOfSections == other.NumberOfSections
            && self.ExportedNamesSize == other.ExportedNamesSize
            && self.DebugDirectorySize == other.DebugDirectorySize
            && self.SectionAlignment == other.SectionAlignment
            && self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for IMAGE_SEPARATE_DEBUG_HEADER {}
unsafe impl ::windows::runtime::Abi for IMAGE_SEPARATE_DEBUG_HEADER {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_SEPARATE_DEBUG_MISMATCH: u32 = 32768u32;
pub const IMAGE_SEPARATE_DEBUG_SIGNATURE: u32 = 18756u32;
pub const IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR: u32 = 60u32;
pub const IMAGE_SIZEOF_FILE_HEADER: u32 = 20u32;
pub const IMAGE_SIZEOF_SECTION_HEADER: u32 = 40u32;
pub const IMAGE_SIZEOF_SHORT_NAME: u32 = 8u32;
pub const IMAGE_SIZEOF_SYMBOL: u32 = 18u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION {
    pub _bitfield: u16,
}
impl IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION {}
impl ::std::default::Default for IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION {}
unsafe impl ::windows::runtime::Abi for IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub struct IMAGE_SYMBOL {
    pub N: IMAGE_SYMBOL_0,
    pub Value: u32,
    pub SectionNumber: i16,
    pub Type: u16,
    pub StorageClass: u8,
    pub NumberOfAuxSymbols: u8,
}
impl IMAGE_SYMBOL {}
impl ::std::default::Default for IMAGE_SYMBOL {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_SYMBOL {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_SYMBOL {}
unsafe impl ::windows::runtime::Abi for IMAGE_SYMBOL {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub union IMAGE_SYMBOL_0 {
    pub ShortName: [u8; 8],
    pub Name: IMAGE_SYMBOL_0_0,
    pub LongName: [u32; 2],
}
impl IMAGE_SYMBOL_0 {}
impl ::std::default::Default for IMAGE_SYMBOL_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_SYMBOL_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_SYMBOL_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_SYMBOL_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub struct IMAGE_SYMBOL_0_0 {
    pub Short: u32,
    pub Long: u32,
}
impl IMAGE_SYMBOL_0_0 {}
impl ::std::default::Default for IMAGE_SYMBOL_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_SYMBOL_0_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_SYMBOL_0_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_SYMBOL_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub struct IMAGE_SYMBOL_EX {
    pub N: IMAGE_SYMBOL_EX_0,
    pub Value: u32,
    pub SectionNumber: i32,
    pub Type: u16,
    pub StorageClass: u8,
    pub NumberOfAuxSymbols: u8,
}
impl IMAGE_SYMBOL_EX {}
impl ::std::default::Default for IMAGE_SYMBOL_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_SYMBOL_EX {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_SYMBOL_EX {}
unsafe impl ::windows::runtime::Abi for IMAGE_SYMBOL_EX {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub union IMAGE_SYMBOL_EX_0 {
    pub ShortName: [u8; 8],
    pub Name: IMAGE_SYMBOL_EX_0_0,
    pub LongName: [u32; 2],
}
impl IMAGE_SYMBOL_EX_0 {}
impl ::std::default::Default for IMAGE_SYMBOL_EX_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_SYMBOL_EX_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_SYMBOL_EX_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_SYMBOL_EX_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub struct IMAGE_SYMBOL_EX_0_0 {
    pub Short: u32,
    pub Long: u32,
}
impl IMAGE_SYMBOL_EX_0_0 {}
impl ::std::default::Default for IMAGE_SYMBOL_EX_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_SYMBOL_EX_0_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_SYMBOL_EX_0_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_SYMBOL_EX_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_SYM_CLASS_ARGUMENT: u32 = 9u32;
pub const IMAGE_SYM_CLASS_AUTOMATIC: u32 = 1u32;
pub const IMAGE_SYM_CLASS_BIT_FIELD: u32 = 18u32;
pub const IMAGE_SYM_CLASS_BLOCK: u32 = 100u32;
pub const IMAGE_SYM_CLASS_CLR_TOKEN: u32 = 107u32;
pub const IMAGE_SYM_CLASS_END_OF_STRUCT: u32 = 102u32;
pub const IMAGE_SYM_CLASS_ENUM_TAG: u32 = 15u32;
pub const IMAGE_SYM_CLASS_EXTERNAL: u32 = 2u32;
pub const IMAGE_SYM_CLASS_EXTERNAL_DEF: u32 = 5u32;
pub const IMAGE_SYM_CLASS_FAR_EXTERNAL: u32 = 68u32;
pub const IMAGE_SYM_CLASS_FILE: u32 = 103u32;
pub const IMAGE_SYM_CLASS_FUNCTION: u32 = 101u32;
pub const IMAGE_SYM_CLASS_LABEL: u32 = 6u32;
pub const IMAGE_SYM_CLASS_MEMBER_OF_ENUM: u32 = 16u32;
pub const IMAGE_SYM_CLASS_MEMBER_OF_STRUCT: u32 = 8u32;
pub const IMAGE_SYM_CLASS_MEMBER_OF_UNION: u32 = 11u32;
pub const IMAGE_SYM_CLASS_NULL: u32 = 0u32;
pub const IMAGE_SYM_CLASS_REGISTER: u32 = 4u32;
pub const IMAGE_SYM_CLASS_REGISTER_PARAM: u32 = 17u32;
pub const IMAGE_SYM_CLASS_SECTION: u32 = 104u32;
pub const IMAGE_SYM_CLASS_STATIC: u32 = 3u32;
pub const IMAGE_SYM_CLASS_STRUCT_TAG: u32 = 10u32;
pub const IMAGE_SYM_CLASS_TYPE_DEFINITION: u32 = 13u32;
pub const IMAGE_SYM_CLASS_UNDEFINED_LABEL: u32 = 7u32;
pub const IMAGE_SYM_CLASS_UNDEFINED_STATIC: u32 = 14u32;
pub const IMAGE_SYM_CLASS_UNION_TAG: u32 = 12u32;
pub const IMAGE_SYM_CLASS_WEAK_EXTERNAL: u32 = 105u32;
pub const IMAGE_SYM_DTYPE_ARRAY: u32 = 3u32;
pub const IMAGE_SYM_DTYPE_FUNCTION: u32 = 2u32;
pub const IMAGE_SYM_DTYPE_NULL: u32 = 0u32;
pub const IMAGE_SYM_DTYPE_POINTER: u32 = 1u32;
pub const IMAGE_SYM_SECTION_MAX: u32 = 65279u32;
pub const IMAGE_SYM_SECTION_MAX_EX: u32 = 2147483647u32;
pub const IMAGE_SYM_TYPE_BYTE: u32 = 12u32;
pub const IMAGE_SYM_TYPE_CHAR: u32 = 2u32;
pub const IMAGE_SYM_TYPE_DOUBLE: u32 = 7u32;
pub const IMAGE_SYM_TYPE_DWORD: u32 = 15u32;
pub const IMAGE_SYM_TYPE_ENUM: u32 = 10u32;
pub const IMAGE_SYM_TYPE_FLOAT: u32 = 6u32;
pub const IMAGE_SYM_TYPE_INT: u32 = 4u32;
pub const IMAGE_SYM_TYPE_LONG: u32 = 5u32;
pub const IMAGE_SYM_TYPE_MOE: u32 = 11u32;
pub const IMAGE_SYM_TYPE_NULL: u32 = 0u32;
pub const IMAGE_SYM_TYPE_PCODE: u32 = 32768u32;
pub const IMAGE_SYM_TYPE_SHORT: u32 = 3u32;
pub const IMAGE_SYM_TYPE_STRUCT: u32 = 8u32;
pub const IMAGE_SYM_TYPE_UINT: u32 = 14u32;
pub const IMAGE_SYM_TYPE_UNION: u32 = 9u32;
pub const IMAGE_SYM_TYPE_VOID: u32 = 1u32;
pub const IMAGE_SYM_TYPE_WORD: u32 = 13u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_THUNK_DATA32 {
    pub u1: IMAGE_THUNK_DATA32_0,
}
impl IMAGE_THUNK_DATA32 {}
impl ::std::default::Default for IMAGE_THUNK_DATA32 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_THUNK_DATA32 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_THUNK_DATA32 {}
unsafe impl ::windows::runtime::Abi for IMAGE_THUNK_DATA32 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union IMAGE_THUNK_DATA32_0 {
    pub ForwarderString: u32,
    pub Function: u32,
    pub Ordinal: u32,
    pub AddressOfData: u32,
}
impl IMAGE_THUNK_DATA32_0 {}
impl ::std::default::Default for IMAGE_THUNK_DATA32_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_THUNK_DATA32_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_THUNK_DATA32_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_THUNK_DATA32_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_THUNK_DATA64 {
    pub u1: IMAGE_THUNK_DATA64_0,
}
impl IMAGE_THUNK_DATA64 {}
impl ::std::default::Default for IMAGE_THUNK_DATA64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_THUNK_DATA64 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_THUNK_DATA64 {}
unsafe impl ::windows::runtime::Abi for IMAGE_THUNK_DATA64 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union IMAGE_THUNK_DATA64_0 {
    pub ForwarderString: u64,
    pub Function: u64,
    pub Ordinal: u64,
    pub AddressOfData: u64,
}
impl IMAGE_THUNK_DATA64_0 {}
impl ::std::default::Default for IMAGE_THUNK_DATA64_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_THUNK_DATA64_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_THUNK_DATA64_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_THUNK_DATA64_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_TLS_DIRECTORY32 {
    pub StartAddressOfRawData: u32,
    pub EndAddressOfRawData: u32,
    pub AddressOfIndex: u32,
    pub AddressOfCallBacks: u32,
    pub SizeOfZeroFill: u32,
    pub Anonymous: IMAGE_TLS_DIRECTORY32_0,
}
impl IMAGE_TLS_DIRECTORY32 {}
impl ::std::default::Default for IMAGE_TLS_DIRECTORY32 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_TLS_DIRECTORY32 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_TLS_DIRECTORY32 {}
unsafe impl ::windows::runtime::Abi for IMAGE_TLS_DIRECTORY32 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union IMAGE_TLS_DIRECTORY32_0 {
    pub Characteristics: u32,
    pub Anonymous: IMAGE_TLS_DIRECTORY32_0_0,
}
impl IMAGE_TLS_DIRECTORY32_0 {}
impl ::std::default::Default for IMAGE_TLS_DIRECTORY32_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_TLS_DIRECTORY32_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_TLS_DIRECTORY32_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_TLS_DIRECTORY32_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_TLS_DIRECTORY32_0_0 {
    pub _bitfield: u32,
}
impl IMAGE_TLS_DIRECTORY32_0_0 {}
impl ::std::default::Default for IMAGE_TLS_DIRECTORY32_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_TLS_DIRECTORY32_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_TLS_DIRECTORY32_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for IMAGE_TLS_DIRECTORY32_0_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_TLS_DIRECTORY32_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(4))]
pub struct IMAGE_TLS_DIRECTORY64 {
    pub StartAddressOfRawData: u64,
    pub EndAddressOfRawData: u64,
    pub AddressOfIndex: u64,
    pub AddressOfCallBacks: u64,
    pub SizeOfZeroFill: u32,
    pub Anonymous: IMAGE_TLS_DIRECTORY64_0,
}
impl IMAGE_TLS_DIRECTORY64 {}
impl ::std::default::Default for IMAGE_TLS_DIRECTORY64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_TLS_DIRECTORY64 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_TLS_DIRECTORY64 {}
unsafe impl ::windows::runtime::Abi for IMAGE_TLS_DIRECTORY64 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union IMAGE_TLS_DIRECTORY64_0 {
    pub Characteristics: u32,
    pub Anonymous: IMAGE_TLS_DIRECTORY64_0_0,
}
impl IMAGE_TLS_DIRECTORY64_0 {}
impl ::std::default::Default for IMAGE_TLS_DIRECTORY64_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_TLS_DIRECTORY64_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_TLS_DIRECTORY64_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_TLS_DIRECTORY64_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMAGE_TLS_DIRECTORY64_0_0 {
    pub _bitfield: u32,
}
impl IMAGE_TLS_DIRECTORY64_0_0 {}
impl ::std::default::Default for IMAGE_TLS_DIRECTORY64_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IMAGE_TLS_DIRECTORY64_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IMAGE_TLS_DIRECTORY64_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for IMAGE_TLS_DIRECTORY64_0_0 {}
unsafe impl ::windows::runtime::Abi for IMAGE_TLS_DIRECTORY64_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(2))]
pub struct IMAGE_VXD_HEADER {
    pub e32_magic: u16,
    pub e32_border: u8,
    pub e32_worder: u8,
    pub e32_level: u32,
    pub e32_cpu: u16,
    pub e32_os: u16,
    pub e32_ver: u32,
    pub e32_mflags: u32,
    pub e32_mpages: u32,
    pub e32_startobj: u32,
    pub e32_eip: u32,
    pub e32_stackobj: u32,
    pub e32_esp: u32,
    pub e32_pagesize: u32,
    pub e32_lastpagesize: u32,
    pub e32_fixupsize: u32,
    pub e32_fixupsum: u32,
    pub e32_ldrsize: u32,
    pub e32_ldrsum: u32,
    pub e32_objtab: u32,
    pub e32_objcnt: u32,
    pub e32_objmap: u32,
    pub e32_itermap: u32,
    pub e32_rsrctab: u32,
    pub e32_rsrccnt: u32,
    pub e32_restab: u32,
    pub e32_enttab: u32,
    pub e32_dirtab: u32,
    pub e32_dircnt: u32,
    pub e32_fpagetab: u32,
    pub e32_frectab: u32,
    pub e32_impmod: u32,
    pub e32_impmodcnt: u32,
    pub e32_impproc: u32,
    pub e32_pagesum: u32,
    pub e32_datapage: u32,
    pub e32_preload: u32,
    pub e32_nrestab: u32,
    pub e32_cbnrestab: u32,
    pub e32_nressum: u32,
    pub e32_autodata: u32,
    pub e32_debuginfo: u32,
    pub e32_debuglen: u32,
    pub e32_instpreload: u32,
    pub e32_instdemand: u32,
    pub e32_heapsize: u32,
    pub e32_res3: [u8; 12],
    pub e32_winresoff: u32,
    pub e32_winreslen: u32,
    pub e32_devid: u16,
    pub e32_ddkver: u16,
}
impl IMAGE_VXD_HEADER {}
impl ::std::default::Default for IMAGE_VXD_HEADER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMAGE_VXD_HEADER {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMAGE_VXD_HEADER {}
unsafe impl ::windows::runtime::Abi for IMAGE_VXD_HEADER {
    type Abi = Self;
    type DefaultType = Self;
}
pub const IMAGE_VXD_SIGNATURE: u32 = 17740u32;
pub const IMAGE_WEAK_EXTERN_ANTI_DEPENDENCY: u32 = 4u32;
pub const IMAGE_WEAK_EXTERN_SEARCH_ALIAS: u32 = 3u32;
pub const IMAGE_WEAK_EXTERN_SEARCH_LIBRARY: u32 = 2u32;
pub const IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY: u32 = 1u32;
pub const IMPORT_OBJECT_HDR_SIG2: u32 = 65535u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IMPORT_OBJECT_HEADER {
    pub Sig1: u16,
    pub Sig2: u16,
    pub Version: u16,
    pub Machine: u16,
    pub TimeDateStamp: u32,
    pub SizeOfData: u32,
    pub Anonymous: IMPORT_OBJECT_HEADER_0,
    pub _bitfield: u16,
}
impl IMPORT_OBJECT_HEADER {}
impl ::std::default::Default for IMPORT_OBJECT_HEADER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMPORT_OBJECT_HEADER {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMPORT_OBJECT_HEADER {}
unsafe impl ::windows::runtime::Abi for IMPORT_OBJECT_HEADER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union IMPORT_OBJECT_HEADER_0 {
    pub Ordinal: u16,
    pub Hint: u16,
}
impl IMPORT_OBJECT_HEADER_0 {}
impl ::std::default::Default for IMPORT_OBJECT_HEADER_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for IMPORT_OBJECT_HEADER_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for IMPORT_OBJECT_HEADER_0 {}
unsafe impl ::windows::runtime::Abi for IMPORT_OBJECT_HEADER_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct IMPORT_OBJECT_NAME_TYPE(pub i32);
pub const IMPORT_OBJECT_ORDINAL: IMPORT_OBJECT_NAME_TYPE = IMPORT_OBJECT_NAME_TYPE(0i32);
pub const IMPORT_OBJECT_NAME: IMPORT_OBJECT_NAME_TYPE = IMPORT_OBJECT_NAME_TYPE(1i32);
pub const IMPORT_OBJECT_NAME_NO_PREFIX: IMPORT_OBJECT_NAME_TYPE = IMPORT_OBJECT_NAME_TYPE(2i32);
pub const IMPORT_OBJECT_NAME_UNDECORATE: IMPORT_OBJECT_NAME_TYPE = IMPORT_OBJECT_NAME_TYPE(3i32);
pub const IMPORT_OBJECT_NAME_EXPORTAS: IMPORT_OBJECT_NAME_TYPE = IMPORT_OBJECT_NAME_TYPE(4i32);
impl ::std::convert::From<i32> for IMPORT_OBJECT_NAME_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for IMPORT_OBJECT_NAME_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct IMPORT_OBJECT_TYPE(pub i32);
pub const IMPORT_OBJECT_CODE: IMPORT_OBJECT_TYPE = IMPORT_OBJECT_TYPE(0i32);
pub const IMPORT_OBJECT_DATA: IMPORT_OBJECT_TYPE = IMPORT_OBJECT_TYPE(1i32);
pub const IMPORT_OBJECT_CONST: IMPORT_OBJECT_TYPE = IMPORT_OBJECT_TYPE(2i32);
impl ::std::convert::From<i32> for IMPORT_OBJECT_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for IMPORT_OBJECT_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const INDEX_DrvAccumulateD3DDirtyRect: i32 = 98i32;
pub const INDEX_DrvAlphaBlend: i32 = 71i32;
pub const INDEX_DrvAssertMode: i32 = 5i32;
pub const INDEX_DrvAssociateSharedSurface: i32 = 96i32;
pub const INDEX_DrvBitBlt: i32 = 18i32;
pub const INDEX_DrvCompletePDEV: i32 = 1i32;
pub const INDEX_DrvCopyBits: i32 = 19i32;
pub const INDEX_DrvCreateDeviceBitmap: i32 = 10i32;
pub const INDEX_DrvCreateDeviceBitmapEx: i32 = 94i32;
pub const INDEX_DrvDeleteDeviceBitmap: i32 = 11i32;
pub const INDEX_DrvDeleteDeviceBitmapEx: i32 = 95i32;
pub const INDEX_DrvDeriveSurface: i32 = 85i32;
pub const INDEX_DrvDescribePixelFormat: i32 = 55i32;
pub const INDEX_DrvDestroyFont: i32 = 43i32;
pub const INDEX_DrvDisableDirectDraw: i32 = 61i32;
pub const INDEX_DrvDisableDriver: i32 = 8i32;
pub const INDEX_DrvDisablePDEV: i32 = 2i32;
pub const INDEX_DrvDisableSurface: i32 = 4i32;
pub const INDEX_DrvDitherColor: i32 = 13i32;
pub const INDEX_DrvDrawEscape: i32 = 25i32;
pub const INDEX_DrvEnableDirectDraw: i32 = 60i32;
pub const INDEX_DrvEnablePDEV: i32 = 0i32;
pub const INDEX_DrvEnableSurface: i32 = 3i32;
pub const INDEX_DrvEndDoc: i32 = 34i32;
pub const INDEX_DrvEndDxInterop: i32 = 100i32;
pub const INDEX_DrvEscape: i32 = 24i32;
pub const INDEX_DrvFillPath: i32 = 15i32;
pub const INDEX_DrvFontManagement: i32 = 47i32;
pub const INDEX_DrvFree: i32 = 42i32;
pub const INDEX_DrvGetDirectDrawInfo: i32 = 59i32;
pub const INDEX_DrvGetGlyphMode: i32 = 37i32;
pub const INDEX_DrvGetModes: i32 = 41i32;
pub const INDEX_DrvGetSynthesizedFontFiles: i32 = 73i32;
pub const INDEX_DrvGetTrueTypeFile: i32 = 50i32;
pub const INDEX_DrvGradientFill: i32 = 68i32;
pub const INDEX_DrvIcmCheckBitmapBits: i32 = 66i32;
pub const INDEX_DrvIcmCreateColorTransform: i32 = 64i32;
pub const INDEX_DrvIcmDeleteColorTransform: i32 = 65i32;
pub const INDEX_DrvIcmSetDeviceGammaRamp: i32 = 67i32;
pub const INDEX_DrvLineTo: i32 = 31i32;
pub const INDEX_DrvLoadFontFile: i32 = 45i32;
pub const INDEX_DrvLockDisplayArea: i32 = 101i32;
pub const INDEX_DrvMovePanning: i32 = 52i32;
pub const INDEX_DrvMovePointer: i32 = 30i32;
pub const INDEX_DrvNextBand: i32 = 58i32;
pub const INDEX_DrvNotify: i32 = 87i32;
pub const INDEX_DrvOffset: i32 = 6i32;
pub const INDEX_DrvPaint: i32 = 17i32;
pub const INDEX_DrvPlgBlt: i32 = 70i32;
pub const INDEX_DrvQueryAdvanceWidths: i32 = 53i32;
pub const INDEX_DrvQueryDeviceSupport: i32 = 76i32;
pub const INDEX_DrvQueryFont: i32 = 26i32;
pub const INDEX_DrvQueryFontCaps: i32 = 44i32;
pub const INDEX_DrvQueryFontData: i32 = 28i32;
pub const INDEX_DrvQueryFontFile: i32 = 51i32;
pub const INDEX_DrvQueryFontTree: i32 = 27i32;
pub const INDEX_DrvQueryGlyphAttrs: i32 = 86i32;
pub const INDEX_DrvQueryPerBandInfo: i32 = 75i32;
pub const INDEX_DrvQuerySpoolType: i32 = 62i32;
pub const INDEX_DrvQueryTrueTypeOutline: i32 = 49i32;
pub const INDEX_DrvQueryTrueTypeTable: i32 = 48i32;
pub const INDEX_DrvRealizeBrush: i32 = 12i32;
pub const INDEX_DrvRenderHint: i32 = 93i32;
pub const INDEX_DrvReserved1: i32 = 77i32;
pub const INDEX_DrvReserved10: i32 = 91i32;
pub const INDEX_DrvReserved11: i32 = 92i32;
pub const INDEX_DrvReserved2: i32 = 78i32;
pub const INDEX_DrvReserved3: i32 = 79i32;
pub const INDEX_DrvReserved4: i32 = 80i32;
pub const INDEX_DrvReserved5: i32 = 81i32;
pub const INDEX_DrvReserved6: i32 = 82i32;
pub const INDEX_DrvReserved7: i32 = 83i32;
pub const INDEX_DrvReserved8: i32 = 84i32;
pub const INDEX_DrvReserved9: i32 = 90i32;
pub const INDEX_DrvResetDevice: i32 = 89i32;
pub const INDEX_DrvResetPDEV: i32 = 7i32;
pub const INDEX_DrvSaveScreenBits: i32 = 40i32;
pub const INDEX_DrvSendPage: i32 = 32i32;
pub const INDEX_DrvSetPalette: i32 = 22i32;
pub const INDEX_DrvSetPixelFormat: i32 = 54i32;
pub const INDEX_DrvSetPointerShape: i32 = 29i32;
pub const INDEX_DrvStartBanding: i32 = 57i32;
pub const INDEX_DrvStartDoc: i32 = 35i32;
pub const INDEX_DrvStartDxInterop: i32 = 99i32;
pub const INDEX_DrvStartPage: i32 = 33i32;
pub const INDEX_DrvStretchBlt: i32 = 20i32;
pub const INDEX_DrvStretchBltROP: i32 = 69i32;
pub const INDEX_DrvStrokeAndFillPath: i32 = 16i32;
pub const INDEX_DrvStrokePath: i32 = 14i32;
pub const INDEX_DrvSurfaceComplete: i32 = 103i32;
pub const INDEX_DrvSwapBuffers: i32 = 56i32;
pub const INDEX_DrvSynchronize: i32 = 38i32;
pub const INDEX_DrvSynchronizeRedirectionBitmaps: i32 = 97i32;
pub const INDEX_DrvSynchronizeSurface: i32 = 88i32;
pub const INDEX_DrvSynthesizeFont: i32 = 72i32;
pub const INDEX_DrvTextOut: i32 = 23i32;
pub const INDEX_DrvTransparentBlt: i32 = 74i32;
pub const INDEX_DrvUnloadFontFile: i32 = 46i32;
pub const INDEX_DrvUnlockDisplayArea: i32 = 102i32;
pub const INDEX_LAST: i32 = 89i32;
pub const INITIAL_CPSR: u32 = 16u32;
pub const INITIAL_FPCSR: u32 = 639u32;
pub const INITIAL_FPSCR: u32 = 0u32;
pub const INITIAL_MXCSR: u32 = 8064u32;
pub const IOCTL_CHANGER_BASE: u32 = 48u32;
pub const IOCTL_CHANGER_EXCHANGE_MEDIUM: u32 = 3162144u32;
pub const IOCTL_CHANGER_GET_ELEMENT_STATUS: u32 = 3194900u32;
pub const IOCTL_CHANGER_GET_PARAMETERS: u32 = 3162112u32;
pub const IOCTL_CHANGER_GET_PRODUCT_DATA: u32 = 3162120u32;
pub const IOCTL_CHANGER_GET_STATUS: u32 = 3162116u32;
pub const IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS: u32 = 3162136u32;
pub const IOCTL_CHANGER_MOVE_MEDIUM: u32 = 3162148u32;
pub const IOCTL_CHANGER_QUERY_VOLUME_TAGS: u32 = 3194924u32;
pub const IOCTL_CHANGER_REINITIALIZE_TRANSPORT: u32 = 3162152u32;
pub const IOCTL_CHANGER_SET_ACCESS: u32 = 3194896u32;
pub const IOCTL_CHANGER_SET_POSITION: u32 = 3162140u32;
pub const IOCTL_DISK_BASE: u32 = 7u32;
pub const IOCTL_DISK_CHECK_VERIFY: u32 = 477184u32;
pub const IOCTL_DISK_CONTROLLER_NUMBER: u32 = 458820u32;
pub const IOCTL_DISK_CREATE_DISK: u32 = 507992u32;
pub const IOCTL_DISK_DELETE_DRIVE_LAYOUT: u32 = 508160u32;
pub const IOCTL_DISK_EJECT_MEDIA: u32 = 477192u32;
pub const IOCTL_DISK_FIND_NEW_DEVICES: u32 = 477208u32;
pub const IOCTL_DISK_FORMAT_DRIVE: u32 = 508876u32;
pub const IOCTL_DISK_FORMAT_TRACKS: u32 = 507928u32;
pub const IOCTL_DISK_FORMAT_TRACKS_EX: u32 = 507948u32;
pub const IOCTL_DISK_GET_CACHE_INFORMATION: u32 = 475348u32;
pub const IOCTL_DISK_GET_DISK_ATTRIBUTES: u32 = 458992u32;
pub const IOCTL_DISK_GET_DRIVE_GEOMETRY: u32 = 458752u32;
pub const IOCTL_DISK_GET_DRIVE_GEOMETRY_EX: u32 = 458912u32;
pub const IOCTL_DISK_GET_DRIVE_LAYOUT: u32 = 475148u32;
pub const IOCTL_DISK_GET_DRIVE_LAYOUT_EX: u32 = 458832u32;
pub const IOCTL_DISK_GET_LENGTH_INFO: u32 = 475228u32;
pub const IOCTL_DISK_GET_MEDIA_TYPES: u32 = 461824u32;
pub const IOCTL_DISK_GET_PARTITION_INFO: u32 = 475140u32;
pub const IOCTL_DISK_GET_PARTITION_INFO_EX: u32 = 458824u32;
pub const IOCTL_DISK_GET_WRITE_CACHE_STATE: u32 = 475356u32;
pub const IOCTL_DISK_GROW_PARTITION: u32 = 508112u32;
pub const IOCTL_DISK_HISTOGRAM_DATA: u32 = 458804u32;
pub const IOCTL_DISK_HISTOGRAM_RESET: u32 = 458808u32;
pub const IOCTL_DISK_HISTOGRAM_STRUCTURE: u32 = 458800u32;
pub const IOCTL_DISK_IS_WRITABLE: u32 = 458788u32;
pub const IOCTL_DISK_LOAD_MEDIA: u32 = 477196u32;
pub const IOCTL_DISK_LOGGING: u32 = 458792u32;
pub const IOCTL_DISK_MEDIA_REMOVAL: u32 = 477188u32;
pub const IOCTL_DISK_PERFORMANCE: u32 = 458784u32;
pub const IOCTL_DISK_PERFORMANCE_OFF: u32 = 458848u32;
pub const IOCTL_DISK_REASSIGN_BLOCKS: u32 = 507932u32;
pub const IOCTL_DISK_REASSIGN_BLOCKS_EX: u32 = 508068u32;
pub const IOCTL_DISK_RELEASE: u32 = 477204u32;
pub const IOCTL_DISK_REQUEST_DATA: u32 = 458816u32;
pub const IOCTL_DISK_REQUEST_STRUCTURE: u32 = 458812u32;
pub const IOCTL_DISK_RESERVE: u32 = 477200u32;
pub const IOCTL_DISK_RESET_SNAPSHOT_INFO: u32 = 508432u32;
pub const IOCTL_DISK_SENSE_DEVICE: u32 = 459744u32;
pub const IOCTL_DISK_SET_CACHE_INFORMATION: u32 = 508120u32;
pub const IOCTL_DISK_SET_DISK_ATTRIBUTES: u32 = 508148u32;
pub const IOCTL_DISK_SET_DRIVE_LAYOUT: u32 = 507920u32;
pub const IOCTL_DISK_SET_DRIVE_LAYOUT_EX: u32 = 507988u32;
pub const IOCTL_DISK_SET_PARTITION_INFO: u32 = 507912u32;
pub const IOCTL_DISK_SET_PARTITION_INFO_EX: u32 = 507980u32;
pub const IOCTL_DISK_UPDATE_DRIVE_SIZE: u32 = 508104u32;
pub const IOCTL_DISK_UPDATE_PROPERTIES: u32 = 459072u32;
pub const IOCTL_DISK_VERIFY: u32 = 458772u32;
pub const IOCTL_SCMBUS_BASE: u32 = 89u32;
pub const IOCTL_SCMBUS_DEVICE_FUNCTION_BASE: u32 = 0u32;
pub const IOCTL_SCM_BUS_GET_LOGICAL_DEVICES: u32 = 5832704u32;
pub const IOCTL_SCM_BUS_GET_PHYSICAL_DEVICES: u32 = 5832708u32;
pub const IOCTL_SCM_BUS_GET_REGIONS: u32 = 5832712u32;
pub const IOCTL_SCM_BUS_QUERY_PROPERTY: u32 = 5832716u32;
pub const IOCTL_SCM_BUS_RUNTIME_FW_ACTIVATE: u32 = 5865488u32;
pub const IOCTL_SCM_BUS_SET_PROPERTY: u32 = 5865492u32;
pub const IOCTL_SCM_LD_GET_INTERLEAVE_SET: u32 = 5835776u32;
pub const IOCTL_SCM_LOGICAL_DEVICE_FUNCTION_BASE: u32 = 768u32;
pub const IOCTL_SCM_PD_FIRMWARE_ACTIVATE: u32 = 5871624u32;
pub const IOCTL_SCM_PD_FIRMWARE_DOWNLOAD: u32 = 5871620u32;
pub const IOCTL_SCM_PD_PASSTHROUGH: u32 = 5888012u32;
pub const IOCTL_SCM_PD_QUERY_PROPERTY: u32 = 5838848u32;
pub const IOCTL_SCM_PD_REINITIALIZE_MEDIA: u32 = 5871636u32;
pub const IOCTL_SCM_PD_SET_PROPERTY: u32 = 5871640u32;
pub const IOCTL_SCM_PD_UPDATE_MANAGEMENT_STATUS: u32 = 5838864u32;
pub const IOCTL_SCM_PHYSICAL_DEVICE_FUNCTION_BASE: u32 = 1536u32;
pub const IOCTL_SERENUM_EXPOSE_HARDWARE: u32 = 3604992u32;
pub const IOCTL_SERENUM_GET_PORT_NAME: u32 = 3605004u32;
pub const IOCTL_SERENUM_PORT_DESC: u32 = 3605000u32;
pub const IOCTL_SERENUM_REMOVE_HARDWARE: u32 = 3604996u32;
pub const IOCTL_SERIAL_LSRMST_INSERT: u32 = 1769596u32;
pub const IOCTL_STORAGE_ALLOCATE_BC_STREAM: u32 = 3004420u32;
pub const IOCTL_STORAGE_ATTRIBUTE_MANAGEMENT: u32 = 3005596u32;
pub const IOCTL_STORAGE_BASE: u32 = 45u32;
pub const IOCTL_STORAGE_BC_VERSION: u32 = 1u32;
pub const IOCTL_STORAGE_BREAK_RESERVATION: u32 = 2969620u32;
pub const IOCTL_STORAGE_CHECK_PRIORITY_HINT_SUPPORT: u32 = 2955392u32;
pub const IOCTL_STORAGE_CHECK_VERIFY: u32 = 2967552u32;
pub const IOCTL_STORAGE_CHECK_VERIFY2: u32 = 2951168u32;
pub const IOCTL_STORAGE_DEVICE_POWER_CAP: u32 = 2956436u32;
pub const IOCTL_STORAGE_DEVICE_TELEMETRY_NOTIFY: u32 = 3002820u32;
pub const IOCTL_STORAGE_DEVICE_TELEMETRY_QUERY_CAPS: u32 = 3002824u32;
pub const IOCTL_STORAGE_DIAGNOSTIC: u32 = 2956448u32;
pub const IOCTL_STORAGE_EJECTION_CONTROL: u32 = 2951488u32;
pub const IOCTL_STORAGE_EJECT_MEDIA: u32 = 2967560u32;
pub const IOCTL_STORAGE_ENABLE_IDLE_POWER: u32 = 2956416u32;
pub const IOCTL_STORAGE_EVENT_NOTIFICATION: u32 = 2956432u32;
pub const IOCTL_STORAGE_FAILURE_PREDICTION_CONFIG: u32 = 2953476u32;
pub const IOCTL_STORAGE_FIND_NEW_DEVICES: u32 = 2967576u32;
pub const IOCTL_STORAGE_FIRMWARE_ACTIVATE: u32 = 3005448u32;
pub const IOCTL_STORAGE_FIRMWARE_DOWNLOAD: u32 = 3005444u32;
pub const IOCTL_STORAGE_FIRMWARE_GET_INFO: u32 = 2956288u32;
pub const IOCTL_STORAGE_FREE_BC_STREAM: u32 = 3004424u32;
pub const IOCTL_STORAGE_GET_BC_PROPERTIES: u32 = 2971648u32;
pub const IOCTL_STORAGE_GET_COUNTERS: u32 = 2953480u32;
pub const IOCTL_STORAGE_GET_DEVICE_INTERNAL_LOG: u32 = 2956484u32;
pub const IOCTL_STORAGE_GET_DEVICE_NUMBER: u32 = 2953344u32;
pub const IOCTL_STORAGE_GET_DEVICE_NUMBER_EX: u32 = 2953348u32;
pub const IOCTL_STORAGE_GET_DEVICE_TELEMETRY: u32 = 3002816u32;
pub const IOCTL_STORAGE_GET_DEVICE_TELEMETRY_RAW: u32 = 3002828u32;
pub const IOCTL_STORAGE_GET_HOTPLUG_INFO: u32 = 2952212u32;
pub const IOCTL_STORAGE_GET_IDLE_POWERUP_REASON: u32 = 2956420u32;
pub const IOCTL_STORAGE_GET_LB_PROVISIONING_MAP_RESOURCES: u32 = 2970632u32;
pub const IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER: u32 = 2952208u32;
pub const IOCTL_STORAGE_GET_MEDIA_TYPES: u32 = 2952192u32;
pub const IOCTL_STORAGE_GET_MEDIA_TYPES_EX: u32 = 2952196u32;
pub const IOCTL_STORAGE_GET_PHYSICAL_ELEMENT_STATUS: u32 = 2956452u32;
pub const IOCTL_STORAGE_LOAD_MEDIA: u32 = 2967564u32;
pub const IOCTL_STORAGE_LOAD_MEDIA2: u32 = 2951180u32;
pub const IOCTL_STORAGE_MANAGE_BYPASS_IO: u32 = 2951360u32;
pub const IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES: u32 = 2987012u32;
pub const IOCTL_STORAGE_MCN_CONTROL: u32 = 2951492u32;
pub const IOCTL_STORAGE_MEDIA_REMOVAL: u32 = 2967556u32;
pub const IOCTL_STORAGE_PERSISTENT_RESERVE_IN: u32 = 2969624u32;
pub const IOCTL_STORAGE_PERSISTENT_RESERVE_OUT: u32 = 3002396u32;
pub const IOCTL_STORAGE_POWER_ACTIVE: u32 = 2956424u32;
pub const IOCTL_STORAGE_POWER_IDLE: u32 = 2956428u32;
pub const IOCTL_STORAGE_PREDICT_FAILURE: u32 = 2953472u32;
pub const IOCTL_STORAGE_PROTOCOL_COMMAND: u32 = 3003328u32;
pub const IOCTL_STORAGE_QUERY_PROPERTY: u32 = 2954240u32;
pub const IOCTL_STORAGE_READ_CAPACITY: u32 = 2969920u32;
pub const IOCTL_STORAGE_REINITIALIZE_MEDIA: u32 = 2987584u32;
pub const IOCTL_STORAGE_RELEASE: u32 = 2967572u32;
pub const IOCTL_STORAGE_REMOVE_ELEMENT_AND_TRUNCATE: u32 = 2956480u32;
pub const IOCTL_STORAGE_RESERVE: u32 = 2967568u32;
pub const IOCTL_STORAGE_RESET_BUS: u32 = 2969600u32;
pub const IOCTL_STORAGE_RESET_DEVICE: u32 = 2969604u32;
pub const IOCTL_STORAGE_RPMB_COMMAND: u32 = 2956440u32;
pub const IOCTL_STORAGE_SET_HOTPLUG_INFO: u32 = 3001368u32;
pub const IOCTL_STORAGE_SET_PROPERTY: u32 = 2987004u32;
pub const IOCTL_STORAGE_SET_TEMPERATURE_THRESHOLD: u32 = 3002880u32;
pub const IOCTL_STORAGE_START_DATA_INTEGRITY_CHECK: u32 = 3004548u32;
pub const IOCTL_STORAGE_STOP_DATA_INTEGRITY_CHECK: u32 = 3004552u32;
pub const IOCTL_VOLUME_BASE: u32 = 86u32;
pub const IOCTL_VOLUME_GET_GPT_ATTRIBUTES: u32 = 5636152u32;
pub const IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS: u32 = 5636096u32;
pub const IOCTL_VOLUME_IS_CLUSTERED: u32 = 5636144u32;
pub const IOCTL_VOLUME_OFFLINE: u32 = 5685260u32;
pub const IOCTL_VOLUME_ONLINE: u32 = 5685256u32;
#[cfg(feature = "Win32_Foundation")]
pub const IO_BAD_BLOCK_WITH_NAME: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479649i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_CDROM_EXCLUSIVE_LOCK: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(1074004101i32 as _);
pub const IO_COMPLETION_MODIFY_STATE: u32 = 2u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct IO_COUNTERS {
    pub ReadOperationCount: u64,
    pub WriteOperationCount: u64,
    pub OtherOperationCount: u64,
    pub ReadTransferCount: u64,
    pub WriteTransferCount: u64,
    pub OtherTransferCount: u64,
}
impl IO_COUNTERS {}
impl ::std::default::Default for IO_COUNTERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IO_COUNTERS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IO_COUNTERS")
            .field("ReadOperationCount", &self.ReadOperationCount)
            .field("WriteOperationCount", &self.WriteOperationCount)
            .field("OtherOperationCount", &self.OtherOperationCount)
            .field("ReadTransferCount", &self.ReadTransferCount)
            .field("WriteTransferCount", &self.WriteTransferCount)
            .field("OtherTransferCount", &self.OtherTransferCount)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IO_COUNTERS {
    fn eq(&self, other: &Self) -> bool {
        self.ReadOperationCount == other.ReadOperationCount
            && self.WriteOperationCount == other.WriteOperationCount
            && self.OtherOperationCount == other.OtherOperationCount
            && self.ReadTransferCount == other.ReadTransferCount
            && self.WriteTransferCount == other.WriteTransferCount
            && self.OtherTransferCount == other.OtherTransferCount
    }
}
impl ::std::cmp::Eq for IO_COUNTERS {}
unsafe impl ::windows::runtime::Abi for IO_COUNTERS {
    type Abi = Self;
    type DefaultType = Self;
}
#[cfg(feature = "Win32_Foundation")]
pub const IO_DRIVER_CANCEL_TIMEOUT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221450i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_DUMP_CALLBACK_EXCEPTION: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479517i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_DUMP_CREATION_SUCCESS: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(262306i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_DUMP_DIRECT_CONFIG_FAILED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479632i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_DUMP_DRIVER_LOAD_FAILURE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479635i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_DUMP_DUMPFILE_CONFLICT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479633i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_DUMP_INITIALIZATION_FAILURE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479634i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_DUMP_PAGE_CONFIG_FAILED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479631i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_DUMP_POINTER_FAILURE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479636i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERROR_DISK_RESOURCES_EXHAUSTED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479530i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERROR_DUMP_CREATION_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479519i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERROR_IO_HARDWARE_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479526i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_BAD_BLOCK: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479673i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_BAD_FIRMWARE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479655i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_CONFIGURATION_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479677i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_CONTROLLER_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479669i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_DMA_CONFLICT_DETECTED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479657i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_DMA_RESOURCE_CONFLICT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479653i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_DRIVER_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479676i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_INCORRECT_IRQL: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479667i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_INSUFFICIENT_RESOURCES: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479678i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_INTERNAL_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479668i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_INTERRUPT_RESOURCE_CONFLICT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479652i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_INVALID_IOBASE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479666i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_INVALID_REQUEST: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479664i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_IRQ_CONFLICT_DETECTED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479656i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_LAYERED_FAILURE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479662i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_MEMORY_CONFLICT_DETECTED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479659i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_MEMORY_RESOURCE_CONFLICT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479651i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_NOT_READY: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479665i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_OVERRUN_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479672i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_PARITY: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479675i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_PORT_CONFLICT_DETECTED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479658i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_PORT_RESOURCE_CONFLICT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479650i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_PORT_TIMEOUT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479563i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_PROTOCOL: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479660i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_RESET: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479661i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_RETRY_SUCCEEDED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(262145i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_SEEK_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479674i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_SEQUENCE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479670i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_THREAD_STUCK_IN_DEVICE_DRIVER: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479572i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_TIMEOUT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479671i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_ERR_VERSION: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479663i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_FILE_QUOTA_CORRUPT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479638i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_FILE_QUOTA_FAILED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221464i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_FILE_QUOTA_LIMIT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(1074004005i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_FILE_QUOTA_STARTED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(1074004006i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_FILE_QUOTA_SUCCEEDED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(1074004007i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_FILE_QUOTA_THRESHOLD: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(1074004004i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_FILE_SYSTEM_CORRUPT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479639i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_FILE_SYSTEM_CORRUPT_WITH_NAME: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479625i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_INFO_THROTTLE_COMPLETE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(1074004087i32 as _);
#[derive(:: std :: clone :: Clone)]
#[repr(C)]
pub struct IO_IRP_EXT_TRACK_OFFSET_HEADER {
    pub Validation: u16,
    pub Flags: u16,
    pub TrackedOffsetCallback: ::std::option::Option<PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK>,
}
impl IO_IRP_EXT_TRACK_OFFSET_HEADER {}
impl ::std::default::Default for IO_IRP_EXT_TRACK_OFFSET_HEADER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for IO_IRP_EXT_TRACK_OFFSET_HEADER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("IO_IRP_EXT_TRACK_OFFSET_HEADER")
            .field("Validation", &self.Validation)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for IO_IRP_EXT_TRACK_OFFSET_HEADER {
    fn eq(&self, other: &Self) -> bool {
        self.Validation == other.Validation
            && self.Flags == other.Flags
            && self.TrackedOffsetCallback.map(|f| f as usize)
                == other.TrackedOffsetCallback.map(|f| f as usize)
    }
}
impl ::std::cmp::Eq for IO_IRP_EXT_TRACK_OFFSET_HEADER {}
unsafe impl ::windows::runtime::Abi for IO_IRP_EXT_TRACK_OFFSET_HEADER {
    type Abi = ::std::mem::ManuallyDrop<Self>;
    type DefaultType = Self;
}
#[cfg(feature = "Win32_Foundation")]
pub const IO_LOST_DELAYED_WRITE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221454i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_LOST_DELAYED_WRITE_NETWORK_DISCONNECTED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221365i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_LOST_DELAYED_WRITE_NETWORK_LOCAL_DISK_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221363i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_LOST_DELAYED_WRITE_NETWORK_SERVER_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221364i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_RECOVERED_VIA_ECC: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221471i32 as _);
pub const IO_REPARSE_TAG_AF_UNIX: i32 = -2147483613i32;
pub const IO_REPARSE_TAG_APPEXECLINK: i32 = -2147483621i32;
pub const IO_REPARSE_TAG_CLOUD: i32 = -1879048166i32;
pub const IO_REPARSE_TAG_CLOUD_1: i32 = -1879044070i32;
pub const IO_REPARSE_TAG_CLOUD_2: i32 = -1879039974i32;
pub const IO_REPARSE_TAG_CLOUD_3: i32 = -1879035878i32;
pub const IO_REPARSE_TAG_CLOUD_4: i32 = -1879031782i32;
pub const IO_REPARSE_TAG_CLOUD_5: i32 = -1879027686i32;
pub const IO_REPARSE_TAG_CLOUD_6: i32 = -1879023590i32;
pub const IO_REPARSE_TAG_CLOUD_7: i32 = -1879019494i32;
pub const IO_REPARSE_TAG_CLOUD_8: i32 = -1879015398i32;
pub const IO_REPARSE_TAG_CLOUD_9: i32 = -1879011302i32;
pub const IO_REPARSE_TAG_CLOUD_A: i32 = -1879007206i32;
pub const IO_REPARSE_TAG_CLOUD_B: i32 = -1879003110i32;
pub const IO_REPARSE_TAG_CLOUD_C: i32 = -1878999014i32;
pub const IO_REPARSE_TAG_CLOUD_D: i32 = -1878994918i32;
pub const IO_REPARSE_TAG_CLOUD_E: i32 = -1878990822i32;
pub const IO_REPARSE_TAG_CLOUD_F: i32 = -1878986726i32;
pub const IO_REPARSE_TAG_CLOUD_MASK: i32 = 61440i32;
pub const IO_REPARSE_TAG_CSV: i32 = -2147483639i32;
pub const IO_REPARSE_TAG_DATALESS_CIM: i32 = -1610612696i32;
pub const IO_REPARSE_TAG_DEDUP: i32 = -2147483629i32;
pub const IO_REPARSE_TAG_DFS: i32 = -2147483638i32;
pub const IO_REPARSE_TAG_DFSR: i32 = -2147483630i32;
pub const IO_REPARSE_TAG_FILE_PLACEHOLDER: i32 = -2147483627i32;
pub const IO_REPARSE_TAG_GLOBAL_REPARSE: i32 = -1610612711i32;
pub const IO_REPARSE_TAG_HSM: i32 = -1073741820i32;
pub const IO_REPARSE_TAG_HSM2: i32 = -2147483642i32;
pub const IO_REPARSE_TAG_MOUNT_POINT: i32 = -1610612733i32;
pub const IO_REPARSE_TAG_NFS: i32 = -2147483628i32;
pub const IO_REPARSE_TAG_ONEDRIVE: i32 = -2147483615i32;
pub const IO_REPARSE_TAG_PROJFS: i32 = -1879048164i32;
pub const IO_REPARSE_TAG_PROJFS_TOMBSTONE: i32 = -1610612702i32;
pub const IO_REPARSE_TAG_RESERVED_ONE: u32 = 1u32;
pub const IO_REPARSE_TAG_RESERVED_RANGE: u32 = 2u32;
pub const IO_REPARSE_TAG_RESERVED_TWO: u32 = 2u32;
pub const IO_REPARSE_TAG_RESERVED_ZERO: u32 = 0u32;
pub const IO_REPARSE_TAG_SIS: i32 = -2147483641i32;
pub const IO_REPARSE_TAG_STORAGE_SYNC: i32 = -2147483618i32;
pub const IO_REPARSE_TAG_SYMLINK: i32 = -1610612724i32;
pub const IO_REPARSE_TAG_UNHANDLED: i32 = -2147483616i32;
pub const IO_REPARSE_TAG_WCI: i32 = -2147483624i32;
pub const IO_REPARSE_TAG_WCI_1: i32 = -1879044072i32;
pub const IO_REPARSE_TAG_WCI_LINK: i32 = -1610612697i32;
pub const IO_REPARSE_TAG_WCI_LINK_1: i32 = -1610608601i32;
pub const IO_REPARSE_TAG_WCI_TOMBSTONE: i32 = -1610612705i32;
pub const IO_REPARSE_TAG_WIM: i32 = -2147483640i32;
pub const IO_REPARSE_TAG_WOF: i32 = -2147483625i32;
#[cfg(feature = "Win32_Foundation")]
pub const IO_SYSTEM_SLEEP_FAILED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073479637i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_ADAPTER_FIRMWARE_UPDATED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(1074004128i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_ALLOCATION_FAILED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221448i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_BUS_RESET: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221386i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_COMPLETION_TIME: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221349i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_DEVICE_HAS_INTERNAL_DUMP: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221361i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_DISK_CAPACITY_CHANGED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221353i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_DISK_FIRMWARE_UPDATED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(1074004127i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_DISK_PROVISIONING_TYPE_CHANGED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221352i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_DISK_SURPRISE_REMOVED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221347i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_DUMP_DISABLED_DEVICE_GONE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221348i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_DUPLICATE_PATH: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221445i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_DUPLICATE_SIGNATURE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221446i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_INTERRUPT_STILL_PENDING: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221451i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_IO_OPERATION_RETRIED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221351i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_LOG_FLUSH_FAILED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221447i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_PAGING_FAILURE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221453i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_REPEATED_DISK_GUID: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221346i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_RESET: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221375i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_SOFT_THRESHOLD_REACHED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221360i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_SOFT_THRESHOLD_REACHED_EX: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221359i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_SOFT_THRESHOLD_REACHED_EX_LUN_LUN: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221358i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_SOFT_THRESHOLD_REACHED_EX_LUN_POOL: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221357i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_SOFT_THRESHOLD_REACHED_EX_POOL_LUN: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221356i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_SOFT_THRESHOLD_REACHED_EX_POOL_POOL: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221355i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_VOLUME_LOST_DISK_EXTENT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221362i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WARNING_WRITE_FUA_PROBLEM: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221372i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WRITE_CACHE_DISABLED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221470i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WRITE_CACHE_ENABLED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221472i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WRN_BAD_FIRMWARE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221478i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const IO_WRN_FAILURE_PREDICTED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147221452i32 as _);
pub const IS_TEXT_UNICODE_DBCS_LEADBYTE: u32 = 1024u32;
pub const IS_TEXT_UNICODE_UTF8: u32 = 2048u32;
#[repr(transparent)]
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: clone :: Clone,
    :: std :: fmt :: Debug,
)]
pub struct IServiceProvider(::windows::runtime::IUnknown);
impl IServiceProvider {
    pub unsafe fn QueryService(
        &self,
        guidservice: *const ::windows::runtime::GUID,
        riid: *const ::windows::runtime::GUID,
        ppvobject: *mut *mut ::std::ffi::c_void,
    ) -> ::windows::runtime::Result<()> {
        (::windows::runtime::Interface::vtable(self).3)(
            ::std::mem::transmute_copy(self),
            ::std::mem::transmute(guidservice),
            ::std::mem::transmute(riid),
            ::std::mem::transmute(ppvobject),
        )
        .ok()
    }
}
unsafe impl ::windows::runtime::Interface for IServiceProvider {
    type Vtable = IServiceProvider_abi;
    const IID: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
        1834041537,
        29750,
        4558,
        [128, 52, 0, 170, 0, 96, 9, 250],
    );
}
impl ::std::convert::From<IServiceProvider> for ::windows::runtime::IUnknown {
    fn from(value: IServiceProvider) -> Self {
        unsafe { ::std::mem::transmute(value) }
    }
}
impl ::std::convert::From<&IServiceProvider> for ::windows::runtime::IUnknown {
    fn from(value: &IServiceProvider) -> Self {
        ::std::convert::From::from(::std::clone::Clone::clone(value))
    }
}
impl<'a> ::windows::runtime::IntoParam<'a, ::windows::runtime::IUnknown> for IServiceProvider {
    fn into_param(self) -> ::windows::runtime::Param<'a, ::windows::runtime::IUnknown> {
        ::windows::runtime::Param::Owned(
            ::std::convert::Into::<::windows::runtime::IUnknown>::into(self),
        )
    }
}
impl<'a> ::windows::runtime::IntoParam<'a, ::windows::runtime::IUnknown> for &IServiceProvider {
    fn into_param(self) -> ::windows::runtime::Param<'a, ::windows::runtime::IUnknown> {
        ::windows::runtime::Param::Owned(
            ::std::convert::Into::<::windows::runtime::IUnknown>::into(::std::clone::Clone::clone(
                self,
            )),
        )
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IServiceProvider_abi(
    pub  unsafe extern "system" fn(
        this: ::windows::runtime::RawPtr,
        iid: &::windows::runtime::GUID,
        interface: *mut ::windows::runtime::RawPtr,
    ) -> ::windows::runtime::HRESULT,
    pub unsafe extern "system" fn(this: ::windows::runtime::RawPtr) -> u32,
    pub unsafe extern "system" fn(this: ::windows::runtime::RawPtr) -> u32,
    pub  unsafe extern "system" fn(
        this: ::windows::runtime::RawPtr,
        guidservice: *const ::windows::runtime::GUID,
        riid: *const ::windows::runtime::GUID,
        ppvobject: *mut *mut ::std::ffi::c_void,
    ) -> ::windows::runtime::HRESULT,
);
#[cfg(feature = "Win32_System_Rpc")]
pub unsafe fn I_RpcNsGetBuffer(message: *mut super::Rpc::RPC_MESSAGE) -> super::Rpc::RPC_STATUS {
    #[cfg(windows)]
    {
        #[link(name = "rpcns4")]
        extern "system" {
            fn I_RpcNsGetBuffer(message: *mut super::Rpc::RPC_MESSAGE) -> super::Rpc::RPC_STATUS;
        }
        ::std::mem::transmute(I_RpcNsGetBuffer(::std::mem::transmute(message)))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(feature = "Win32_System_Rpc")]
pub unsafe fn I_RpcNsRaiseException(
    message: *mut super::Rpc::RPC_MESSAGE,
    status: super::Rpc::RPC_STATUS,
) {
    #[cfg(windows)]
    {
        #[link(name = "rpcns4")]
        extern "system" {
            fn I_RpcNsRaiseException(
                message: *mut super::Rpc::RPC_MESSAGE,
                status: super::Rpc::RPC_STATUS,
            );
        }
        ::std::mem::transmute(I_RpcNsRaiseException(
            ::std::mem::transmute(message),
            ::std::mem::transmute(status),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(feature = "Win32_System_Rpc")]
pub unsafe fn I_RpcNsSendReceive(
    message: *mut super::Rpc::RPC_MESSAGE,
    handle: *mut *mut ::std::ffi::c_void,
) -> super::Rpc::RPC_STATUS {
    #[cfg(windows)]
    {
        #[link(name = "rpcns4")]
        extern "system" {
            fn I_RpcNsSendReceive(
                message: *mut super::Rpc::RPC_MESSAGE,
                handle: *mut *mut ::std::ffi::c_void,
            ) -> super::Rpc::RPC_STATUS;
        }
        ::std::mem::transmute(I_RpcNsSendReceive(
            ::std::mem::transmute(message),
            ::std::mem::transmute(handle),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(feature = "Win32_System_Rpc")]
pub unsafe fn I_RpcReBindBuffer(message: *mut super::Rpc::RPC_MESSAGE) -> super::Rpc::RPC_STATUS {
    #[cfg(windows)]
    {
        #[link(name = "rpcns4")]
        extern "system" {
            fn I_RpcReBindBuffer(message: *mut super::Rpc::RPC_MESSAGE) -> super::Rpc::RPC_STATUS;
        }
        ::std::mem::transmute(I_RpcReBindBuffer(::std::mem::transmute(message)))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct JOBOBJECTINFOCLASS(pub i32);
pub const JobObjectBasicAccountingInformation: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(1i32);
pub const JobObjectBasicLimitInformation: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(2i32);
pub const JobObjectBasicProcessIdList: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(3i32);
pub const JobObjectBasicUIRestrictions: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(4i32);
pub const JobObjectSecurityLimitInformation: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(5i32);
pub const JobObjectEndOfJobTimeInformation: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(6i32);
pub const JobObjectAssociateCompletionPortInformation: JOBOBJECTINFOCLASS =
    JOBOBJECTINFOCLASS(7i32);
pub const JobObjectBasicAndIoAccountingInformation: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(8i32);
pub const JobObjectExtendedLimitInformation: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(9i32);
pub const JobObjectJobSetInformation: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(10i32);
pub const JobObjectGroupInformation: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(11i32);
pub const JobObjectNotificationLimitInformation: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(12i32);
pub const JobObjectLimitViolationInformation: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(13i32);
pub const JobObjectGroupInformationEx: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(14i32);
pub const JobObjectCpuRateControlInformation: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(15i32);
pub const JobObjectCompletionFilter: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(16i32);
pub const JobObjectCompletionCounter: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(17i32);
pub const JobObjectReserved1Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(18i32);
pub const JobObjectReserved2Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(19i32);
pub const JobObjectReserved3Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(20i32);
pub const JobObjectReserved4Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(21i32);
pub const JobObjectReserved5Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(22i32);
pub const JobObjectReserved6Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(23i32);
pub const JobObjectReserved7Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(24i32);
pub const JobObjectReserved8Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(25i32);
pub const JobObjectReserved9Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(26i32);
pub const JobObjectReserved10Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(27i32);
pub const JobObjectReserved11Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(28i32);
pub const JobObjectReserved12Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(29i32);
pub const JobObjectReserved13Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(30i32);
pub const JobObjectReserved14Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(31i32);
pub const JobObjectNetRateControlInformation: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(32i32);
pub const JobObjectNotificationLimitInformation2: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(33i32);
pub const JobObjectLimitViolationInformation2: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(34i32);
pub const JobObjectCreateSilo: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(35i32);
pub const JobObjectSiloBasicInformation: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(36i32);
pub const JobObjectReserved15Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(37i32);
pub const JobObjectReserved16Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(38i32);
pub const JobObjectReserved17Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(39i32);
pub const JobObjectReserved18Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(40i32);
pub const JobObjectReserved19Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(41i32);
pub const JobObjectReserved20Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(42i32);
pub const JobObjectReserved21Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(43i32);
pub const JobObjectReserved22Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(44i32);
pub const JobObjectReserved23Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(45i32);
pub const JobObjectReserved24Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(46i32);
pub const JobObjectReserved25Information: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(47i32);
pub const MaxJobObjectInfoClass: JOBOBJECTINFOCLASS = JOBOBJECTINFOCLASS(48i32);
impl ::std::convert::From<i32> for JOBOBJECTINFOCLASS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for JOBOBJECTINFOCLASS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    pub CompletionKey: *mut ::std::ffi::c_void,
    pub CompletionPort: super::super::Foundation::HANDLE,
}
#[cfg(feature = "Win32_Foundation")]
impl JOBOBJECT_ASSOCIATE_COMPLETION_PORT {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_ASSOCIATE_COMPLETION_PORT")
            .field("CompletionKey", &self.CompletionKey)
            .field("CompletionPort", &self.CompletionPort)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    fn eq(&self, other: &Self) -> bool {
        self.CompletionKey == other.CompletionKey && self.CompletionPort == other.CompletionPort
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for JOBOBJECT_ASSOCIATE_COMPLETION_PORT {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    pub TotalUserTime: i64,
    pub TotalKernelTime: i64,
    pub ThisPeriodTotalUserTime: i64,
    pub ThisPeriodTotalKernelTime: i64,
    pub TotalPageFaultCount: u32,
    pub TotalProcesses: u32,
    pub ActiveProcesses: u32,
    pub TotalTerminatedProcesses: u32,
}
impl JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {}
impl ::std::default::Default for JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_BASIC_ACCOUNTING_INFORMATION")
            .field("TotalUserTime", &self.TotalUserTime)
            .field("TotalKernelTime", &self.TotalKernelTime)
            .field("ThisPeriodTotalUserTime", &self.ThisPeriodTotalUserTime)
            .field("ThisPeriodTotalKernelTime", &self.ThisPeriodTotalKernelTime)
            .field("TotalPageFaultCount", &self.TotalPageFaultCount)
            .field("TotalProcesses", &self.TotalProcesses)
            .field("ActiveProcesses", &self.ActiveProcesses)
            .field("TotalTerminatedProcesses", &self.TotalTerminatedProcesses)
            .finish()
    }
}
impl ::std::cmp::PartialEq for JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.TotalUserTime == other.TotalUserTime
            && self.TotalKernelTime == other.TotalKernelTime
            && self.ThisPeriodTotalUserTime == other.ThisPeriodTotalUserTime
            && self.ThisPeriodTotalKernelTime == other.ThisPeriodTotalKernelTime
            && self.TotalPageFaultCount == other.TotalPageFaultCount
            && self.TotalProcesses == other.TotalProcesses
            && self.ActiveProcesses == other.ActiveProcesses
            && self.TotalTerminatedProcesses == other.TotalTerminatedProcesses
    }
}
impl ::std::cmp::Eq for JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    pub BasicInfo: JOBOBJECT_BASIC_ACCOUNTING_INFORMATION,
    pub IoInfo: IO_COUNTERS,
}
impl JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {}
impl ::std::default::Default for JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION")
            .field("BasicInfo", &self.BasicInfo)
            .field("IoInfo", &self.IoInfo)
            .finish()
    }
}
impl ::std::cmp::PartialEq for JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.BasicInfo == other.BasicInfo && self.IoInfo == other.IoInfo
    }
}
impl ::std::cmp::Eq for JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_JobObjects")]
pub struct JOBOBJECT_BASIC_LIMIT_INFORMATION {
    pub PerProcessUserTimeLimit: i64,
    pub PerJobUserTimeLimit: i64,
    pub LimitFlags: super::JobObjects::JOB_OBJECT_LIMIT,
    pub MinimumWorkingSetSize: usize,
    pub MaximumWorkingSetSize: usize,
    pub ActiveProcessLimit: u32,
    pub Affinity: usize,
    pub PriorityClass: u32,
    pub SchedulingClass: u32,
}
#[cfg(feature = "Win32_System_JobObjects")]
impl JOBOBJECT_BASIC_LIMIT_INFORMATION {}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::default::Default for JOBOBJECT_BASIC_LIMIT_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::fmt::Debug for JOBOBJECT_BASIC_LIMIT_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_BASIC_LIMIT_INFORMATION")
            .field("PerProcessUserTimeLimit", &self.PerProcessUserTimeLimit)
            .field("PerJobUserTimeLimit", &self.PerJobUserTimeLimit)
            .field("LimitFlags", &self.LimitFlags)
            .field("MinimumWorkingSetSize", &self.MinimumWorkingSetSize)
            .field("MaximumWorkingSetSize", &self.MaximumWorkingSetSize)
            .field("ActiveProcessLimit", &self.ActiveProcessLimit)
            .field("Affinity", &self.Affinity)
            .field("PriorityClass", &self.PriorityClass)
            .field("SchedulingClass", &self.SchedulingClass)
            .finish()
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::cmp::PartialEq for JOBOBJECT_BASIC_LIMIT_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.PerProcessUserTimeLimit == other.PerProcessUserTimeLimit
            && self.PerJobUserTimeLimit == other.PerJobUserTimeLimit
            && self.LimitFlags == other.LimitFlags
            && self.MinimumWorkingSetSize == other.MinimumWorkingSetSize
            && self.MaximumWorkingSetSize == other.MaximumWorkingSetSize
            && self.ActiveProcessLimit == other.ActiveProcessLimit
            && self.Affinity == other.Affinity
            && self.PriorityClass == other.PriorityClass
            && self.SchedulingClass == other.SchedulingClass
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::cmp::Eq for JOBOBJECT_BASIC_LIMIT_INFORMATION {}
#[cfg(feature = "Win32_System_JobObjects")]
unsafe impl ::windows::runtime::Abi for JOBOBJECT_BASIC_LIMIT_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct JOBOBJECT_BASIC_PROCESS_ID_LIST {
    pub NumberOfAssignedProcesses: u32,
    pub NumberOfProcessIdsInList: u32,
    pub ProcessIdList: [usize; 1],
}
impl JOBOBJECT_BASIC_PROCESS_ID_LIST {}
impl ::std::default::Default for JOBOBJECT_BASIC_PROCESS_ID_LIST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for JOBOBJECT_BASIC_PROCESS_ID_LIST {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_BASIC_PROCESS_ID_LIST")
            .field("NumberOfAssignedProcesses", &self.NumberOfAssignedProcesses)
            .field("NumberOfProcessIdsInList", &self.NumberOfProcessIdsInList)
            .field("ProcessIdList", &self.ProcessIdList)
            .finish()
    }
}
impl ::std::cmp::PartialEq for JOBOBJECT_BASIC_PROCESS_ID_LIST {
    fn eq(&self, other: &Self) -> bool {
        self.NumberOfAssignedProcesses == other.NumberOfAssignedProcesses
            && self.NumberOfProcessIdsInList == other.NumberOfProcessIdsInList
            && self.ProcessIdList == other.ProcessIdList
    }
}
impl ::std::cmp::Eq for JOBOBJECT_BASIC_PROCESS_ID_LIST {}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_BASIC_PROCESS_ID_LIST {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_JobObjects")]
pub struct JOBOBJECT_BASIC_UI_RESTRICTIONS {
    pub UIRestrictionsClass: super::JobObjects::JOB_OBJECT_UILIMIT,
}
#[cfg(feature = "Win32_System_JobObjects")]
impl JOBOBJECT_BASIC_UI_RESTRICTIONS {}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::default::Default for JOBOBJECT_BASIC_UI_RESTRICTIONS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::fmt::Debug for JOBOBJECT_BASIC_UI_RESTRICTIONS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_BASIC_UI_RESTRICTIONS")
            .field("UIRestrictionsClass", &self.UIRestrictionsClass)
            .finish()
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::cmp::PartialEq for JOBOBJECT_BASIC_UI_RESTRICTIONS {
    fn eq(&self, other: &Self) -> bool {
        self.UIRestrictionsClass == other.UIRestrictionsClass
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::cmp::Eq for JOBOBJECT_BASIC_UI_RESTRICTIONS {}
#[cfg(feature = "Win32_System_JobObjects")]
unsafe impl ::windows::runtime::Abi for JOBOBJECT_BASIC_UI_RESTRICTIONS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
    pub ControlFlags: JOB_OBJECT_CPU_RATE_CONTROL,
    pub Anonymous: JOBOBJECT_CPU_RATE_CONTROL_INFORMATION_0,
}
impl JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {}
impl ::std::default::Default for JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union JOBOBJECT_CPU_RATE_CONTROL_INFORMATION_0 {
    pub CpuRate: u32,
    pub Weight: u32,
    pub Anonymous: JOBOBJECT_CPU_RATE_CONTROL_INFORMATION_0_0,
}
impl JOBOBJECT_CPU_RATE_CONTROL_INFORMATION_0 {}
impl ::std::default::Default for JOBOBJECT_CPU_RATE_CONTROL_INFORMATION_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for JOBOBJECT_CPU_RATE_CONTROL_INFORMATION_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for JOBOBJECT_CPU_RATE_CONTROL_INFORMATION_0 {}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_CPU_RATE_CONTROL_INFORMATION_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct JOBOBJECT_CPU_RATE_CONTROL_INFORMATION_0_0 {
    pub MinRate: u16,
    pub MaxRate: u16,
}
impl JOBOBJECT_CPU_RATE_CONTROL_INFORMATION_0_0 {}
impl ::std::default::Default for JOBOBJECT_CPU_RATE_CONTROL_INFORMATION_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for JOBOBJECT_CPU_RATE_CONTROL_INFORMATION_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("MinRate", &self.MinRate)
            .field("MaxRate", &self.MaxRate)
            .finish()
    }
}
impl ::std::cmp::PartialEq for JOBOBJECT_CPU_RATE_CONTROL_INFORMATION_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.MinRate == other.MinRate && self.MaxRate == other.MaxRate
    }
}
impl ::std::cmp::Eq for JOBOBJECT_CPU_RATE_CONTROL_INFORMATION_0_0 {}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_CPU_RATE_CONTROL_INFORMATION_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    pub EndOfJobTimeAction: JOB_OBJECT_TERMINATE_AT_END_ACTION,
}
impl JOBOBJECT_END_OF_JOB_TIME_INFORMATION {}
impl ::std::default::Default for JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_END_OF_JOB_TIME_INFORMATION")
            .field("EndOfJobTimeAction", &self.EndOfJobTimeAction)
            .finish()
    }
}
impl ::std::cmp::PartialEq for JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.EndOfJobTimeAction == other.EndOfJobTimeAction
    }
}
impl ::std::cmp::Eq for JOBOBJECT_END_OF_JOB_TIME_INFORMATION {}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_JobObjects")]
pub struct JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    pub BasicLimitInformation: JOBOBJECT_BASIC_LIMIT_INFORMATION,
    pub IoInfo: IO_COUNTERS,
    pub ProcessMemoryLimit: usize,
    pub JobMemoryLimit: usize,
    pub PeakProcessMemoryUsed: usize,
    pub PeakJobMemoryUsed: usize,
}
#[cfg(feature = "Win32_System_JobObjects")]
impl JOBOBJECT_EXTENDED_LIMIT_INFORMATION {}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::default::Default for JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::fmt::Debug for JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_EXTENDED_LIMIT_INFORMATION")
            .field("BasicLimitInformation", &self.BasicLimitInformation)
            .field("IoInfo", &self.IoInfo)
            .field("ProcessMemoryLimit", &self.ProcessMemoryLimit)
            .field("JobMemoryLimit", &self.JobMemoryLimit)
            .field("PeakProcessMemoryUsed", &self.PeakProcessMemoryUsed)
            .field("PeakJobMemoryUsed", &self.PeakJobMemoryUsed)
            .finish()
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::cmp::PartialEq for JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.BasicLimitInformation == other.BasicLimitInformation
            && self.IoInfo == other.IoInfo
            && self.ProcessMemoryLimit == other.ProcessMemoryLimit
            && self.JobMemoryLimit == other.JobMemoryLimit
            && self.PeakProcessMemoryUsed == other.PeakProcessMemoryUsed
            && self.PeakJobMemoryUsed == other.PeakJobMemoryUsed
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::cmp::Eq for JOBOBJECT_EXTENDED_LIMIT_INFORMATION {}
#[cfg(feature = "Win32_System_JobObjects")]
unsafe impl ::windows::runtime::Abi for JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS(pub i32);
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE: JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS =
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS(1i32);
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE: JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS =
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS(2i32);
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS: JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS =
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS(3i32);
impl ::std::convert::From<i32> for JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct JOBOBJECT_IO_ATTRIBUTION_INFORMATION {
    pub ControlFlags: u32,
    pub ReadStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
    pub WriteStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
}
impl JOBOBJECT_IO_ATTRIBUTION_INFORMATION {}
impl ::std::default::Default for JOBOBJECT_IO_ATTRIBUTION_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for JOBOBJECT_IO_ATTRIBUTION_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_IO_ATTRIBUTION_INFORMATION")
            .field("ControlFlags", &self.ControlFlags)
            .field("ReadStats", &self.ReadStats)
            .field("WriteStats", &self.WriteStats)
            .finish()
    }
}
impl ::std::cmp::PartialEq for JOBOBJECT_IO_ATTRIBUTION_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.ControlFlags == other.ControlFlags
            && self.ReadStats == other.ReadStats
            && self.WriteStats == other.WriteStats
    }
}
impl ::std::cmp::Eq for JOBOBJECT_IO_ATTRIBUTION_INFORMATION {}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_IO_ATTRIBUTION_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct JOBOBJECT_IO_ATTRIBUTION_STATS {
    pub IoCount: usize,
    pub TotalNonOverlappedQueueTime: u64,
    pub TotalNonOverlappedServiceTime: u64,
    pub TotalSize: u64,
}
impl JOBOBJECT_IO_ATTRIBUTION_STATS {}
impl ::std::default::Default for JOBOBJECT_IO_ATTRIBUTION_STATS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for JOBOBJECT_IO_ATTRIBUTION_STATS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_IO_ATTRIBUTION_STATS")
            .field("IoCount", &self.IoCount)
            .field(
                "TotalNonOverlappedQueueTime",
                &self.TotalNonOverlappedQueueTime,
            )
            .field(
                "TotalNonOverlappedServiceTime",
                &self.TotalNonOverlappedServiceTime,
            )
            .field("TotalSize", &self.TotalSize)
            .finish()
    }
}
impl ::std::cmp::PartialEq for JOBOBJECT_IO_ATTRIBUTION_STATS {
    fn eq(&self, other: &Self) -> bool {
        self.IoCount == other.IoCount
            && self.TotalNonOverlappedQueueTime == other.TotalNonOverlappedQueueTime
            && self.TotalNonOverlappedServiceTime == other.TotalNonOverlappedServiceTime
            && self.TotalSize == other.TotalSize
    }
}
impl ::std::cmp::Eq for JOBOBJECT_IO_ATTRIBUTION_STATS {}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_IO_ATTRIBUTION_STATS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {
    pub MaxIops: i64,
    pub MaxBandwidth: i64,
    pub ReservationIops: i64,
    pub VolumeName: super::super::Foundation::PWSTR,
    pub BaseIoSize: u32,
    pub ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    pub VolumeNameLength: u16,
}
#[cfg(feature = "Win32_Foundation")]
impl JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE")
            .field("MaxIops", &self.MaxIops)
            .field("MaxBandwidth", &self.MaxBandwidth)
            .field("ReservationIops", &self.ReservationIops)
            .field("VolumeName", &self.VolumeName)
            .field("BaseIoSize", &self.BaseIoSize)
            .field("ControlFlags", &self.ControlFlags)
            .field("VolumeNameLength", &self.VolumeNameLength)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {
    fn eq(&self, other: &Self) -> bool {
        self.MaxIops == other.MaxIops
            && self.MaxBandwidth == other.MaxBandwidth
            && self.ReservationIops == other.ReservationIops
            && self.VolumeName == other.VolumeName
            && self.BaseIoSize == other.BaseIoSize
            && self.ControlFlags == other.ControlFlags
            && self.VolumeNameLength == other.VolumeNameLength
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {
    pub MaxIops: i64,
    pub MaxBandwidth: i64,
    pub ReservationIops: i64,
    pub VolumeName: super::super::Foundation::PWSTR,
    pub BaseIoSize: u32,
    pub ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    pub VolumeNameLength: u16,
    pub CriticalReservationIops: i64,
    pub ReservationBandwidth: i64,
    pub CriticalReservationBandwidth: i64,
    pub MaxTimePercent: i64,
    pub ReservationTimePercent: i64,
    pub CriticalReservationTimePercent: i64,
}
#[cfg(feature = "Win32_Foundation")]
impl JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2")
            .field("MaxIops", &self.MaxIops)
            .field("MaxBandwidth", &self.MaxBandwidth)
            .field("ReservationIops", &self.ReservationIops)
            .field("VolumeName", &self.VolumeName)
            .field("BaseIoSize", &self.BaseIoSize)
            .field("ControlFlags", &self.ControlFlags)
            .field("VolumeNameLength", &self.VolumeNameLength)
            .field("CriticalReservationIops", &self.CriticalReservationIops)
            .field("ReservationBandwidth", &self.ReservationBandwidth)
            .field(
                "CriticalReservationBandwidth",
                &self.CriticalReservationBandwidth,
            )
            .field("MaxTimePercent", &self.MaxTimePercent)
            .field("ReservationTimePercent", &self.ReservationTimePercent)
            .field(
                "CriticalReservationTimePercent",
                &self.CriticalReservationTimePercent,
            )
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {
    fn eq(&self, other: &Self) -> bool {
        self.MaxIops == other.MaxIops
            && self.MaxBandwidth == other.MaxBandwidth
            && self.ReservationIops == other.ReservationIops
            && self.VolumeName == other.VolumeName
            && self.BaseIoSize == other.BaseIoSize
            && self.ControlFlags == other.ControlFlags
            && self.VolumeNameLength == other.VolumeNameLength
            && self.CriticalReservationIops == other.CriticalReservationIops
            && self.ReservationBandwidth == other.ReservationBandwidth
            && self.CriticalReservationBandwidth == other.CriticalReservationBandwidth
            && self.MaxTimePercent == other.MaxTimePercent
            && self.ReservationTimePercent == other.ReservationTimePercent
            && self.CriticalReservationTimePercent == other.CriticalReservationTimePercent
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {
    pub MaxIops: i64,
    pub MaxBandwidth: i64,
    pub ReservationIops: i64,
    pub VolumeName: super::super::Foundation::PWSTR,
    pub BaseIoSize: u32,
    pub ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    pub VolumeNameLength: u16,
    pub CriticalReservationIops: i64,
    pub ReservationBandwidth: i64,
    pub CriticalReservationBandwidth: i64,
    pub MaxTimePercent: i64,
    pub ReservationTimePercent: i64,
    pub CriticalReservationTimePercent: i64,
    pub SoftMaxIops: i64,
    pub SoftMaxBandwidth: i64,
    pub SoftMaxTimePercent: i64,
    pub LimitExcessNotifyIops: i64,
    pub LimitExcessNotifyBandwidth: i64,
    pub LimitExcessNotifyTimePercent: i64,
}
#[cfg(feature = "Win32_Foundation")]
impl JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3")
            .field("MaxIops", &self.MaxIops)
            .field("MaxBandwidth", &self.MaxBandwidth)
            .field("ReservationIops", &self.ReservationIops)
            .field("VolumeName", &self.VolumeName)
            .field("BaseIoSize", &self.BaseIoSize)
            .field("ControlFlags", &self.ControlFlags)
            .field("VolumeNameLength", &self.VolumeNameLength)
            .field("CriticalReservationIops", &self.CriticalReservationIops)
            .field("ReservationBandwidth", &self.ReservationBandwidth)
            .field(
                "CriticalReservationBandwidth",
                &self.CriticalReservationBandwidth,
            )
            .field("MaxTimePercent", &self.MaxTimePercent)
            .field("ReservationTimePercent", &self.ReservationTimePercent)
            .field(
                "CriticalReservationTimePercent",
                &self.CriticalReservationTimePercent,
            )
            .field("SoftMaxIops", &self.SoftMaxIops)
            .field("SoftMaxBandwidth", &self.SoftMaxBandwidth)
            .field("SoftMaxTimePercent", &self.SoftMaxTimePercent)
            .field("LimitExcessNotifyIops", &self.LimitExcessNotifyIops)
            .field(
                "LimitExcessNotifyBandwidth",
                &self.LimitExcessNotifyBandwidth,
            )
            .field(
                "LimitExcessNotifyTimePercent",
                &self.LimitExcessNotifyTimePercent,
            )
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {
    fn eq(&self, other: &Self) -> bool {
        self.MaxIops == other.MaxIops
            && self.MaxBandwidth == other.MaxBandwidth
            && self.ReservationIops == other.ReservationIops
            && self.VolumeName == other.VolumeName
            && self.BaseIoSize == other.BaseIoSize
            && self.ControlFlags == other.ControlFlags
            && self.VolumeNameLength == other.VolumeNameLength
            && self.CriticalReservationIops == other.CriticalReservationIops
            && self.ReservationBandwidth == other.ReservationBandwidth
            && self.CriticalReservationBandwidth == other.CriticalReservationBandwidth
            && self.MaxTimePercent == other.MaxTimePercent
            && self.ReservationTimePercent == other.ReservationTimePercent
            && self.CriticalReservationTimePercent == other.CriticalReservationTimePercent
            && self.SoftMaxIops == other.SoftMaxIops
            && self.SoftMaxBandwidth == other.SoftMaxBandwidth
            && self.SoftMaxTimePercent == other.SoftMaxTimePercent
            && self.LimitExcessNotifyIops == other.LimitExcessNotifyIops
            && self.LimitExcessNotifyBandwidth == other.LimitExcessNotifyBandwidth
            && self.LimitExcessNotifyTimePercent == other.LimitExcessNotifyTimePercent
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct JOBOBJECT_JOBSET_INFORMATION {
    pub MemberLevel: u32,
}
impl JOBOBJECT_JOBSET_INFORMATION {}
impl ::std::default::Default for JOBOBJECT_JOBSET_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for JOBOBJECT_JOBSET_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_JOBSET_INFORMATION")
            .field("MemberLevel", &self.MemberLevel)
            .finish()
    }
}
impl ::std::cmp::PartialEq for JOBOBJECT_JOBSET_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.MemberLevel == other.MemberLevel
    }
}
impl ::std::cmp::Eq for JOBOBJECT_JOBSET_INFORMATION {}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_JOBSET_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_JobObjects")]
pub struct JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
    pub LimitFlags: super::JobObjects::JOB_OBJECT_LIMIT,
    pub ViolationLimitFlags: super::JobObjects::JOB_OBJECT_LIMIT,
    pub IoReadBytes: u64,
    pub IoReadBytesLimit: u64,
    pub IoWriteBytes: u64,
    pub IoWriteBytesLimit: u64,
    pub PerJobUserTime: i64,
    pub PerJobUserTimeLimit: i64,
    pub JobMemory: u64,
    pub JobMemoryLimit: u64,
    pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub RateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
#[cfg(feature = "Win32_System_JobObjects")]
impl JOBOBJECT_LIMIT_VIOLATION_INFORMATION {}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::default::Default for JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::fmt::Debug for JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_LIMIT_VIOLATION_INFORMATION")
            .field("LimitFlags", &self.LimitFlags)
            .field("ViolationLimitFlags", &self.ViolationLimitFlags)
            .field("IoReadBytes", &self.IoReadBytes)
            .field("IoReadBytesLimit", &self.IoReadBytesLimit)
            .field("IoWriteBytes", &self.IoWriteBytes)
            .field("IoWriteBytesLimit", &self.IoWriteBytesLimit)
            .field("PerJobUserTime", &self.PerJobUserTime)
            .field("PerJobUserTimeLimit", &self.PerJobUserTimeLimit)
            .field("JobMemory", &self.JobMemory)
            .field("JobMemoryLimit", &self.JobMemoryLimit)
            .field("RateControlTolerance", &self.RateControlTolerance)
            .field("RateControlToleranceLimit", &self.RateControlToleranceLimit)
            .finish()
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::cmp::PartialEq for JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.LimitFlags == other.LimitFlags
            && self.ViolationLimitFlags == other.ViolationLimitFlags
            && self.IoReadBytes == other.IoReadBytes
            && self.IoReadBytesLimit == other.IoReadBytesLimit
            && self.IoWriteBytes == other.IoWriteBytes
            && self.IoWriteBytesLimit == other.IoWriteBytesLimit
            && self.PerJobUserTime == other.PerJobUserTime
            && self.PerJobUserTimeLimit == other.PerJobUserTimeLimit
            && self.JobMemory == other.JobMemory
            && self.JobMemoryLimit == other.JobMemoryLimit
            && self.RateControlTolerance == other.RateControlTolerance
            && self.RateControlToleranceLimit == other.RateControlToleranceLimit
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::cmp::Eq for JOBOBJECT_LIMIT_VIOLATION_INFORMATION {}
#[cfg(feature = "Win32_System_JobObjects")]
unsafe impl ::windows::runtime::Abi for JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_JobObjects")]
pub struct JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 {
    pub LimitFlags: super::JobObjects::JOB_OBJECT_LIMIT,
    pub ViolationLimitFlags: super::JobObjects::JOB_OBJECT_LIMIT,
    pub IoReadBytes: u64,
    pub IoReadBytesLimit: u64,
    pub IoWriteBytes: u64,
    pub IoWriteBytesLimit: u64,
    pub PerJobUserTime: i64,
    pub PerJobUserTimeLimit: i64,
    pub JobMemory: u64,
    pub Anonymous1: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_0,
    pub Anonymous2: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_1,
    pub Anonymous3: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_2,
    pub JobLowMemoryLimit: u64,
    pub IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub IoRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub NetRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
#[cfg(feature = "Win32_System_JobObjects")]
impl JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 {}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::default::Default for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::cmp::PartialEq for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::cmp::Eq for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 {}
#[cfg(feature = "Win32_System_JobObjects")]
unsafe impl ::windows::runtime::Abi for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_0 {
    pub JobHighMemoryLimit: u64,
    pub JobMemoryLimit: u64,
}
impl JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_0 {}
impl ::std::default::Default for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_0 {}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_1 {
    pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub CpuRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
impl JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_1 {}
impl ::std::default::Default for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_1 {}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_2 {
    pub RateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub CpuRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
impl JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_2 {}
impl ::std::default::Default for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_2 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_2 {}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct JOBOBJECT_NET_RATE_CONTROL_INFORMATION {
    pub MaxBandwidth: u64,
    pub ControlFlags: JOB_OBJECT_NET_RATE_CONTROL_FLAGS,
    pub DscpTag: u8,
}
impl JOBOBJECT_NET_RATE_CONTROL_INFORMATION {}
impl ::std::default::Default for JOBOBJECT_NET_RATE_CONTROL_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for JOBOBJECT_NET_RATE_CONTROL_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_NET_RATE_CONTROL_INFORMATION")
            .field("MaxBandwidth", &self.MaxBandwidth)
            .field("ControlFlags", &self.ControlFlags)
            .field("DscpTag", &self.DscpTag)
            .finish()
    }
}
impl ::std::cmp::PartialEq for JOBOBJECT_NET_RATE_CONTROL_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.MaxBandwidth == other.MaxBandwidth
            && self.ControlFlags == other.ControlFlags
            && self.DscpTag == other.DscpTag
    }
}
impl ::std::cmp::Eq for JOBOBJECT_NET_RATE_CONTROL_INFORMATION {}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_NET_RATE_CONTROL_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_JobObjects")]
pub struct JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
    pub IoReadBytesLimit: u64,
    pub IoWriteBytesLimit: u64,
    pub PerJobUserTimeLimit: i64,
    pub JobMemoryLimit: u64,
    pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub RateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    pub LimitFlags: super::JobObjects::JOB_OBJECT_LIMIT,
}
#[cfg(feature = "Win32_System_JobObjects")]
impl JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::default::Default for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::fmt::Debug for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION")
            .field("IoReadBytesLimit", &self.IoReadBytesLimit)
            .field("IoWriteBytesLimit", &self.IoWriteBytesLimit)
            .field("PerJobUserTimeLimit", &self.PerJobUserTimeLimit)
            .field("JobMemoryLimit", &self.JobMemoryLimit)
            .field("RateControlTolerance", &self.RateControlTolerance)
            .field(
                "RateControlToleranceInterval",
                &self.RateControlToleranceInterval,
            )
            .field("LimitFlags", &self.LimitFlags)
            .finish()
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::cmp::PartialEq for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.IoReadBytesLimit == other.IoReadBytesLimit
            && self.IoWriteBytesLimit == other.IoWriteBytesLimit
            && self.PerJobUserTimeLimit == other.PerJobUserTimeLimit
            && self.JobMemoryLimit == other.JobMemoryLimit
            && self.RateControlTolerance == other.RateControlTolerance
            && self.RateControlToleranceInterval == other.RateControlToleranceInterval
            && self.LimitFlags == other.LimitFlags
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::cmp::Eq for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {}
#[cfg(feature = "Win32_System_JobObjects")]
unsafe impl ::windows::runtime::Abi for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_JobObjects")]
pub struct JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 {
    pub IoReadBytesLimit: u64,
    pub IoWriteBytesLimit: u64,
    pub PerJobUserTimeLimit: i64,
    pub Anonymous1: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_0,
    pub Anonymous2: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_1,
    pub Anonymous3: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_2,
    pub LimitFlags: super::JobObjects::JOB_OBJECT_LIMIT,
    pub IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub JobLowMemoryLimit: u64,
    pub IoRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    pub NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub NetRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
}
#[cfg(feature = "Win32_System_JobObjects")]
impl JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 {}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::default::Default for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::cmp::PartialEq for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_JobObjects")]
impl ::std::cmp::Eq for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 {}
#[cfg(feature = "Win32_System_JobObjects")]
unsafe impl ::windows::runtime::Abi for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_0 {
    pub JobHighMemoryLimit: u64,
    pub JobMemoryLimit: u64,
}
impl JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_0 {}
impl ::std::default::Default for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_0 {}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_1 {
    pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub CpuRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
impl JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_1 {}
impl ::std::default::Default for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_1 {}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_2 {
    pub RateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    pub CpuRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
}
impl JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_2 {}
impl ::std::default::Default for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_2 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_2 {}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct JOBOBJECT_RATE_CONTROL_TOLERANCE(pub i32);
pub const ToleranceLow: JOBOBJECT_RATE_CONTROL_TOLERANCE = JOBOBJECT_RATE_CONTROL_TOLERANCE(1i32);
pub const ToleranceMedium: JOBOBJECT_RATE_CONTROL_TOLERANCE =
    JOBOBJECT_RATE_CONTROL_TOLERANCE(2i32);
pub const ToleranceHigh: JOBOBJECT_RATE_CONTROL_TOLERANCE = JOBOBJECT_RATE_CONTROL_TOLERANCE(3i32);
impl ::std::convert::From<i32> for JOBOBJECT_RATE_CONTROL_TOLERANCE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_RATE_CONTROL_TOLERANCE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL(pub i32);
pub const ToleranceIntervalShort: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL =
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL(1i32);
pub const ToleranceIntervalMedium: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL =
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL(2i32);
pub const ToleranceIntervalLong: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL =
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL(3i32);
impl ::std::convert::From<i32> for JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_Security",
    feature = "Win32_System_JobObjects"
))]
pub struct JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    pub SecurityLimitFlags: super::JobObjects::JOB_OBJECT_SECURITY,
    pub JobToken: super::super::Foundation::HANDLE,
    pub SidsToDisable: *mut super::super::Security::TOKEN_GROUPS,
    pub PrivilegesToDelete: *mut super::super::Security::TOKEN_PRIVILEGES,
    pub RestrictedSids: *mut super::super::Security::TOKEN_GROUPS,
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_Security",
    feature = "Win32_System_JobObjects"
))]
impl JOBOBJECT_SECURITY_LIMIT_INFORMATION {}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_Security",
    feature = "Win32_System_JobObjects"
))]
impl ::std::default::Default for JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_Security",
    feature = "Win32_System_JobObjects"
))]
impl ::std::fmt::Debug for JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOBOBJECT_SECURITY_LIMIT_INFORMATION")
            .field("SecurityLimitFlags", &self.SecurityLimitFlags)
            .field("JobToken", &self.JobToken)
            .field("SidsToDisable", &self.SidsToDisable)
            .field("PrivilegesToDelete", &self.PrivilegesToDelete)
            .field("RestrictedSids", &self.RestrictedSids)
            .finish()
    }
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_Security",
    feature = "Win32_System_JobObjects"
))]
impl ::std::cmp::PartialEq for JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.SecurityLimitFlags == other.SecurityLimitFlags
            && self.JobToken == other.JobToken
            && self.SidsToDisable == other.SidsToDisable
            && self.PrivilegesToDelete == other.PrivilegesToDelete
            && self.RestrictedSids == other.RestrictedSids
    }
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_Security",
    feature = "Win32_System_JobObjects"
))]
impl ::std::cmp::Eq for JOBOBJECT_SECURITY_LIMIT_INFORMATION {}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_Security",
    feature = "Win32_System_JobObjects"
))]
unsafe impl ::windows::runtime::Abi for JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const JOB_OBJECT_ASSIGN_PROCESS: u32 = 1u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct JOB_OBJECT_CPU_RATE_CONTROL(pub u32);
pub const JOB_OBJECT_CPU_RATE_CONTROL_ENABLE: JOB_OBJECT_CPU_RATE_CONTROL =
    JOB_OBJECT_CPU_RATE_CONTROL(1u32);
pub const JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED: JOB_OBJECT_CPU_RATE_CONTROL =
    JOB_OBJECT_CPU_RATE_CONTROL(2u32);
pub const JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP: JOB_OBJECT_CPU_RATE_CONTROL =
    JOB_OBJECT_CPU_RATE_CONTROL(4u32);
pub const JOB_OBJECT_CPU_RATE_CONTROL_NOTIFY: JOB_OBJECT_CPU_RATE_CONTROL =
    JOB_OBJECT_CPU_RATE_CONTROL(8u32);
pub const JOB_OBJECT__CPU_RATE_CONTROL_MIN_MAX_RATE: JOB_OBJECT_CPU_RATE_CONTROL =
    JOB_OBJECT_CPU_RATE_CONTROL(16u32);
impl ::std::convert::From<u32> for JOB_OBJECT_CPU_RATE_CONTROL {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for JOB_OBJECT_CPU_RATE_CONTROL {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for JOB_OBJECT_CPU_RATE_CONTROL {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for JOB_OBJECT_CPU_RATE_CONTROL {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for JOB_OBJECT_CPU_RATE_CONTROL {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for JOB_OBJECT_CPU_RATE_CONTROL {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for JOB_OBJECT_CPU_RATE_CONTROL {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const JOB_OBJECT_CPU_RATE_CONTROL_MIN_MAX_RATE: u32 = 16u32;
pub const JOB_OBJECT_CPU_RATE_CONTROL_VALID_FLAGS: u32 = 31u32;
pub const JOB_OBJECT_IMPERSONATE: u32 = 32u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct JOB_OBJECT_IO_RATE_CONTROL_FLAGS(pub i32);
pub const JOB_OBJECT_IO_RATE_CONTROL_ENABLE: JOB_OBJECT_IO_RATE_CONTROL_FLAGS =
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS(1i32);
pub const JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME: JOB_OBJECT_IO_RATE_CONTROL_FLAGS =
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS(2i32);
pub const JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL: JOB_OBJECT_IO_RATE_CONTROL_FLAGS =
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS(4i32);
pub const JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP:
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS = JOB_OBJECT_IO_RATE_CONTROL_FLAGS(8i32);
pub const JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS: JOB_OBJECT_IO_RATE_CONTROL_FLAGS =
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS(15i32);
impl ::std::convert::From<i32> for JOB_OBJECT_IO_RATE_CONTROL_FLAGS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for JOB_OBJECT_IO_RATE_CONTROL_FLAGS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS: u32 = 8u32;
pub const JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT: u32 = 3u32;
pub const JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO: u32 = 4u32;
pub const JOB_OBJECT_MSG_END_OF_JOB_TIME: u32 = 1u32;
pub const JOB_OBJECT_MSG_END_OF_PROCESS_TIME: u32 = 2u32;
pub const JOB_OBJECT_MSG_EXIT_PROCESS: u32 = 7u32;
pub const JOB_OBJECT_MSG_JOB_CYCLE_TIME_LIMIT: u32 = 12u32;
pub const JOB_OBJECT_MSG_JOB_MEMORY_LIMIT: u32 = 10u32;
pub const JOB_OBJECT_MSG_MAXIMUM: u32 = 13u32;
pub const JOB_OBJECT_MSG_MINIMUM: u32 = 1u32;
pub const JOB_OBJECT_MSG_NEW_PROCESS: u32 = 6u32;
pub const JOB_OBJECT_MSG_NOTIFICATION_LIMIT: u32 = 11u32;
pub const JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT: u32 = 9u32;
pub const JOB_OBJECT_MSG_SILO_TERMINATED: u32 = 13u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct JOB_OBJECT_NET_RATE_CONTROL_FLAGS(pub i32);
pub const JOB_OBJECT_NET_RATE_CONTROL_ENABLE: JOB_OBJECT_NET_RATE_CONTROL_FLAGS =
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS(1i32);
pub const JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH: JOB_OBJECT_NET_RATE_CONTROL_FLAGS =
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS(2i32);
pub const JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG: JOB_OBJECT_NET_RATE_CONTROL_FLAGS =
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS(4i32);
pub const JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS: JOB_OBJECT_NET_RATE_CONTROL_FLAGS =
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS(7i32);
impl ::std::convert::From<i32> for JOB_OBJECT_NET_RATE_CONTROL_FLAGS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for JOB_OBJECT_NET_RATE_CONTROL_FLAGS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const JOB_OBJECT_NET_RATE_CONTROL_MAX_DSCP_TAG: u32 = 64u32;
pub const JOB_OBJECT_QUERY: u32 = 4u32;
pub const JOB_OBJECT_SET_ATTRIBUTES: u32 = 2u32;
pub const JOB_OBJECT_SET_SECURITY_ATTRIBUTES: u32 = 16u32;
pub const JOB_OBJECT_TERMINATE: u32 = 8u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct JOB_OBJECT_TERMINATE_AT_END_ACTION(pub u32);
pub const JOB_OBJECT_TERMINATE_AT_END_OF_JOB: JOB_OBJECT_TERMINATE_AT_END_ACTION =
    JOB_OBJECT_TERMINATE_AT_END_ACTION(0u32);
pub const JOB_OBJECT_POST_AT_END_OF_JOB: JOB_OBJECT_TERMINATE_AT_END_ACTION =
    JOB_OBJECT_TERMINATE_AT_END_ACTION(1u32);
impl ::std::convert::From<u32> for JOB_OBJECT_TERMINATE_AT_END_ACTION {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for JOB_OBJECT_TERMINATE_AT_END_ACTION {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for JOB_OBJECT_TERMINATE_AT_END_ACTION {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for JOB_OBJECT_TERMINATE_AT_END_ACTION {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for JOB_OBJECT_TERMINATE_AT_END_ACTION {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for JOB_OBJECT_TERMINATE_AT_END_ACTION {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for JOB_OBJECT_TERMINATE_AT_END_ACTION {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const JOB_OBJECT_UILIMIT_ALL: u32 = 255u32;
pub const JOB_OBJECT_UI_VALID_FLAGS: u32 = 255u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct JOB_SET_ARRAY {
    pub JobHandle: super::super::Foundation::HANDLE,
    pub MemberLevel: u32,
    pub Flags: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl JOB_SET_ARRAY {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for JOB_SET_ARRAY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for JOB_SET_ARRAY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("JOB_SET_ARRAY")
            .field("JobHandle", &self.JobHandle)
            .field("MemberLevel", &self.MemberLevel)
            .field("Flags", &self.Flags)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for JOB_SET_ARRAY {
    fn eq(&self, other: &Self) -> bool {
        self.JobHandle == other.JobHandle
            && self.MemberLevel == other.MemberLevel
            && self.Flags == other.Flags
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for JOB_SET_ARRAY {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for JOB_SET_ARRAY {
    type Abi = Self;
    type DefaultType = Self;
}
pub const JOIN_BEVEL: i32 = 1i32;
pub const JOIN_MITER: i32 = 2i32;
pub const JOIN_ROUND: i32 = 0i32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct KERNEL_CET_CONTEXT {
    pub Ssp: u64,
    pub Rip: u64,
    pub SegCs: u16,
    pub Anonymous: KERNEL_CET_CONTEXT_0,
    pub Fill: [u16; 2],
}
impl KERNEL_CET_CONTEXT {}
impl ::std::default::Default for KERNEL_CET_CONTEXT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for KERNEL_CET_CONTEXT {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for KERNEL_CET_CONTEXT {}
unsafe impl ::windows::runtime::Abi for KERNEL_CET_CONTEXT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union KERNEL_CET_CONTEXT_0 {
    pub AllFlags: u16,
    pub Anonymous: KERNEL_CET_CONTEXT_0_0,
}
impl KERNEL_CET_CONTEXT_0 {}
impl ::std::default::Default for KERNEL_CET_CONTEXT_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for KERNEL_CET_CONTEXT_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for KERNEL_CET_CONTEXT_0 {}
unsafe impl ::windows::runtime::Abi for KERNEL_CET_CONTEXT_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct KERNEL_CET_CONTEXT_0_0 {
    pub _bitfield: u16,
}
impl KERNEL_CET_CONTEXT_0_0 {}
impl ::std::default::Default for KERNEL_CET_CONTEXT_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for KERNEL_CET_CONTEXT_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for KERNEL_CET_CONTEXT_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for KERNEL_CET_CONTEXT_0_0 {}
unsafe impl ::windows::runtime::Abi for KERNEL_CET_CONTEXT_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct KNONVOLATILE_CONTEXT_POINTERS {
    pub Anonymous1: KNONVOLATILE_CONTEXT_POINTERS_0,
    pub Anonymous2: KNONVOLATILE_CONTEXT_POINTERS_1,
}
impl KNONVOLATILE_CONTEXT_POINTERS {}
impl ::std::default::Default for KNONVOLATILE_CONTEXT_POINTERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for KNONVOLATILE_CONTEXT_POINTERS {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for KNONVOLATILE_CONTEXT_POINTERS {}
unsafe impl ::windows::runtime::Abi for KNONVOLATILE_CONTEXT_POINTERS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union KNONVOLATILE_CONTEXT_POINTERS_0 {
    pub FloatingContext: [*mut M128A; 16],
    pub Anonymous: KNONVOLATILE_CONTEXT_POINTERS_0_0,
}
impl KNONVOLATILE_CONTEXT_POINTERS_0 {}
impl ::std::default::Default for KNONVOLATILE_CONTEXT_POINTERS_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for KNONVOLATILE_CONTEXT_POINTERS_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for KNONVOLATILE_CONTEXT_POINTERS_0 {}
unsafe impl ::windows::runtime::Abi for KNONVOLATILE_CONTEXT_POINTERS_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct KNONVOLATILE_CONTEXT_POINTERS_0_0 {
    pub Xmm0: *mut M128A,
    pub Xmm1: *mut M128A,
    pub Xmm2: *mut M128A,
    pub Xmm3: *mut M128A,
    pub Xmm4: *mut M128A,
    pub Xmm5: *mut M128A,
    pub Xmm6: *mut M128A,
    pub Xmm7: *mut M128A,
    pub Xmm8: *mut M128A,
    pub Xmm9: *mut M128A,
    pub Xmm10: *mut M128A,
    pub Xmm11: *mut M128A,
    pub Xmm12: *mut M128A,
    pub Xmm13: *mut M128A,
    pub Xmm14: *mut M128A,
    pub Xmm15: *mut M128A,
}
impl KNONVOLATILE_CONTEXT_POINTERS_0_0 {}
impl ::std::default::Default for KNONVOLATILE_CONTEXT_POINTERS_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for KNONVOLATILE_CONTEXT_POINTERS_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("Xmm0", &self.Xmm0)
            .field("Xmm1", &self.Xmm1)
            .field("Xmm2", &self.Xmm2)
            .field("Xmm3", &self.Xmm3)
            .field("Xmm4", &self.Xmm4)
            .field("Xmm5", &self.Xmm5)
            .field("Xmm6", &self.Xmm6)
            .field("Xmm7", &self.Xmm7)
            .field("Xmm8", &self.Xmm8)
            .field("Xmm9", &self.Xmm9)
            .field("Xmm10", &self.Xmm10)
            .field("Xmm11", &self.Xmm11)
            .field("Xmm12", &self.Xmm12)
            .field("Xmm13", &self.Xmm13)
            .field("Xmm14", &self.Xmm14)
            .field("Xmm15", &self.Xmm15)
            .finish()
    }
}
impl ::std::cmp::PartialEq for KNONVOLATILE_CONTEXT_POINTERS_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Xmm0 == other.Xmm0
            && self.Xmm1 == other.Xmm1
            && self.Xmm2 == other.Xmm2
            && self.Xmm3 == other.Xmm3
            && self.Xmm4 == other.Xmm4
            && self.Xmm5 == other.Xmm5
            && self.Xmm6 == other.Xmm6
            && self.Xmm7 == other.Xmm7
            && self.Xmm8 == other.Xmm8
            && self.Xmm9 == other.Xmm9
            && self.Xmm10 == other.Xmm10
            && self.Xmm11 == other.Xmm11
            && self.Xmm12 == other.Xmm12
            && self.Xmm13 == other.Xmm13
            && self.Xmm14 == other.Xmm14
            && self.Xmm15 == other.Xmm15
    }
}
impl ::std::cmp::Eq for KNONVOLATILE_CONTEXT_POINTERS_0_0 {}
unsafe impl ::windows::runtime::Abi for KNONVOLATILE_CONTEXT_POINTERS_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union KNONVOLATILE_CONTEXT_POINTERS_1 {
    pub IntegerContext: [*mut u64; 16],
    pub Anonymous: KNONVOLATILE_CONTEXT_POINTERS_1_0,
}
impl KNONVOLATILE_CONTEXT_POINTERS_1 {}
impl ::std::default::Default for KNONVOLATILE_CONTEXT_POINTERS_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for KNONVOLATILE_CONTEXT_POINTERS_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for KNONVOLATILE_CONTEXT_POINTERS_1 {}
unsafe impl ::windows::runtime::Abi for KNONVOLATILE_CONTEXT_POINTERS_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct KNONVOLATILE_CONTEXT_POINTERS_1_0 {
    pub Rax: *mut u64,
    pub Rcx: *mut u64,
    pub Rdx: *mut u64,
    pub Rbx: *mut u64,
    pub Rsp: *mut u64,
    pub Rbp: *mut u64,
    pub Rsi: *mut u64,
    pub Rdi: *mut u64,
    pub R8: *mut u64,
    pub R9: *mut u64,
    pub R10: *mut u64,
    pub R11: *mut u64,
    pub R12: *mut u64,
    pub R13: *mut u64,
    pub R14: *mut u64,
    pub R15: *mut u64,
}
impl KNONVOLATILE_CONTEXT_POINTERS_1_0 {}
impl ::std::default::Default for KNONVOLATILE_CONTEXT_POINTERS_1_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for KNONVOLATILE_CONTEXT_POINTERS_1_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("Rax", &self.Rax)
            .field("Rcx", &self.Rcx)
            .field("Rdx", &self.Rdx)
            .field("Rbx", &self.Rbx)
            .field("Rsp", &self.Rsp)
            .field("Rbp", &self.Rbp)
            .field("Rsi", &self.Rsi)
            .field("Rdi", &self.Rdi)
            .field("R8", &self.R8)
            .field("R9", &self.R9)
            .field("R10", &self.R10)
            .field("R11", &self.R11)
            .field("R12", &self.R12)
            .field("R13", &self.R13)
            .field("R14", &self.R14)
            .field("R15", &self.R15)
            .finish()
    }
}
impl ::std::cmp::PartialEq for KNONVOLATILE_CONTEXT_POINTERS_1_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Rax == other.Rax
            && self.Rcx == other.Rcx
            && self.Rdx == other.Rdx
            && self.Rbx == other.Rbx
            && self.Rsp == other.Rsp
            && self.Rbp == other.Rbp
            && self.Rsi == other.Rsi
            && self.Rdi == other.Rdi
            && self.R8 == other.R8
            && self.R9 == other.R9
            && self.R10 == other.R10
            && self.R11 == other.R11
            && self.R12 == other.R12
            && self.R13 == other.R13
            && self.R14 == other.R14
            && self.R15 == other.R15
    }
}
impl ::std::cmp::Eq for KNONVOLATILE_CONTEXT_POINTERS_1_0 {}
unsafe impl ::windows::runtime::Abi for KNONVOLATILE_CONTEXT_POINTERS_1_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct KNONVOLATILE_CONTEXT_POINTERS_ARM64 {
    pub X19: *mut u64,
    pub X20: *mut u64,
    pub X21: *mut u64,
    pub X22: *mut u64,
    pub X23: *mut u64,
    pub X24: *mut u64,
    pub X25: *mut u64,
    pub X26: *mut u64,
    pub X27: *mut u64,
    pub X28: *mut u64,
    pub Fp: *mut u64,
    pub Lr: *mut u64,
    pub D8: *mut u64,
    pub D9: *mut u64,
    pub D10: *mut u64,
    pub D11: *mut u64,
    pub D12: *mut u64,
    pub D13: *mut u64,
    pub D14: *mut u64,
    pub D15: *mut u64,
}
impl KNONVOLATILE_CONTEXT_POINTERS_ARM64 {}
impl ::std::default::Default for KNONVOLATILE_CONTEXT_POINTERS_ARM64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for KNONVOLATILE_CONTEXT_POINTERS_ARM64 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("KNONVOLATILE_CONTEXT_POINTERS_ARM64")
            .field("X19", &self.X19)
            .field("X20", &self.X20)
            .field("X21", &self.X21)
            .field("X22", &self.X22)
            .field("X23", &self.X23)
            .field("X24", &self.X24)
            .field("X25", &self.X25)
            .field("X26", &self.X26)
            .field("X27", &self.X27)
            .field("X28", &self.X28)
            .field("Fp", &self.Fp)
            .field("Lr", &self.Lr)
            .field("D8", &self.D8)
            .field("D9", &self.D9)
            .field("D10", &self.D10)
            .field("D11", &self.D11)
            .field("D12", &self.D12)
            .field("D13", &self.D13)
            .field("D14", &self.D14)
            .field("D15", &self.D15)
            .finish()
    }
}
impl ::std::cmp::PartialEq for KNONVOLATILE_CONTEXT_POINTERS_ARM64 {
    fn eq(&self, other: &Self) -> bool {
        self.X19 == other.X19
            && self.X20 == other.X20
            && self.X21 == other.X21
            && self.X22 == other.X22
            && self.X23 == other.X23
            && self.X24 == other.X24
            && self.X25 == other.X25
            && self.X26 == other.X26
            && self.X27 == other.X27
            && self.X28 == other.X28
            && self.Fp == other.Fp
            && self.Lr == other.Lr
            && self.D8 == other.D8
            && self.D9 == other.D9
            && self.D10 == other.D10
            && self.D11 == other.D11
            && self.D12 == other.D12
            && self.D13 == other.D13
            && self.D14 == other.D14
            && self.D15 == other.D15
    }
}
impl ::std::cmp::Eq for KNONVOLATILE_CONTEXT_POINTERS_ARM64 {}
unsafe impl ::windows::runtime::Abi for KNONVOLATILE_CONTEXT_POINTERS_ARM64 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct KTMOBJECT_CURSOR {
    pub LastQuery: ::windows::runtime::GUID,
    pub ObjectIdCount: u32,
    pub ObjectIds: [::windows::runtime::GUID; 1],
}
impl KTMOBJECT_CURSOR {}
impl ::std::default::Default for KTMOBJECT_CURSOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for KTMOBJECT_CURSOR {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("KTMOBJECT_CURSOR")
            .field("LastQuery", &self.LastQuery)
            .field("ObjectIdCount", &self.ObjectIdCount)
            .field("ObjectIds", &self.ObjectIds)
            .finish()
    }
}
impl ::std::cmp::PartialEq for KTMOBJECT_CURSOR {
    fn eq(&self, other: &Self) -> bool {
        self.LastQuery == other.LastQuery
            && self.ObjectIdCount == other.ObjectIdCount
            && self.ObjectIds == other.ObjectIds
    }
}
impl ::std::cmp::Eq for KTMOBJECT_CURSOR {}
unsafe impl ::windows::runtime::Abi for KTMOBJECT_CURSOR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct KTMOBJECT_TYPE(pub i32);
pub const KTMOBJECT_TRANSACTION: KTMOBJECT_TYPE = KTMOBJECT_TYPE(0i32);
pub const KTMOBJECT_TRANSACTION_MANAGER: KTMOBJECT_TYPE = KTMOBJECT_TYPE(1i32);
pub const KTMOBJECT_RESOURCE_MANAGER: KTMOBJECT_TYPE = KTMOBJECT_TYPE(2i32);
pub const KTMOBJECT_ENLISTMENT: KTMOBJECT_TYPE = KTMOBJECT_TYPE(3i32);
pub const KTMOBJECT_INVALID: KTMOBJECT_TYPE = KTMOBJECT_TYPE(4i32);
impl ::std::convert::From<i32> for KTMOBJECT_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for KTMOBJECT_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const LANG_AFRIKAANS: u32 = 54u32;
pub const LANG_ALBANIAN: u32 = 28u32;
pub const LANG_ALSATIAN: u32 = 132u32;
pub const LANG_AMHARIC: u32 = 94u32;
pub const LANG_ARABIC: u32 = 1u32;
pub const LANG_ARMENIAN: u32 = 43u32;
pub const LANG_ASSAMESE: u32 = 77u32;
pub const LANG_AZERBAIJANI: u32 = 44u32;
pub const LANG_AZERI: u32 = 44u32;
pub const LANG_BANGLA: u32 = 69u32;
pub const LANG_BASHKIR: u32 = 109u32;
pub const LANG_BASQUE: u32 = 45u32;
pub const LANG_BELARUSIAN: u32 = 35u32;
pub const LANG_BENGALI: u32 = 69u32;
pub const LANG_BOSNIAN: u32 = 26u32;
pub const LANG_BOSNIAN_NEUTRAL: u32 = 30746u32;
pub const LANG_BRETON: u32 = 126u32;
pub const LANG_BULGARIAN: u32 = 2u32;
pub const LANG_CATALAN: u32 = 3u32;
pub const LANG_CENTRAL_KURDISH: u32 = 146u32;
pub const LANG_CHEROKEE: u32 = 92u32;
pub const LANG_CHINESE: u32 = 4u32;
pub const LANG_CHINESE_SIMPLIFIED: u32 = 4u32;
pub const LANG_CHINESE_TRADITIONAL: u32 = 31748u32;
pub const LANG_CORSICAN: u32 = 131u32;
pub const LANG_CROATIAN: u32 = 26u32;
pub const LANG_CZECH: u32 = 5u32;
pub const LANG_DANISH: u32 = 6u32;
pub const LANG_DARI: u32 = 140u32;
pub const LANG_DIVEHI: u32 = 101u32;
pub const LANG_DUTCH: u32 = 19u32;
pub const LANG_ENGLISH: u32 = 9u32;
pub const LANG_ESTONIAN: u32 = 37u32;
pub const LANG_FAEROESE: u32 = 56u32;
pub const LANG_FARSI: u32 = 41u32;
pub const LANG_FILIPINO: u32 = 100u32;
pub const LANG_FINNISH: u32 = 11u32;
pub const LANG_FRENCH: u32 = 12u32;
pub const LANG_FRISIAN: u32 = 98u32;
pub const LANG_FULAH: u32 = 103u32;
pub const LANG_GALICIAN: u32 = 86u32;
pub const LANG_GEORGIAN: u32 = 55u32;
pub const LANG_GERMAN: u32 = 7u32;
pub const LANG_GREEK: u32 = 8u32;
pub const LANG_GREENLANDIC: u32 = 111u32;
pub const LANG_GUJARATI: u32 = 71u32;
pub const LANG_HAUSA: u32 = 104u32;
pub const LANG_HAWAIIAN: u32 = 117u32;
pub const LANG_HEBREW: u32 = 13u32;
pub const LANG_HINDI: u32 = 57u32;
pub const LANG_HUNGARIAN: u32 = 14u32;
pub const LANG_ICELANDIC: u32 = 15u32;
pub const LANG_IGBO: u32 = 112u32;
pub const LANG_INDONESIAN: u32 = 33u32;
pub const LANG_INUKTITUT: u32 = 93u32;
pub const LANG_INVARIANT: u32 = 127u32;
pub const LANG_IRISH: u32 = 60u32;
pub const LANG_ITALIAN: u32 = 16u32;
pub const LANG_JAPANESE: u32 = 17u32;
pub const LANG_KANNADA: u32 = 75u32;
pub const LANG_KASHMIRI: u32 = 96u32;
pub const LANG_KAZAK: u32 = 63u32;
pub const LANG_KHMER: u32 = 83u32;
pub const LANG_KICHE: u32 = 134u32;
pub const LANG_KINYARWANDA: u32 = 135u32;
pub const LANG_KONKANI: u32 = 87u32;
pub const LANG_KOREAN: u32 = 18u32;
pub const LANG_KYRGYZ: u32 = 64u32;
pub const LANG_LAO: u32 = 84u32;
pub const LANG_LATVIAN: u32 = 38u32;
pub const LANG_LITHUANIAN: u32 = 39u32;
pub const LANG_LOWER_SORBIAN: u32 = 46u32;
pub const LANG_LUXEMBOURGISH: u32 = 110u32;
pub const LANG_MACEDONIAN: u32 = 47u32;
pub const LANG_MALAY: u32 = 62u32;
pub const LANG_MALAYALAM: u32 = 76u32;
pub const LANG_MALTESE: u32 = 58u32;
pub const LANG_MANIPURI: u32 = 88u32;
pub const LANG_MAORI: u32 = 129u32;
pub const LANG_MAPUDUNGUN: u32 = 122u32;
pub const LANG_MARATHI: u32 = 78u32;
pub const LANG_MOHAWK: u32 = 124u32;
pub const LANG_MONGOLIAN: u32 = 80u32;
pub const LANG_NEPALI: u32 = 97u32;
pub const LANG_NEUTRAL: u32 = 0u32;
pub const LANG_NORWEGIAN: u32 = 20u32;
pub const LANG_OCCITAN: u32 = 130u32;
pub const LANG_ODIA: u32 = 72u32;
pub const LANG_ORIYA: u32 = 72u32;
pub const LANG_PASHTO: u32 = 99u32;
pub const LANG_PERSIAN: u32 = 41u32;
pub const LANG_POLISH: u32 = 21u32;
pub const LANG_PORTUGUESE: u32 = 22u32;
pub const LANG_PULAR: u32 = 103u32;
pub const LANG_PUNJABI: u32 = 70u32;
pub const LANG_QUECHUA: u32 = 107u32;
pub const LANG_ROMANIAN: u32 = 24u32;
pub const LANG_ROMANSH: u32 = 23u32;
pub const LANG_RUSSIAN: u32 = 25u32;
pub const LANG_SAKHA: u32 = 133u32;
pub const LANG_SAMI: u32 = 59u32;
pub const LANG_SANSKRIT: u32 = 79u32;
pub const LANG_SCOTTISH_GAELIC: u32 = 145u32;
pub const LANG_SERBIAN: u32 = 26u32;
pub const LANG_SERBIAN_NEUTRAL: u32 = 31770u32;
pub const LANG_SINDHI: u32 = 89u32;
pub const LANG_SINHALESE: u32 = 91u32;
pub const LANG_SLOVAK: u32 = 27u32;
pub const LANG_SLOVENIAN: u32 = 36u32;
pub const LANG_SOTHO: u32 = 108u32;
pub const LANG_SPANISH: u32 = 10u32;
pub const LANG_SWAHILI: u32 = 65u32;
pub const LANG_SWEDISH: u32 = 29u32;
pub const LANG_SYRIAC: u32 = 90u32;
pub const LANG_TAJIK: u32 = 40u32;
pub const LANG_TAMAZIGHT: u32 = 95u32;
pub const LANG_TAMIL: u32 = 73u32;
pub const LANG_TATAR: u32 = 68u32;
pub const LANG_TELUGU: u32 = 74u32;
pub const LANG_THAI: u32 = 30u32;
pub const LANG_TIBETAN: u32 = 81u32;
pub const LANG_TIGRIGNA: u32 = 115u32;
pub const LANG_TIGRINYA: u32 = 115u32;
pub const LANG_TSWANA: u32 = 50u32;
pub const LANG_TURKISH: u32 = 31u32;
pub const LANG_TURKMEN: u32 = 66u32;
pub const LANG_UIGHUR: u32 = 128u32;
pub const LANG_UKRAINIAN: u32 = 34u32;
pub const LANG_UPPER_SORBIAN: u32 = 46u32;
pub const LANG_URDU: u32 = 32u32;
pub const LANG_UZBEK: u32 = 67u32;
pub const LANG_VALENCIAN: u32 = 3u32;
pub const LANG_VIETNAMESE: u32 = 42u32;
pub const LANG_WELSH: u32 = 82u32;
pub const LANG_WOLOF: u32 = 136u32;
pub const LANG_XHOSA: u32 = 52u32;
pub const LANG_YAKUT: u32 = 133u32;
pub const LANG_YI: u32 = 120u32;
pub const LANG_YORUBA: u32 = 106u32;
pub const LANG_ZULU: u32 = 53u32;
pub const LA_ALTERNATE: u32 = 2u32;
pub const LA_GEOMETRIC: u32 = 1u32;
pub const LA_STARTGAP: u32 = 4u32;
pub const LA_STYLED: u32 = 8u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct LIGATURE {
    pub culSize: u32,
    pub pwsz: super::super::Foundation::PWSTR,
    pub chglyph: u32,
    pub ahglyph: [u32; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl LIGATURE {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for LIGATURE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for LIGATURE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("LIGATURE")
            .field("culSize", &self.culSize)
            .field("pwsz", &self.pwsz)
            .field("chglyph", &self.chglyph)
            .field("ahglyph", &self.ahglyph)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for LIGATURE {
    fn eq(&self, other: &Self) -> bool {
        self.culSize == other.culSize
            && self.pwsz == other.pwsz
            && self.chglyph == other.chglyph
            && self.ahglyph == other.ahglyph
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for LIGATURE {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for LIGATURE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const LMEM_DISCARDABLE: u32 = 3840u32;
pub const LMEM_DISCARDED: u32 = 16384u32;
pub const LMEM_INVALID_HANDLE: u32 = 32768u32;
pub const LMEM_LOCKCOUNT: u32 = 255u32;
pub const LMEM_MODIFY: u32 = 128u32;
pub const LMEM_NOCOMPACT: u32 = 16u32;
pub const LMEM_NODISCARD: u32 = 32u32;
pub const LMEM_VALID_FLAGS: u32 = 3954u32;
pub const LOCALE_NAME_MAX_LENGTH: u32 = 85u32;
pub const LOCALE_TRANSIENT_KEYBOARD1: u32 = 8192u32;
pub const LOCALE_TRANSIENT_KEYBOARD2: u32 = 9216u32;
pub const LOCALE_TRANSIENT_KEYBOARD3: u32 = 10240u32;
pub const LOCALE_TRANSIENT_KEYBOARD4: u32 = 11264u32;
pub const LOCKF_LOGICAL_LOCK: u32 = 0u32;
pub const LOCKF_PHYSICAL_LOCK: u32 = 1u32;
pub const LOCKP_ALLOW_MEM_MAPPING: u32 = 0u32;
pub const LOCKP_ALLOW_WRITES: u32 = 1u32;
pub const LOCKP_FAIL_MEM_MAPPING: u32 = 2u32;
pub const LOCKP_FAIL_WRITES: u32 = 0u32;
pub const LOCKP_LOCK_FOR_FORMAT: u32 = 4u32;
pub const LOCKP_USER_MASK: u32 = 3u32;
pub const LOCK_ELEMENT: u32 = 0u32;
pub const LOCK_UNLOCK_DOOR: u32 = 2u32;
pub const LOCK_UNLOCK_IEPORT: u32 = 1u32;
pub const LOCK_UNLOCK_KEYPAD: u32 = 4u32;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_DATA: u32 = 16777216u32;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_INDEX: u32 = 33554432u32;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_MASK: u32 = 4278190080u32;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_SYSTEM: u32 = 50331648u32;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_DENY_DEFRAG_SET: u32 = 2u32;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_FS_SYSTEM_FILE: u32 = 4u32;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_PAGE_FILE: u32 = 1u32;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_TXF_SYSTEM_FILE: u32 = 8u32;
#[cfg(feature = "Win32_Foundation")]
pub type LPD3DENUMDEVICESCALLBACK = unsafe extern "system" fn(
    lpguid: *mut ::windows::runtime::GUID,
    lpdevicedescription: super::super::Foundation::PSTR,
    lpdevicename: super::super::Foundation::PSTR,
    param3: *mut _D3DDeviceDesc,
    param4: *mut _D3DDeviceDesc,
    param5: *mut ::std::ffi::c_void,
) -> ::windows::runtime::HRESULT;
#[cfg(feature = "Win32_Foundation")]
pub type LPD3DENUMDEVICESCALLBACK7 = unsafe extern "system" fn(
    lpdevicedescription: super::super::Foundation::PSTR,
    lpdevicename: super::super::Foundation::PSTR,
    param2: *mut _D3DDeviceDesc7,
    param3: *mut ::std::ffi::c_void,
) -> ::windows::runtime::HRESULT;
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub type LPD3DENUMPIXELFORMATSCALLBACK = unsafe extern "system" fn(
    lpddpixfmt: *mut super::super::Graphics::DirectDraw::DDPIXELFORMAT,
    lpcontext: *mut ::std::ffi::c_void,
) -> ::windows::runtime::HRESULT;
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub type LPD3DENUMTEXTUREFORMATSCALLBACK = unsafe extern "system" fn(
    lpddsd: *mut super::super::Graphics::DirectDraw::DDSURFACEDESC,
    lpcontext: *mut ::std::ffi::c_void,
)
    -> ::windows::runtime::HRESULT;
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub type LPD3DNTHAL_CLEAR2CB = unsafe extern "system" fn(param0: *mut D3DNTHAL_CLEAR2DATA) -> u32;
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
pub type LPD3DNTHAL_CONTEXTCREATECB =
    unsafe extern "system" fn(param0: *mut D3DNTHAL_CONTEXTCREATEDATA) -> u32;
pub type LPD3DNTHAL_CONTEXTDESTROYALLCB =
    unsafe extern "system" fn(param0: *mut D3DNTHAL_CONTEXTDESTROYALLDATA) -> u32;
pub type LPD3DNTHAL_CONTEXTDESTROYCB =
    unsafe extern "system" fn(param0: *mut D3DNTHAL_CONTEXTDESTROYDATA) -> u32;
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
pub type LPD3DNTHAL_DRAWPRIMITIVES2CB =
    unsafe extern "system" fn(param0: *mut D3DNTHAL_DRAWPRIMITIVES2DATA) -> u32;
pub type LPD3DNTHAL_SCENECAPTURECB =
    unsafe extern "system" fn(param0: *mut D3DNTHAL_SCENECAPTUREDATA) -> u32;
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
pub type LPD3DNTHAL_SETRENDERTARGETCB =
    unsafe extern "system" fn(param0: *mut D3DNTHAL_SETRENDERTARGETDATA) -> u32;
#[cfg(feature = "Win32_Foundation")]
pub type LPD3DNTHAL_TEXTURECREATECB =
    unsafe extern "system" fn(param0: *mut D3DNTHAL_TEXTURECREATEDATA) -> u32;
pub type LPD3DNTHAL_TEXTUREDESTROYCB =
    unsafe extern "system" fn(param0: *mut D3DNTHAL_TEXTUREDESTROYDATA) -> u32;
#[cfg(feature = "Win32_Foundation")]
pub type LPD3DNTHAL_TEXTUREGETSURFCB =
    unsafe extern "system" fn(param0: *mut D3DNTHAL_TEXTUREGETSURFDATA) -> u32;
pub type LPD3DNTHAL_TEXTURESWAPCB =
    unsafe extern "system" fn(param0: *mut D3DNTHAL_TEXTURESWAPDATA) -> u32;
pub type LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB =
    unsafe extern "system" fn(param0: *mut D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA) -> u32;
pub type LPD3DVALIDATECALLBACK = unsafe extern "system" fn(
    lpuserarg: *mut ::std::ffi::c_void,
    dwoffset: u32,
) -> ::windows::runtime::HRESULT;
pub type LPTHREAD_START_ROUTINE =
    unsafe extern "system" fn(lpthreadparameter: *mut ::std::ffi::c_void) -> u32;
pub type LPTIMECALLBACK =
    unsafe extern "system" fn(utimerid: u32, umsg: u32, dwuser: usize, dw1: usize, dw2: usize);
pub const LTP_PC_SMT: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct LUID {
    pub LowPart: u32,
    pub HighPart: i32,
}
impl LUID {}
impl ::std::default::Default for LUID {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for LUID {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("LUID")
            .field("LowPart", &self.LowPart)
            .field("HighPart", &self.HighPart)
            .finish()
    }
}
impl ::std::cmp::PartialEq for LUID {
    fn eq(&self, other: &Self) -> bool {
        self.LowPart == other.LowPart && self.HighPart == other.HighPart
    }
}
impl ::std::cmp::Eq for LUID {}
unsafe impl ::windows::runtime::Abi for LUID {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct M128A {
    pub Low: u64,
    pub High: i64,
}
impl M128A {}
impl ::std::default::Default for M128A {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for M128A {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("M128A")
            .field("Low", &self.Low)
            .field("High", &self.High)
            .finish()
    }
}
impl ::std::cmp::PartialEq for M128A {
    fn eq(&self, other: &Self) -> bool {
        self.Low == other.Low && self.High == other.High
    }
}
impl ::std::cmp::Eq for M128A {}
unsafe impl ::windows::runtime::Abi for M128A {
    type Abi = Self;
    type DefaultType = Self;
}
pub const MAILSLOT_NO_MESSAGE: u32 = 4294967295u32;
pub const MAILSLOT_WAIT_FOREVER: u32 = 4294967295u32;
pub const MARK_HANDLE_CLOUD_SYNC: u32 = 2048u32;
pub const MARK_HANDLE_DISABLE_FILE_METADATA_OPTIMIZATION: u32 = 4096u32;
pub const MARK_HANDLE_ENABLE_CPU_CACHE: u32 = 268435456u32;
pub const MARK_HANDLE_ENABLE_USN_SOURCE_ON_PAGING_IO: u32 = 8192u32;
pub const MARK_HANDLE_FILTER_METADATA: u32 = 512u32;
pub const MARK_HANDLE_NOT_READ_COPY: u32 = 256u32;
pub const MARK_HANDLE_NOT_REALTIME: u32 = 64u32;
pub const MARK_HANDLE_NOT_TXF_SYSTEM_LOG: u32 = 8u32;
pub const MARK_HANDLE_PROTECT_CLUSTERS: u32 = 1u32;
pub const MARK_HANDLE_READ_COPY: u32 = 128u32;
pub const MARK_HANDLE_REALTIME: u32 = 32u32;
pub const MARK_HANDLE_RETURN_PURGE_FAILURE: u32 = 1024u32;
pub const MARK_HANDLE_SKIP_COHERENCY_SYNC_DISALLOW_WRITES: u32 = 16384u32;
pub const MARK_HANDLE_SUPPRESS_VOLUME_OPEN_FLUSH: u32 = 32768u32;
pub const MARK_HANDLE_TXF_SYSTEM_LOG: u32 = 4u32;
pub const MAXBYTE: u32 = 255u32;
pub const MAXCHAR: u32 = 127u32;
pub const MAXCHARSETS: u32 = 16u32;
pub const MAXDWORD: u32 = 4294967295u32;
pub const MAXIMUM_ALLOWED: u32 = 33554432u32;
pub const MAXIMUM_ENCRYPTION_VALUE: u32 = 4u32;
pub const MAXIMUM_PROCESSORS: u32 = 64u32;
pub const MAXIMUM_PROC_PER_GROUP: u32 = 64u32;
pub const MAXIMUM_SUPPORTED_EXTENSION: u32 = 512u32;
pub const MAXIMUM_SUSPEND_COUNT: u32 = 127u32;
pub const MAXIMUM_WAIT_OBJECTS: u32 = 64u32;
pub const MAXIMUM_XSTATE_FEATURES: u32 = 64u32;
pub const MAXLOGICALLOGNAMESIZE: u32 = 256u32;
pub const MAXLONG: u32 = 2147483647u32;
pub const MAXLONGLONG: u64 = 9223372036854775807u64;
pub const MAXSHORT: u32 = 32767u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct MAXVERSIONTESTED_INFO {
    pub MaxVersionTested: u64,
}
impl MAXVERSIONTESTED_INFO {}
impl ::std::default::Default for MAXVERSIONTESTED_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for MAXVERSIONTESTED_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("MAXVERSIONTESTED_INFO")
            .field("MaxVersionTested", &self.MaxVersionTested)
            .finish()
    }
}
impl ::std::cmp::PartialEq for MAXVERSIONTESTED_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.MaxVersionTested == other.MaxVersionTested
    }
}
impl ::std::cmp::Eq for MAXVERSIONTESTED_INFO {}
unsafe impl ::windows::runtime::Abi for MAXVERSIONTESTED_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
pub const MAXWORD: u32 = 65535u32;
pub const MAX_ACL_REVISION: u32 = 4u32;
pub const MAX_DEVPROP_TYPE: u32 = 25u32;
pub const MAX_DEVPROP_TYPEMOD: u32 = 8192u32;
pub const MAX_FW_BUCKET_ID_LENGTH: u32 = 132u32;
pub const MAX_HW_COUNTERS: u32 = 16u32;
pub const MAX_INTERFACE_CODES: u32 = 8u32;
pub const MAX_UCSCHAR: u32 = 1114111u32;
pub const MAX_VOLUME_ID_SIZE: u32 = 36u32;
pub const MAX_VOLUME_TEMPLATE_SIZE: u32 = 40u32;
#[cfg(feature = "Win32_Foundation")]
pub const MCA_BUS_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414022i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_BUS_TIMEOUT_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414021i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_CACHE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414083i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_CPU: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414030i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_CPU_BUS: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414079i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_MAS: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414075i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_MEM_1_2: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414071i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_MEM_1_2_5: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414069i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_MEM_1_2_5_4: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414067i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_MEM_UNKNOWN: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414073i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_PCI_BUS_MASTER_ABORT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414055i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_PCI_BUS_MASTER_ABORT_NO_INFO: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414053i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_PCI_BUS_PARITY: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414063i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_PCI_BUS_PARITY_NO_INFO: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414061i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_PCI_BUS_SERR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414059i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_PCI_BUS_SERR_NO_INFO: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414057i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_PCI_BUS_TIMEOUT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414051i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_PCI_BUS_TIMEOUT_NO_INFO: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414049i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_PCI_BUS_UNKNOWN: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414047i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_PCI_DEVICE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414045i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_PLATFORM_SPECIFIC: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414041i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_REGISTER_FILE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414077i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_SMBIOS: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414043i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_SYSTEM_EVENT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414065i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_TLB: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414081i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_UNKNOWN: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414039i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_ERROR_UNKNOWN_NO_CPU: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414037i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_EXTERNAL_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414017i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_FRC_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414016i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_INFO_CPU_THERMAL_THROTTLING_REMOVED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(1074069616i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_INFO_MEMORY_PAGE_MARKED_BAD: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(1074069620i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_INFO_NO_MORE_CORRECTED_ERROR_LOGS: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(1074069619i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_INTERNALTIMER_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414020i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_MEMORYHIERARCHY_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414024i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_MICROCODE_ROM_PARITY_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414018i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_TLB_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-1073414023i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_CACHE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155908i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_CMC_THRESHOLD_EXCEEDED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155859i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_CPE_THRESHOLD_EXCEEDED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155858i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_CPU: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155855i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_CPU_BUS: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155904i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_CPU_THERMAL_THROTTLED: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155857i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_MAS: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155900i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_MEM_1_2: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155896i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_MEM_1_2_5: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155894i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_MEM_1_2_5_4: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155892i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_MEM_UNKNOWN: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155898i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_PCI_BUS_MASTER_ABORT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155880i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_PCI_BUS_MASTER_ABORT_NO_INFO: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155878i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_PCI_BUS_PARITY: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155888i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_PCI_BUS_PARITY_NO_INFO: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155886i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_PCI_BUS_SERR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155884i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_PCI_BUS_SERR_NO_INFO: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155882i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_PCI_BUS_TIMEOUT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155876i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_PCI_BUS_TIMEOUT_NO_INFO: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155874i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_PCI_BUS_UNKNOWN: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155872i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_PCI_DEVICE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155870i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_PLATFORM_SPECIFIC: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155866i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_REGISTER_FILE: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155902i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_SMBIOS: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155868i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_SYSTEM_EVENT: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155890i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_TLB: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155906i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_UNKNOWN: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155864i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const MCA_WARNING_UNKNOWN_NO_CPU: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2147155862i32 as _);
pub const MEDIA_CURRENTLY_MOUNTED: u32 = 2147483648u32;
pub const MEDIA_ERASEABLE: u32 = 1u32;
pub const MEDIA_READ_ONLY: u32 = 4u32;
pub const MEDIA_READ_WRITE: u32 = 8u32;
pub const MEDIA_WRITE_ONCE: u32 = 2u32;
pub const MEDIA_WRITE_PROTECTED: u32 = 256u32;
pub const MEMORY_ALLOCATION_ALIGNMENT: u32 = 16u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE {
    pub Type: MEM_DEDICATED_ATTRIBUTE_TYPE,
    pub Reserved: u32,
    pub Value: u64,
}
impl MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE {}
impl ::std::default::Default for MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE")
            .field("Type", &self.Type)
            .field("Reserved", &self.Reserved)
            .field("Value", &self.Value)
            .finish()
    }
}
impl ::std::cmp::PartialEq for MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type && self.Reserved == other.Reserved && self.Value == other.Value
    }
}
impl ::std::cmp::Eq for MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE {}
unsafe impl ::windows::runtime::Abi for MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION {
    pub NextEntryOffset: u32,
    pub SizeOfInformation: u32,
    pub Flags: u32,
    pub AttributesOffset: u32,
    pub AttributeCount: u32,
    pub Reserved: u32,
    pub TypeId: u64,
}
impl MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION {}
impl ::std::default::Default for MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION")
            .field("NextEntryOffset", &self.NextEntryOffset)
            .field("SizeOfInformation", &self.SizeOfInformation)
            .field("Flags", &self.Flags)
            .field("AttributesOffset", &self.AttributesOffset)
            .field("AttributeCount", &self.AttributeCount)
            .field("Reserved", &self.Reserved)
            .field("TypeId", &self.TypeId)
            .finish()
    }
}
impl ::std::cmp::PartialEq for MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset
            && self.SizeOfInformation == other.SizeOfInformation
            && self.Flags == other.Flags
            && self.AttributesOffset == other.AttributesOffset
            && self.AttributeCount == other.AttributeCount
            && self.Reserved == other.Reserved
            && self.TypeId == other.TypeId
    }
}
impl ::std::cmp::Eq for MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION {}
unsafe impl ::windows::runtime::Abi for MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const MEMORY_PARTITION_MODIFY_ACCESS: u32 = 2u32;
pub const MEMORY_PARTITION_QUERY_ACCESS: u32 = 1u32;
pub const MEMORY_PRIORITY_LOWEST: u32 = 0u32;
pub const MEM_4MB_PAGES: u32 = 2147483648u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct MEM_ADDRESS_REQUIREMENTS {
    pub LowestStartingAddress: *mut ::std::ffi::c_void,
    pub HighestEndingAddress: *mut ::std::ffi::c_void,
    pub Alignment: usize,
}
impl MEM_ADDRESS_REQUIREMENTS {}
impl ::std::default::Default for MEM_ADDRESS_REQUIREMENTS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for MEM_ADDRESS_REQUIREMENTS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("MEM_ADDRESS_REQUIREMENTS")
            .field("LowestStartingAddress", &self.LowestStartingAddress)
            .field("HighestEndingAddress", &self.HighestEndingAddress)
            .field("Alignment", &self.Alignment)
            .finish()
    }
}
impl ::std::cmp::PartialEq for MEM_ADDRESS_REQUIREMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.LowestStartingAddress == other.LowestStartingAddress
            && self.HighestEndingAddress == other.HighestEndingAddress
            && self.Alignment == other.Alignment
    }
}
impl ::std::cmp::Eq for MEM_ADDRESS_REQUIREMENTS {}
unsafe impl ::windows::runtime::Abi for MEM_ADDRESS_REQUIREMENTS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const MEM_COALESCE_PLACEHOLDERS: u32 = 1u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct MEM_DEDICATED_ATTRIBUTE_TYPE(pub i32);
pub const MemDedicatedAttributeReadBandwidth: MEM_DEDICATED_ATTRIBUTE_TYPE =
    MEM_DEDICATED_ATTRIBUTE_TYPE(0i32);
pub const MemDedicatedAttributeReadLatency: MEM_DEDICATED_ATTRIBUTE_TYPE =
    MEM_DEDICATED_ATTRIBUTE_TYPE(1i32);
pub const MemDedicatedAttributeWriteBandwidth: MEM_DEDICATED_ATTRIBUTE_TYPE =
    MEM_DEDICATED_ATTRIBUTE_TYPE(2i32);
pub const MemDedicatedAttributeWriteLatency: MEM_DEDICATED_ATTRIBUTE_TYPE =
    MEM_DEDICATED_ATTRIBUTE_TYPE(3i32);
pub const MemDedicatedAttributeMax: MEM_DEDICATED_ATTRIBUTE_TYPE =
    MEM_DEDICATED_ATTRIBUTE_TYPE(4i32);
impl ::std::convert::From<i32> for MEM_DEDICATED_ATTRIBUTE_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for MEM_DEDICATED_ATTRIBUTE_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const MEM_DIFFERENT_IMAGE_BASE_OK: u32 = 8388608u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct MEM_EXTENDED_PARAMETER {
    pub Anonymous1: MEM_EXTENDED_PARAMETER_0,
    pub Anonymous2: MEM_EXTENDED_PARAMETER_1,
}
#[cfg(feature = "Win32_Foundation")]
impl MEM_EXTENDED_PARAMETER {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for MEM_EXTENDED_PARAMETER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for MEM_EXTENDED_PARAMETER {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for MEM_EXTENDED_PARAMETER {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for MEM_EXTENDED_PARAMETER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct MEM_EXTENDED_PARAMETER_0 {
    pub _bitfield: u64,
}
impl MEM_EXTENDED_PARAMETER_0 {}
impl ::std::default::Default for MEM_EXTENDED_PARAMETER_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for MEM_EXTENDED_PARAMETER_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous1_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for MEM_EXTENDED_PARAMETER_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for MEM_EXTENDED_PARAMETER_0 {}
unsafe impl ::windows::runtime::Abi for MEM_EXTENDED_PARAMETER_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub union MEM_EXTENDED_PARAMETER_1 {
    pub ULong64: u64,
    pub Pointer: *mut ::std::ffi::c_void,
    pub Size: usize,
    pub Handle: super::super::Foundation::HANDLE,
    pub ULong: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl MEM_EXTENDED_PARAMETER_1 {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for MEM_EXTENDED_PARAMETER_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for MEM_EXTENDED_PARAMETER_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for MEM_EXTENDED_PARAMETER_1 {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for MEM_EXTENDED_PARAMETER_1 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const MEM_EXTENDED_PARAMETER_EC_CODE: u32 = 64u32;
pub const MEM_EXTENDED_PARAMETER_GRAPHICS: u32 = 1u32;
pub const MEM_EXTENDED_PARAMETER_NONPAGED: u32 = 2u32;
pub const MEM_EXTENDED_PARAMETER_NONPAGED_HUGE: u32 = 16u32;
pub const MEM_EXTENDED_PARAMETER_NONPAGED_LARGE: u32 = 8u32;
pub const MEM_EXTENDED_PARAMETER_SOFT_FAULT_PAGES: u32 = 32u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct MEM_EXTENDED_PARAMETER_TYPE(pub i32);
pub const MemExtendedParameterInvalidType: MEM_EXTENDED_PARAMETER_TYPE =
    MEM_EXTENDED_PARAMETER_TYPE(0i32);
pub const MemExtendedParameterAddressRequirements: MEM_EXTENDED_PARAMETER_TYPE =
    MEM_EXTENDED_PARAMETER_TYPE(1i32);
pub const MemExtendedParameterNumaNode: MEM_EXTENDED_PARAMETER_TYPE =
    MEM_EXTENDED_PARAMETER_TYPE(2i32);
pub const MemExtendedParameterPartitionHandle: MEM_EXTENDED_PARAMETER_TYPE =
    MEM_EXTENDED_PARAMETER_TYPE(3i32);
pub const MemExtendedParameterUserPhysicalHandle: MEM_EXTENDED_PARAMETER_TYPE =
    MEM_EXTENDED_PARAMETER_TYPE(4i32);
pub const MemExtendedParameterAttributeFlags: MEM_EXTENDED_PARAMETER_TYPE =
    MEM_EXTENDED_PARAMETER_TYPE(5i32);
pub const MemExtendedParameterImageMachine: MEM_EXTENDED_PARAMETER_TYPE =
    MEM_EXTENDED_PARAMETER_TYPE(6i32);
pub const MemExtendedParameterMax: MEM_EXTENDED_PARAMETER_TYPE = MEM_EXTENDED_PARAMETER_TYPE(7i32);
impl ::std::convert::From<i32> for MEM_EXTENDED_PARAMETER_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for MEM_EXTENDED_PARAMETER_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const MEM_EXTENDED_PARAMETER_TYPE_BITS: u32 = 8u32;
pub const MEM_EXTENDED_PARAMETER_ZERO_PAGES_OPTIONAL: u32 = 4u32;
pub const MEM_PHYSICAL: u32 = 4194304u32;
pub const MEM_ROTATE: u32 = 8388608u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct MEM_SECTION_EXTENDED_PARAMETER_TYPE(pub i32);
pub const MemSectionExtendedParameterInvalidType: MEM_SECTION_EXTENDED_PARAMETER_TYPE =
    MEM_SECTION_EXTENDED_PARAMETER_TYPE(0i32);
pub const MemSectionExtendedParameterUserPhysicalFlags: MEM_SECTION_EXTENDED_PARAMETER_TYPE =
    MEM_SECTION_EXTENDED_PARAMETER_TYPE(1i32);
pub const MemSectionExtendedParameterNumaNode: MEM_SECTION_EXTENDED_PARAMETER_TYPE =
    MEM_SECTION_EXTENDED_PARAMETER_TYPE(2i32);
pub const MemSectionExtendedParameterSigningLevel: MEM_SECTION_EXTENDED_PARAMETER_TYPE =
    MEM_SECTION_EXTENDED_PARAMETER_TYPE(3i32);
pub const MemSectionExtendedParameterMax: MEM_SECTION_EXTENDED_PARAMETER_TYPE =
    MEM_SECTION_EXTENDED_PARAMETER_TYPE(4i32);
impl ::std::convert::From<i32> for MEM_SECTION_EXTENDED_PARAMETER_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for MEM_SECTION_EXTENDED_PARAMETER_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const MEM_TOP_DOWN: u32 = 1048576u32;
pub const MEM_WRITE_WATCH: u32 = 2097152u32;
pub const MESSAGE_RESOURCE_UNICODE: u32 = 1u32;
pub const MESSAGE_RESOURCE_UTF8: u32 = 2u32;
pub const METHOD_BUFFERED: u32 = 0u32;
pub const METHOD_DIRECT_FROM_HARDWARE: u32 = 2u32;
pub const METHOD_DIRECT_TO_HARDWARE: u32 = 1u32;
pub const METHOD_IN_DIRECT: u32 = 1u32;
pub const METHOD_NEITHER: u32 = 3u32;
pub const METHOD_OUT_DIRECT: u32 = 2u32;
pub const MINCHAR: u32 = 128u32;
pub const MINLONG: u32 = 2147483648u32;
pub const MINSHORT: u32 = 32768u32;
pub const MIN_UCSCHAR: u32 = 0u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct MONITOR_DISPLAY_STATE(pub i32);
pub const PowerMonitorOff: MONITOR_DISPLAY_STATE = MONITOR_DISPLAY_STATE(0i32);
pub const PowerMonitorOn: MONITOR_DISPLAY_STATE = MONITOR_DISPLAY_STATE(1i32);
pub const PowerMonitorDim: MONITOR_DISPLAY_STATE = MONITOR_DISPLAY_STATE(2i32);
impl ::std::convert::From<i32> for MONITOR_DISPLAY_STATE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for MONITOR_DISPLAY_STATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct MOVE_FILE_DATA32 {
    pub FileHandle: u32,
    pub StartingVcn: i64,
    pub StartingLcn: i64,
    pub ClusterCount: u32,
}
impl MOVE_FILE_DATA32 {}
impl ::std::default::Default for MOVE_FILE_DATA32 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for MOVE_FILE_DATA32 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("MOVE_FILE_DATA32")
            .field("FileHandle", &self.FileHandle)
            .field("StartingVcn", &self.StartingVcn)
            .field("StartingLcn", &self.StartingLcn)
            .field("ClusterCount", &self.ClusterCount)
            .finish()
    }
}
impl ::std::cmp::PartialEq for MOVE_FILE_DATA32 {
    fn eq(&self, other: &Self) -> bool {
        self.FileHandle == other.FileHandle
            && self.StartingVcn == other.StartingVcn
            && self.StartingLcn == other.StartingLcn
            && self.ClusterCount == other.ClusterCount
    }
}
impl ::std::cmp::Eq for MOVE_FILE_DATA32 {}
unsafe impl ::windows::runtime::Abi for MOVE_FILE_DATA32 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct MOVE_FILE_RECORD_DATA {
    pub FileHandle: super::super::Foundation::HANDLE,
    pub SourceFileRecord: i64,
    pub TargetFileRecord: i64,
}
#[cfg(feature = "Win32_Foundation")]
impl MOVE_FILE_RECORD_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for MOVE_FILE_RECORD_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for MOVE_FILE_RECORD_DATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("MOVE_FILE_RECORD_DATA")
            .field("FileHandle", &self.FileHandle)
            .field("SourceFileRecord", &self.SourceFileRecord)
            .field("TargetFileRecord", &self.TargetFileRecord)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for MOVE_FILE_RECORD_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.FileHandle == other.FileHandle
            && self.SourceFileRecord == other.SourceFileRecord
            && self.TargetFileRecord == other.TargetFileRecord
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for MOVE_FILE_RECORD_DATA {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for MOVE_FILE_RECORD_DATA {
    type Abi = Self;
    type DefaultType = Self;
}
pub const MS_CDDDEVICEBITMAP: u32 = 4u32;
pub const MS_NOTSYSTEMMEMORY: u32 = 1u32;
pub const MS_PPM_SOFTWARE_ALL: u32 = 1u32;
pub const MS_REUSEDDEVICEBITMAP: u32 = 8u32;
pub const MS_SHAREDACCESS: u32 = 2u32;
pub const MUTANT_QUERY_STATE: u32 = 1u32;
pub const NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct NETWORK_APP_INSTANCE_EA {
    pub AppInstanceID: ::windows::runtime::GUID,
    pub CsvFlags: u32,
}
impl NETWORK_APP_INSTANCE_EA {}
impl ::std::default::Default for NETWORK_APP_INSTANCE_EA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for NETWORK_APP_INSTANCE_EA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("NETWORK_APP_INSTANCE_EA")
            .field("AppInstanceID", &self.AppInstanceID)
            .field("CsvFlags", &self.CsvFlags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for NETWORK_APP_INSTANCE_EA {
    fn eq(&self, other: &Self) -> bool {
        self.AppInstanceID == other.AppInstanceID && self.CsvFlags == other.CsvFlags
    }
}
impl ::std::cmp::Eq for NETWORK_APP_INSTANCE_EA {}
unsafe impl ::windows::runtime::Abi for NETWORK_APP_INSTANCE_EA {
    type Abi = Self;
    type DefaultType = Self;
}
pub const NLS_VALID_LOCALE_MASK: u32 = 1048575u32;
pub const NONVOL_FP_NUMREG_ARM64: u32 = 8u32;
pub const NONVOL_INT_NUMREG_ARM64: u32 = 11u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(4))]
pub struct NON_PAGED_DEBUG_INFO {
    pub Signature: u16,
    pub Flags: u16,
    pub Size: u32,
    pub Machine: u16,
    pub Characteristics: u16,
    pub TimeDateStamp: u32,
    pub CheckSum: u32,
    pub SizeOfImage: u32,
    pub ImageBase: u64,
}
impl NON_PAGED_DEBUG_INFO {}
impl ::std::default::Default for NON_PAGED_DEBUG_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for NON_PAGED_DEBUG_INFO {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for NON_PAGED_DEBUG_INFO {}
unsafe impl ::windows::runtime::Abi for NON_PAGED_DEBUG_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
pub const NON_PAGED_DEBUG_SIGNATURE: u32 = 18766u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct NOTIFY_USER_POWER_SETTING {
    pub Guid: ::windows::runtime::GUID,
}
impl NOTIFY_USER_POWER_SETTING {}
impl ::std::default::Default for NOTIFY_USER_POWER_SETTING {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for NOTIFY_USER_POWER_SETTING {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("NOTIFY_USER_POWER_SETTING")
            .field("Guid", &self.Guid)
            .finish()
    }
}
impl ::std::cmp::PartialEq for NOTIFY_USER_POWER_SETTING {
    fn eq(&self, other: &Self) -> bool {
        self.Guid == other.Guid
    }
}
impl ::std::cmp::Eq for NOTIFY_USER_POWER_SETTING {}
unsafe impl ::windows::runtime::Abi for NOTIFY_USER_POWER_SETTING {
    type Abi = Self;
    type DefaultType = Self;
}
pub const NO_SUBGROUP_GUID: ::windows::runtime::GUID = ::windows::runtime::GUID::from_values(
    4272111934,
    32261,
    18705,
    [154, 113, 112, 3, 49, 241, 194, 148],
);
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
pub struct NT_TIB {
    pub ExceptionList: *mut EXCEPTION_REGISTRATION_RECORD,
    pub StackBase: *mut ::std::ffi::c_void,
    pub StackLimit: *mut ::std::ffi::c_void,
    pub SubSystemTib: *mut ::std::ffi::c_void,
    pub Anonymous: NT_TIB_0,
    pub ArbitraryUserPointer: *mut ::std::ffi::c_void,
    pub Self_: *mut NT_TIB,
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl NT_TIB {}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl ::std::default::Default for NT_TIB {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl ::std::cmp::PartialEq for NT_TIB {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
impl ::std::cmp::Eq for NT_TIB {}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug",
    feature = "Win32_System_Kernel"
))]
unsafe impl ::windows::runtime::Abi for NT_TIB {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union NT_TIB_0 {
    pub FiberData: *mut ::std::ffi::c_void,
    pub Version: u32,
}
impl NT_TIB_0 {}
impl ::std::default::Default for NT_TIB_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for NT_TIB_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for NT_TIB_0 {}
unsafe impl ::windows::runtime::Abi for NT_TIB_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct NT_TIB32 {
    pub ExceptionList: u32,
    pub StackBase: u32,
    pub StackLimit: u32,
    pub SubSystemTib: u32,
    pub Anonymous: NT_TIB32_0,
    pub ArbitraryUserPointer: u32,
    pub Self_: u32,
}
impl NT_TIB32 {}
impl ::std::default::Default for NT_TIB32 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for NT_TIB32 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for NT_TIB32 {}
unsafe impl ::windows::runtime::Abi for NT_TIB32 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union NT_TIB32_0 {
    pub FiberData: u32,
    pub Version: u32,
}
impl NT_TIB32_0 {}
impl ::std::default::Default for NT_TIB32_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for NT_TIB32_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for NT_TIB32_0 {}
unsafe impl ::windows::runtime::Abi for NT_TIB32_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct NT_TIB64 {
    pub ExceptionList: u64,
    pub StackBase: u64,
    pub StackLimit: u64,
    pub SubSystemTib: u64,
    pub Anonymous: NT_TIB64_0,
    pub ArbitraryUserPointer: u64,
    pub Self_: u64,
}
impl NT_TIB64 {}
impl ::std::default::Default for NT_TIB64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for NT_TIB64 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for NT_TIB64 {}
unsafe impl ::windows::runtime::Abi for NT_TIB64 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union NT_TIB64_0 {
    pub FiberData: u64,
    pub Version: u32,
}
impl NT_TIB64_0 {}
impl ::std::default::Default for NT_TIB64_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for NT_TIB64_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for NT_TIB64_0 {}
unsafe impl ::windows::runtime::Abi for NT_TIB64_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Kernel")]
pub struct NUMA_NODE_RELATIONSHIP {
    pub NodeNumber: u32,
    pub Reserved: [u8; 18],
    pub GroupCount: u16,
    pub Anonymous: NUMA_NODE_RELATIONSHIP_0,
}
#[cfg(feature = "Win32_System_Kernel")]
impl NUMA_NODE_RELATIONSHIP {}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::default::Default for NUMA_NODE_RELATIONSHIP {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::cmp::PartialEq for NUMA_NODE_RELATIONSHIP {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::cmp::Eq for NUMA_NODE_RELATIONSHIP {}
#[cfg(feature = "Win32_System_Kernel")]
unsafe impl ::windows::runtime::Abi for NUMA_NODE_RELATIONSHIP {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Kernel")]
pub union NUMA_NODE_RELATIONSHIP_0 {
    pub GroupMask: super::Kernel::GROUP_AFFINITY,
    pub GroupMasks: [super::Kernel::GROUP_AFFINITY; 1],
}
#[cfg(feature = "Win32_System_Kernel")]
impl NUMA_NODE_RELATIONSHIP_0 {}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::default::Default for NUMA_NODE_RELATIONSHIP_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::cmp::PartialEq for NUMA_NODE_RELATIONSHIP_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::cmp::Eq for NUMA_NODE_RELATIONSHIP_0 {}
#[cfg(feature = "Win32_System_Kernel")]
unsafe impl ::windows::runtime::Abi for NUMA_NODE_RELATIONSHIP_0 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const NUMA_NO_PREFERRED_NODE: u32 = 4294967295u32;
pub const NUM_DISCHARGE_POLICIES: u32 = 4u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct NV_MEMORY_RANGE {
    pub BaseAddress: *mut ::std::ffi::c_void,
    pub Length: usize,
}
impl NV_MEMORY_RANGE {}
impl ::std::default::Default for NV_MEMORY_RANGE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for NV_MEMORY_RANGE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("NV_MEMORY_RANGE")
            .field("BaseAddress", &self.BaseAddress)
            .field("Length", &self.Length)
            .finish()
    }
}
impl ::std::cmp::PartialEq for NV_MEMORY_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.BaseAddress == other.BaseAddress && self.Length == other.Length
    }
}
impl ::std::cmp::Eq for NV_MEMORY_RANGE {}
unsafe impl ::windows::runtime::Abi for NV_MEMORY_RANGE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const N_BTMASK: u32 = 15u32;
pub const N_BTSHFT: u32 = 4u32;
pub const N_TMASK: u32 = 48u32;
pub const N_TMASK1: u32 = 192u32;
pub const N_TMASK2: u32 = 240u32;
pub const N_TSHIFT: u32 = 2u32;
pub const OBSOLETE_DISK_GET_WRITE_CACHE_STATE: u32 = 475356u32;
pub const OBSOLETE_IOCTL_STORAGE_RESET_BUS: u32 = 3002368u32;
pub const OBSOLETE_IOCTL_STORAGE_RESET_DEVICE: u32 = 3002372u32;
pub const OC_BANK_CLIP: u32 = 1u32;
pub const OFFLOAD_READ_FLAG_ALL_ZERO_BEYOND_CURRENT_RANGE: u32 = 1u32;
pub const OPENGL_CMD: u32 = 4352u32;
pub const OPENGL_GETINFO: u32 = 4353u32;
pub const OPLOCK_LEVEL_CACHE_HANDLE: u32 = 2u32;
pub const OPLOCK_LEVEL_CACHE_READ: u32 = 1u32;
pub const OPLOCK_LEVEL_CACHE_WRITE: u32 = 4u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct OS_DEPLOYEMENT_STATE_VALUES(pub i32);
pub const OS_DEPLOYMENT_STANDARD: OS_DEPLOYEMENT_STATE_VALUES = OS_DEPLOYEMENT_STATE_VALUES(1i32);
pub const OS_DEPLOYMENT_COMPACT: OS_DEPLOYEMENT_STATE_VALUES = OS_DEPLOYEMENT_STATE_VALUES(2i32);
impl ::std::convert::From<i32> for OS_DEPLOYEMENT_STATE_VALUES {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for OS_DEPLOYEMENT_STATE_VALUES {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct OVERLAPPED {
    pub Internal: usize,
    pub InternalHigh: usize,
    pub Anonymous: OVERLAPPED_0,
    pub hEvent: super::super::Foundation::HANDLE,
}
#[cfg(feature = "Win32_Foundation")]
impl OVERLAPPED {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for OVERLAPPED {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for OVERLAPPED {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for OVERLAPPED {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for OVERLAPPED {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union OVERLAPPED_0 {
    pub Anonymous: OVERLAPPED_0_0,
    pub Pointer: *mut ::std::ffi::c_void,
}
impl OVERLAPPED_0 {}
impl ::std::default::Default for OVERLAPPED_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for OVERLAPPED_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for OVERLAPPED_0 {}
unsafe impl ::windows::runtime::Abi for OVERLAPPED_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct OVERLAPPED_0_0 {
    pub Offset: u32,
    pub OffsetHigh: u32,
}
impl OVERLAPPED_0_0 {}
impl ::std::default::Default for OVERLAPPED_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for OVERLAPPED_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("Offset", &self.Offset)
            .field("OffsetHigh", &self.OffsetHigh)
            .finish()
    }
}
impl ::std::cmp::PartialEq for OVERLAPPED_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Offset == other.Offset && self.OffsetHigh == other.OffsetHigh
    }
}
impl ::std::cmp::Eq for OVERLAPPED_0_0 {}
unsafe impl ::windows::runtime::Abi for OVERLAPPED_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PACKEDEVENTINFO {
    pub ulSize: u32,
    pub ulNumEventsForLogFile: u32,
    pub ulOffsets: [u32; 1],
}
impl PACKEDEVENTINFO {}
impl ::std::default::Default for PACKEDEVENTINFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PACKEDEVENTINFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PACKEDEVENTINFO")
            .field("ulSize", &self.ulSize)
            .field("ulNumEventsForLogFile", &self.ulNumEventsForLogFile)
            .field("ulOffsets", &self.ulOffsets)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PACKEDEVENTINFO {
    fn eq(&self, other: &Self) -> bool {
        self.ulSize == other.ulSize
            && self.ulNumEventsForLogFile == other.ulNumEventsForLogFile
            && self.ulOffsets == other.ulOffsets
    }
}
impl ::std::cmp::Eq for PACKEDEVENTINFO {}
unsafe impl ::windows::runtime::Abi for PACKEDEVENTINFO {
    type Abi = Self;
    type DefaultType = Self;
}
pub const PAL_BGR: u32 = 8u32;
pub const PAL_BITFIELDS: u32 = 2u32;
pub const PAL_CMYK: u32 = 16u32;
pub const PAL_INDEXED: u32 = 1u32;
pub const PAL_RGB: u32 = 4u32;
pub type PAPCFUNC = unsafe extern "system" fn(parameter: usize);
pub const PARTIITON_OS_DATA: u32 = 41u32;
pub const PARTITION_BSP: u32 = 43u32;
pub const PARTITION_DM: u32 = 84u32;
pub const PARTITION_DPP: u32 = 44u32;
pub const PARTITION_ENTRY_UNUSED: u32 = 0u32;
pub const PARTITION_EXTENDED: u32 = 5u32;
pub const PARTITION_EZDRIVE: u32 = 85u32;
pub const PARTITION_FAT32: u32 = 11u32;
pub const PARTITION_FAT32_XINT13: u32 = 12u32;
pub const PARTITION_FAT_12: u32 = 1u32;
pub const PARTITION_FAT_16: u32 = 4u32;
pub const PARTITION_GPT: u32 = 238u32;
pub const PARTITION_HUGE: u32 = 6u32;
pub const PARTITION_IFS: u32 = 7u32;
pub const PARTITION_LDM: u32 = 66u32;
pub const PARTITION_MAIN_OS: u32 = 40u32;
pub const PARTITION_MSFT_RECOVERY: u32 = 39u32;
pub const PARTITION_NTFT: u32 = 128u32;
pub const PARTITION_OS2BOOTMGR: u32 = 10u32;
pub const PARTITION_PREP: u32 = 65u32;
pub const PARTITION_PRE_INSTALLED: u32 = 42u32;
pub const PARTITION_SPACES: u32 = 231u32;
pub const PARTITION_SPACES_DATA: u32 = 215u32;
pub const PARTITION_SYSTEM: u32 = 239u32;
pub const PARTITION_UNIX: u32 = 99u32;
pub const PARTITION_WINDOWS_SYSTEM: u32 = 45u32;
pub const PARTITION_XENIX_1: u32 = 2u32;
pub const PARTITION_XENIX_2: u32 = 3u32;
pub const PARTITION_XINT13: u32 = 14u32;
pub const PARTITION_XINT13_EXTENDED: u32 = 15u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PATHNAME_BUFFER {
    pub PathNameLength: u32,
    pub Name: [u16; 1],
}
impl PATHNAME_BUFFER {}
impl ::std::default::Default for PATHNAME_BUFFER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PATHNAME_BUFFER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PATHNAME_BUFFER")
            .field("PathNameLength", &self.PathNameLength)
            .field("Name", &self.Name)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PATHNAME_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.PathNameLength == other.PathNameLength && self.Name == other.Name
    }
}
impl ::std::cmp::Eq for PATHNAME_BUFFER {}
unsafe impl ::windows::runtime::Abi for PATHNAME_BUFFER {
    type Abi = Self;
    type DefaultType = Self;
}
pub const PDCAP_D0_SUPPORTED: u32 = 1u32;
pub const PDCAP_D1_SUPPORTED: u32 = 2u32;
pub const PDCAP_D2_SUPPORTED: u32 = 4u32;
pub const PDCAP_D3_SUPPORTED: u32 = 8u32;
pub const PDCAP_WAKE_FROM_D0_SUPPORTED: u32 = 16u32;
pub const PDCAP_WAKE_FROM_D1_SUPPORTED: u32 = 32u32;
pub const PDCAP_WAKE_FROM_D2_SUPPORTED: u32 = 64u32;
pub const PDCAP_WAKE_FROM_D3_SUPPORTED: u32 = 128u32;
pub const PDCAP_WARM_EJECT_SUPPORTED: u32 = 256u32;
pub const PD_BEGINSUBPATH: u32 = 1u32;
pub const PD_BEZIERS: u32 = 16u32;
pub const PD_CLOSEFIGURE: u32 = 8u32;
pub const PD_ENDSUBPATH: u32 = 2u32;
pub const PD_RESETSTYLE: u32 = 4u32;
pub const PERFORMANCE_DATA_VERSION: u32 = 1u32;
pub const PERFSTATE_POLICY_CHANGE_DECREASE_MAX: u32 = 2u32;
pub const PERFSTATE_POLICY_CHANGE_IDEAL: u32 = 0u32;
pub const PERFSTATE_POLICY_CHANGE_IDEAL_AGGRESSIVE: u32 = 3u32;
pub const PERFSTATE_POLICY_CHANGE_INCREASE_MAX: u32 = 3u32;
pub const PERFSTATE_POLICY_CHANGE_ROCKET: u32 = 2u32;
pub const PERFSTATE_POLICY_CHANGE_SINGLE: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PERF_BIN {
    pub NumberOfBins: u32,
    pub TypeOfBin: u32,
    pub BinsRanges: [BIN_RANGE; 1],
}
impl PERF_BIN {}
impl ::std::default::Default for PERF_BIN {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PERF_BIN {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PERF_BIN")
            .field("NumberOfBins", &self.NumberOfBins)
            .field("TypeOfBin", &self.TypeOfBin)
            .field("BinsRanges", &self.BinsRanges)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PERF_BIN {
    fn eq(&self, other: &Self) -> bool {
        self.NumberOfBins == other.NumberOfBins
            && self.TypeOfBin == other.TypeOfBin
            && self.BinsRanges == other.BinsRanges
    }
}
impl ::std::cmp::Eq for PERF_BIN {}
unsafe impl ::windows::runtime::Abi for PERF_BIN {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PERSISTENT_RESERVE_COMMAND {
    pub Version: u32,
    pub Size: u32,
    pub Anonymous: PERSISTENT_RESERVE_COMMAND_0,
}
impl PERSISTENT_RESERVE_COMMAND {}
impl ::std::default::Default for PERSISTENT_RESERVE_COMMAND {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PERSISTENT_RESERVE_COMMAND {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PERSISTENT_RESERVE_COMMAND {}
unsafe impl ::windows::runtime::Abi for PERSISTENT_RESERVE_COMMAND {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PERSISTENT_RESERVE_COMMAND_0 {
    pub PR_IN: PERSISTENT_RESERVE_COMMAND_0_0,
    pub PR_OUT: PERSISTENT_RESERVE_COMMAND_0_1,
}
impl PERSISTENT_RESERVE_COMMAND_0 {}
impl ::std::default::Default for PERSISTENT_RESERVE_COMMAND_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PERSISTENT_RESERVE_COMMAND_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PERSISTENT_RESERVE_COMMAND_0 {}
unsafe impl ::windows::runtime::Abi for PERSISTENT_RESERVE_COMMAND_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PERSISTENT_RESERVE_COMMAND_0_0 {
    pub _bitfield: u8,
    pub AllocationLength: u16,
}
impl PERSISTENT_RESERVE_COMMAND_0_0 {}
impl ::std::default::Default for PERSISTENT_RESERVE_COMMAND_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PERSISTENT_RESERVE_COMMAND_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_PR_IN_e__Struct")
            .field("_bitfield", &self._bitfield)
            .field("AllocationLength", &self.AllocationLength)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PERSISTENT_RESERVE_COMMAND_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield && self.AllocationLength == other.AllocationLength
    }
}
impl ::std::cmp::Eq for PERSISTENT_RESERVE_COMMAND_0_0 {}
unsafe impl ::windows::runtime::Abi for PERSISTENT_RESERVE_COMMAND_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PERSISTENT_RESERVE_COMMAND_0_1 {
    pub _bitfield1: u8,
    pub _bitfield2: u8,
    pub ParameterList: [u8; 1],
}
impl PERSISTENT_RESERVE_COMMAND_0_1 {}
impl ::std::default::Default for PERSISTENT_RESERVE_COMMAND_0_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PERSISTENT_RESERVE_COMMAND_0_1 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_PR_OUT_e__Struct")
            .field("_bitfield1", &self._bitfield1)
            .field("_bitfield2", &self._bitfield2)
            .field("ParameterList", &self.ParameterList)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PERSISTENT_RESERVE_COMMAND_0_1 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield1 == other._bitfield1
            && self._bitfield2 == other._bitfield2
            && self.ParameterList == other.ParameterList
    }
}
impl ::std::cmp::Eq for PERSISTENT_RESERVE_COMMAND_0_1 {}
unsafe impl ::windows::runtime::Abi for PERSISTENT_RESERVE_COMMAND_0_1 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const PERSISTENT_VOLUME_STATE_BACKED_BY_WIM: u32 = 64u32;
pub const PERSISTENT_VOLUME_STATE_CHKDSK_RAN_ONCE: u32 = 1024u32;
pub const PERSISTENT_VOLUME_STATE_CONTAINS_BACKING_WIM: u32 = 32u32;
pub const PERSISTENT_VOLUME_STATE_DAX_FORMATTED: u32 = 4096u32;
pub const PERSISTENT_VOLUME_STATE_GLOBAL_METADATA_NO_SEEK_PENALTY: u32 = 4u32;
pub const PERSISTENT_VOLUME_STATE_LOCAL_METADATA_NO_SEEK_PENALTY: u32 = 8u32;
pub const PERSISTENT_VOLUME_STATE_MODIFIED_BY_CHKDSK: u32 = 2048u32;
pub const PERSISTENT_VOLUME_STATE_NO_HEAT_GATHERING: u32 = 16u32;
pub const PERSISTENT_VOLUME_STATE_NO_WRITE_AUTO_TIERING: u32 = 128u32;
pub const PERSISTENT_VOLUME_STATE_REALLOCATE_ALL_DATA_WRITES: u32 = 512u32;
pub const PERSISTENT_VOLUME_STATE_SHORT_NAME_CREATION_DISABLED: u32 = 1u32;
pub const PERSISTENT_VOLUME_STATE_TXF_DISABLED: u32 = 256u32;
pub const PERSISTENT_VOLUME_STATE_VOLUME_SCRUB_DISABLED: u32 = 2u32;
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug"
))]
pub type PEXCEPTION_FILTER = unsafe extern "system" fn(
    exceptionpointers: *mut super::Diagnostics::Debug::EXCEPTION_POINTERS,
    establisherframe: *const ::std::ffi::c_void,
) -> i32;
pub type PFLS_CALLBACK_FUNCTION = unsafe extern "system" fn(lpflsdata: *const ::std::ffi::c_void);
pub type PFN = unsafe extern "system" fn() -> isize;
pub type PFND3DNTPARSEUNKNOWNCOMMAND = unsafe extern "system" fn(
    lpvcommands: *mut ::std::ffi::c_void,
    lplpvreturnedcommand: *mut *mut ::std::ffi::c_void,
) -> ::windows::runtime::HRESULT;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvAccumulateD3DDirtyRect =
    unsafe extern "system" fn(
        param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
        param1: *mut CDDDXGK_REDIRBITMAPPRESENTINFO,
    ) -> super::super::Foundation::BOOL;
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_Gdi",
    feature = "Win32_UI_DisplayDevices"
))]
pub type PFN_DrvAlphaBlend = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param2: *mut super::super::UI::DisplayDevices::CLIPOBJ,
    param3: *mut super::super::UI::DisplayDevices::XLATEOBJ,
    param4: *mut super::super::Foundation::RECTL,
    param5: *mut super::super::Foundation::RECTL,
    param6: *mut super::super::UI::DisplayDevices::BLENDOBJ,
) -> super::super::Foundation::BOOL;
#[cfg(feature = "Win32_Foundation")]
pub type PFN_DrvAssertMode = unsafe extern "system" fn(
    param0: DHPDEV,
    param1: super::super::Foundation::BOOL,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvAssociateSharedSurface =
    unsafe extern "system" fn(
        param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
        param1: super::super::Foundation::HANDLE,
        param2: super::super::Foundation::HANDLE,
        param3: super::super::Foundation::SIZE,
    ) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvBitBlt = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param2: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param3: *mut super::super::UI::DisplayDevices::CLIPOBJ,
    param4: *mut super::super::UI::DisplayDevices::XLATEOBJ,
    param5: *mut super::super::Foundation::RECTL,
    param6: *mut super::super::Foundation::POINTL,
    param7: *mut super::super::Foundation::POINTL,
    param8: *mut super::super::UI::DisplayDevices::BRUSHOBJ,
    param9: *mut super::super::Foundation::POINTL,
    param10: u32,
) -> super::super::Foundation::BOOL;
pub type PFN_DrvCompletePDEV = unsafe extern "system" fn(param0: DHPDEV, param1: HDEV);
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvCopyBits = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param2: *mut super::super::UI::DisplayDevices::CLIPOBJ,
    param3: *mut super::super::UI::DisplayDevices::XLATEOBJ,
    param4: *mut super::super::Foundation::RECTL,
    param5: *mut super::super::Foundation::POINTL,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub type PFN_DrvCreateDeviceBitmap =
    unsafe extern "system" fn(
        param0: DHPDEV,
        param1: super::super::Foundation::SIZE,
        param2: u32,
    ) -> super::super::Graphics::Gdi::HBITMAP;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub type PFN_DrvCreateDeviceBitmapEx =
    unsafe extern "system" fn(
        param0: DHPDEV,
        param1: super::super::Foundation::SIZE,
        param2: u32,
        param3: u32,
        param4: DHSURF,
        param5: u32,
        param6: u32,
        param7: *mut super::super::Foundation::HANDLE,
    ) -> super::super::Graphics::Gdi::HBITMAP;
pub type PFN_DrvDeleteDeviceBitmap = unsafe extern "system" fn(param0: DHSURF);
pub type PFN_DrvDeleteDeviceBitmapEx = unsafe extern "system" fn(param0: DHSURF);
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_Graphics_Gdi",
    feature = "Win32_UI_DisplayDevices"
))]
pub type PFN_DrvDeriveSurface = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::DD_DIRECTDRAW_GLOBAL,
    param1: *mut super::super::UI::DisplayDevices::DD_SURFACE_LOCAL,
) -> super::super::Graphics::Gdi::HBITMAP;
#[cfg(feature = "Win32_Graphics_OpenGL")]
pub type PFN_DrvDescribePixelFormat = unsafe extern "system" fn(
    param0: DHPDEV,
    param1: i32,
    param2: u32,
    param3: *mut super::super::Graphics::OpenGL::PIXELFORMATDESCRIPTOR,
) -> i32;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvDestroyFont =
    unsafe extern "system" fn(param0: *mut super::super::UI::DisplayDevices::FONTOBJ);
pub type PFN_DrvDisableDirectDraw = unsafe extern "system" fn(param0: DHPDEV);
pub type PFN_DrvDisableDriver = unsafe extern "system" fn();
pub type PFN_DrvDisablePDEV = unsafe extern "system" fn(param0: DHPDEV);
pub type PFN_DrvDisableSurface = unsafe extern "system" fn(param0: DHPDEV);
pub type PFN_DrvDitherColor =
    unsafe extern "system" fn(param0: DHPDEV, param1: u32, param2: u32, param3: *mut u32) -> u32;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvDrawEscape = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: u32,
    param2: *mut super::super::UI::DisplayDevices::CLIPOBJ,
    param3: *mut super::super::Foundation::RECTL,
    param4: u32,
    param5: *mut ::std::ffi::c_void,
) -> u32;
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_Graphics_Gdi",
    feature = "Win32_UI_DisplayDevices"
))]
pub type PFN_DrvEnableDirectDraw = unsafe extern "system" fn(
    param0: DHPDEV,
    param1: *mut ::std::mem::ManuallyDrop<super::super::UI::DisplayDevices::DD_CALLBACKS>,
    param2: *mut ::std::mem::ManuallyDrop<super::super::UI::DisplayDevices::DD_SURFACECALLBACKS>,
    param3: *mut ::std::mem::ManuallyDrop<super::super::UI::DisplayDevices::DD_PALETTECALLBACKS>,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvEnableDriver = unsafe extern "system" fn(
    param0: u32,
    param1: u32,
    param2: *mut super::super::UI::DisplayDevices::DRVENABLEDATA,
) -> super::super::Foundation::BOOL;
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_Gdi",
    feature = "Win32_UI_DisplayDevices"
))]
pub type PFN_DrvEnablePDEV = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::DEVMODEW,
    param1: super::super::Foundation::PWSTR,
    param2: u32,
    param3: *mut HSURF,
    param4: u32,
    param5: *mut super::super::UI::DisplayDevices::GDIINFO,
    param6: u32,
    param7: *mut super::super::UI::DisplayDevices::DEVINFO,
    param8: HDEV,
    param9: super::super::Foundation::PWSTR,
    param10: super::super::Foundation::HANDLE,
) -> DHPDEV;
pub type PFN_DrvEnableSurface = unsafe extern "system" fn(param0: DHPDEV) -> HSURF;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvEndDoc = unsafe extern "system" fn(
    pso: *mut super::super::UI::DisplayDevices::SURFOBJ,
    fl: u32,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvEndDxInterop = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: super::super::Foundation::BOOL,
    param2: *mut super::super::Foundation::BOOL,
    kernelmodedevicehandle: *mut ::std::ffi::c_void,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvEscape = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: u32,
    param2: u32,
    param3: *mut ::std::ffi::c_void,
    param4: u32,
    param5: *mut ::std::ffi::c_void,
) -> u32;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvFillPath = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::PATHOBJ,
    param2: *mut super::super::UI::DisplayDevices::CLIPOBJ,
    param3: *mut super::super::UI::DisplayDevices::BRUSHOBJ,
    param4: *mut super::super::Foundation::POINTL,
    param5: u32,
    param6: u32,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvFontManagement = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::FONTOBJ,
    param2: u32,
    param3: u32,
    param4: *mut ::std::ffi::c_void,
    param5: u32,
    param6: *mut ::std::ffi::c_void,
) -> u32;
pub type PFN_DrvFree = unsafe extern "system" fn(param0: *mut ::std::ffi::c_void, param1: usize);
#[cfg(all(
    feature = "Win32_Devices_Display",
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_DirectDraw",
    feature = "Win32_UI_DisplayDevices"
))]
pub type PFN_DrvGetDirectDrawInfo = unsafe extern "system" fn(
    param0: DHPDEV,
    param1: *mut ::std::mem::ManuallyDrop<super::super::UI::DisplayDevices::DD_HALINFO>,
    param2: *mut u32,
    param3: *mut super::super::UI::DisplayDevices::VIDEOMEMORY,
    param4: *mut u32,
    param5: *mut u32,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvGetGlyphMode = unsafe extern "system" fn(
    dhpdev: DHPDEV,
    pfo: *mut super::super::UI::DisplayDevices::FONTOBJ,
) -> u32;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvGetModes = unsafe extern "system" fn(
    param0: super::super::Foundation::HANDLE,
    param1: u32,
    param2: *mut super::super::UI::DisplayDevices::DEVMODEW,
) -> u32;
pub type PFN_DrvGetTrueTypeFile =
    unsafe extern "system" fn(param0: usize, param1: *mut u32) -> *mut ::std::ffi::c_void;
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_Gdi",
    feature = "Win32_UI_DisplayDevices"
))]
pub type PFN_DrvGradientFill = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::CLIPOBJ,
    param2: *mut super::super::UI::DisplayDevices::XLATEOBJ,
    param3: *mut super::super::Graphics::Gdi::TRIVERTEX,
    param4: u32,
    param5: *mut ::std::ffi::c_void,
    param6: u32,
    param7: *mut super::super::Foundation::RECTL,
    param8: *mut super::super::Foundation::POINTL,
    param9: u32,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvIcmCheckBitmapBits = unsafe extern "system" fn(
    param0: DHPDEV,
    param1: super::super::Foundation::HANDLE,
    param2: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param3: *mut u8,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_ColorSystem"))]
pub type PFN_DrvIcmCreateColorTransform =
    unsafe extern "system" fn(
        param0: DHPDEV,
        param1: *mut super::super::UI::ColorSystem::LOGCOLORSPACEW,
        param2: *mut ::std::ffi::c_void,
        param3: u32,
        param4: *mut ::std::ffi::c_void,
        param5: u32,
        param6: *mut ::std::ffi::c_void,
        param7: u32,
        param8: u32,
    ) -> super::super::Foundation::HANDLE;
#[cfg(feature = "Win32_Foundation")]
pub type PFN_DrvIcmDeleteColorTransform =
    unsafe extern "system" fn(
        param0: DHPDEV,
        param1: super::super::Foundation::HANDLE,
    ) -> super::super::Foundation::BOOL;
#[cfg(feature = "Win32_Foundation")]
pub type PFN_DrvIcmSetDeviceGammaRamp = unsafe extern "system" fn(
    param0: DHPDEV,
    param1: u32,
    param2: *mut ::std::ffi::c_void,
)
    -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvLineTo = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::CLIPOBJ,
    param2: *mut super::super::UI::DisplayDevices::BRUSHOBJ,
    param3: i32,
    param4: i32,
    param5: i32,
    param6: i32,
    param7: *mut super::super::Foundation::RECTL,
    param8: u32,
) -> super::super::Foundation::BOOL;
#[cfg(feature = "Win32_Graphics_Gdi")]
pub type PFN_DrvLoadFontFile = unsafe extern "system" fn(
    param0: u32,
    param1: *mut usize,
    param2: *mut *mut ::std::ffi::c_void,
    param3: *mut u32,
    param4: *mut super::super::Graphics::Gdi::DESIGNVECTOR,
    param5: u32,
    param6: u32,
) -> usize;
#[cfg(feature = "Win32_Foundation")]
pub type PFN_DrvLockDisplayArea =
    unsafe extern "system" fn(param0: DHPDEV, param1: *mut super::super::Foundation::RECTL);
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvMovePointer = unsafe extern "system" fn(
    pso: *mut super::super::UI::DisplayDevices::SURFOBJ,
    x: i32,
    y: i32,
    prcl: *mut super::super::Foundation::RECTL,
);
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvNextBand = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    ppointl: *mut super::super::Foundation::POINTL,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvNotify = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: u32,
    param2: *mut ::std::ffi::c_void,
);
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvPaint = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::CLIPOBJ,
    param2: *mut super::super::UI::DisplayDevices::BRUSHOBJ,
    param3: *mut super::super::Foundation::POINTL,
    param4: u32,
) -> super::super::Foundation::BOOL;
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_Gdi",
    feature = "Win32_UI_DisplayDevices"
))]
pub type PFN_DrvPlgBlt = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param2: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param3: *mut super::super::UI::DisplayDevices::CLIPOBJ,
    param4: *mut super::super::UI::DisplayDevices::XLATEOBJ,
    param5: *mut super::super::Graphics::Gdi::COLORADJUSTMENT,
    param6: *mut super::super::Foundation::POINTL,
    param7: *mut POINTFIX,
    param8: *mut super::super::Foundation::RECTL,
    param9: *mut super::super::Foundation::POINTL,
    param10: u32,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvQueryAdvanceWidths = unsafe extern "system" fn(
    param0: DHPDEV,
    param1: *mut super::super::UI::DisplayDevices::FONTOBJ,
    param2: u32,
    param3: *mut u32,
    param4: *mut ::std::ffi::c_void,
    param5: u32,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvQueryDeviceSupport = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::XLATEOBJ,
    param2: *mut XFORMOBJ,
    param3: u32,
    param4: u32,
    param5: *mut ::std::ffi::c_void,
    param6: u32,
    param7: *mut ::std::ffi::c_void,
) -> super::super::Foundation::BOOL;
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_Gdi",
    feature = "Win32_UI_DisplayDevices"
))]
pub type PFN_DrvQueryFont =
    unsafe extern "system" fn(
        param0: DHPDEV,
        param1: usize,
        param2: u32,
        param3: *mut usize,
    ) -> *mut super::super::UI::DisplayDevices::IFIMETRICS;
pub type PFN_DrvQueryFontCaps = unsafe extern "system" fn(param0: u32, param1: *mut u32) -> i32;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvQueryFontData = unsafe extern "system" fn(
    param0: DHPDEV,
    param1: *mut super::super::UI::DisplayDevices::FONTOBJ,
    param2: u32,
    param3: u32,
    param4: *mut super::super::UI::DisplayDevices::GLYPHDATA,
    param5: *mut ::std::ffi::c_void,
    param6: u32,
) -> i32;
pub type PFN_DrvQueryFontFile =
    unsafe extern "system" fn(param0: usize, param1: u32, param2: u32, param3: *mut u32) -> i32;
pub type PFN_DrvQueryFontTree = unsafe extern "system" fn(
    param0: DHPDEV,
    param1: usize,
    param2: u32,
    param3: u32,
    param4: *mut usize,
) -> *mut ::std::ffi::c_void;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvQueryPerBandInfo = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::PERBANDINFO,
) -> super::super::Foundation::BOOL;
#[cfg(feature = "Win32_Foundation")]
pub type PFN_DrvQuerySpoolType = unsafe extern "system" fn(
    dhpdev: DHPDEV,
    pwchtype: super::super::Foundation::PWSTR,
) -> super::super::Foundation::BOOL;
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_Gdi",
    feature = "Win32_UI_DisplayDevices"
))]
pub type PFN_DrvQueryTrueTypeOutline = unsafe extern "system" fn(
    param0: DHPDEV,
    param1: *mut super::super::UI::DisplayDevices::FONTOBJ,
    param2: u32,
    param3: super::super::Foundation::BOOL,
    param4: *mut super::super::UI::DisplayDevices::GLYPHDATA,
    param5: u32,
    param6: *mut super::super::Graphics::Gdi::TTPOLYGONHEADER,
) -> i32;
#[cfg(feature = "Win32_Foundation")]
pub type PFN_DrvQueryTrueTypeSection = unsafe extern "system" fn(
    param0: u32,
    param1: u32,
    param2: u32,
    param3: *mut super::super::Foundation::HANDLE,
    param4: *mut i32,
) -> i32;
pub type PFN_DrvQueryTrueTypeTable = unsafe extern "system" fn(
    param0: usize,
    param1: u32,
    param2: u32,
    param3: i32,
    param4: u32,
    param5: *mut u8,
    param6: *mut *mut u8,
    param7: *mut u32,
) -> i32;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvRealizeBrush = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::BRUSHOBJ,
    param1: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param2: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param3: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param4: *mut super::super::UI::DisplayDevices::XLATEOBJ,
    param5: u32,
) -> super::super::Foundation::BOOL;
pub type PFN_DrvRenderHint = unsafe extern "system" fn(
    dhpdev: DHPDEV,
    notifycode: u32,
    length: usize,
    data: *const ::std::ffi::c_void,
) -> i32;
pub type PFN_DrvResetDevice =
    unsafe extern "system" fn(param0: DHPDEV, param1: *mut ::std::ffi::c_void) -> u32;
#[cfg(feature = "Win32_Foundation")]
pub type PFN_DrvResetPDEV = unsafe extern "system" fn(
    dhpdevold: DHPDEV,
    dhpdevnew: DHPDEV,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvSaveScreenBits = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: u32,
    param2: usize,
    param3: *mut super::super::Foundation::RECTL,
) -> usize;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvSendPage = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvSetPalette = unsafe extern "system" fn(
    param0: DHPDEV,
    param1: *mut super::super::UI::DisplayDevices::PALOBJ,
    param2: u32,
    param3: u32,
    param4: u32,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvSetPixelFormat = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: i32,
    param2: super::super::Foundation::HWND,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvSetPointerShape = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param2: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param3: *mut super::super::UI::DisplayDevices::XLATEOBJ,
    param4: i32,
    param5: i32,
    param6: i32,
    param7: i32,
    param8: *mut super::super::Foundation::RECTL,
    param9: u32,
) -> u32;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvStartBanding = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    ppointl: *mut super::super::Foundation::POINTL,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvStartDoc = unsafe extern "system" fn(
    pso: *mut super::super::UI::DisplayDevices::SURFOBJ,
    pwszdocname: super::super::Foundation::PWSTR,
    dwjobid: u32,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvStartDxInterop = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: super::super::Foundation::BOOL,
    kernelmodedevicehandle: *mut ::std::ffi::c_void,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvStartPage = unsafe extern "system" fn(
    pso: *mut super::super::UI::DisplayDevices::SURFOBJ,
) -> super::super::Foundation::BOOL;
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_Gdi",
    feature = "Win32_UI_DisplayDevices"
))]
pub type PFN_DrvStretchBlt = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param2: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param3: *mut super::super::UI::DisplayDevices::CLIPOBJ,
    param4: *mut super::super::UI::DisplayDevices::XLATEOBJ,
    param5: *mut super::super::Graphics::Gdi::COLORADJUSTMENT,
    param6: *mut super::super::Foundation::POINTL,
    param7: *mut super::super::Foundation::RECTL,
    param8: *mut super::super::Foundation::RECTL,
    param9: *mut super::super::Foundation::POINTL,
    param10: u32,
) -> super::super::Foundation::BOOL;
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_Graphics_Gdi",
    feature = "Win32_UI_DisplayDevices"
))]
pub type PFN_DrvStretchBltROP = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param2: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param3: *mut super::super::UI::DisplayDevices::CLIPOBJ,
    param4: *mut super::super::UI::DisplayDevices::XLATEOBJ,
    param5: *mut super::super::Graphics::Gdi::COLORADJUSTMENT,
    param6: *mut super::super::Foundation::POINTL,
    param7: *mut super::super::Foundation::RECTL,
    param8: *mut super::super::Foundation::RECTL,
    param9: *mut super::super::Foundation::POINTL,
    param10: u32,
    param11: *mut super::super::UI::DisplayDevices::BRUSHOBJ,
    param12: u32,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvStrokeAndFillPath = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::PATHOBJ,
    param2: *mut super::super::UI::DisplayDevices::CLIPOBJ,
    param3: *mut XFORMOBJ,
    param4: *mut super::super::UI::DisplayDevices::BRUSHOBJ,
    param5: *mut super::super::UI::DisplayDevices::LINEATTRS,
    param6: *mut super::super::UI::DisplayDevices::BRUSHOBJ,
    param7: *mut super::super::Foundation::POINTL,
    param8: u32,
    param9: u32,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvStrokePath = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::PATHOBJ,
    param2: *mut super::super::UI::DisplayDevices::CLIPOBJ,
    param3: *mut XFORMOBJ,
    param4: *mut super::super::UI::DisplayDevices::BRUSHOBJ,
    param5: *mut super::super::Foundation::POINTL,
    param6: *mut super::super::UI::DisplayDevices::LINEATTRS,
    param7: u32,
) -> super::super::Foundation::BOOL;
#[cfg(feature = "Win32_Foundation")]
pub type PFN_DrvSurfaceComplete = unsafe extern "system" fn(
    param0: DHPDEV,
    param1: super::super::Foundation::HANDLE,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvSwapBuffers = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::WNDOBJ,
) -> super::super::Foundation::BOOL;
#[cfg(feature = "Win32_Foundation")]
pub type PFN_DrvSynchronize =
    unsafe extern "system" fn(param0: DHPDEV, param1: *mut super::super::Foundation::RECTL);
#[cfg(feature = "Win32_Foundation")]
pub type PFN_DrvSynchronizeRedirectionBitmaps =
    unsafe extern "system" fn(
        param0: DHPDEV,
        param1: *mut u64,
    ) -> super::super::Foundation::NTSTATUS;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvSynchronizeSurface = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::Foundation::RECTL,
    param2: u32,
);
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvTextOut = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::STROBJ,
    param2: *mut super::super::UI::DisplayDevices::FONTOBJ,
    param3: *mut super::super::UI::DisplayDevices::CLIPOBJ,
    param4: *mut super::super::Foundation::RECTL,
    param5: *mut super::super::Foundation::RECTL,
    param6: *mut super::super::UI::DisplayDevices::BRUSHOBJ,
    param7: *mut super::super::UI::DisplayDevices::BRUSHOBJ,
    param8: *mut super::super::Foundation::POINTL,
    param9: u32,
) -> super::super::Foundation::BOOL;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type PFN_DrvTransparentBlt = unsafe extern "system" fn(
    param0: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param1: *mut super::super::UI::DisplayDevices::SURFOBJ,
    param2: *mut super::super::UI::DisplayDevices::CLIPOBJ,
    param3: *mut super::super::UI::DisplayDevices::XLATEOBJ,
    param4: *mut super::super::Foundation::RECTL,
    param5: *mut super::super::Foundation::RECTL,
    param6: u32,
    param7: u32,
) -> super::super::Foundation::BOOL;
#[cfg(feature = "Win32_Foundation")]
pub type PFN_DrvUnloadFontFile =
    unsafe extern "system" fn(param0: usize) -> super::super::Foundation::BOOL;
#[cfg(feature = "Win32_Foundation")]
pub type PFN_DrvUnlockDisplayArea =
    unsafe extern "system" fn(param0: DHPDEV, param1: *mut super::super::Foundation::RECTL);
#[cfg(feature = "Win32_Foundation")]
pub type PFN_EngCombineRgn = unsafe extern "system" fn(
    hrgntrg: super::super::Foundation::HANDLE,
    hrgnsrc1: super::super::Foundation::HANDLE,
    hrgnsrc2: super::super::Foundation::HANDLE,
    imode: i32,
) -> i32;
#[cfg(feature = "Win32_Foundation")]
pub type PFN_EngCopyRgn = unsafe extern "system" fn(
    hrgndst: super::super::Foundation::HANDLE,
    hrgnsrc: super::super::Foundation::HANDLE,
) -> i32;
#[cfg(feature = "Win32_Foundation")]
pub type PFN_EngCreateRectRgn = unsafe extern "system" fn(
    left: i32,
    top: i32,
    right: i32,
    bottom: i32,
) -> super::super::Foundation::HANDLE;
#[cfg(feature = "Win32_Foundation")]
pub type PFN_EngDeleteRgn = unsafe extern "system" fn(hrgn: super::super::Foundation::HANDLE);
#[cfg(feature = "Win32_Foundation")]
pub type PFN_EngIntersectRgn = unsafe extern "system" fn(
    hrgnresult: super::super::Foundation::HANDLE,
    hrgna: super::super::Foundation::HANDLE,
    hrgnb: super::super::Foundation::HANDLE,
) -> i32;
#[cfg(feature = "Win32_Foundation")]
pub type PFN_EngSubtractRgn = unsafe extern "system" fn(
    hrgnresult: super::super::Foundation::HANDLE,
    hrgna: super::super::Foundation::HANDLE,
    hrgnb: super::super::Foundation::HANDLE,
) -> i32;
#[cfg(feature = "Win32_Foundation")]
pub type PFN_EngUnionRgn = unsafe extern "system" fn(
    hrgnresult: super::super::Foundation::HANDLE,
    hrgna: super::super::Foundation::HANDLE,
    hrgnb: super::super::Foundation::HANDLE,
) -> i32;
#[cfg(feature = "Win32_Foundation")]
pub type PFN_EngXorRgn = unsafe extern "system" fn(
    hrgnresult: super::super::Foundation::HANDLE,
    hrgna: super::super::Foundation::HANDLE,
    hrgnb: super::super::Foundation::HANDLE,
) -> i32;
pub const PF_ALPHA_BYTE_INSTRUCTIONS: u32 = 5u32;
pub const PF_ARM_NEON_INSTRUCTIONS_AVAILABLE: u32 = 19u32;
pub const PF_ARM_V82_DP_INSTRUCTIONS_AVAILABLE: u32 = 43u32;
pub const PF_ARM_V83_JSCVT_INSTRUCTIONS_AVAILABLE: u32 = 44u32;
pub const PF_AVX2_INSTRUCTIONS_AVAILABLE: u32 = 40u32;
pub const PF_AVX512F_INSTRUCTIONS_AVAILABLE: u32 = 41u32;
pub const PF_AVX_INSTRUCTIONS_AVAILABLE: u32 = 39u32;
pub const PF_ERMS_AVAILABLE: u32 = 42u32;
pub const PF_MONITORX_INSTRUCTION_AVAILABLE: u32 = 35u32;
pub const PF_NON_TEMPORAL_LEVEL_ALL: u32 = 0u32;
pub const PF_PPC_MOVEMEM_64BIT_OK: u32 = 4u32;
pub const PF_RDPID_INSTRUCTION_AVAILABLE: u32 = 33u32;
pub const PF_RDRAND_INSTRUCTION_AVAILABLE: u32 = 28u32;
pub const PF_RDTSCP_INSTRUCTION_AVAILABLE: u32 = 32u32;
pub const PF_SSE4_1_INSTRUCTIONS_AVAILABLE: u32 = 37u32;
pub const PF_SSE4_2_INSTRUCTIONS_AVAILABLE: u32 = 38u32;
pub const PF_SSE_DAZ_MODE_AVAILABLE: u32 = 11u32;
pub const PF_SSSE3_INSTRUCTIONS_AVAILABLE: u32 = 36u32;
pub const PF_TEMPORAL_LEVEL_1: u32 = 1u32;
pub const PF_TEMPORAL_LEVEL_2: u32 = 2u32;
pub const PF_TEMPORAL_LEVEL_3: u32 = 3u32;
pub type PGET_RUNTIME_FUNCTION_CALLBACK =
    unsafe extern "system" fn(
        controlpc: u64,
        context: *const ::std::ffi::c_void,
    ) -> *mut IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PHYSICAL_ELEMENT_STATUS {
    pub Version: u32,
    pub Size: u32,
    pub DescriptorCount: u32,
    pub ReturnedDescriptorCount: u32,
    pub ElementIdentifierBeingDepoped: u32,
    pub Reserved: u32,
    pub Descriptors: [PHYSICAL_ELEMENT_STATUS_DESCRIPTOR; 1],
}
impl PHYSICAL_ELEMENT_STATUS {}
impl ::std::default::Default for PHYSICAL_ELEMENT_STATUS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PHYSICAL_ELEMENT_STATUS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PHYSICAL_ELEMENT_STATUS")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("DescriptorCount", &self.DescriptorCount)
            .field("ReturnedDescriptorCount", &self.ReturnedDescriptorCount)
            .field(
                "ElementIdentifierBeingDepoped",
                &self.ElementIdentifierBeingDepoped,
            )
            .field("Reserved", &self.Reserved)
            .field("Descriptors", &self.Descriptors)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PHYSICAL_ELEMENT_STATUS {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.DescriptorCount == other.DescriptorCount
            && self.ReturnedDescriptorCount == other.ReturnedDescriptorCount
            && self.ElementIdentifierBeingDepoped == other.ElementIdentifierBeingDepoped
            && self.Reserved == other.Reserved
            && self.Descriptors == other.Descriptors
    }
}
impl ::std::cmp::Eq for PHYSICAL_ELEMENT_STATUS {}
unsafe impl ::windows::runtime::Abi for PHYSICAL_ELEMENT_STATUS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PHYSICAL_ELEMENT_STATUS_DESCRIPTOR {
    pub Version: u32,
    pub Size: u32,
    pub ElementIdentifier: u32,
    pub PhysicalElementType: u8,
    pub PhysicalElementHealth: u8,
    pub Reserved1: [u8; 2],
    pub AssociatedCapacity: u64,
    pub Reserved2: [u32; 4],
}
impl PHYSICAL_ELEMENT_STATUS_DESCRIPTOR {}
impl ::std::default::Default for PHYSICAL_ELEMENT_STATUS_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PHYSICAL_ELEMENT_STATUS_DESCRIPTOR {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PHYSICAL_ELEMENT_STATUS_DESCRIPTOR")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("ElementIdentifier", &self.ElementIdentifier)
            .field("PhysicalElementType", &self.PhysicalElementType)
            .field("PhysicalElementHealth", &self.PhysicalElementHealth)
            .field("Reserved1", &self.Reserved1)
            .field("AssociatedCapacity", &self.AssociatedCapacity)
            .field("Reserved2", &self.Reserved2)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PHYSICAL_ELEMENT_STATUS_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.ElementIdentifier == other.ElementIdentifier
            && self.PhysicalElementType == other.PhysicalElementType
            && self.PhysicalElementHealth == other.PhysicalElementHealth
            && self.Reserved1 == other.Reserved1
            && self.AssociatedCapacity == other.AssociatedCapacity
            && self.Reserved2 == other.Reserved2
    }
}
impl ::std::cmp::Eq for PHYSICAL_ELEMENT_STATUS_DESCRIPTOR {}
unsafe impl ::windows::runtime::Abi for PHYSICAL_ELEMENT_STATUS_DESCRIPTOR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PHYSICAL_ELEMENT_STATUS_REQUEST {
    pub Version: u32,
    pub Size: u32,
    pub StartingElement: u32,
    pub Filter: u8,
    pub ReportType: u8,
    pub Reserved: [u8; 2],
}
impl PHYSICAL_ELEMENT_STATUS_REQUEST {}
impl ::std::default::Default for PHYSICAL_ELEMENT_STATUS_REQUEST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PHYSICAL_ELEMENT_STATUS_REQUEST {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PHYSICAL_ELEMENT_STATUS_REQUEST")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("StartingElement", &self.StartingElement)
            .field("Filter", &self.Filter)
            .field("ReportType", &self.ReportType)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PHYSICAL_ELEMENT_STATUS_REQUEST {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.StartingElement == other.StartingElement
            && self.Filter == other.Filter
            && self.ReportType == other.ReportType
            && self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for PHYSICAL_ELEMENT_STATUS_REQUEST {}
unsafe impl ::windows::runtime::Abi for PHYSICAL_ELEMENT_STATUS_REQUEST {
    type Abi = Self;
    type DefaultType = Self;
}
pub type PIMAGE_TLS_CALLBACK = unsafe extern "system" fn(
    dllhandle: *mut ::std::ffi::c_void,
    reason: u32,
    reserved: *mut ::std::ffi::c_void,
);
pub type PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK = unsafe extern "system" fn(
    sourcecontext: *const ::std::mem::ManuallyDrop<IO_IRP_EXT_TRACK_OFFSET_HEADER>,
    targetcontext: *mut ::std::mem::ManuallyDrop<IO_IRP_EXT_TRACK_OFFSET_HEADER>,
    relativeoffset: i64,
);
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct POINTE {
    pub x: f32,
    pub y: f32,
}
impl POINTE {}
impl ::std::default::Default for POINTE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for POINTE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("POINTE")
            .field("x", &self.x)
            .field("y", &self.y)
            .finish()
    }
}
impl ::std::cmp::PartialEq for POINTE {
    fn eq(&self, other: &Self) -> bool {
        self.x == other.x && self.y == other.y
    }
}
impl ::std::cmp::Eq for POINTE {}
unsafe impl ::windows::runtime::Abi for POINTE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct POINTFIX {
    pub x: i32,
    pub y: i32,
}
impl POINTFIX {}
impl ::std::default::Default for POINTFIX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for POINTFIX {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("POINTFIX")
            .field("x", &self.x)
            .field("y", &self.y)
            .finish()
    }
}
impl ::std::cmp::PartialEq for POINTFIX {
    fn eq(&self, other: &Self) -> bool {
        self.x == other.x && self.y == other.y
    }
}
impl ::std::cmp::Eq for POINTFIX {}
unsafe impl ::windows::runtime::Abi for POINTFIX {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct POINTQF {
    pub x: i64,
    pub y: i64,
}
impl POINTQF {}
impl ::std::default::Default for POINTQF {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for POINTQF {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("POINTQF")
            .field("x", &self.x)
            .field("y", &self.y)
            .finish()
    }
}
impl ::std::cmp::PartialEq for POINTQF {
    fn eq(&self, other: &Self) -> bool {
        self.x == other.x && self.y == other.y
    }
}
impl ::std::cmp::Eq for POINTQF {}
unsafe impl ::windows::runtime::Abi for POINTQF {
    type Abi = Self;
    type DefaultType = Self;
}
pub const POLICY_AUDIT_SUBCATEGORY_COUNT: u32 = 59u32;
#[cfg(feature = "Win32_Foundation")]
pub type POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK = unsafe extern "system" fn(
    process: super::super::Foundation::HANDLE,
    tableaddress: *const ::std::ffi::c_void,
    entries: *mut u32,
    functions: *mut *mut IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
) -> u32;
pub const POWERBUTTON_ACTION_INDEX_HIBERNATE: u32 = 2u32;
pub const POWERBUTTON_ACTION_INDEX_NOTHING: u32 = 0u32;
pub const POWERBUTTON_ACTION_INDEX_SHUTDOWN: u32 = 3u32;
pub const POWERBUTTON_ACTION_INDEX_SLEEP: u32 = 1u32;
pub const POWERBUTTON_ACTION_INDEX_TURN_OFF_THE_DISPLAY: u32 = 4u32;
pub const POWERBUTTON_ACTION_VALUE_HIBERNATE: u32 = 3u32;
pub const POWERBUTTON_ACTION_VALUE_NOTHING: u32 = 0u32;
pub const POWERBUTTON_ACTION_VALUE_SHUTDOWN: u32 = 6u32;
pub const POWERBUTTON_ACTION_VALUE_SLEEP: u32 = 2u32;
pub const POWERBUTTON_ACTION_VALUE_TURN_OFF_THE_DISPLAY: u32 = 8u32;
pub const POWER_ACTION_ACPI_CRITICAL: u32 = 16777216u32;
pub const POWER_ACTION_ACPI_USER_NOTIFY: u32 = 33554432u32;
pub const POWER_ACTION_CRITICAL: u32 = 2147483648u32;
pub const POWER_ACTION_DIRECTED_DRIPS: u32 = 67108864u32;
pub const POWER_ACTION_DISABLE_WAKES: u32 = 1073741824u32;
pub const POWER_ACTION_DOZE_TO_HIBERNATE: u32 = 32u32;
pub const POWER_ACTION_HIBERBOOT: u32 = 8u32;
pub const POWER_ACTION_LIGHTEST_FIRST: u32 = 268435456u32;
pub const POWER_ACTION_LOCK_CONSOLE: u32 = 536870912u32;
pub const POWER_ACTION_OVERRIDE_APPS: u32 = 4u32;
pub const POWER_ACTION_PSEUDO_TRANSITION: u32 = 134217728u32;
pub const POWER_ACTION_QUERY_ALLOWED: u32 = 1u32;
pub const POWER_ACTION_UI_ALLOWED: u32 = 2u32;
pub const POWER_ACTION_USER_NOTIFY: u32 = 16u32;
pub const POWER_CONNECTIVITY_IN_STANDBY_DISABLED: u32 = 0u32;
pub const POWER_CONNECTIVITY_IN_STANDBY_ENABLED: u32 = 1u32;
pub const POWER_CONNECTIVITY_IN_STANDBY_SYSTEM_MANAGED: u32 = 2u32;
pub const POWER_DEVICE_IDLE_POLICY_CONSERVATIVE: u32 = 1u32;
pub const POWER_DEVICE_IDLE_POLICY_PERFORMANCE: u32 = 0u32;
pub const POWER_DISCONNECTED_STANDBY_MODE_AGGRESSIVE: u32 = 1u32;
pub const POWER_DISCONNECTED_STANDBY_MODE_NORMAL: u32 = 0u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct POWER_IDLE_RESILIENCY {
    pub CoalescingTimeout: u32,
    pub IdleResiliencyPeriod: u32,
}
impl POWER_IDLE_RESILIENCY {}
impl ::std::default::Default for POWER_IDLE_RESILIENCY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for POWER_IDLE_RESILIENCY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("POWER_IDLE_RESILIENCY")
            .field("CoalescingTimeout", &self.CoalescingTimeout)
            .field("IdleResiliencyPeriod", &self.IdleResiliencyPeriod)
            .finish()
    }
}
impl ::std::cmp::PartialEq for POWER_IDLE_RESILIENCY {
    fn eq(&self, other: &Self) -> bool {
        self.CoalescingTimeout == other.CoalescingTimeout
            && self.IdleResiliencyPeriod == other.IdleResiliencyPeriod
    }
}
impl ::std::cmp::Eq for POWER_IDLE_RESILIENCY {}
unsafe impl ::windows::runtime::Abi for POWER_IDLE_RESILIENCY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct POWER_INFORMATION_LEVEL(pub i32);
pub const SystemPowerPolicyAc: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(0i32);
pub const SystemPowerPolicyDc: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(1i32);
pub const VerifySystemPolicyAc: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(2i32);
pub const VerifySystemPolicyDc: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(3i32);
pub const SystemPowerCapabilities: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(4i32);
pub const SystemBatteryState: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(5i32);
pub const SystemPowerStateHandler: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(6i32);
pub const ProcessorStateHandler: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(7i32);
pub const SystemPowerPolicyCurrent: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(8i32);
pub const AdministratorPowerPolicy: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(9i32);
pub const SystemReserveHiberFile: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(10i32);
pub const ProcessorInformation: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(11i32);
pub const SystemPowerInformation: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(12i32);
pub const ProcessorStateHandler2: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(13i32);
pub const LastWakeTime: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(14i32);
pub const LastSleepTime: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(15i32);
pub const SystemExecutionState: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(16i32);
pub const SystemPowerStateNotifyHandler: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(17i32);
pub const ProcessorPowerPolicyAc: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(18i32);
pub const ProcessorPowerPolicyDc: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(19i32);
pub const VerifyProcessorPowerPolicyAc: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(20i32);
pub const VerifyProcessorPowerPolicyDc: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(21i32);
pub const ProcessorPowerPolicyCurrent: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(22i32);
pub const SystemPowerStateLogging: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(23i32);
pub const SystemPowerLoggingEntry: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(24i32);
pub const SetPowerSettingValue: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(25i32);
pub const NotifyUserPowerSetting: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(26i32);
pub const PowerInformationLevelUnused0: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(27i32);
pub const SystemMonitorHiberBootPowerOff: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(28i32);
pub const SystemVideoState: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(29i32);
pub const TraceApplicationPowerMessage: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(30i32);
pub const TraceApplicationPowerMessageEnd: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(31i32);
pub const ProcessorPerfStates: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(32i32);
pub const ProcessorIdleStates: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(33i32);
pub const ProcessorCap: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(34i32);
pub const SystemWakeSource: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(35i32);
pub const SystemHiberFileInformation: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(36i32);
pub const TraceServicePowerMessage: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(37i32);
pub const ProcessorLoad: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(38i32);
pub const PowerShutdownNotification: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(39i32);
pub const MonitorCapabilities: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(40i32);
pub const SessionPowerInit: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(41i32);
pub const SessionDisplayState: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(42i32);
pub const PowerRequestCreate: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(43i32);
pub const PowerRequestAction: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(44i32);
pub const GetPowerRequestList: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(45i32);
pub const ProcessorInformationEx: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(46i32);
pub const NotifyUserModeLegacyPowerEvent: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(47i32);
pub const GroupPark: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(48i32);
pub const ProcessorIdleDomains: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(49i32);
pub const WakeTimerList: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(50i32);
pub const SystemHiberFileSize: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(51i32);
pub const ProcessorIdleStatesHv: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(52i32);
pub const ProcessorPerfStatesHv: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(53i32);
pub const ProcessorPerfCapHv: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(54i32);
pub const ProcessorSetIdle: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(55i32);
pub const LogicalProcessorIdling: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(56i32);
pub const UserPresence: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(57i32);
pub const PowerSettingNotificationName: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(58i32);
pub const GetPowerSettingValue: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(59i32);
pub const IdleResiliency: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(60i32);
pub const SessionRITState: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(61i32);
pub const SessionConnectNotification: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(62i32);
pub const SessionPowerCleanup: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(63i32);
pub const SessionLockState: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(64i32);
pub const SystemHiberbootState: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(65i32);
pub const PlatformInformation: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(66i32);
pub const PdcInvocation: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(67i32);
pub const MonitorInvocation: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(68i32);
pub const FirmwareTableInformationRegistered: POWER_INFORMATION_LEVEL =
    POWER_INFORMATION_LEVEL(69i32);
pub const SetShutdownSelectedTime: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(70i32);
pub const SuspendResumeInvocation: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(71i32);
pub const PlmPowerRequestCreate: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(72i32);
pub const ScreenOff: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(73i32);
pub const CsDeviceNotification: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(74i32);
pub const PlatformRole: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(75i32);
pub const LastResumePerformance: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(76i32);
pub const DisplayBurst: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(77i32);
pub const ExitLatencySamplingPercentage: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(78i32);
pub const RegisterSpmPowerSettings: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(79i32);
pub const PlatformIdleStates: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(80i32);
pub const ProcessorIdleVeto: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(81i32);
pub const PlatformIdleVeto: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(82i32);
pub const SystemBatteryStatePrecise: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(83i32);
pub const ThermalEvent: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(84i32);
pub const PowerRequestActionInternal: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(85i32);
pub const BatteryDeviceState: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(86i32);
pub const PowerInformationInternal: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(87i32);
pub const ThermalStandby: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(88i32);
pub const SystemHiberFileType: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(89i32);
pub const PhysicalPowerButtonPress: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(90i32);
pub const QueryPotentialDripsConstraint: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(91i32);
pub const EnergyTrackerCreate: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(92i32);
pub const EnergyTrackerQuery: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(93i32);
pub const UpdateBlackBoxRecorder: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(94i32);
pub const SessionAllowExternalDmaDevices: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(95i32);
pub const SendSuspendResumeNotification: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(96i32);
pub const PowerInformationLevelMaximum: POWER_INFORMATION_LEVEL = POWER_INFORMATION_LEVEL(97i32);
impl ::std::convert::From<i32> for POWER_INFORMATION_LEVEL {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for POWER_INFORMATION_LEVEL {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct POWER_MONITOR_INVOCATION {
    pub Console: super::super::Foundation::BOOLEAN,
    pub RequestReason: POWER_MONITOR_REQUEST_REASON,
}
#[cfg(feature = "Win32_Foundation")]
impl POWER_MONITOR_INVOCATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for POWER_MONITOR_INVOCATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for POWER_MONITOR_INVOCATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("POWER_MONITOR_INVOCATION")
            .field("Console", &self.Console)
            .field("RequestReason", &self.RequestReason)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for POWER_MONITOR_INVOCATION {
    fn eq(&self, other: &Self) -> bool {
        self.Console == other.Console && self.RequestReason == other.RequestReason
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for POWER_MONITOR_INVOCATION {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for POWER_MONITOR_INVOCATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct POWER_MONITOR_REQUEST_REASON(pub i32);
pub const MonitorRequestReasonUnknown: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(0i32);
pub const MonitorRequestReasonPowerButton: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(1i32);
pub const MonitorRequestReasonRemoteConnection: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(2i32);
pub const MonitorRequestReasonScMonitorpower: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(3i32);
pub const MonitorRequestReasonUserInput: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(4i32);
pub const MonitorRequestReasonAcDcDisplayBurst: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(5i32);
pub const MonitorRequestReasonUserDisplayBurst: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(6i32);
pub const MonitorRequestReasonPoSetSystemState: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(7i32);
pub const MonitorRequestReasonSetThreadExecutionState: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(8i32);
pub const MonitorRequestReasonFullWake: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(9i32);
pub const MonitorRequestReasonSessionUnlock: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(10i32);
pub const MonitorRequestReasonScreenOffRequest: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(11i32);
pub const MonitorRequestReasonIdleTimeout: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(12i32);
pub const MonitorRequestReasonPolicyChange: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(13i32);
pub const MonitorRequestReasonSleepButton: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(14i32);
pub const MonitorRequestReasonLid: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(15i32);
pub const MonitorRequestReasonBatteryCountChange: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(16i32);
pub const MonitorRequestReasonGracePeriod: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(17i32);
pub const MonitorRequestReasonPnP: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(18i32);
pub const MonitorRequestReasonDP: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(19i32);
pub const MonitorRequestReasonSxTransition: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(20i32);
pub const MonitorRequestReasonSystemIdle: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(21i32);
pub const MonitorRequestReasonNearProximity: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(22i32);
pub const MonitorRequestReasonThermalStandby: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(23i32);
pub const MonitorRequestReasonResumePdc: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(24i32);
pub const MonitorRequestReasonResumeS4: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(25i32);
pub const MonitorRequestReasonTerminal: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(26i32);
pub const MonitorRequestReasonPdcSignal: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(27i32);
pub const MonitorRequestReasonAcDcDisplayBurstSuppressed: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(28i32);
pub const MonitorRequestReasonSystemStateEntered: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(29i32);
pub const MonitorRequestReasonWinrt: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(30i32);
pub const MonitorRequestReasonUserInputKeyboard: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(31i32);
pub const MonitorRequestReasonUserInputMouse: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(32i32);
pub const MonitorRequestReasonUserInputTouchpad: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(33i32);
pub const MonitorRequestReasonUserInputPen: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(34i32);
pub const MonitorRequestReasonUserInputAccelerometer: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(35i32);
pub const MonitorRequestReasonUserInputHid: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(36i32);
pub const MonitorRequestReasonUserInputPoUserPresent: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(37i32);
pub const MonitorRequestReasonUserInputSessionSwitch: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(38i32);
pub const MonitorRequestReasonUserInputInitialization: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(39i32);
pub const MonitorRequestReasonPdcSignalWindowsMobilePwrNotif: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(40i32);
pub const MonitorRequestReasonPdcSignalWindowsMobileShell: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(41i32);
pub const MonitorRequestReasonPdcSignalHeyCortana: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(42i32);
pub const MonitorRequestReasonPdcSignalHolographicShell: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(43i32);
pub const MonitorRequestReasonPdcSignalFingerprint: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(44i32);
pub const MonitorRequestReasonDirectedDrips: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(45i32);
pub const MonitorRequestReasonDim: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(46i32);
pub const MonitorRequestReasonBuiltinPanel: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(47i32);
pub const MonitorRequestReasonDisplayRequiredUnDim: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(48i32);
pub const MonitorRequestReasonBatteryCountChangeSuppressed: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(49i32);
pub const MonitorRequestReasonResumeModernStandby: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(50i32);
pub const MonitorRequestReasonTerminalInit: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(51i32);
pub const MonitorRequestReasonPdcSignalSensorsHumanPresence: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(52i32);
pub const MonitorRequestReasonBatteryPreCritical: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(53i32);
pub const MonitorRequestReasonUserInputTouch: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(54i32);
pub const MonitorRequestReasonMax: POWER_MONITOR_REQUEST_REASON =
    POWER_MONITOR_REQUEST_REASON(55i32);
impl ::std::convert::From<i32> for POWER_MONITOR_REQUEST_REASON {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for POWER_MONITOR_REQUEST_REASON {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct POWER_MONITOR_REQUEST_TYPE(pub i32);
pub const MonitorRequestTypeOff: POWER_MONITOR_REQUEST_TYPE = POWER_MONITOR_REQUEST_TYPE(0i32);
pub const MonitorRequestTypeOnAndPresent: POWER_MONITOR_REQUEST_TYPE =
    POWER_MONITOR_REQUEST_TYPE(1i32);
pub const MonitorRequestTypeToggleOn: POWER_MONITOR_REQUEST_TYPE = POWER_MONITOR_REQUEST_TYPE(2i32);
impl ::std::convert::From<i32> for POWER_MONITOR_REQUEST_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for POWER_MONITOR_REQUEST_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct POWER_PLATFORM_INFORMATION {
    pub AoAc: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl POWER_PLATFORM_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for POWER_PLATFORM_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for POWER_PLATFORM_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("POWER_PLATFORM_INFORMATION")
            .field("AoAc", &self.AoAc)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for POWER_PLATFORM_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.AoAc == other.AoAc
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for POWER_PLATFORM_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for POWER_PLATFORM_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct POWER_REQUEST_CONTEXT_FLAGS(pub u32);
pub const POWER_REQUEST_CONTEXT_DETAILED_STRING: POWER_REQUEST_CONTEXT_FLAGS =
    POWER_REQUEST_CONTEXT_FLAGS(2u32);
pub const POWER_REQUEST_CONTEXT_SIMPLE_STRING: POWER_REQUEST_CONTEXT_FLAGS =
    POWER_REQUEST_CONTEXT_FLAGS(1u32);
impl ::std::convert::From<u32> for POWER_REQUEST_CONTEXT_FLAGS {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for POWER_REQUEST_CONTEXT_FLAGS {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for POWER_REQUEST_CONTEXT_FLAGS {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for POWER_REQUEST_CONTEXT_FLAGS {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for POWER_REQUEST_CONTEXT_FLAGS {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for POWER_REQUEST_CONTEXT_FLAGS {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for POWER_REQUEST_CONTEXT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const POWER_REQUEST_CONTEXT_VERSION: u32 = 0u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct POWER_REQUEST_TYPE(pub i32);
pub const PowerRequestDisplayRequired: POWER_REQUEST_TYPE = POWER_REQUEST_TYPE(0i32);
pub const PowerRequestSystemRequired: POWER_REQUEST_TYPE = POWER_REQUEST_TYPE(1i32);
pub const PowerRequestAwayModeRequired: POWER_REQUEST_TYPE = POWER_REQUEST_TYPE(2i32);
pub const PowerRequestExecutionRequired: POWER_REQUEST_TYPE = POWER_REQUEST_TYPE(3i32);
impl ::std::convert::From<i32> for POWER_REQUEST_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for POWER_REQUEST_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES {
    pub IsAllowed: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES")
            .field("IsAllowed", &self.IsAllowed)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES {
    fn eq(&self, other: &Self) -> bool {
        self.IsAllowed == other.IsAllowed
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct POWER_SESSION_CONNECT {
    pub Connected: super::super::Foundation::BOOLEAN,
    pub Console: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl POWER_SESSION_CONNECT {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for POWER_SESSION_CONNECT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for POWER_SESSION_CONNECT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("POWER_SESSION_CONNECT")
            .field("Connected", &self.Connected)
            .field("Console", &self.Console)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for POWER_SESSION_CONNECT {
    fn eq(&self, other: &Self) -> bool {
        self.Connected == other.Connected && self.Console == other.Console
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for POWER_SESSION_CONNECT {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for POWER_SESSION_CONNECT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct POWER_SESSION_RIT_STATE {
    pub Active: super::super::Foundation::BOOLEAN,
    pub LastInputTime: u64,
}
#[cfg(feature = "Win32_Foundation")]
impl POWER_SESSION_RIT_STATE {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for POWER_SESSION_RIT_STATE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for POWER_SESSION_RIT_STATE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("POWER_SESSION_RIT_STATE")
            .field("Active", &self.Active)
            .field("LastInputTime", &self.LastInputTime)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for POWER_SESSION_RIT_STATE {
    fn eq(&self, other: &Self) -> bool {
        self.Active == other.Active && self.LastInputTime == other.LastInputTime
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for POWER_SESSION_RIT_STATE {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for POWER_SESSION_RIT_STATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct POWER_SESSION_TIMEOUTS {
    pub InputTimeout: u32,
    pub DisplayTimeout: u32,
}
impl POWER_SESSION_TIMEOUTS {}
impl ::std::default::Default for POWER_SESSION_TIMEOUTS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for POWER_SESSION_TIMEOUTS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("POWER_SESSION_TIMEOUTS")
            .field("InputTimeout", &self.InputTimeout)
            .field("DisplayTimeout", &self.DisplayTimeout)
            .finish()
    }
}
impl ::std::cmp::PartialEq for POWER_SESSION_TIMEOUTS {
    fn eq(&self, other: &Self) -> bool {
        self.InputTimeout == other.InputTimeout && self.DisplayTimeout == other.DisplayTimeout
    }
}
impl ::std::cmp::Eq for POWER_SESSION_TIMEOUTS {}
unsafe impl ::windows::runtime::Abi for POWER_SESSION_TIMEOUTS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct POWER_SESSION_WINLOGON {
    pub SessionId: u32,
    pub Console: super::super::Foundation::BOOLEAN,
    pub Locked: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl POWER_SESSION_WINLOGON {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for POWER_SESSION_WINLOGON {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for POWER_SESSION_WINLOGON {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("POWER_SESSION_WINLOGON")
            .field("SessionId", &self.SessionId)
            .field("Console", &self.Console)
            .field("Locked", &self.Locked)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for POWER_SESSION_WINLOGON {
    fn eq(&self, other: &Self) -> bool {
        self.SessionId == other.SessionId
            && self.Console == other.Console
            && self.Locked == other.Locked
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for POWER_SESSION_WINLOGON {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for POWER_SESSION_WINLOGON {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct POWER_SETTING_ALTITUDE(pub i32);
pub const ALTITUDE_GROUP_POLICY: POWER_SETTING_ALTITUDE = POWER_SETTING_ALTITUDE(0i32);
pub const ALTITUDE_USER: POWER_SETTING_ALTITUDE = POWER_SETTING_ALTITUDE(1i32);
pub const ALTITUDE_RUNTIME_OVERRIDE: POWER_SETTING_ALTITUDE = POWER_SETTING_ALTITUDE(2i32);
pub const ALTITUDE_PROVISIONING: POWER_SETTING_ALTITUDE = POWER_SETTING_ALTITUDE(3i32);
pub const ALTITUDE_OEM_CUSTOMIZATION: POWER_SETTING_ALTITUDE = POWER_SETTING_ALTITUDE(4i32);
pub const ALTITUDE_INTERNAL_OVERRIDE: POWER_SETTING_ALTITUDE = POWER_SETTING_ALTITUDE(5i32);
pub const ALTITUDE_OS_DEFAULT: POWER_SETTING_ALTITUDE = POWER_SETTING_ALTITUDE(6i32);
impl ::std::convert::From<i32> for POWER_SETTING_ALTITUDE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for POWER_SETTING_ALTITUDE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const POWER_SETTING_VALUE_VERSION: u32 = 1u32;
pub const POWER_SYSTEM_MAXIMUM: u32 = 7u32;
pub const POWER_USER_NOTIFY_FORCED_SHUTDOWN: u32 = 32u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct POWER_USER_PRESENCE {
    pub UserPresence: POWER_USER_PRESENCE_TYPE,
}
impl POWER_USER_PRESENCE {}
impl ::std::default::Default for POWER_USER_PRESENCE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for POWER_USER_PRESENCE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("POWER_USER_PRESENCE")
            .field("UserPresence", &self.UserPresence)
            .finish()
    }
}
impl ::std::cmp::PartialEq for POWER_USER_PRESENCE {
    fn eq(&self, other: &Self) -> bool {
        self.UserPresence == other.UserPresence
    }
}
impl ::std::cmp::Eq for POWER_USER_PRESENCE {}
unsafe impl ::windows::runtime::Abi for POWER_USER_PRESENCE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct POWER_USER_PRESENCE_TYPE(pub i32);
pub const UserNotPresent: POWER_USER_PRESENCE_TYPE = POWER_USER_PRESENCE_TYPE(0i32);
pub const UserPresent: POWER_USER_PRESENCE_TYPE = POWER_USER_PRESENCE_TYPE(1i32);
pub const UserUnknown: POWER_USER_PRESENCE_TYPE = POWER_USER_PRESENCE_TYPE(255i32);
impl ::std::convert::From<i32> for POWER_USER_PRESENCE_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for POWER_USER_PRESENCE_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const PO_ALL_INTEGERS: u32 = 4u32;
pub const PO_BEZIERS: u32 = 1u32;
pub const PO_ELLIPSE: u32 = 2u32;
pub const PO_ENUM_AS_INTEGERS: u32 = 8u32;
pub const PO_THROTTLE_ADAPTIVE: u32 = 3u32;
pub const PO_THROTTLE_CONSTANT: u32 = 1u32;
pub const PO_THROTTLE_DEGRADE: u32 = 2u32;
pub const PO_THROTTLE_MAXIMUM: u32 = 4u32;
pub const PO_THROTTLE_NONE: u32 = 0u32;
pub const PO_WIDENED: u32 = 16u32;
pub const PPC_BGR_ORDER_HORIZONTAL_STRIPES: u32 = 5u32;
pub const PPC_BGR_ORDER_VERTICAL_STRIPES: u32 = 3u32;
pub const PPC_DEFAULT: u32 = 0u32;
pub const PPC_RGB_ORDER_HORIZONTAL_STRIPES: u32 = 4u32;
pub const PPC_RGB_ORDER_VERTICAL_STRIPES: u32 = 2u32;
pub const PPC_UNDEFINED: u32 = 1u32;
pub const PPG_DEFAULT: u32 = 0u32;
pub const PPG_SRGB: u32 = 1u32;
pub const PPM_FIRMWARE_ACPI1C2: u32 = 1u32;
pub const PPM_FIRMWARE_ACPI1C3: u32 = 2u32;
pub const PPM_FIRMWARE_ACPI1TSTATES: u32 = 4u32;
pub const PPM_FIRMWARE_CPC: u32 = 262144u32;
pub const PPM_FIRMWARE_CSD: u32 = 16u32;
pub const PPM_FIRMWARE_CST: u32 = 8u32;
pub const PPM_FIRMWARE_LPI: u32 = 524288u32;
pub const PPM_FIRMWARE_OSC: u32 = 65536u32;
pub const PPM_FIRMWARE_PCCH: u32 = 16384u32;
pub const PPM_FIRMWARE_PCCP: u32 = 32768u32;
pub const PPM_FIRMWARE_PCT: u32 = 32u32;
pub const PPM_FIRMWARE_PDC: u32 = 131072u32;
pub const PPM_FIRMWARE_PPC: u32 = 256u32;
pub const PPM_FIRMWARE_PSD: u32 = 512u32;
pub const PPM_FIRMWARE_PSS: u32 = 64u32;
pub const PPM_FIRMWARE_PTC: u32 = 1024u32;
pub const PPM_FIRMWARE_TPC: u32 = 4096u32;
pub const PPM_FIRMWARE_TSD: u32 = 8192u32;
pub const PPM_FIRMWARE_TSS: u32 = 2048u32;
pub const PPM_FIRMWARE_XPSS: u32 = 128u32;
pub const PPM_IDLESTATES_DATA_GUID: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3121843728,
        57936,
        19159,
        [134, 22, 207, 26, 122, 212, 16, 231],
    );
pub const PPM_IDLESTATE_CHANGE_GUID: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1211694671,
        63260,
        20049,
        [158, 204, 132, 48, 167, 172, 76, 108],
    );
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PPM_IDLESTATE_EVENT {
    pub NewState: u32,
    pub OldState: u32,
    pub Processors: u64,
}
impl PPM_IDLESTATE_EVENT {}
impl ::std::default::Default for PPM_IDLESTATE_EVENT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PPM_IDLESTATE_EVENT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PPM_IDLESTATE_EVENT")
            .field("NewState", &self.NewState)
            .field("OldState", &self.OldState)
            .field("Processors", &self.Processors)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PPM_IDLESTATE_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.NewState == other.NewState
            && self.OldState == other.OldState
            && self.Processors == other.Processors
    }
}
impl ::std::cmp::Eq for PPM_IDLESTATE_EVENT {}
unsafe impl ::windows::runtime::Abi for PPM_IDLESTATE_EVENT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PPM_IDLE_ACCOUNTING {
    pub StateCount: u32,
    pub TotalTransitions: u32,
    pub ResetCount: u32,
    pub StartTime: u64,
    pub State: [PPM_IDLE_STATE_ACCOUNTING; 1],
}
impl PPM_IDLE_ACCOUNTING {}
impl ::std::default::Default for PPM_IDLE_ACCOUNTING {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PPM_IDLE_ACCOUNTING {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PPM_IDLE_ACCOUNTING")
            .field("StateCount", &self.StateCount)
            .field("TotalTransitions", &self.TotalTransitions)
            .field("ResetCount", &self.ResetCount)
            .field("StartTime", &self.StartTime)
            .field("State", &self.State)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PPM_IDLE_ACCOUNTING {
    fn eq(&self, other: &Self) -> bool {
        self.StateCount == other.StateCount
            && self.TotalTransitions == other.TotalTransitions
            && self.ResetCount == other.ResetCount
            && self.StartTime == other.StartTime
            && self.State == other.State
    }
}
impl ::std::cmp::Eq for PPM_IDLE_ACCOUNTING {}
unsafe impl ::windows::runtime::Abi for PPM_IDLE_ACCOUNTING {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PPM_IDLE_ACCOUNTING_EX {
    pub StateCount: u32,
    pub TotalTransitions: u32,
    pub ResetCount: u32,
    pub AbortCount: u32,
    pub StartTime: u64,
    pub State: [PPM_IDLE_STATE_ACCOUNTING_EX; 1],
}
impl PPM_IDLE_ACCOUNTING_EX {}
impl ::std::default::Default for PPM_IDLE_ACCOUNTING_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PPM_IDLE_ACCOUNTING_EX {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PPM_IDLE_ACCOUNTING_EX")
            .field("StateCount", &self.StateCount)
            .field("TotalTransitions", &self.TotalTransitions)
            .field("ResetCount", &self.ResetCount)
            .field("AbortCount", &self.AbortCount)
            .field("StartTime", &self.StartTime)
            .field("State", &self.State)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PPM_IDLE_ACCOUNTING_EX {
    fn eq(&self, other: &Self) -> bool {
        self.StateCount == other.StateCount
            && self.TotalTransitions == other.TotalTransitions
            && self.ResetCount == other.ResetCount
            && self.AbortCount == other.AbortCount
            && self.StartTime == other.StartTime
            && self.State == other.State
    }
}
impl ::std::cmp::Eq for PPM_IDLE_ACCOUNTING_EX {}
unsafe impl ::windows::runtime::Abi for PPM_IDLE_ACCOUNTING_EX {
    type Abi = Self;
    type DefaultType = Self;
}
pub const PPM_IDLE_ACCOUNTING_EX_GUID: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3598368057,
        33272,
        19038,
        [129, 82, 114, 227, 30, 201, 18, 238],
    );
pub const PPM_IDLE_ACCOUNTING_GUID: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        3802296184,
        44551,
        20192,
        [163, 15, 206, 84, 245, 90, 148, 205],
    );
pub const PPM_IDLE_IMPLEMENTATION_CSTATES: u32 = 1u32;
pub const PPM_IDLE_IMPLEMENTATION_LPISTATES: u32 = 4u32;
pub const PPM_IDLE_IMPLEMENTATION_MICROPEP: u32 = 3u32;
pub const PPM_IDLE_IMPLEMENTATION_NONE: u32 = 0u32;
pub const PPM_IDLE_IMPLEMENTATION_PEP: u32 = 2u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PPM_IDLE_STATE_ACCOUNTING {
    pub IdleTransitions: u32,
    pub FailedTransitions: u32,
    pub InvalidBucketIndex: u32,
    pub TotalTime: u64,
    pub IdleTimeBuckets: [u32; 6],
}
impl PPM_IDLE_STATE_ACCOUNTING {}
impl ::std::default::Default for PPM_IDLE_STATE_ACCOUNTING {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PPM_IDLE_STATE_ACCOUNTING {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PPM_IDLE_STATE_ACCOUNTING")
            .field("IdleTransitions", &self.IdleTransitions)
            .field("FailedTransitions", &self.FailedTransitions)
            .field("InvalidBucketIndex", &self.InvalidBucketIndex)
            .field("TotalTime", &self.TotalTime)
            .field("IdleTimeBuckets", &self.IdleTimeBuckets)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PPM_IDLE_STATE_ACCOUNTING {
    fn eq(&self, other: &Self) -> bool {
        self.IdleTransitions == other.IdleTransitions
            && self.FailedTransitions == other.FailedTransitions
            && self.InvalidBucketIndex == other.InvalidBucketIndex
            && self.TotalTime == other.TotalTime
            && self.IdleTimeBuckets == other.IdleTimeBuckets
    }
}
impl ::std::cmp::Eq for PPM_IDLE_STATE_ACCOUNTING {}
unsafe impl ::windows::runtime::Abi for PPM_IDLE_STATE_ACCOUNTING {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PPM_IDLE_STATE_ACCOUNTING_EX {
    pub TotalTime: u64,
    pub IdleTransitions: u32,
    pub FailedTransitions: u32,
    pub InvalidBucketIndex: u32,
    pub MinTimeUs: u32,
    pub MaxTimeUs: u32,
    pub CancelledTransitions: u32,
    pub IdleTimeBuckets: [PPM_IDLE_STATE_BUCKET_EX; 16],
}
impl PPM_IDLE_STATE_ACCOUNTING_EX {}
impl ::std::default::Default for PPM_IDLE_STATE_ACCOUNTING_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PPM_IDLE_STATE_ACCOUNTING_EX {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PPM_IDLE_STATE_ACCOUNTING_EX")
            .field("TotalTime", &self.TotalTime)
            .field("IdleTransitions", &self.IdleTransitions)
            .field("FailedTransitions", &self.FailedTransitions)
            .field("InvalidBucketIndex", &self.InvalidBucketIndex)
            .field("MinTimeUs", &self.MinTimeUs)
            .field("MaxTimeUs", &self.MaxTimeUs)
            .field("CancelledTransitions", &self.CancelledTransitions)
            .field("IdleTimeBuckets", &self.IdleTimeBuckets)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PPM_IDLE_STATE_ACCOUNTING_EX {
    fn eq(&self, other: &Self) -> bool {
        self.TotalTime == other.TotalTime
            && self.IdleTransitions == other.IdleTransitions
            && self.FailedTransitions == other.FailedTransitions
            && self.InvalidBucketIndex == other.InvalidBucketIndex
            && self.MinTimeUs == other.MinTimeUs
            && self.MaxTimeUs == other.MaxTimeUs
            && self.CancelledTransitions == other.CancelledTransitions
            && self.IdleTimeBuckets == other.IdleTimeBuckets
    }
}
impl ::std::cmp::Eq for PPM_IDLE_STATE_ACCOUNTING_EX {}
unsafe impl ::windows::runtime::Abi for PPM_IDLE_STATE_ACCOUNTING_EX {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PPM_IDLE_STATE_BUCKET_EX {
    pub TotalTimeUs: u64,
    pub MinTimeUs: u32,
    pub MaxTimeUs: u32,
    pub Count: u32,
}
impl PPM_IDLE_STATE_BUCKET_EX {}
impl ::std::default::Default for PPM_IDLE_STATE_BUCKET_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PPM_IDLE_STATE_BUCKET_EX {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PPM_IDLE_STATE_BUCKET_EX")
            .field("TotalTimeUs", &self.TotalTimeUs)
            .field("MinTimeUs", &self.MinTimeUs)
            .field("MaxTimeUs", &self.MaxTimeUs)
            .field("Count", &self.Count)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PPM_IDLE_STATE_BUCKET_EX {
    fn eq(&self, other: &Self) -> bool {
        self.TotalTimeUs == other.TotalTimeUs
            && self.MinTimeUs == other.MinTimeUs
            && self.MaxTimeUs == other.MaxTimeUs
            && self.Count == other.Count
    }
}
impl ::std::cmp::Eq for PPM_IDLE_STATE_BUCKET_EX {}
unsafe impl ::windows::runtime::Abi for PPM_IDLE_STATE_BUCKET_EX {
    type Abi = Self;
    type DefaultType = Self;
}
pub const PPM_PERFMON_PERFSTATE_GUID: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2144437842,
        3326,
        16594,
        [176, 161, 11, 6, 106, 135, 117, 158],
    );
pub const PPM_PERFORMANCE_IMPLEMENTATION_CPPC: u32 = 3u32;
pub const PPM_PERFORMANCE_IMPLEMENTATION_NONE: u32 = 0u32;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PCCV1: u32 = 2u32;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PEP: u32 = 4u32;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PSTATES: u32 = 1u32;
pub const PPM_PERFSTATES_DATA_GUID: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1460194336,
        32064,
        19444,
        [180, 170, 43, 1, 51, 141, 1, 38],
    );
pub const PPM_PERFSTATE_CHANGE_GUID: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2779983325,
        32569,
        19132,
        [184, 146, 144, 14, 67, 181, 158, 187],
    );
pub const PPM_PERFSTATE_DOMAIN_CHANGE_GUID: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2573101951,
        54867,
        18810,
        [185, 120, 54, 163, 12, 41, 191, 1],
    );
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PPM_PERFSTATE_DOMAIN_EVENT {
    pub State: u32,
    pub Latency: u32,
    pub Speed: u32,
    pub Processors: u64,
}
impl PPM_PERFSTATE_DOMAIN_EVENT {}
impl ::std::default::Default for PPM_PERFSTATE_DOMAIN_EVENT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PPM_PERFSTATE_DOMAIN_EVENT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PPM_PERFSTATE_DOMAIN_EVENT")
            .field("State", &self.State)
            .field("Latency", &self.Latency)
            .field("Speed", &self.Speed)
            .field("Processors", &self.Processors)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PPM_PERFSTATE_DOMAIN_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.State == other.State
            && self.Latency == other.Latency
            && self.Speed == other.Speed
            && self.Processors == other.Processors
    }
}
impl ::std::cmp::Eq for PPM_PERFSTATE_DOMAIN_EVENT {}
unsafe impl ::windows::runtime::Abi for PPM_PERFSTATE_DOMAIN_EVENT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PPM_PERFSTATE_EVENT {
    pub State: u32,
    pub Status: u32,
    pub Latency: u32,
    pub Speed: u32,
    pub Processor: u32,
}
impl PPM_PERFSTATE_EVENT {}
impl ::std::default::Default for PPM_PERFSTATE_EVENT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PPM_PERFSTATE_EVENT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PPM_PERFSTATE_EVENT")
            .field("State", &self.State)
            .field("Status", &self.Status)
            .field("Latency", &self.Latency)
            .field("Speed", &self.Speed)
            .field("Processor", &self.Processor)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PPM_PERFSTATE_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.State == other.State
            && self.Status == other.Status
            && self.Latency == other.Latency
            && self.Speed == other.Speed
            && self.Processor == other.Processor
    }
}
impl ::std::cmp::Eq for PPM_PERFSTATE_EVENT {}
unsafe impl ::windows::runtime::Abi for PPM_PERFSTATE_EVENT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PPM_THERMALCHANGE_EVENT {
    pub ThermalConstraint: u32,
    pub Processors: u64,
}
impl PPM_THERMALCHANGE_EVENT {}
impl ::std::default::Default for PPM_THERMALCHANGE_EVENT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PPM_THERMALCHANGE_EVENT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PPM_THERMALCHANGE_EVENT")
            .field("ThermalConstraint", &self.ThermalConstraint)
            .field("Processors", &self.Processors)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PPM_THERMALCHANGE_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.ThermalConstraint == other.ThermalConstraint && self.Processors == other.Processors
    }
}
impl ::std::cmp::Eq for PPM_THERMALCHANGE_EVENT {}
unsafe impl ::windows::runtime::Abi for PPM_THERMALCHANGE_EVENT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const PPM_THERMALCONSTRAINT_GUID: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        2823996104,
        6732,
        16955,
        [140, 44, 243, 13, 130, 147, 26, 136],
    );
pub const PPM_THERMAL_POLICY_CHANGE_GUID: ::windows::runtime::GUID =
    ::windows::runtime::GUID::from_values(
        1223915448,
        26752,
        19579,
        [139, 220, 56, 1, 118, 198, 101, 77],
    );
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PPM_THERMAL_POLICY_EVENT {
    pub Mode: u8,
    pub Processors: u64,
}
impl PPM_THERMAL_POLICY_EVENT {}
impl ::std::default::Default for PPM_THERMAL_POLICY_EVENT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PPM_THERMAL_POLICY_EVENT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PPM_THERMAL_POLICY_EVENT")
            .field("Mode", &self.Mode)
            .field("Processors", &self.Processors)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PPM_THERMAL_POLICY_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.Mode == other.Mode && self.Processors == other.Processors
    }
}
impl ::std::cmp::Eq for PPM_THERMAL_POLICY_EVENT {}
unsafe impl ::windows::runtime::Abi for PPM_THERMAL_POLICY_EVENT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PPM_WMI_IDLE_STATE {
    pub Latency: u32,
    pub Power: u32,
    pub TimeCheck: u32,
    pub PromotePercent: u8,
    pub DemotePercent: u8,
    pub StateType: u8,
    pub Reserved: u8,
    pub StateFlags: u32,
    pub Context: u32,
    pub IdleHandler: u32,
    pub Reserved1: u32,
}
impl PPM_WMI_IDLE_STATE {}
impl ::std::default::Default for PPM_WMI_IDLE_STATE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PPM_WMI_IDLE_STATE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PPM_WMI_IDLE_STATE")
            .field("Latency", &self.Latency)
            .field("Power", &self.Power)
            .field("TimeCheck", &self.TimeCheck)
            .field("PromotePercent", &self.PromotePercent)
            .field("DemotePercent", &self.DemotePercent)
            .field("StateType", &self.StateType)
            .field("Reserved", &self.Reserved)
            .field("StateFlags", &self.StateFlags)
            .field("Context", &self.Context)
            .field("IdleHandler", &self.IdleHandler)
            .field("Reserved1", &self.Reserved1)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PPM_WMI_IDLE_STATE {
    fn eq(&self, other: &Self) -> bool {
        self.Latency == other.Latency
            && self.Power == other.Power
            && self.TimeCheck == other.TimeCheck
            && self.PromotePercent == other.PromotePercent
            && self.DemotePercent == other.DemotePercent
            && self.StateType == other.StateType
            && self.Reserved == other.Reserved
            && self.StateFlags == other.StateFlags
            && self.Context == other.Context
            && self.IdleHandler == other.IdleHandler
            && self.Reserved1 == other.Reserved1
    }
}
impl ::std::cmp::Eq for PPM_WMI_IDLE_STATE {}
unsafe impl ::windows::runtime::Abi for PPM_WMI_IDLE_STATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PPM_WMI_IDLE_STATES {
    pub Type: u32,
    pub Count: u32,
    pub TargetState: u32,
    pub OldState: u32,
    pub TargetProcessors: u64,
    pub State: [PPM_WMI_IDLE_STATE; 1],
}
impl PPM_WMI_IDLE_STATES {}
impl ::std::default::Default for PPM_WMI_IDLE_STATES {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PPM_WMI_IDLE_STATES {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PPM_WMI_IDLE_STATES")
            .field("Type", &self.Type)
            .field("Count", &self.Count)
            .field("TargetState", &self.TargetState)
            .field("OldState", &self.OldState)
            .field("TargetProcessors", &self.TargetProcessors)
            .field("State", &self.State)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PPM_WMI_IDLE_STATES {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type
            && self.Count == other.Count
            && self.TargetState == other.TargetState
            && self.OldState == other.OldState
            && self.TargetProcessors == other.TargetProcessors
            && self.State == other.State
    }
}
impl ::std::cmp::Eq for PPM_WMI_IDLE_STATES {}
unsafe impl ::windows::runtime::Abi for PPM_WMI_IDLE_STATES {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PPM_WMI_IDLE_STATES_EX {
    pub Type: u32,
    pub Count: u32,
    pub TargetState: u32,
    pub OldState: u32,
    pub TargetProcessors: *mut ::std::ffi::c_void,
    pub State: [PPM_WMI_IDLE_STATE; 1],
}
impl PPM_WMI_IDLE_STATES_EX {}
impl ::std::default::Default for PPM_WMI_IDLE_STATES_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PPM_WMI_IDLE_STATES_EX {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PPM_WMI_IDLE_STATES_EX")
            .field("Type", &self.Type)
            .field("Count", &self.Count)
            .field("TargetState", &self.TargetState)
            .field("OldState", &self.OldState)
            .field("TargetProcessors", &self.TargetProcessors)
            .field("State", &self.State)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PPM_WMI_IDLE_STATES_EX {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type
            && self.Count == other.Count
            && self.TargetState == other.TargetState
            && self.OldState == other.OldState
            && self.TargetProcessors == other.TargetProcessors
            && self.State == other.State
    }
}
impl ::std::cmp::Eq for PPM_WMI_IDLE_STATES_EX {}
unsafe impl ::windows::runtime::Abi for PPM_WMI_IDLE_STATES_EX {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PPM_WMI_LEGACY_PERFSTATE {
    pub Frequency: u32,
    pub Flags: u32,
    pub PercentFrequency: u32,
}
impl PPM_WMI_LEGACY_PERFSTATE {}
impl ::std::default::Default for PPM_WMI_LEGACY_PERFSTATE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PPM_WMI_LEGACY_PERFSTATE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PPM_WMI_LEGACY_PERFSTATE")
            .field("Frequency", &self.Frequency)
            .field("Flags", &self.Flags)
            .field("PercentFrequency", &self.PercentFrequency)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PPM_WMI_LEGACY_PERFSTATE {
    fn eq(&self, other: &Self) -> bool {
        self.Frequency == other.Frequency
            && self.Flags == other.Flags
            && self.PercentFrequency == other.PercentFrequency
    }
}
impl ::std::cmp::Eq for PPM_WMI_LEGACY_PERFSTATE {}
unsafe impl ::windows::runtime::Abi for PPM_WMI_LEGACY_PERFSTATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PPM_WMI_PERF_STATE {
    pub Frequency: u32,
    pub Power: u32,
    pub PercentFrequency: u8,
    pub IncreaseLevel: u8,
    pub DecreaseLevel: u8,
    pub Type: u8,
    pub IncreaseTime: u32,
    pub DecreaseTime: u32,
    pub Control: u64,
    pub Status: u64,
    pub HitCount: u32,
    pub Reserved1: u32,
    pub Reserved2: u64,
    pub Reserved3: u64,
}
impl PPM_WMI_PERF_STATE {}
impl ::std::default::Default for PPM_WMI_PERF_STATE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PPM_WMI_PERF_STATE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PPM_WMI_PERF_STATE")
            .field("Frequency", &self.Frequency)
            .field("Power", &self.Power)
            .field("PercentFrequency", &self.PercentFrequency)
            .field("IncreaseLevel", &self.IncreaseLevel)
            .field("DecreaseLevel", &self.DecreaseLevel)
            .field("Type", &self.Type)
            .field("IncreaseTime", &self.IncreaseTime)
            .field("DecreaseTime", &self.DecreaseTime)
            .field("Control", &self.Control)
            .field("Status", &self.Status)
            .field("HitCount", &self.HitCount)
            .field("Reserved1", &self.Reserved1)
            .field("Reserved2", &self.Reserved2)
            .field("Reserved3", &self.Reserved3)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PPM_WMI_PERF_STATE {
    fn eq(&self, other: &Self) -> bool {
        self.Frequency == other.Frequency
            && self.Power == other.Power
            && self.PercentFrequency == other.PercentFrequency
            && self.IncreaseLevel == other.IncreaseLevel
            && self.DecreaseLevel == other.DecreaseLevel
            && self.Type == other.Type
            && self.IncreaseTime == other.IncreaseTime
            && self.DecreaseTime == other.DecreaseTime
            && self.Control == other.Control
            && self.Status == other.Status
            && self.HitCount == other.HitCount
            && self.Reserved1 == other.Reserved1
            && self.Reserved2 == other.Reserved2
            && self.Reserved3 == other.Reserved3
    }
}
impl ::std::cmp::Eq for PPM_WMI_PERF_STATE {}
unsafe impl ::windows::runtime::Abi for PPM_WMI_PERF_STATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PPM_WMI_PERF_STATES {
    pub Count: u32,
    pub MaxFrequency: u32,
    pub CurrentState: u32,
    pub MaxPerfState: u32,
    pub MinPerfState: u32,
    pub LowestPerfState: u32,
    pub ThermalConstraint: u32,
    pub BusyAdjThreshold: u8,
    pub PolicyType: u8,
    pub Type: u8,
    pub Reserved: u8,
    pub TimerInterval: u32,
    pub TargetProcessors: u64,
    pub PStateHandler: u32,
    pub PStateContext: u32,
    pub TStateHandler: u32,
    pub TStateContext: u32,
    pub FeedbackHandler: u32,
    pub Reserved1: u32,
    pub Reserved2: u64,
    pub State: [PPM_WMI_PERF_STATE; 1],
}
impl PPM_WMI_PERF_STATES {}
impl ::std::default::Default for PPM_WMI_PERF_STATES {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PPM_WMI_PERF_STATES {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PPM_WMI_PERF_STATES")
            .field("Count", &self.Count)
            .field("MaxFrequency", &self.MaxFrequency)
            .field("CurrentState", &self.CurrentState)
            .field("MaxPerfState", &self.MaxPerfState)
            .field("MinPerfState", &self.MinPerfState)
            .field("LowestPerfState", &self.LowestPerfState)
            .field("ThermalConstraint", &self.ThermalConstraint)
            .field("BusyAdjThreshold", &self.BusyAdjThreshold)
            .field("PolicyType", &self.PolicyType)
            .field("Type", &self.Type)
            .field("Reserved", &self.Reserved)
            .field("TimerInterval", &self.TimerInterval)
            .field("TargetProcessors", &self.TargetProcessors)
            .field("PStateHandler", &self.PStateHandler)
            .field("PStateContext", &self.PStateContext)
            .field("TStateHandler", &self.TStateHandler)
            .field("TStateContext", &self.TStateContext)
            .field("FeedbackHandler", &self.FeedbackHandler)
            .field("Reserved1", &self.Reserved1)
            .field("Reserved2", &self.Reserved2)
            .field("State", &self.State)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PPM_WMI_PERF_STATES {
    fn eq(&self, other: &Self) -> bool {
        self.Count == other.Count
            && self.MaxFrequency == other.MaxFrequency
            && self.CurrentState == other.CurrentState
            && self.MaxPerfState == other.MaxPerfState
            && self.MinPerfState == other.MinPerfState
            && self.LowestPerfState == other.LowestPerfState
            && self.ThermalConstraint == other.ThermalConstraint
            && self.BusyAdjThreshold == other.BusyAdjThreshold
            && self.PolicyType == other.PolicyType
            && self.Type == other.Type
            && self.Reserved == other.Reserved
            && self.TimerInterval == other.TimerInterval
            && self.TargetProcessors == other.TargetProcessors
            && self.PStateHandler == other.PStateHandler
            && self.PStateContext == other.PStateContext
            && self.TStateHandler == other.TStateHandler
            && self.TStateContext == other.TStateContext
            && self.FeedbackHandler == other.FeedbackHandler
            && self.Reserved1 == other.Reserved1
            && self.Reserved2 == other.Reserved2
            && self.State == other.State
    }
}
impl ::std::cmp::Eq for PPM_WMI_PERF_STATES {}
unsafe impl ::windows::runtime::Abi for PPM_WMI_PERF_STATES {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PPM_WMI_PERF_STATES_EX {
    pub Count: u32,
    pub MaxFrequency: u32,
    pub CurrentState: u32,
    pub MaxPerfState: u32,
    pub MinPerfState: u32,
    pub LowestPerfState: u32,
    pub ThermalConstraint: u32,
    pub BusyAdjThreshold: u8,
    pub PolicyType: u8,
    pub Type: u8,
    pub Reserved: u8,
    pub TimerInterval: u32,
    pub TargetProcessors: *mut ::std::ffi::c_void,
    pub PStateHandler: u32,
    pub PStateContext: u32,
    pub TStateHandler: u32,
    pub TStateContext: u32,
    pub FeedbackHandler: u32,
    pub Reserved1: u32,
    pub Reserved2: u64,
    pub State: [PPM_WMI_PERF_STATE; 1],
}
impl PPM_WMI_PERF_STATES_EX {}
impl ::std::default::Default for PPM_WMI_PERF_STATES_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PPM_WMI_PERF_STATES_EX {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PPM_WMI_PERF_STATES_EX")
            .field("Count", &self.Count)
            .field("MaxFrequency", &self.MaxFrequency)
            .field("CurrentState", &self.CurrentState)
            .field("MaxPerfState", &self.MaxPerfState)
            .field("MinPerfState", &self.MinPerfState)
            .field("LowestPerfState", &self.LowestPerfState)
            .field("ThermalConstraint", &self.ThermalConstraint)
            .field("BusyAdjThreshold", &self.BusyAdjThreshold)
            .field("PolicyType", &self.PolicyType)
            .field("Type", &self.Type)
            .field("Reserved", &self.Reserved)
            .field("TimerInterval", &self.TimerInterval)
            .field("TargetProcessors", &self.TargetProcessors)
            .field("PStateHandler", &self.PStateHandler)
            .field("PStateContext", &self.PStateContext)
            .field("TStateHandler", &self.TStateHandler)
            .field("TStateContext", &self.TStateContext)
            .field("FeedbackHandler", &self.FeedbackHandler)
            .field("Reserved1", &self.Reserved1)
            .field("Reserved2", &self.Reserved2)
            .field("State", &self.State)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PPM_WMI_PERF_STATES_EX {
    fn eq(&self, other: &Self) -> bool {
        self.Count == other.Count
            && self.MaxFrequency == other.MaxFrequency
            && self.CurrentState == other.CurrentState
            && self.MaxPerfState == other.MaxPerfState
            && self.MinPerfState == other.MinPerfState
            && self.LowestPerfState == other.LowestPerfState
            && self.ThermalConstraint == other.ThermalConstraint
            && self.BusyAdjThreshold == other.BusyAdjThreshold
            && self.PolicyType == other.PolicyType
            && self.Type == other.Type
            && self.Reserved == other.Reserved
            && self.TimerInterval == other.TimerInterval
            && self.TargetProcessors == other.TargetProcessors
            && self.PStateHandler == other.PStateHandler
            && self.PStateContext == other.PStateContext
            && self.TStateHandler == other.TStateHandler
            && self.TStateContext == other.TStateContext
            && self.FeedbackHandler == other.FeedbackHandler
            && self.Reserved1 == other.Reserved1
            && self.Reserved2 == other.Reserved2
            && self.State == other.State
    }
}
impl ::std::cmp::Eq for PPM_WMI_PERF_STATES_EX {}
unsafe impl ::windows::runtime::Abi for PPM_WMI_PERF_STATES_EX {
    type Abi = Self;
    type DefaultType = Self;
}
pub const PRAGMA_DEPRECATED_DDK: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct PREVENT_MEDIA_REMOVAL {
    pub PreventMediaRemoval: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl PREVENT_MEDIA_REMOVAL {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for PREVENT_MEDIA_REMOVAL {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for PREVENT_MEDIA_REMOVAL {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PREVENT_MEDIA_REMOVAL")
            .field("PreventMediaRemoval", &self.PreventMediaRemoval)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for PREVENT_MEDIA_REMOVAL {
    fn eq(&self, other: &Self) -> bool {
        self.PreventMediaRemoval == other.PreventMediaRemoval
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for PREVENT_MEDIA_REMOVAL {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for PREVENT_MEDIA_REMOVAL {
    type Abi = Self;
    type DefaultType = Self;
}
pub const PRIMARY_ORDER_ABC: u32 = 0u32;
pub const PRIMARY_ORDER_ACB: u32 = 1u32;
pub const PRIMARY_ORDER_BAC: u32 = 2u32;
pub const PRIMARY_ORDER_BCA: u32 = 3u32;
pub const PRIMARY_ORDER_CAB: u32 = 5u32;
pub const PRIMARY_ORDER_CBA: u32 = 4u32;
pub const PRIVILEGE_SET_ALL_NECESSARY: u32 = 1u32;
pub const PROCESSOR_ALPHA_21064: u32 = 21064u32;
pub const PROCESSOR_AMD_X8664: u32 = 8664u32;
pub const PROCESSOR_ARCHITECTURE_ALPHA: u32 = 2u32;
pub const PROCESSOR_ARCHITECTURE_ALPHA64: u32 = 7u32;
pub const PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64: u32 = 13u32;
pub const PROCESSOR_ARCHITECTURE_ARM64: u32 = 12u32;
pub const PROCESSOR_ARCHITECTURE_IA32_ON_ARM64: u32 = 14u32;
pub const PROCESSOR_ARCHITECTURE_IA32_ON_WIN64: u32 = 10u32;
pub const PROCESSOR_ARCHITECTURE_MIPS: u32 = 1u32;
pub const PROCESSOR_ARCHITECTURE_MSIL: u32 = 8u32;
pub const PROCESSOR_ARCHITECTURE_NEUTRAL: u32 = 11u32;
pub const PROCESSOR_ARCHITECTURE_PPC: u32 = 3u32;
pub const PROCESSOR_ARCHITECTURE_SHX: u32 = 4u32;
pub const PROCESSOR_ARM720: u32 = 1824u32;
pub const PROCESSOR_ARM820: u32 = 2080u32;
pub const PROCESSOR_ARM920: u32 = 2336u32;
pub const PROCESSOR_ARM_7TDMI: u32 = 70001u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct PROCESSOR_CACHE_TYPE(pub i32);
pub const CacheUnified: PROCESSOR_CACHE_TYPE = PROCESSOR_CACHE_TYPE(0i32);
pub const CacheInstruction: PROCESSOR_CACHE_TYPE = PROCESSOR_CACHE_TYPE(1i32);
pub const CacheData: PROCESSOR_CACHE_TYPE = PROCESSOR_CACHE_TYPE(2i32);
pub const CacheTrace: PROCESSOR_CACHE_TYPE = PROCESSOR_CACHE_TYPE(3i32);
impl ::std::convert::From<i32> for PROCESSOR_CACHE_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for PROCESSOR_CACHE_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const PROCESSOR_DUTY_CYCLING_DISABLED: u32 = 0u32;
pub const PROCESSOR_DUTY_CYCLING_ENABLED: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESSOR_GROUP_INFO {
    pub MaximumProcessorCount: u8,
    pub ActiveProcessorCount: u8,
    pub Reserved: [u8; 38],
    pub ActiveProcessorMask: usize,
}
impl PROCESSOR_GROUP_INFO {}
impl ::std::default::Default for PROCESSOR_GROUP_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESSOR_GROUP_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PROCESSOR_GROUP_INFO")
            .field("MaximumProcessorCount", &self.MaximumProcessorCount)
            .field("ActiveProcessorCount", &self.ActiveProcessorCount)
            .field("Reserved", &self.Reserved)
            .field("ActiveProcessorMask", &self.ActiveProcessorMask)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESSOR_GROUP_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.MaximumProcessorCount == other.MaximumProcessorCount
            && self.ActiveProcessorCount == other.ActiveProcessorCount
            && self.Reserved == other.Reserved
            && self.ActiveProcessorMask == other.ActiveProcessorMask
    }
}
impl ::std::cmp::Eq for PROCESSOR_GROUP_INFO {}
unsafe impl ::windows::runtime::Abi for PROCESSOR_GROUP_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
pub const PROCESSOR_HITACHI_SH3: u32 = 10003u32;
pub const PROCESSOR_HITACHI_SH3E: u32 = 10004u32;
pub const PROCESSOR_HITACHI_SH4: u32 = 10005u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESSOR_IDLESTATE_INFO {
    pub TimeCheck: u32,
    pub DemotePercent: u8,
    pub PromotePercent: u8,
    pub Spare: [u8; 2],
}
impl PROCESSOR_IDLESTATE_INFO {}
impl ::std::default::Default for PROCESSOR_IDLESTATE_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESSOR_IDLESTATE_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PROCESSOR_IDLESTATE_INFO")
            .field("TimeCheck", &self.TimeCheck)
            .field("DemotePercent", &self.DemotePercent)
            .field("PromotePercent", &self.PromotePercent)
            .field("Spare", &self.Spare)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESSOR_IDLESTATE_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.TimeCheck == other.TimeCheck
            && self.DemotePercent == other.DemotePercent
            && self.PromotePercent == other.PromotePercent
            && self.Spare == other.Spare
    }
}
impl ::std::cmp::Eq for PROCESSOR_IDLESTATE_INFO {}
unsafe impl ::windows::runtime::Abi for PROCESSOR_IDLESTATE_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESSOR_IDLESTATE_POLICY {
    pub Revision: u16,
    pub Flags: PROCESSOR_IDLESTATE_POLICY_0,
    pub PolicyCount: u32,
    pub Policy: [PROCESSOR_IDLESTATE_INFO; 3],
}
impl PROCESSOR_IDLESTATE_POLICY {}
impl ::std::default::Default for PROCESSOR_IDLESTATE_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESSOR_IDLESTATE_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESSOR_IDLESTATE_POLICY {}
unsafe impl ::windows::runtime::Abi for PROCESSOR_IDLESTATE_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESSOR_IDLESTATE_POLICY_0 {
    pub AsWORD: u16,
    pub Anonymous: PROCESSOR_IDLESTATE_POLICY_0_0,
}
impl PROCESSOR_IDLESTATE_POLICY_0 {}
impl ::std::default::Default for PROCESSOR_IDLESTATE_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESSOR_IDLESTATE_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESSOR_IDLESTATE_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESSOR_IDLESTATE_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESSOR_IDLESTATE_POLICY_0_0 {
    pub _bitfield: u16,
}
impl PROCESSOR_IDLESTATE_POLICY_0_0 {}
impl ::std::default::Default for PROCESSOR_IDLESTATE_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESSOR_IDLESTATE_POLICY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESSOR_IDLESTATE_POLICY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESSOR_IDLESTATE_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESSOR_IDLESTATE_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const PROCESSOR_IDLESTATE_POLICY_COUNT: u32 = 3u32;
pub const PROCESSOR_INTEL_386: u32 = 386u32;
pub const PROCESSOR_INTEL_486: u32 = 486u32;
pub const PROCESSOR_INTEL_IA64: u32 = 2200u32;
pub const PROCESSOR_INTEL_PENTIUM: u32 = 586u32;
pub const PROCESSOR_MIPS_R4000: u32 = 4000u32;
pub const PROCESSOR_MOTOROLA_821: u32 = 821u32;
pub const PROCESSOR_OPTIL: u32 = 18767u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESSOR_PERFSTATE_POLICY {
    pub Revision: u32,
    pub MaxThrottle: u8,
    pub MinThrottle: u8,
    pub BusyAdjThreshold: u8,
    pub Anonymous: PROCESSOR_PERFSTATE_POLICY_0,
    pub TimeCheck: u32,
    pub IncreaseTime: u32,
    pub DecreaseTime: u32,
    pub IncreasePercent: u32,
    pub DecreasePercent: u32,
}
impl PROCESSOR_PERFSTATE_POLICY {}
impl ::std::default::Default for PROCESSOR_PERFSTATE_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESSOR_PERFSTATE_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESSOR_PERFSTATE_POLICY {}
unsafe impl ::windows::runtime::Abi for PROCESSOR_PERFSTATE_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESSOR_PERFSTATE_POLICY_0 {
    pub Spare: u8,
    pub Flags: PROCESSOR_PERFSTATE_POLICY_0_0,
}
impl PROCESSOR_PERFSTATE_POLICY_0 {}
impl ::std::default::Default for PROCESSOR_PERFSTATE_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESSOR_PERFSTATE_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESSOR_PERFSTATE_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESSOR_PERFSTATE_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESSOR_PERFSTATE_POLICY_0_0 {
    pub AsBYTE: u8,
    pub Anonymous: PROCESSOR_PERFSTATE_POLICY_0_0_0,
}
impl PROCESSOR_PERFSTATE_POLICY_0_0 {}
impl ::std::default::Default for PROCESSOR_PERFSTATE_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESSOR_PERFSTATE_POLICY_0_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESSOR_PERFSTATE_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESSOR_PERFSTATE_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESSOR_PERFSTATE_POLICY_0_0_0 {
    pub _bitfield: u8,
}
impl PROCESSOR_PERFSTATE_POLICY_0_0_0 {}
impl ::std::default::Default for PROCESSOR_PERFSTATE_POLICY_0_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESSOR_PERFSTATE_POLICY_0_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESSOR_PERFSTATE_POLICY_0_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESSOR_PERFSTATE_POLICY_0_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESSOR_PERFSTATE_POLICY_0_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_DISABLED: u32 = 0u32;
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_ENABLED: u32 = 1u32;
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE: u32 = 2u32;
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE_AT_GUARANTEED: u32 = 5u32;
pub const PROCESSOR_PERF_BOOST_MODE_DISABLED: u32 = 0u32;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE: u32 = 4u32;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE_AT_GUARANTEED: u32 = 6u32;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_ENABLED: u32 = 3u32;
pub const PROCESSOR_PERF_BOOST_MODE_ENABLED: u32 = 1u32;
pub const PROCESSOR_PERF_BOOST_MODE_MAX: u32 = 6u32;
pub const PROCESSOR_PERF_BOOST_POLICY_DISABLED: u32 = 0u32;
pub const PROCESSOR_PERF_BOOST_POLICY_MAX: u32 = 100u32;
pub const PROCESSOR_PERF_ENERGY_PREFERENCE: u32 = 0u32;
pub const PROCESSOR_PERF_MAXIMUM_ACTIVITY_WINDOW: u32 = 1270000000u32;
pub const PROCESSOR_PERF_MINIMUM_ACTIVITY_WINDOW: u32 = 0u32;
pub const PROCESSOR_PERF_PERFORMANCE_PREFERENCE: u32 = 255u32;
pub const PROCESSOR_PPC_601: u32 = 601u32;
pub const PROCESSOR_PPC_603: u32 = 603u32;
pub const PROCESSOR_PPC_604: u32 = 604u32;
pub const PROCESSOR_PPC_620: u32 = 620u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Kernel")]
pub struct PROCESSOR_RELATIONSHIP {
    pub Flags: u8,
    pub EfficiencyClass: u8,
    pub Reserved: [u8; 20],
    pub GroupCount: u16,
    pub GroupMask: [super::Kernel::GROUP_AFFINITY; 1],
}
#[cfg(feature = "Win32_System_Kernel")]
impl PROCESSOR_RELATIONSHIP {}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::default::Default for PROCESSOR_RELATIONSHIP {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::fmt::Debug for PROCESSOR_RELATIONSHIP {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PROCESSOR_RELATIONSHIP")
            .field("Flags", &self.Flags)
            .field("EfficiencyClass", &self.EfficiencyClass)
            .field("Reserved", &self.Reserved)
            .field("GroupCount", &self.GroupCount)
            .field("GroupMask", &self.GroupMask)
            .finish()
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::cmp::PartialEq for PROCESSOR_RELATIONSHIP {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
            && self.EfficiencyClass == other.EfficiencyClass
            && self.Reserved == other.Reserved
            && self.GroupCount == other.GroupCount
            && self.GroupMask == other.GroupMask
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::cmp::Eq for PROCESSOR_RELATIONSHIP {}
#[cfg(feature = "Win32_System_Kernel")]
unsafe impl ::windows::runtime::Abi for PROCESSOR_RELATIONSHIP {
    type Abi = Self;
    type DefaultType = Self;
}
pub const PROCESSOR_SHx_SH3: u32 = 103u32;
pub const PROCESSOR_SHx_SH4: u32 = 104u32;
pub const PROCESSOR_STRONGARM: u32 = 2577u32;
pub const PROCESSOR_THROTTLE_AUTOMATIC: u32 = 2u32;
pub const PROCESSOR_THROTTLE_DISABLED: u32 = 0u32;
pub const PROCESSOR_THROTTLE_ENABLED: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_DYNAMIC_EH_CONTINUATION_TARGET {
    pub TargetAddress: usize,
    pub Flags: usize,
}
impl PROCESS_DYNAMIC_EH_CONTINUATION_TARGET {}
impl ::std::default::Default for PROCESS_DYNAMIC_EH_CONTINUATION_TARGET {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_DYNAMIC_EH_CONTINUATION_TARGET {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PROCESS_DYNAMIC_EH_CONTINUATION_TARGET")
            .field("TargetAddress", &self.TargetAddress)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_DYNAMIC_EH_CONTINUATION_TARGET {
    fn eq(&self, other: &Self) -> bool {
        self.TargetAddress == other.TargetAddress && self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for PROCESS_DYNAMIC_EH_CONTINUATION_TARGET {}
unsafe impl ::windows::runtime::Abi for PROCESS_DYNAMIC_EH_CONTINUATION_TARGET {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION {
    pub NumberOfTargets: u16,
    pub Reserved: u16,
    pub Reserved2: u32,
    pub Targets: *mut PROCESS_DYNAMIC_EH_CONTINUATION_TARGET,
}
impl PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION {}
impl ::std::default::Default for PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION")
            .field("NumberOfTargets", &self.NumberOfTargets)
            .field("Reserved", &self.Reserved)
            .field("Reserved2", &self.Reserved2)
            .field("Targets", &self.Targets)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NumberOfTargets == other.NumberOfTargets
            && self.Reserved == other.Reserved
            && self.Reserved2 == other.Reserved2
            && self.Targets == other.Targets
    }
}
impl ::std::cmp::Eq for PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION {}
unsafe impl ::windows::runtime::Abi for PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE {
    pub BaseAddress: usize,
    pub Size: usize,
    pub Flags: u32,
}
impl PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE {}
impl ::std::default::Default for PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE")
            .field("BaseAddress", &self.BaseAddress)
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.BaseAddress == other.BaseAddress
            && self.Size == other.Size
            && self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE {}
unsafe impl ::windows::runtime::Abi for PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION {
    pub NumberOfRanges: u16,
    pub Reserved: u16,
    pub Reserved2: u32,
    pub Ranges: *mut PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE,
}
impl PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION {}
impl ::std::default::Default for PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION")
            .field("NumberOfRanges", &self.NumberOfRanges)
            .field("Reserved", &self.Reserved)
            .field("Reserved2", &self.Reserved2)
            .field("Ranges", &self.Ranges)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NumberOfRanges == other.NumberOfRanges
            && self.Reserved == other.Reserved
            && self.Reserved2 == other.Reserved2
            && self.Ranges == other.Ranges
    }
}
impl ::std::cmp::Eq for PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION {}
unsafe impl ::windows::runtime::Abi for PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct PROCESS_HEAP_ENTRY {
    pub lpData: *mut ::std::ffi::c_void,
    pub cbData: u32,
    pub cbOverhead: u8,
    pub iRegionIndex: u8,
    pub wFlags: u16,
    pub Anonymous: PROCESS_HEAP_ENTRY_0,
}
#[cfg(feature = "Win32_Foundation")]
impl PROCESS_HEAP_ENTRY {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for PROCESS_HEAP_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for PROCESS_HEAP_ENTRY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for PROCESS_HEAP_ENTRY {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for PROCESS_HEAP_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub union PROCESS_HEAP_ENTRY_0 {
    pub Block: PROCESS_HEAP_ENTRY_0_0,
    pub Region: PROCESS_HEAP_ENTRY_0_1,
}
#[cfg(feature = "Win32_Foundation")]
impl PROCESS_HEAP_ENTRY_0 {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for PROCESS_HEAP_ENTRY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for PROCESS_HEAP_ENTRY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for PROCESS_HEAP_ENTRY_0 {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for PROCESS_HEAP_ENTRY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct PROCESS_HEAP_ENTRY_0_0 {
    pub hMem: super::super::Foundation::HANDLE,
    pub dwReserved: [u32; 3],
}
#[cfg(feature = "Win32_Foundation")]
impl PROCESS_HEAP_ENTRY_0_0 {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for PROCESS_HEAP_ENTRY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for PROCESS_HEAP_ENTRY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Block_e__Struct")
            .field("hMem", &self.hMem)
            .field("dwReserved", &self.dwReserved)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for PROCESS_HEAP_ENTRY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.hMem == other.hMem && self.dwReserved == other.dwReserved
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for PROCESS_HEAP_ENTRY_0_0 {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for PROCESS_HEAP_ENTRY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_HEAP_ENTRY_0_1 {
    pub dwCommittedSize: u32,
    pub dwUnCommittedSize: u32,
    pub lpFirstBlock: *mut ::std::ffi::c_void,
    pub lpLastBlock: *mut ::std::ffi::c_void,
}
impl PROCESS_HEAP_ENTRY_0_1 {}
impl ::std::default::Default for PROCESS_HEAP_ENTRY_0_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_HEAP_ENTRY_0_1 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Region_e__Struct")
            .field("dwCommittedSize", &self.dwCommittedSize)
            .field("dwUnCommittedSize", &self.dwUnCommittedSize)
            .field("lpFirstBlock", &self.lpFirstBlock)
            .field("lpLastBlock", &self.lpLastBlock)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_HEAP_ENTRY_0_1 {
    fn eq(&self, other: &Self) -> bool {
        self.dwCommittedSize == other.dwCommittedSize
            && self.dwUnCommittedSize == other.dwUnCommittedSize
            && self.lpFirstBlock == other.lpFirstBlock
            && self.lpLastBlock == other.lpLastBlock
    }
}
impl ::std::cmp::Eq for PROCESS_HEAP_ENTRY_0_1 {}
unsafe impl ::windows::runtime::Abi for PROCESS_HEAP_ENTRY_0_1 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const PROCESS_HEAP_ENTRY_BUSY: u32 = 4u32;
pub const PROCESS_HEAP_ENTRY_DDESHARE: u32 = 32u32;
pub const PROCESS_HEAP_ENTRY_MOVEABLE: u32 = 16u32;
pub const PROCESS_HEAP_REGION: u32 = 1u32;
pub const PROCESS_HEAP_SEG_ALLOC: u32 = 8u32;
pub const PROCESS_HEAP_UNCOMMITTED_RANGE: u32 = 2u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_ASLR_POLICY {
    pub Anonymous: PROCESS_MITIGATION_ASLR_POLICY_0,
}
impl PROCESS_MITIGATION_ASLR_POLICY {}
impl ::std::default::Default for PROCESS_MITIGATION_ASLR_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_ASLR_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_ASLR_POLICY {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_ASLR_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESS_MITIGATION_ASLR_POLICY_0 {
    pub Flags: u32,
    pub Anonymous: PROCESS_MITIGATION_ASLR_POLICY_0_0,
}
impl PROCESS_MITIGATION_ASLR_POLICY_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_ASLR_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_ASLR_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_ASLR_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_ASLR_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_ASLR_POLICY_0_0 {
    pub _bitfield: u32,
}
impl PROCESS_MITIGATION_ASLR_POLICY_0_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_ASLR_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_MITIGATION_ASLR_POLICY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_ASLR_POLICY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_ASLR_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_ASLR_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
    pub Anonymous: PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_0,
}
impl PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {}
impl ::std::default::Default for PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_0 {
    pub Flags: u32,
    pub Anonymous: PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_0_0,
}
impl PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_0_0 {
    pub _bitfield: u32,
}
impl PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_0_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
    pub Anonymous: PROCESS_MITIGATION_CHILD_PROCESS_POLICY_0,
}
impl PROCESS_MITIGATION_CHILD_PROCESS_POLICY {}
impl ::std::default::Default for PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_CHILD_PROCESS_POLICY {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESS_MITIGATION_CHILD_PROCESS_POLICY_0 {
    pub Flags: u32,
    pub Anonymous: PROCESS_MITIGATION_CHILD_PROCESS_POLICY_0_0,
}
impl PROCESS_MITIGATION_CHILD_PROCESS_POLICY_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_CHILD_PROCESS_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_CHILD_PROCESS_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_CHILD_PROCESS_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_CHILD_PROCESS_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_CHILD_PROCESS_POLICY_0_0 {
    pub _bitfield: u32,
}
impl PROCESS_MITIGATION_CHILD_PROCESS_POLICY_0_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_CHILD_PROCESS_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_MITIGATION_CHILD_PROCESS_POLICY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_CHILD_PROCESS_POLICY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_CHILD_PROCESS_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_CHILD_PROCESS_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
    pub Anonymous: PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_0,
}
impl PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {}
impl ::std::default::Default for PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_0 {
    pub Flags: u32,
    pub Anonymous: PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_0_0,
}
impl PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_0_0 {
    pub _bitfield: u32,
}
impl PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_0_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct PROCESS_MITIGATION_DEP_POLICY {
    pub Anonymous: PROCESS_MITIGATION_DEP_POLICY_0,
    pub Permanent: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl PROCESS_MITIGATION_DEP_POLICY {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for PROCESS_MITIGATION_DEP_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_DEP_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for PROCESS_MITIGATION_DEP_POLICY {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_DEP_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESS_MITIGATION_DEP_POLICY_0 {
    pub Flags: u32,
    pub Anonymous: PROCESS_MITIGATION_DEP_POLICY_0_0,
}
impl PROCESS_MITIGATION_DEP_POLICY_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_DEP_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_DEP_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_DEP_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_DEP_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_DEP_POLICY_0_0 {
    pub _bitfield: u32,
}
impl PROCESS_MITIGATION_DEP_POLICY_0_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_DEP_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_MITIGATION_DEP_POLICY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_DEP_POLICY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_DEP_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_DEP_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
    pub Anonymous: PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_0,
}
impl PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {}
impl ::std::default::Default for PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_0 {
    pub Flags: u32,
    pub Anonymous: PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_0_0,
}
impl PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_0_0 {
    pub _bitfield: u32,
}
impl PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_0_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
    pub Anonymous: PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY_0,
}
impl PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {}
impl ::std::default::Default for PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY_0 {
    pub Flags: u32,
    pub Anonymous: PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY_0_0,
}
impl PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY_0_0 {
    pub _bitfield: u32,
}
impl PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY_0_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_FONT_DISABLE_POLICY {
    pub Anonymous: PROCESS_MITIGATION_FONT_DISABLE_POLICY_0,
}
impl PROCESS_MITIGATION_FONT_DISABLE_POLICY {}
impl ::std::default::Default for PROCESS_MITIGATION_FONT_DISABLE_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_FONT_DISABLE_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_FONT_DISABLE_POLICY {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_FONT_DISABLE_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESS_MITIGATION_FONT_DISABLE_POLICY_0 {
    pub Flags: u32,
    pub Anonymous: PROCESS_MITIGATION_FONT_DISABLE_POLICY_0_0,
}
impl PROCESS_MITIGATION_FONT_DISABLE_POLICY_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_FONT_DISABLE_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_FONT_DISABLE_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_FONT_DISABLE_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_FONT_DISABLE_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_FONT_DISABLE_POLICY_0_0 {
    pub _bitfield: u32,
}
impl PROCESS_MITIGATION_FONT_DISABLE_POLICY_0_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_FONT_DISABLE_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_MITIGATION_FONT_DISABLE_POLICY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_FONT_DISABLE_POLICY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_FONT_DISABLE_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_FONT_DISABLE_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
    pub Anonymous: PROCESS_MITIGATION_IMAGE_LOAD_POLICY_0,
}
impl PROCESS_MITIGATION_IMAGE_LOAD_POLICY {}
impl ::std::default::Default for PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_IMAGE_LOAD_POLICY {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESS_MITIGATION_IMAGE_LOAD_POLICY_0 {
    pub Flags: u32,
    pub Anonymous: PROCESS_MITIGATION_IMAGE_LOAD_POLICY_0_0,
}
impl PROCESS_MITIGATION_IMAGE_LOAD_POLICY_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_IMAGE_LOAD_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_IMAGE_LOAD_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_IMAGE_LOAD_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_IMAGE_LOAD_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_IMAGE_LOAD_POLICY_0_0 {
    pub _bitfield: u32,
}
impl PROCESS_MITIGATION_IMAGE_LOAD_POLICY_0_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_IMAGE_LOAD_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_MITIGATION_IMAGE_LOAD_POLICY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_IMAGE_LOAD_POLICY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_IMAGE_LOAD_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_IMAGE_LOAD_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
    pub Anonymous: PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_0,
}
impl PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {}
impl ::std::default::Default for PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_0 {
    pub Flags: u32,
    pub Anonymous: PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_0_0,
}
impl PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_0_0 {
    pub _bitfield: u32,
}
impl PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_0_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct PROCESS_MITIGATION_POLICY(pub i32);
pub const ProcessDEPPolicy: PROCESS_MITIGATION_POLICY = PROCESS_MITIGATION_POLICY(0i32);
pub const ProcessASLRPolicy: PROCESS_MITIGATION_POLICY = PROCESS_MITIGATION_POLICY(1i32);
pub const ProcessDynamicCodePolicy: PROCESS_MITIGATION_POLICY = PROCESS_MITIGATION_POLICY(2i32);
pub const ProcessStrictHandleCheckPolicy: PROCESS_MITIGATION_POLICY =
    PROCESS_MITIGATION_POLICY(3i32);
pub const ProcessSystemCallDisablePolicy: PROCESS_MITIGATION_POLICY =
    PROCESS_MITIGATION_POLICY(4i32);
pub const ProcessMitigationOptionsMask: PROCESS_MITIGATION_POLICY = PROCESS_MITIGATION_POLICY(5i32);
pub const ProcessExtensionPointDisablePolicy: PROCESS_MITIGATION_POLICY =
    PROCESS_MITIGATION_POLICY(6i32);
pub const ProcessControlFlowGuardPolicy: PROCESS_MITIGATION_POLICY =
    PROCESS_MITIGATION_POLICY(7i32);
pub const ProcessSignaturePolicy: PROCESS_MITIGATION_POLICY = PROCESS_MITIGATION_POLICY(8i32);
pub const ProcessFontDisablePolicy: PROCESS_MITIGATION_POLICY = PROCESS_MITIGATION_POLICY(9i32);
pub const ProcessImageLoadPolicy: PROCESS_MITIGATION_POLICY = PROCESS_MITIGATION_POLICY(10i32);
pub const ProcessSystemCallFilterPolicy: PROCESS_MITIGATION_POLICY =
    PROCESS_MITIGATION_POLICY(11i32);
pub const ProcessPayloadRestrictionPolicy: PROCESS_MITIGATION_POLICY =
    PROCESS_MITIGATION_POLICY(12i32);
pub const ProcessChildProcessPolicy: PROCESS_MITIGATION_POLICY = PROCESS_MITIGATION_POLICY(13i32);
pub const ProcessSideChannelIsolationPolicy: PROCESS_MITIGATION_POLICY =
    PROCESS_MITIGATION_POLICY(14i32);
pub const ProcessUserShadowStackPolicy: PROCESS_MITIGATION_POLICY =
    PROCESS_MITIGATION_POLICY(15i32);
pub const ProcessRedirectionTrustPolicy: PROCESS_MITIGATION_POLICY =
    PROCESS_MITIGATION_POLICY(16i32);
pub const MaxProcessMitigationPolicy: PROCESS_MITIGATION_POLICY = PROCESS_MITIGATION_POLICY(17i32);
impl ::std::convert::From<i32> for PROCESS_MITIGATION_POLICY {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY {
    pub Anonymous: PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_0,
}
impl PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY {}
impl ::std::default::Default for PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_0 {
    pub Flags: u32,
    pub Anonymous: PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_0_0,
}
impl PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_0_0 {
    pub _bitfield: u32,
}
impl PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_0_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {
    pub Anonymous: PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_0,
}
impl PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {}
impl ::std::default::Default for PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_0 {
    pub Flags: u32,
    pub Anonymous: PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_0_0,
}
impl PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_0_0 {
    pub _bitfield: u32,
}
impl PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_0_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
    pub Anonymous: PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY_0,
}
impl PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {}
impl ::std::default::Default for PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY_0 {
    pub Flags: u32,
    pub Anonymous: PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY_0_0,
}
impl PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY_0_0 {
    pub _bitfield: u32,
}
impl PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY_0_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
    pub Anonymous: PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_0,
}
impl PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {}
impl ::std::default::Default for PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_0 {
    pub Flags: u32,
    pub Anonymous: PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_0_0,
}
impl PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_0_0 {
    pub _bitfield: u32,
}
impl PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_0_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
    pub Anonymous: PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_0,
}
impl PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {}
impl ::std::default::Default for PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_0 {
    pub Flags: u32,
    pub Anonymous: PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_0_0,
}
impl PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_0_0 {
    pub _bitfield: u32,
}
impl PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_0_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY {
    pub Anonymous: PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_0,
}
impl PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY {}
impl ::std::default::Default for PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_0 {
    pub Flags: u32,
    pub Anonymous: PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_0_0,
}
impl PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_0_0 {
    pub _bitfield: u32,
}
impl PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_0_0 {}
impl ::std::default::Default for PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_0_0 {}
unsafe impl ::windows::runtime::Abi for PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const PROCESS_TRUST_LABEL_SECURITY_INFORMATION: i32 = 128i32;
pub const PROC_IDLE_BUCKET_COUNT: u32 = 6u32;
pub const PROC_IDLE_BUCKET_COUNT_EX: u32 = 16u32;
pub const PRODUCT_ARM64_SERVER: u32 = 120u32;
pub const PRODUCT_AZURESTACKHCI_SERVER_CORE: u32 = 406u32;
pub const PRODUCT_AZURE_NANO_SERVER: u32 = 169u32;
pub const PRODUCT_AZURE_SERVER_CLOUDHOST: u32 = 199u32;
pub const PRODUCT_AZURE_SERVER_CLOUDMOS: u32 = 200u32;
pub const PRODUCT_AZURE_SERVER_CORE: u32 = 168u32;
pub const PRODUCT_CLOUD: u32 = 178u32;
pub const PRODUCT_CLOUDE: u32 = 183u32;
pub const PRODUCT_CLOUDEDITION: u32 = 203u32;
pub const PRODUCT_CLOUDEDITIONN: u32 = 202u32;
pub const PRODUCT_CLOUDEN: u32 = 186u32;
pub const PRODUCT_CLOUDN: u32 = 179u32;
pub const PRODUCT_CLOUD_HOST_INFRASTRUCTURE_SERVER: u32 = 124u32;
pub const PRODUCT_CLOUD_STORAGE_SERVER: u32 = 110u32;
pub const PRODUCT_CONNECTED_CAR: u32 = 117u32;
pub const PRODUCT_CORE_ARM: u32 = 97u32;
pub const PRODUCT_CORE_CONNECTED: u32 = 111u32;
pub const PRODUCT_CORE_CONNECTED_COUNTRYSPECIFIC: u32 = 116u32;
pub const PRODUCT_CORE_CONNECTED_N: u32 = 113u32;
pub const PRODUCT_CORE_CONNECTED_SINGLELANGUAGE: u32 = 115u32;
pub const PRODUCT_DATACENTER_EVALUATION_SERVER_CORE: u32 = 159u32;
pub const PRODUCT_DATACENTER_NANO_SERVER: u32 = 143u32;
pub const PRODUCT_DATACENTER_SERVER_AZURE_EDITION: u32 = 407u32;
pub const PRODUCT_DATACENTER_SERVER_CORE_AZURE_EDITION: u32 = 408u32;
pub const PRODUCT_DATACENTER_WS_SERVER_CORE: u32 = 147u32;
pub const PRODUCT_EMBEDDED: u32 = 65u32;
pub const PRODUCT_EMBEDDED_A: u32 = 88u32;
pub const PRODUCT_EMBEDDED_AUTOMOTIVE: u32 = 85u32;
pub const PRODUCT_EMBEDDED_E: u32 = 90u32;
pub const PRODUCT_EMBEDDED_EVAL: u32 = 107u32;
pub const PRODUCT_EMBEDDED_E_EVAL: u32 = 108u32;
pub const PRODUCT_EMBEDDED_INDUSTRY: u32 = 89u32;
pub const PRODUCT_EMBEDDED_INDUSTRY_A: u32 = 86u32;
pub const PRODUCT_EMBEDDED_INDUSTRY_A_E: u32 = 92u32;
pub const PRODUCT_EMBEDDED_INDUSTRY_E: u32 = 91u32;
pub const PRODUCT_EMBEDDED_INDUSTRY_EVAL: u32 = 105u32;
pub const PRODUCT_EMBEDDED_INDUSTRY_E_EVAL: u32 = 106u32;
pub const PRODUCT_ENTERPRISEG: u32 = 171u32;
pub const PRODUCT_ENTERPRISEGN: u32 = 172u32;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION: u32 = 140u32;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION_N: u32 = 141u32;
pub const PRODUCT_HOLOGRAPHIC: u32 = 135u32;
pub const PRODUCT_HOLOGRAPHIC_BUSINESS: u32 = 136u32;
pub const PRODUCT_HUBOS: u32 = 180u32;
pub const PRODUCT_ID_LENGTH: u32 = 16u32;
pub const PRODUCT_INDUSTRY_HANDHELD: u32 = 118u32;
pub const PRODUCT_IOTEDGEOS: u32 = 187u32;
pub const PRODUCT_IOTENTERPRISE: u32 = 188u32;
pub const PRODUCT_IOTENTERPRISES: u32 = 191u32;
pub const PRODUCT_IOTOS: u32 = 185u32;
pub const PRODUCT_LITE: u32 = 189u32;
pub const PRODUCT_NANO_SERVER: u32 = 109u32;
pub const PRODUCT_ONECOREUPDATEOS: u32 = 182u32;
pub const PRODUCT_PPI_PRO: u32 = 119u32;
pub const PRODUCT_PROFESSIONAL_EMBEDDED: u32 = 58u32;
pub const PRODUCT_PROFESSIONAL_S: u32 = 127u32;
pub const PRODUCT_PROFESSIONAL_STUDENT: u32 = 112u32;
pub const PRODUCT_PROFESSIONAL_STUDENT_N: u32 = 114u32;
pub const PRODUCT_PROFESSIONAL_S_N: u32 = 128u32;
pub const PRODUCT_PRO_CHINA: u32 = 139u32;
pub const PRODUCT_PRO_FOR_EDUCATION: u32 = 164u32;
pub const PRODUCT_PRO_FOR_EDUCATION_N: u32 = 165u32;
pub const PRODUCT_PRO_SINGLE_LANGUAGE: u32 = 138u32;
pub const PRODUCT_SERVERRDSH: u32 = 175u32;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE: u32 = 57u32;
pub const PRODUCT_STANDARD_EVALUATION_SERVER_CORE: u32 = 160u32;
pub const PRODUCT_STANDARD_NANO_SERVER: u32 = 144u32;
pub const PRODUCT_STANDARD_SERVER_CORE: u32 = 13u32;
pub const PRODUCT_STANDARD_WS_SERVER_CORE: u32 = 148u32;
pub const PRODUCT_THINPC: u32 = 87u32;
pub const PRODUCT_UNLICENSED: u32 = 2882382797u32;
pub const PRODUCT_UTILITY_VM: u32 = 149u32;
pub const PRODUCT_XBOX_DURANGOHOSTOS: u32 = 196u32;
pub const PRODUCT_XBOX_ERAOS: u32 = 195u32;
pub const PRODUCT_XBOX_GAMEOS: u32 = 194u32;
pub const PRODUCT_XBOX_NATIVEOS: u32 = 193u32;
pub const PRODUCT_XBOX_SCARLETTHOSTOS: u32 = 197u32;
pub const PRODUCT_XBOX_SYSTEMOS: u32 = 192u32;
pub const PROJFS_PROTOCOL_VERSION: u32 = 3u32;
pub type PRTL_UMS_SCHEDULER_ENTRY_POINT = unsafe extern "system" fn(
    reason: RTL_UMS_SCHEDULER_REASON,
    activationpayload: usize,
    schedulerparam: *const ::std::ffi::c_void,
);
#[cfg(feature = "Win32_Foundation")]
pub type PTERMINATION_HANDLER = unsafe extern "system" fn(
    _abnormal_termination: super::super::Foundation::BOOLEAN,
    establisherframe: u64,
);
pub type PTP_CLEANUP_GROUP_CANCEL_CALLBACK = unsafe extern "system" fn(
    objectcontext: *mut ::std::ffi::c_void,
    cleanupcontext: *mut ::std::ffi::c_void,
);
pub type PTP_SIMPLE_CALLBACK = unsafe extern "system" fn(
    instance: *mut TP_CALLBACK_INSTANCE,
    context: *mut ::std::ffi::c_void,
);
pub type PTP_TIMER_CALLBACK = unsafe extern "system" fn(
    instance: *mut TP_CALLBACK_INSTANCE,
    context: *mut ::std::ffi::c_void,
    timer: *mut TP_TIMER,
);
pub type PTP_WAIT_CALLBACK = unsafe extern "system" fn(
    instance: *mut TP_CALLBACK_INSTANCE,
    context: *mut ::std::ffi::c_void,
    wait: *mut TP_WAIT,
    waitresult: u32,
);
pub type PTP_WORK_CALLBACK = unsafe extern "system" fn(
    instance: *mut TP_CALLBACK_INSTANCE,
    context: *mut ::std::ffi::c_void,
    work: *mut TP_WORK,
);
pub type PUMS_SCHEDULER_ENTRY_POINT = unsafe extern "system" fn(
    reason: RTL_UMS_SCHEDULER_REASON,
    activationpayload: usize,
    schedulerparam: *const ::std::ffi::c_void,
);
pub const PcTeb: u32 = 24u32;
pub const QAW_GETEASYWIDTHS: u32 = 1u32;
pub const QAW_GETWIDTHS: u32 = 0u32;
pub const QC_1BIT: u32 = 2u32;
pub const QC_4BIT: u32 = 4u32;
pub const QC_OUTLINES: u32 = 1u32;
pub const QDS_CHECKJPEGFORMAT: u32 = 0u32;
pub const QDS_CHECKPNGFORMAT: u32 = 1u32;
pub const QFD_GLYPHANDBITMAP: i32 = 1i32;
pub const QFD_GLYPHANDOUTLINE: i32 = 2i32;
pub const QFD_MAXEXTENTS: i32 = 3i32;
pub const QFD_TT_GLYPHANDBITMAP: i32 = 4i32;
pub const QFD_TT_GRAY1_BITMAP: i32 = 5i32;
pub const QFD_TT_GRAY2_BITMAP: i32 = 6i32;
pub const QFD_TT_GRAY4_BITMAP: i32 = 8i32;
pub const QFD_TT_GRAY8_BITMAP: i32 = 9i32;
pub const QFD_TT_MONO_BITMAP: i32 = 5i32;
pub const QFF_DESCRIPTION: i32 = 1i32;
pub const QFF_NUMFACES: i32 = 2i32;
pub const QFT_GLYPHSET: i32 = 3i32;
pub const QFT_KERNPAIRS: i32 = 2i32;
pub const QFT_LIGATURES: i32 = 1i32;
pub const QSA_3DNOW: u32 = 16384u32;
pub const QSA_MMX: u32 = 256u32;
pub const QSA_SSE: u32 = 8192u32;
pub const QSA_SSE1: u32 = 8192u32;
pub const QSA_SSE2: u32 = 65536u32;
pub const QSA_SSE3: u32 = 524288u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct QUERY_BAD_RANGES_INPUT {
    pub Flags: u32,
    pub NumRanges: u32,
    pub Ranges: [QUERY_BAD_RANGES_INPUT_RANGE; 1],
}
impl QUERY_BAD_RANGES_INPUT {}
impl ::std::default::Default for QUERY_BAD_RANGES_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for QUERY_BAD_RANGES_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("QUERY_BAD_RANGES_INPUT")
            .field("Flags", &self.Flags)
            .field("NumRanges", &self.NumRanges)
            .field("Ranges", &self.Ranges)
            .finish()
    }
}
impl ::std::cmp::PartialEq for QUERY_BAD_RANGES_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
            && self.NumRanges == other.NumRanges
            && self.Ranges == other.Ranges
    }
}
impl ::std::cmp::Eq for QUERY_BAD_RANGES_INPUT {}
unsafe impl ::windows::runtime::Abi for QUERY_BAD_RANGES_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct QUERY_BAD_RANGES_INPUT_RANGE {
    pub StartOffset: u64,
    pub LengthInBytes: u64,
}
impl QUERY_BAD_RANGES_INPUT_RANGE {}
impl ::std::default::Default for QUERY_BAD_RANGES_INPUT_RANGE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for QUERY_BAD_RANGES_INPUT_RANGE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("QUERY_BAD_RANGES_INPUT_RANGE")
            .field("StartOffset", &self.StartOffset)
            .field("LengthInBytes", &self.LengthInBytes)
            .finish()
    }
}
impl ::std::cmp::PartialEq for QUERY_BAD_RANGES_INPUT_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.StartOffset == other.StartOffset && self.LengthInBytes == other.LengthInBytes
    }
}
impl ::std::cmp::Eq for QUERY_BAD_RANGES_INPUT_RANGE {}
unsafe impl ::windows::runtime::Abi for QUERY_BAD_RANGES_INPUT_RANGE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct QUERY_BAD_RANGES_OUTPUT {
    pub Flags: u32,
    pub NumBadRanges: u32,
    pub NextOffsetToLookUp: u64,
    pub BadRanges: [QUERY_BAD_RANGES_OUTPUT_RANGE; 1],
}
impl QUERY_BAD_RANGES_OUTPUT {}
impl ::std::default::Default for QUERY_BAD_RANGES_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for QUERY_BAD_RANGES_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("QUERY_BAD_RANGES_OUTPUT")
            .field("Flags", &self.Flags)
            .field("NumBadRanges", &self.NumBadRanges)
            .field("NextOffsetToLookUp", &self.NextOffsetToLookUp)
            .field("BadRanges", &self.BadRanges)
            .finish()
    }
}
impl ::std::cmp::PartialEq for QUERY_BAD_RANGES_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
            && self.NumBadRanges == other.NumBadRanges
            && self.NextOffsetToLookUp == other.NextOffsetToLookUp
            && self.BadRanges == other.BadRanges
    }
}
impl ::std::cmp::Eq for QUERY_BAD_RANGES_OUTPUT {}
unsafe impl ::windows::runtime::Abi for QUERY_BAD_RANGES_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct QUERY_BAD_RANGES_OUTPUT_RANGE {
    pub Flags: u32,
    pub Reserved: u32,
    pub StartOffset: u64,
    pub LengthInBytes: u64,
}
impl QUERY_BAD_RANGES_OUTPUT_RANGE {}
impl ::std::default::Default for QUERY_BAD_RANGES_OUTPUT_RANGE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for QUERY_BAD_RANGES_OUTPUT_RANGE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("QUERY_BAD_RANGES_OUTPUT_RANGE")
            .field("Flags", &self.Flags)
            .field("Reserved", &self.Reserved)
            .field("StartOffset", &self.StartOffset)
            .field("LengthInBytes", &self.LengthInBytes)
            .finish()
    }
}
impl ::std::cmp::PartialEq for QUERY_BAD_RANGES_OUTPUT_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
            && self.Reserved == other.Reserved
            && self.StartOffset == other.StartOffset
            && self.LengthInBytes == other.LengthInBytes
    }
}
impl ::std::cmp::Eq for QUERY_BAD_RANGES_OUTPUT_RANGE {}
unsafe impl ::windows::runtime::Abi for QUERY_BAD_RANGES_OUTPUT_RANGE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_GUEST_VOLUMES: u32 = 2u32;
pub const QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_HOST_VOLUMES: u32 = 1u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct QUERY_FILE_LAYOUT_FILTER_TYPE(pub i32);
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_NONE: QUERY_FILE_LAYOUT_FILTER_TYPE =
    QUERY_FILE_LAYOUT_FILTER_TYPE(0i32);
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_CLUSTERS: QUERY_FILE_LAYOUT_FILTER_TYPE =
    QUERY_FILE_LAYOUT_FILTER_TYPE(1i32);
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_FILEID: QUERY_FILE_LAYOUT_FILTER_TYPE =
    QUERY_FILE_LAYOUT_FILTER_TYPE(2i32);
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_STORAGE_RESERVE_ID: QUERY_FILE_LAYOUT_FILTER_TYPE =
    QUERY_FILE_LAYOUT_FILTER_TYPE(3i32);
pub const QUERY_FILE_LAYOUT_NUM_FILTER_TYPES: QUERY_FILE_LAYOUT_FILTER_TYPE =
    QUERY_FILE_LAYOUT_FILTER_TYPE(4i32);
impl ::std::convert::From<i32> for QUERY_FILE_LAYOUT_FILTER_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for QUERY_FILE_LAYOUT_FILTER_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const QUERY_FILE_LAYOUT_INCLUDE_EXTENTS: u32 = 8u32;
pub const QUERY_FILE_LAYOUT_INCLUDE_EXTRA_INFO: u32 = 16u32;
pub const QUERY_FILE_LAYOUT_INCLUDE_FILES_WITH_DSC_ATTRIBUTE: u32 = 4096u32;
pub const QUERY_FILE_LAYOUT_INCLUDE_FULL_PATH_IN_NAMES: u32 = 64u32;
pub const QUERY_FILE_LAYOUT_INCLUDE_NAMES: u32 = 2u32;
pub const QUERY_FILE_LAYOUT_INCLUDE_ONLY_FILES_WITH_SPECIFIC_ATTRIBUTES: u32 = 2048u32;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAMS: u32 = 4u32;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAMS_WITH_NO_CLUSTERS_ALLOCATED: u32 = 32u32;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION: u32 = 128u32;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_DATA_ATTRIBUTE: u32 = 8192u32;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_DSC_ATTRIBUTE: u32 = 256u32;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_EA_ATTRIBUTE: u32 = 32768u32;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_EFS_ATTRIBUTE: u32 = 1024u32;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_REPARSE_ATTRIBUTE: u32 = 16384u32;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_TXF_ATTRIBUTE: u32 = 512u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct QUERY_FILE_LAYOUT_INPUT {
    pub Anonymous: QUERY_FILE_LAYOUT_INPUT_0,
    pub Flags: u32,
    pub FilterType: QUERY_FILE_LAYOUT_FILTER_TYPE,
    pub Reserved: u32,
    pub Filter: QUERY_FILE_LAYOUT_INPUT_1,
}
impl QUERY_FILE_LAYOUT_INPUT {}
impl ::std::default::Default for QUERY_FILE_LAYOUT_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for QUERY_FILE_LAYOUT_INPUT {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for QUERY_FILE_LAYOUT_INPUT {}
unsafe impl ::windows::runtime::Abi for QUERY_FILE_LAYOUT_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union QUERY_FILE_LAYOUT_INPUT_0 {
    pub FilterEntryCount: u32,
    pub NumberOfPairs: u32,
}
impl QUERY_FILE_LAYOUT_INPUT_0 {}
impl ::std::default::Default for QUERY_FILE_LAYOUT_INPUT_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for QUERY_FILE_LAYOUT_INPUT_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for QUERY_FILE_LAYOUT_INPUT_0 {}
unsafe impl ::windows::runtime::Abi for QUERY_FILE_LAYOUT_INPUT_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union QUERY_FILE_LAYOUT_INPUT_1 {
    pub ClusterRanges: [CLUSTER_RANGE; 1],
    pub FileReferenceRanges: [FILE_REFERENCE_RANGE; 1],
    pub StorageReserveIds: [STORAGE_RESERVE_ID; 1],
}
impl QUERY_FILE_LAYOUT_INPUT_1 {}
impl ::std::default::Default for QUERY_FILE_LAYOUT_INPUT_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for QUERY_FILE_LAYOUT_INPUT_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for QUERY_FILE_LAYOUT_INPUT_1 {}
unsafe impl ::windows::runtime::Abi for QUERY_FILE_LAYOUT_INPUT_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct QUERY_FILE_LAYOUT_OUTPUT {
    pub FileEntryCount: u32,
    pub FirstFileOffset: u32,
    pub Flags: u32,
    pub Reserved: u32,
}
impl QUERY_FILE_LAYOUT_OUTPUT {}
impl ::std::default::Default for QUERY_FILE_LAYOUT_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for QUERY_FILE_LAYOUT_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("QUERY_FILE_LAYOUT_OUTPUT")
            .field("FileEntryCount", &self.FileEntryCount)
            .field("FirstFileOffset", &self.FirstFileOffset)
            .field("Flags", &self.Flags)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for QUERY_FILE_LAYOUT_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.FileEntryCount == other.FileEntryCount
            && self.FirstFileOffset == other.FirstFileOffset
            && self.Flags == other.Flags
            && self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for QUERY_FILE_LAYOUT_OUTPUT {}
unsafe impl ::windows::runtime::Abi for QUERY_FILE_LAYOUT_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const QUERY_FILE_LAYOUT_REPARSE_DATA_INVALID: u32 = 1u32;
pub const QUERY_FILE_LAYOUT_REPARSE_TAG_INVALID: u32 = 2u32;
pub const QUERY_FILE_LAYOUT_RESTART: u32 = 1u32;
pub const QUERY_FILE_LAYOUT_SINGLE_INSTANCED: u32 = 1u32;
pub const QUERY_STORAGE_CLASSES_FLAGS_MEASURE_READ: u32 = 1073741824u32;
pub const QUERY_STORAGE_CLASSES_FLAGS_MEASURE_WRITE: u32 = 2147483648u32;
pub const QUERY_STORAGE_CLASSES_FLAGS_NO_DEFRAG_VOLUME: u32 = 536870912u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct QUOTA_LIMITS_EX {
    pub PagedPoolLimit: usize,
    pub NonPagedPoolLimit: usize,
    pub MinimumWorkingSetSize: usize,
    pub MaximumWorkingSetSize: usize,
    pub PagefileLimit: usize,
    pub TimeLimit: i64,
    pub WorkingSetLimit: usize,
    pub Reserved2: usize,
    pub Reserved3: usize,
    pub Reserved4: usize,
    pub Flags: u32,
    pub CpuRateLimit: RATE_QUOTA_LIMIT,
}
impl QUOTA_LIMITS_EX {}
impl ::std::default::Default for QUOTA_LIMITS_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for QUOTA_LIMITS_EX {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for QUOTA_LIMITS_EX {}
unsafe impl ::windows::runtime::Abi for QUOTA_LIMITS_EX {
    type Abi = Self;
    type DefaultType = Self;
}
pub const QUOTA_LIMITS_HARDWS_MAX_DISABLE: u32 = 8u32;
pub const QUOTA_LIMITS_HARDWS_MAX_ENABLE: u32 = 4u32;
pub const QUOTA_LIMITS_HARDWS_MIN_DISABLE: u32 = 2u32;
pub const QUOTA_LIMITS_HARDWS_MIN_ENABLE: u32 = 1u32;
pub const QUOTA_LIMITS_USE_DEFAULT_LIMITS: u32 = 16u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union RATE_QUOTA_LIMIT {
    pub RateData: u32,
    pub Anonymous: RATE_QUOTA_LIMIT_0,
}
impl RATE_QUOTA_LIMIT {}
impl ::std::default::Default for RATE_QUOTA_LIMIT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for RATE_QUOTA_LIMIT {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for RATE_QUOTA_LIMIT {}
unsafe impl ::windows::runtime::Abi for RATE_QUOTA_LIMIT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct RATE_QUOTA_LIMIT_0 {
    pub _bitfield: u32,
}
impl RATE_QUOTA_LIMIT_0 {}
impl ::std::default::Default for RATE_QUOTA_LIMIT_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for RATE_QUOTA_LIMIT_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for RATE_QUOTA_LIMIT_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for RATE_QUOTA_LIMIT_0 {}
unsafe impl ::windows::runtime::Abi for RATE_QUOTA_LIMIT_0 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const RB_DITHERCOLOR: i32 = -2147483648i32;
pub const READ_ATTRIBUTES: u32 = 208u32;
pub const READ_ATTRIBUTE_BUFFER_SIZE: u32 = 512u32;
pub const READ_COMPRESSION_INFO_VALID: u32 = 32u32;
pub const READ_COPY_NUMBER_BYPASS_CACHE_FLAG: u32 = 256u32;
pub const READ_COPY_NUMBER_KEY: u32 = 1380142592u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct READ_ELEMENT_ADDRESS_INFO {
    pub NumberOfElements: u32,
    pub ElementStatus: [CHANGER_ELEMENT_STATUS; 1],
}
impl READ_ELEMENT_ADDRESS_INFO {}
impl ::std::default::Default for READ_ELEMENT_ADDRESS_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for READ_ELEMENT_ADDRESS_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("READ_ELEMENT_ADDRESS_INFO")
            .field("NumberOfElements", &self.NumberOfElements)
            .field("ElementStatus", &self.ElementStatus)
            .finish()
    }
}
impl ::std::cmp::PartialEq for READ_ELEMENT_ADDRESS_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.NumberOfElements == other.NumberOfElements && self.ElementStatus == other.ElementStatus
    }
}
impl ::std::cmp::Eq for READ_ELEMENT_ADDRESS_INFO {}
unsafe impl ::windows::runtime::Abi for READ_ELEMENT_ADDRESS_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
pub const READ_THREAD_PROFILING_FLAG_DISPATCHING: u32 = 1u32;
pub const READ_THREAD_PROFILING_FLAG_HARDWARE_COUNTERS: u32 = 2u32;
pub const READ_THRESHOLDS: u32 = 209u32;
pub const READ_THRESHOLD_BUFFER_SIZE: u32 = 512u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct REARRANGE_FILE_DATA {
    pub SourceStartingOffset: u64,
    pub TargetOffset: u64,
    pub SourceFileHandle: super::super::Foundation::HANDLE,
    pub Length: u32,
    pub Flags: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl REARRANGE_FILE_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for REARRANGE_FILE_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for REARRANGE_FILE_DATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("REARRANGE_FILE_DATA")
            .field("SourceStartingOffset", &self.SourceStartingOffset)
            .field("TargetOffset", &self.TargetOffset)
            .field("SourceFileHandle", &self.SourceFileHandle)
            .field("Length", &self.Length)
            .field("Flags", &self.Flags)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for REARRANGE_FILE_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.SourceStartingOffset == other.SourceStartingOffset
            && self.TargetOffset == other.TargetOffset
            && self.SourceFileHandle == other.SourceFileHandle
            && self.Length == other.Length
            && self.Flags == other.Flags
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for REARRANGE_FILE_DATA {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for REARRANGE_FILE_DATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct REARRANGE_FILE_DATA32 {
    pub SourceStartingOffset: u64,
    pub TargetOffset: u64,
    pub SourceFileHandle: u32,
    pub Length: u32,
    pub Flags: u32,
}
impl REARRANGE_FILE_DATA32 {}
impl ::std::default::Default for REARRANGE_FILE_DATA32 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for REARRANGE_FILE_DATA32 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("REARRANGE_FILE_DATA32")
            .field("SourceStartingOffset", &self.SourceStartingOffset)
            .field("TargetOffset", &self.TargetOffset)
            .field("SourceFileHandle", &self.SourceFileHandle)
            .field("Length", &self.Length)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for REARRANGE_FILE_DATA32 {
    fn eq(&self, other: &Self) -> bool {
        self.SourceStartingOffset == other.SourceStartingOffset
            && self.TargetOffset == other.TargetOffset
            && self.SourceFileHandle == other.SourceFileHandle
            && self.Length == other.Length
            && self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for REARRANGE_FILE_DATA32 {}
unsafe impl ::windows::runtime::Abi for REARRANGE_FILE_DATA32 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct REASON_CONTEXT {
    pub Version: u32,
    pub Flags: POWER_REQUEST_CONTEXT_FLAGS,
    pub Reason: REASON_CONTEXT_0,
}
#[cfg(feature = "Win32_Foundation")]
impl REASON_CONTEXT {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for REASON_CONTEXT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for REASON_CONTEXT {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for REASON_CONTEXT {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for REASON_CONTEXT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub union REASON_CONTEXT_0 {
    pub Detailed: REASON_CONTEXT_0_0,
    pub SimpleReasonString: super::super::Foundation::PWSTR,
}
#[cfg(feature = "Win32_Foundation")]
impl REASON_CONTEXT_0 {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for REASON_CONTEXT_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for REASON_CONTEXT_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for REASON_CONTEXT_0 {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for REASON_CONTEXT_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct REASON_CONTEXT_0_0 {
    pub LocalizedReasonModule: super::super::Foundation::HINSTANCE,
    pub LocalizedReasonId: u32,
    pub ReasonStringCount: u32,
    pub ReasonStrings: *mut super::super::Foundation::PWSTR,
}
#[cfg(feature = "Win32_Foundation")]
impl REASON_CONTEXT_0_0 {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for REASON_CONTEXT_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for REASON_CONTEXT_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Detailed_e__Struct")
            .field("LocalizedReasonModule", &self.LocalizedReasonModule)
            .field("LocalizedReasonId", &self.LocalizedReasonId)
            .field("ReasonStringCount", &self.ReasonStringCount)
            .field("ReasonStrings", &self.ReasonStrings)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for REASON_CONTEXT_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.LocalizedReasonModule == other.LocalizedReasonModule
            && self.LocalizedReasonId == other.LocalizedReasonId
            && self.ReasonStringCount == other.ReasonStringCount
            && self.ReasonStrings == other.ReasonStrings
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for REASON_CONTEXT_0_0 {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for REASON_CONTEXT_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const RECOVERED_READS_VALID: u32 = 4u32;
pub const RECOVERED_WRITES_VALID: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct RECTFX {
    pub xLeft: i32,
    pub yTop: i32,
    pub xRight: i32,
    pub yBottom: i32,
}
impl RECTFX {}
impl ::std::default::Default for RECTFX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for RECTFX {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RECTFX")
            .field("xLeft", &self.xLeft)
            .field("yTop", &self.yTop)
            .field("xRight", &self.xRight)
            .field("yBottom", &self.yBottom)
            .finish()
    }
}
impl ::std::cmp::PartialEq for RECTFX {
    fn eq(&self, other: &Self) -> bool {
        self.xLeft == other.xLeft
            && self.yTop == other.yTop
            && self.xRight == other.xRight
            && self.yBottom == other.yBottom
    }
}
impl ::std::cmp::Eq for RECTFX {}
unsafe impl ::windows::runtime::Abi for RECTFX {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO {
    pub Version: u32,
    pub Accurate: u32,
    pub Supported: u32,
    pub AccurateMask0: u32,
}
impl REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO {}
impl ::std::default::Default for REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO")
            .field("Version", &self.Version)
            .field("Accurate", &self.Accurate)
            .field("Supported", &self.Supported)
            .field("AccurateMask0", &self.AccurateMask0)
            .finish()
    }
}
impl ::std::cmp::PartialEq for REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Accurate == other.Accurate
            && self.Supported == other.Supported
            && self.AccurateMask0 == other.AccurateMask0
    }
}
impl ::std::cmp::Eq for REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO {}
unsafe impl ::windows::runtime::Abi for REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
pub const REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO_VERSION: u32 = 1u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct REFS_SMR_VOLUME_GC_ACTION(pub i32);
pub const SmrGcActionStart: REFS_SMR_VOLUME_GC_ACTION = REFS_SMR_VOLUME_GC_ACTION(1i32);
pub const SmrGcActionStartFullSpeed: REFS_SMR_VOLUME_GC_ACTION = REFS_SMR_VOLUME_GC_ACTION(2i32);
pub const SmrGcActionPause: REFS_SMR_VOLUME_GC_ACTION = REFS_SMR_VOLUME_GC_ACTION(3i32);
pub const SmrGcActionStop: REFS_SMR_VOLUME_GC_ACTION = REFS_SMR_VOLUME_GC_ACTION(4i32);
impl ::std::convert::From<i32> for REFS_SMR_VOLUME_GC_ACTION {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for REFS_SMR_VOLUME_GC_ACTION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct REFS_SMR_VOLUME_GC_METHOD(pub i32);
pub const SmrGcMethodCompaction: REFS_SMR_VOLUME_GC_METHOD = REFS_SMR_VOLUME_GC_METHOD(1i32);
pub const SmrGcMethodCompression: REFS_SMR_VOLUME_GC_METHOD = REFS_SMR_VOLUME_GC_METHOD(2i32);
pub const SmrGcMethodRotation: REFS_SMR_VOLUME_GC_METHOD = REFS_SMR_VOLUME_GC_METHOD(3i32);
impl ::std::convert::From<i32> for REFS_SMR_VOLUME_GC_METHOD {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for REFS_SMR_VOLUME_GC_METHOD {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct REFS_SMR_VOLUME_GC_PARAMETERS {
    pub Version: u32,
    pub Flags: u32,
    pub Action: REFS_SMR_VOLUME_GC_ACTION,
    pub Method: REFS_SMR_VOLUME_GC_METHOD,
    pub IoGranularity: u32,
    pub CompressionFormat: u32,
    pub Unused: [u64; 8],
}
impl REFS_SMR_VOLUME_GC_PARAMETERS {}
impl ::std::default::Default for REFS_SMR_VOLUME_GC_PARAMETERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for REFS_SMR_VOLUME_GC_PARAMETERS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("REFS_SMR_VOLUME_GC_PARAMETERS")
            .field("Version", &self.Version)
            .field("Flags", &self.Flags)
            .field("Action", &self.Action)
            .field("Method", &self.Method)
            .field("IoGranularity", &self.IoGranularity)
            .field("CompressionFormat", &self.CompressionFormat)
            .field("Unused", &self.Unused)
            .finish()
    }
}
impl ::std::cmp::PartialEq for REFS_SMR_VOLUME_GC_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Flags == other.Flags
            && self.Action == other.Action
            && self.Method == other.Method
            && self.IoGranularity == other.IoGranularity
            && self.CompressionFormat == other.CompressionFormat
            && self.Unused == other.Unused
    }
}
impl ::std::cmp::Eq for REFS_SMR_VOLUME_GC_PARAMETERS {}
unsafe impl ::windows::runtime::Abi for REFS_SMR_VOLUME_GC_PARAMETERS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const REFS_SMR_VOLUME_GC_PARAMETERS_VERSION_V1: u32 = 1u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct REFS_SMR_VOLUME_GC_STATE(pub i32);
pub const SmrGcStateInactive: REFS_SMR_VOLUME_GC_STATE = REFS_SMR_VOLUME_GC_STATE(0i32);
pub const SmrGcStatePaused: REFS_SMR_VOLUME_GC_STATE = REFS_SMR_VOLUME_GC_STATE(1i32);
pub const SmrGcStateActive: REFS_SMR_VOLUME_GC_STATE = REFS_SMR_VOLUME_GC_STATE(2i32);
pub const SmrGcStateActiveFullSpeed: REFS_SMR_VOLUME_GC_STATE = REFS_SMR_VOLUME_GC_STATE(3i32);
impl ::std::convert::From<i32> for REFS_SMR_VOLUME_GC_STATE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for REFS_SMR_VOLUME_GC_STATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct REFS_SMR_VOLUME_INFO_OUTPUT {
    pub Version: u32,
    pub Flags: u32,
    pub SizeOfRandomlyWritableTier: i64,
    pub FreeSpaceInRandomlyWritableTier: i64,
    pub SizeofSMRTier: i64,
    pub FreeSpaceInSMRTier: i64,
    pub UsableFreeSpaceInSMRTier: i64,
    pub VolumeGcState: REFS_SMR_VOLUME_GC_STATE,
    pub VolumeGcLastStatus: u32,
    pub CurrentGcBandFillPercentage: u32,
    pub Unused: [u64; 6],
}
impl REFS_SMR_VOLUME_INFO_OUTPUT {}
impl ::std::default::Default for REFS_SMR_VOLUME_INFO_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for REFS_SMR_VOLUME_INFO_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("REFS_SMR_VOLUME_INFO_OUTPUT")
            .field("Version", &self.Version)
            .field("Flags", &self.Flags)
            .field(
                "SizeOfRandomlyWritableTier",
                &self.SizeOfRandomlyWritableTier,
            )
            .field(
                "FreeSpaceInRandomlyWritableTier",
                &self.FreeSpaceInRandomlyWritableTier,
            )
            .field("SizeofSMRTier", &self.SizeofSMRTier)
            .field("FreeSpaceInSMRTier", &self.FreeSpaceInSMRTier)
            .field("UsableFreeSpaceInSMRTier", &self.UsableFreeSpaceInSMRTier)
            .field("VolumeGcState", &self.VolumeGcState)
            .field("VolumeGcLastStatus", &self.VolumeGcLastStatus)
            .field(
                "CurrentGcBandFillPercentage",
                &self.CurrentGcBandFillPercentage,
            )
            .field("Unused", &self.Unused)
            .finish()
    }
}
impl ::std::cmp::PartialEq for REFS_SMR_VOLUME_INFO_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Flags == other.Flags
            && self.SizeOfRandomlyWritableTier == other.SizeOfRandomlyWritableTier
            && self.FreeSpaceInRandomlyWritableTier == other.FreeSpaceInRandomlyWritableTier
            && self.SizeofSMRTier == other.SizeofSMRTier
            && self.FreeSpaceInSMRTier == other.FreeSpaceInSMRTier
            && self.UsableFreeSpaceInSMRTier == other.UsableFreeSpaceInSMRTier
            && self.VolumeGcState == other.VolumeGcState
            && self.VolumeGcLastStatus == other.VolumeGcLastStatus
            && self.CurrentGcBandFillPercentage == other.CurrentGcBandFillPercentage
            && self.Unused == other.Unused
    }
}
impl ::std::cmp::Eq for REFS_SMR_VOLUME_INFO_OUTPUT {}
unsafe impl ::windows::runtime::Abi for REFS_SMR_VOLUME_INFO_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const REFS_SMR_VOLUME_INFO_OUTPUT_VERSION_V0: u32 = 0u32;
pub const REFS_SMR_VOLUME_INFO_OUTPUT_VERSION_V1: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct REFS_VOLUME_DATA_BUFFER {
    pub ByteCount: u32,
    pub MajorVersion: u32,
    pub MinorVersion: u32,
    pub BytesPerPhysicalSector: u32,
    pub VolumeSerialNumber: i64,
    pub NumberSectors: i64,
    pub TotalClusters: i64,
    pub FreeClusters: i64,
    pub TotalReserved: i64,
    pub BytesPerSector: u32,
    pub BytesPerCluster: u32,
    pub MaximumSizeOfResidentFile: i64,
    pub FastTierDataFillRatio: u16,
    pub SlowTierDataFillRatio: u16,
    pub DestagesFastTierToSlowTierRate: u32,
    pub Reserved: [i64; 9],
}
impl REFS_VOLUME_DATA_BUFFER {}
impl ::std::default::Default for REFS_VOLUME_DATA_BUFFER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for REFS_VOLUME_DATA_BUFFER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("REFS_VOLUME_DATA_BUFFER")
            .field("ByteCount", &self.ByteCount)
            .field("MajorVersion", &self.MajorVersion)
            .field("MinorVersion", &self.MinorVersion)
            .field("BytesPerPhysicalSector", &self.BytesPerPhysicalSector)
            .field("VolumeSerialNumber", &self.VolumeSerialNumber)
            .field("NumberSectors", &self.NumberSectors)
            .field("TotalClusters", &self.TotalClusters)
            .field("FreeClusters", &self.FreeClusters)
            .field("TotalReserved", &self.TotalReserved)
            .field("BytesPerSector", &self.BytesPerSector)
            .field("BytesPerCluster", &self.BytesPerCluster)
            .field("MaximumSizeOfResidentFile", &self.MaximumSizeOfResidentFile)
            .field("FastTierDataFillRatio", &self.FastTierDataFillRatio)
            .field("SlowTierDataFillRatio", &self.SlowTierDataFillRatio)
            .field(
                "DestagesFastTierToSlowTierRate",
                &self.DestagesFastTierToSlowTierRate,
            )
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for REFS_VOLUME_DATA_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.ByteCount == other.ByteCount
            && self.MajorVersion == other.MajorVersion
            && self.MinorVersion == other.MinorVersion
            && self.BytesPerPhysicalSector == other.BytesPerPhysicalSector
            && self.VolumeSerialNumber == other.VolumeSerialNumber
            && self.NumberSectors == other.NumberSectors
            && self.TotalClusters == other.TotalClusters
            && self.FreeClusters == other.FreeClusters
            && self.TotalReserved == other.TotalReserved
            && self.BytesPerSector == other.BytesPerSector
            && self.BytesPerCluster == other.BytesPerCluster
            && self.MaximumSizeOfResidentFile == other.MaximumSizeOfResidentFile
            && self.FastTierDataFillRatio == other.FastTierDataFillRatio
            && self.SlowTierDataFillRatio == other.SlowTierDataFillRatio
            && self.DestagesFastTierToSlowTierRate == other.DestagesFastTierToSlowTierRate
            && self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for REFS_VOLUME_DATA_BUFFER {}
unsafe impl ::windows::runtime::Abi for REFS_VOLUME_DATA_BUFFER {
    type Abi = Self;
    type DefaultType = Self;
}
pub const REG_APP_HIVE: i32 = 16i32;
pub const REG_APP_HIVE_OPEN_READ_ONLY: i32 = 8192i32;
pub const REG_BOOT_HIVE: i32 = 1024i32;
pub const REG_FLUSH_HIVE_FILE_GROWTH: i32 = 4096i32;
pub const REG_FORCE_UNLOAD: u32 = 1u32;
pub const REG_HIVE_EXACT_FILE_GROWTH: i32 = 128i32;
pub const REG_HIVE_NO_RM: i32 = 256i32;
pub const REG_HIVE_SINGLE_LOG: i32 = 512i32;
pub const REG_IMMUTABLE: i32 = 16384i32;
pub const REG_LOAD_HIVE_OPEN_HANDLE: i32 = 2048i32;
pub const REG_NO_IMPERSONATION_FALLBACK: i32 = 32768i32;
pub const REG_NO_LAZY_FLUSH: i32 = 4i32;
pub const REG_OPEN_READ_ONLY: i32 = 8192i32;
pub const REG_PROCESS_PRIVATE: i32 = 32i32;
pub const REG_REFRESH_HIVE: i32 = 2i32;
pub const REG_START_JOURNAL: i32 = 64i32;
pub const REG_UNLOAD_LEGAL_FLAGS: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct REMOVE_ELEMENT_AND_TRUNCATE_REQUEST {
    pub Version: u32,
    pub Size: u32,
    pub RequestCapacity: u64,
    pub ElementIdentifier: u32,
    pub Reserved: u32,
}
impl REMOVE_ELEMENT_AND_TRUNCATE_REQUEST {}
impl ::std::default::Default for REMOVE_ELEMENT_AND_TRUNCATE_REQUEST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for REMOVE_ELEMENT_AND_TRUNCATE_REQUEST {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("REMOVE_ELEMENT_AND_TRUNCATE_REQUEST")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("RequestCapacity", &self.RequestCapacity)
            .field("ElementIdentifier", &self.ElementIdentifier)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for REMOVE_ELEMENT_AND_TRUNCATE_REQUEST {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.RequestCapacity == other.RequestCapacity
            && self.ElementIdentifier == other.ElementIdentifier
            && self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for REMOVE_ELEMENT_AND_TRUNCATE_REQUEST {}
unsafe impl ::windows::runtime::Abi for REMOVE_ELEMENT_AND_TRUNCATE_REQUEST {
    type Abi = Self;
    type DefaultType = Self;
}
pub const REPLACE_ALTERNATE: u32 = 11u32;
pub const REPLACE_PRIMARY: u32 = 10u32;
pub const REQUEST_OPLOCK_CURRENT_VERSION: u32 = 1u32;
pub const REQUEST_OPLOCK_INPUT_FLAG_ACK: u32 = 2u32;
pub const REQUEST_OPLOCK_INPUT_FLAG_COMPLETE_ACK_ON_CLOSE: u32 = 4u32;
pub const REQUEST_OPLOCK_INPUT_FLAG_REQUEST: u32 = 1u32;
pub const REQUEST_OPLOCK_OUTPUT_FLAG_ACK_REQUIRED: u32 = 1u32;
pub const REQUEST_OPLOCK_OUTPUT_FLAG_MODES_PROVIDED: u32 = 2u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct REQUEST_RAW_ENCRYPTED_DATA {
    pub FileOffset: i64,
    pub Length: u32,
}
impl REQUEST_RAW_ENCRYPTED_DATA {}
impl ::std::default::Default for REQUEST_RAW_ENCRYPTED_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for REQUEST_RAW_ENCRYPTED_DATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("REQUEST_RAW_ENCRYPTED_DATA")
            .field("FileOffset", &self.FileOffset)
            .field("Length", &self.Length)
            .finish()
    }
}
impl ::std::cmp::PartialEq for REQUEST_RAW_ENCRYPTED_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.FileOffset == other.FileOffset && self.Length == other.Length
    }
}
impl ::std::cmp::Eq for REQUEST_RAW_ENCRYPTED_DATA {}
unsafe impl ::windows::runtime::Abi for REQUEST_RAW_ENCRYPTED_DATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct RESOURCEMANAGER_BASIC_INFORMATION {
    pub ResourceManagerId: ::windows::runtime::GUID,
    pub DescriptionLength: u32,
    pub Description: [u16; 1],
}
impl RESOURCEMANAGER_BASIC_INFORMATION {}
impl ::std::default::Default for RESOURCEMANAGER_BASIC_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for RESOURCEMANAGER_BASIC_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RESOURCEMANAGER_BASIC_INFORMATION")
            .field("ResourceManagerId", &self.ResourceManagerId)
            .field("DescriptionLength", &self.DescriptionLength)
            .field("Description", &self.Description)
            .finish()
    }
}
impl ::std::cmp::PartialEq for RESOURCEMANAGER_BASIC_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.ResourceManagerId == other.ResourceManagerId
            && self.DescriptionLength == other.DescriptionLength
            && self.Description == other.Description
    }
}
impl ::std::cmp::Eq for RESOURCEMANAGER_BASIC_INFORMATION {}
unsafe impl ::windows::runtime::Abi for RESOURCEMANAGER_BASIC_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const RESOURCEMANAGER_COMPLETE_PROPAGATION: u32 = 64u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct RESOURCEMANAGER_COMPLETION_INFORMATION {
    pub IoCompletionPortHandle: super::super::Foundation::HANDLE,
    pub CompletionKey: usize,
}
#[cfg(feature = "Win32_Foundation")]
impl RESOURCEMANAGER_COMPLETION_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for RESOURCEMANAGER_COMPLETION_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for RESOURCEMANAGER_COMPLETION_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RESOURCEMANAGER_COMPLETION_INFORMATION")
            .field("IoCompletionPortHandle", &self.IoCompletionPortHandle)
            .field("CompletionKey", &self.CompletionKey)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for RESOURCEMANAGER_COMPLETION_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.IoCompletionPortHandle == other.IoCompletionPortHandle
            && self.CompletionKey == other.CompletionKey
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for RESOURCEMANAGER_COMPLETION_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for RESOURCEMANAGER_COMPLETION_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const RESOURCEMANAGER_ENLIST: u32 = 8u32;
pub const RESOURCEMANAGER_GET_NOTIFICATION: u32 = 16u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct RESOURCEMANAGER_INFORMATION_CLASS(pub i32);
pub const ResourceManagerBasicInformation: RESOURCEMANAGER_INFORMATION_CLASS =
    RESOURCEMANAGER_INFORMATION_CLASS(0i32);
pub const ResourceManagerCompletionInformation: RESOURCEMANAGER_INFORMATION_CLASS =
    RESOURCEMANAGER_INFORMATION_CLASS(1i32);
impl ::std::convert::From<i32> for RESOURCEMANAGER_INFORMATION_CLASS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for RESOURCEMANAGER_INFORMATION_CLASS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const RESOURCEMANAGER_QUERY_INFORMATION: u32 = 1u32;
pub const RESOURCEMANAGER_RECOVER: u32 = 4u32;
pub const RESOURCEMANAGER_REGISTER_PROTOCOL: u32 = 32u32;
pub const RESOURCEMANAGER_SET_INFORMATION: u32 = 2u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct RESUME_PERFORMANCE {
    pub PostTimeMs: u32,
    pub TotalResumeTimeMs: u64,
    pub ResumeCompleteTimestamp: u64,
}
impl RESUME_PERFORMANCE {}
impl ::std::default::Default for RESUME_PERFORMANCE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for RESUME_PERFORMANCE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RESUME_PERFORMANCE")
            .field("PostTimeMs", &self.PostTimeMs)
            .field("TotalResumeTimeMs", &self.TotalResumeTimeMs)
            .field("ResumeCompleteTimestamp", &self.ResumeCompleteTimestamp)
            .finish()
    }
}
impl ::std::cmp::PartialEq for RESUME_PERFORMANCE {
    fn eq(&self, other: &Self) -> bool {
        self.PostTimeMs == other.PostTimeMs
            && self.TotalResumeTimeMs == other.TotalResumeTimeMs
            && self.ResumeCompleteTimestamp == other.ResumeCompleteTimestamp
    }
}
impl ::std::cmp::Eq for RESUME_PERFORMANCE {}
unsafe impl ::windows::runtime::Abi for RESUME_PERFORMANCE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const RETRACT_IEPORT: u32 = 3u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER {
    pub ExtentCount: u32,
    pub StartingVcn: i64,
    pub Extents: [RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0; 1],
}
impl RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER {}
impl ::std::default::Default for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER")
            .field("ExtentCount", &self.ExtentCount)
            .field("StartingVcn", &self.StartingVcn)
            .field("Extents", &self.Extents)
            .finish()
    }
}
impl ::std::cmp::PartialEq for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.ExtentCount == other.ExtentCount
            && self.StartingVcn == other.StartingVcn
            && self.Extents == other.Extents
    }
}
impl ::std::cmp::Eq for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER {}
unsafe impl ::windows::runtime::Abi for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0 {
    pub NextVcn: i64,
    pub Lcn: i64,
    pub ReferenceCount: u32,
}
impl RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0 {}
impl ::std::default::Default for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("NextVcn", &self.NextVcn)
            .field("Lcn", &self.Lcn)
            .field("ReferenceCount", &self.ReferenceCount)
            .finish()
    }
}
impl ::std::cmp::PartialEq for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0 {
    fn eq(&self, other: &Self) -> bool {
        self.NextVcn == other.NextVcn
            && self.Lcn == other.Lcn
            && self.ReferenceCount == other.ReferenceCount
    }
}
impl ::std::cmp::Eq for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0 {}
unsafe impl ::windows::runtime::Abi for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct RETRIEVAL_POINTER_COUNT {
    pub ExtentCount: u32,
}
impl RETRIEVAL_POINTER_COUNT {}
impl ::std::default::Default for RETRIEVAL_POINTER_COUNT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for RETRIEVAL_POINTER_COUNT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RETRIEVAL_POINTER_COUNT")
            .field("ExtentCount", &self.ExtentCount)
            .finish()
    }
}
impl ::std::cmp::PartialEq for RETRIEVAL_POINTER_COUNT {
    fn eq(&self, other: &Self) -> bool {
        self.ExtentCount == other.ExtentCount
    }
}
impl ::std::cmp::Eq for RETRIEVAL_POINTER_COUNT {}
unsafe impl ::windows::runtime::Abi for RETRIEVAL_POINTER_COUNT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const RETURN_SMART_STATUS: u32 = 218u32;
pub const REVISION_LENGTH: u32 = 4u32;
pub const ROTFLAGS_ALLOWANYCLIENT: u32 = 2u32;
pub const ROTFLAGS_REGISTRATIONKEEPSALIVE: u32 = 1u32;
pub const ROT_COMPARE_MAX: u32 = 2048u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Rpc")]
pub struct RPC_IMPORT_CONTEXT_P {
    pub LookupContext: *mut ::std::ffi::c_void,
    pub ProposedHandle: *mut ::std::ffi::c_void,
    pub Bindings: *mut super::Rpc::RPC_BINDING_VECTOR,
}
#[cfg(feature = "Win32_System_Rpc")]
impl RPC_IMPORT_CONTEXT_P {}
#[cfg(feature = "Win32_System_Rpc")]
impl ::std::default::Default for RPC_IMPORT_CONTEXT_P {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Rpc")]
impl ::std::fmt::Debug for RPC_IMPORT_CONTEXT_P {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RPC_IMPORT_CONTEXT_P")
            .field("LookupContext", &self.LookupContext)
            .field("ProposedHandle", &self.ProposedHandle)
            .field("Bindings", &self.Bindings)
            .finish()
    }
}
#[cfg(feature = "Win32_System_Rpc")]
impl ::std::cmp::PartialEq for RPC_IMPORT_CONTEXT_P {
    fn eq(&self, other: &Self) -> bool {
        self.LookupContext == other.LookupContext
            && self.ProposedHandle == other.ProposedHandle
            && self.Bindings == other.Bindings
    }
}
#[cfg(feature = "Win32_System_Rpc")]
impl ::std::cmp::Eq for RPC_IMPORT_CONTEXT_P {}
#[cfg(feature = "Win32_System_Rpc")]
unsafe impl ::windows::runtime::Abi for RPC_IMPORT_CONTEXT_P {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct RTL_BARRIER {
    pub Reserved1: u32,
    pub Reserved2: u32,
    pub Reserved3: [usize; 2],
    pub Reserved4: u32,
    pub Reserved5: u32,
}
impl RTL_BARRIER {}
impl ::std::default::Default for RTL_BARRIER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for RTL_BARRIER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RTL_BARRIER")
            .field("Reserved1", &self.Reserved1)
            .field("Reserved2", &self.Reserved2)
            .field("Reserved3", &self.Reserved3)
            .field("Reserved4", &self.Reserved4)
            .field("Reserved5", &self.Reserved5)
            .finish()
    }
}
impl ::std::cmp::PartialEq for RTL_BARRIER {
    fn eq(&self, other: &Self) -> bool {
        self.Reserved1 == other.Reserved1
            && self.Reserved2 == other.Reserved2
            && self.Reserved3 == other.Reserved3
            && self.Reserved4 == other.Reserved4
            && self.Reserved5 == other.Reserved5
    }
}
impl ::std::cmp::Eq for RTL_BARRIER {}
unsafe impl ::windows::runtime::Abi for RTL_BARRIER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct RTL_CONDITION_VARIABLE {
    pub Ptr: *mut ::std::ffi::c_void,
}
impl RTL_CONDITION_VARIABLE {}
impl ::std::default::Default for RTL_CONDITION_VARIABLE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for RTL_CONDITION_VARIABLE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RTL_CONDITION_VARIABLE")
            .field("Ptr", &self.Ptr)
            .finish()
    }
}
impl ::std::cmp::PartialEq for RTL_CONDITION_VARIABLE {
    fn eq(&self, other: &Self) -> bool {
        self.Ptr == other.Ptr
    }
}
impl ::std::cmp::Eq for RTL_CONDITION_VARIABLE {}
unsafe impl ::windows::runtime::Abi for RTL_CONDITION_VARIABLE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const RTL_CONDITION_VARIABLE_LOCKMODE_SHARED: u32 = 1u32;
pub const RTL_CORRELATION_VECTOR_STRING_LENGTH: u32 = 129u32;
pub const RTL_CORRELATION_VECTOR_V1_LENGTH: u32 = 64u32;
pub const RTL_CORRELATION_VECTOR_V1_PREFIX_LENGTH: u32 = 16u32;
pub const RTL_CORRELATION_VECTOR_V2_LENGTH: u32 = 128u32;
pub const RTL_CORRELATION_VECTOR_V2_PREFIX_LENGTH: u32 = 22u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub struct RTL_CRITICAL_SECTION {
    pub DebugInfo: *mut RTL_CRITICAL_SECTION_DEBUG,
    pub LockCount: i32,
    pub RecursionCount: i32,
    pub OwningThread: super::super::Foundation::HANDLE,
    pub LockSemaphore: super::super::Foundation::HANDLE,
    pub SpinCount: usize,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl RTL_CRITICAL_SECTION {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::std::default::Default for RTL_CRITICAL_SECTION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::std::fmt::Debug for RTL_CRITICAL_SECTION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RTL_CRITICAL_SECTION")
            .field("DebugInfo", &self.DebugInfo)
            .field("LockCount", &self.LockCount)
            .field("RecursionCount", &self.RecursionCount)
            .field("OwningThread", &self.OwningThread)
            .field("LockSemaphore", &self.LockSemaphore)
            .field("SpinCount", &self.SpinCount)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::std::cmp::PartialEq for RTL_CRITICAL_SECTION {
    fn eq(&self, other: &Self) -> bool {
        self.DebugInfo == other.DebugInfo
            && self.LockCount == other.LockCount
            && self.RecursionCount == other.RecursionCount
            && self.OwningThread == other.OwningThread
            && self.LockSemaphore == other.LockSemaphore
            && self.SpinCount == other.SpinCount
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::std::cmp::Eq for RTL_CRITICAL_SECTION {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
unsafe impl ::windows::runtime::Abi for RTL_CRITICAL_SECTION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const RTL_CRITICAL_SECTION_ALL_FLAG_BITS: u32 = 4278190080u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub struct RTL_CRITICAL_SECTION_DEBUG {
    pub Type: u16,
    pub CreatorBackTraceIndex: u16,
    pub CriticalSection: *mut RTL_CRITICAL_SECTION,
    pub ProcessLocksList: super::Kernel::LIST_ENTRY,
    pub EntryCount: u32,
    pub ContentionCount: u32,
    pub Flags: u32,
    pub CreatorBackTraceIndexHigh: u16,
    pub SpareWORD: u16,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl RTL_CRITICAL_SECTION_DEBUG {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::std::default::Default for RTL_CRITICAL_SECTION_DEBUG {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::std::fmt::Debug for RTL_CRITICAL_SECTION_DEBUG {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RTL_CRITICAL_SECTION_DEBUG")
            .field("Type", &self.Type)
            .field("CreatorBackTraceIndex", &self.CreatorBackTraceIndex)
            .field("CriticalSection", &self.CriticalSection)
            .field("ProcessLocksList", &self.ProcessLocksList)
            .field("EntryCount", &self.EntryCount)
            .field("ContentionCount", &self.ContentionCount)
            .field("Flags", &self.Flags)
            .field("CreatorBackTraceIndexHigh", &self.CreatorBackTraceIndexHigh)
            .field("SpareWORD", &self.SpareWORD)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::std::cmp::PartialEq for RTL_CRITICAL_SECTION_DEBUG {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type
            && self.CreatorBackTraceIndex == other.CreatorBackTraceIndex
            && self.CriticalSection == other.CriticalSection
            && self.ProcessLocksList == other.ProcessLocksList
            && self.EntryCount == other.EntryCount
            && self.ContentionCount == other.ContentionCount
            && self.Flags == other.Flags
            && self.CreatorBackTraceIndexHigh == other.CreatorBackTraceIndexHigh
            && self.SpareWORD == other.SpareWORD
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::std::cmp::Eq for RTL_CRITICAL_SECTION_DEBUG {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
unsafe impl ::windows::runtime::Abi for RTL_CRITICAL_SECTION_DEBUG {
    type Abi = Self;
    type DefaultType = Self;
}
pub const RTL_CRITICAL_SECTION_DEBUG_FLAG_STATIC_INIT: u32 = 1u32;
pub const RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN: u32 = 33554432u32;
pub const RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO: u32 = 268435456u32;
pub const RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO: u32 = 16777216u32;
pub const RTL_CRITICAL_SECTION_FLAG_RESOURCE_TYPE: u32 = 134217728u32;
pub const RTL_CRITICAL_SECTION_FLAG_STATIC_INIT: u32 = 67108864u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union RTL_RUN_ONCE {
    pub Ptr: *mut ::std::ffi::c_void,
}
impl RTL_RUN_ONCE {}
impl ::std::default::Default for RTL_RUN_ONCE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for RTL_RUN_ONCE {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for RTL_RUN_ONCE {}
unsafe impl ::windows::runtime::Abi for RTL_RUN_ONCE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const RTL_RUN_ONCE_ASYNC: u32 = 2u32;
pub const RTL_RUN_ONCE_CHECK_ONLY: u32 = 1u32;
pub const RTL_RUN_ONCE_CTX_RESERVED_BITS: u32 = 2u32;
pub const RTL_RUN_ONCE_INIT_FAILED: u32 = 4u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct RTL_SRWLOCK {
    pub Ptr: *mut ::std::ffi::c_void,
}
impl RTL_SRWLOCK {}
impl ::std::default::Default for RTL_SRWLOCK {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for RTL_SRWLOCK {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RTL_SRWLOCK")
            .field("Ptr", &self.Ptr)
            .finish()
    }
}
impl ::std::cmp::PartialEq for RTL_SRWLOCK {
    fn eq(&self, other: &Self) -> bool {
        self.Ptr == other.Ptr
    }
}
impl ::std::cmp::Eq for RTL_SRWLOCK {}
unsafe impl ::windows::runtime::Abi for RTL_SRWLOCK {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct RTL_SYSTEM_GLOBAL_DATA_ID(pub i32);
pub const GlobalDataIdUnknown: RTL_SYSTEM_GLOBAL_DATA_ID = RTL_SYSTEM_GLOBAL_DATA_ID(0i32);
pub const GlobalDataIdRngSeedVersion: RTL_SYSTEM_GLOBAL_DATA_ID = RTL_SYSTEM_GLOBAL_DATA_ID(1i32);
pub const GlobalDataIdInterruptTime: RTL_SYSTEM_GLOBAL_DATA_ID = RTL_SYSTEM_GLOBAL_DATA_ID(2i32);
pub const GlobalDataIdTimeZoneBias: RTL_SYSTEM_GLOBAL_DATA_ID = RTL_SYSTEM_GLOBAL_DATA_ID(3i32);
pub const GlobalDataIdImageNumberLow: RTL_SYSTEM_GLOBAL_DATA_ID = RTL_SYSTEM_GLOBAL_DATA_ID(4i32);
pub const GlobalDataIdImageNumberHigh: RTL_SYSTEM_GLOBAL_DATA_ID = RTL_SYSTEM_GLOBAL_DATA_ID(5i32);
pub const GlobalDataIdTimeZoneId: RTL_SYSTEM_GLOBAL_DATA_ID = RTL_SYSTEM_GLOBAL_DATA_ID(6i32);
pub const GlobalDataIdNtMajorVersion: RTL_SYSTEM_GLOBAL_DATA_ID = RTL_SYSTEM_GLOBAL_DATA_ID(7i32);
pub const GlobalDataIdNtMinorVersion: RTL_SYSTEM_GLOBAL_DATA_ID = RTL_SYSTEM_GLOBAL_DATA_ID(8i32);
pub const GlobalDataIdSystemExpirationDate: RTL_SYSTEM_GLOBAL_DATA_ID =
    RTL_SYSTEM_GLOBAL_DATA_ID(9i32);
pub const GlobalDataIdKdDebuggerEnabled: RTL_SYSTEM_GLOBAL_DATA_ID =
    RTL_SYSTEM_GLOBAL_DATA_ID(10i32);
pub const GlobalDataIdCyclesPerYield: RTL_SYSTEM_GLOBAL_DATA_ID = RTL_SYSTEM_GLOBAL_DATA_ID(11i32);
pub const GlobalDataIdSafeBootMode: RTL_SYSTEM_GLOBAL_DATA_ID = RTL_SYSTEM_GLOBAL_DATA_ID(12i32);
pub const GlobalDataIdLastSystemRITEventTickCount: RTL_SYSTEM_GLOBAL_DATA_ID =
    RTL_SYSTEM_GLOBAL_DATA_ID(13i32);
impl ::std::convert::From<i32> for RTL_SYSTEM_GLOBAL_DATA_ID {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for RTL_SYSTEM_GLOBAL_DATA_ID {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct RTL_UMS_SCHEDULER_REASON(pub i32);
pub const UmsSchedulerStartup: RTL_UMS_SCHEDULER_REASON = RTL_UMS_SCHEDULER_REASON(0i32);
pub const UmsSchedulerThreadBlocked: RTL_UMS_SCHEDULER_REASON = RTL_UMS_SCHEDULER_REASON(1i32);
pub const UmsSchedulerThreadYield: RTL_UMS_SCHEDULER_REASON = RTL_UMS_SCHEDULER_REASON(2i32);
impl ::std::convert::From<i32> for RTL_UMS_SCHEDULER_REASON {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for RTL_UMS_SCHEDULER_REASON {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct RTL_UMS_THREAD_INFO_CLASS(pub i32);
pub const UmsThreadInvalidInfoClass: RTL_UMS_THREAD_INFO_CLASS = RTL_UMS_THREAD_INFO_CLASS(0i32);
pub const UmsThreadUserContext: RTL_UMS_THREAD_INFO_CLASS = RTL_UMS_THREAD_INFO_CLASS(1i32);
pub const UmsThreadPriority: RTL_UMS_THREAD_INFO_CLASS = RTL_UMS_THREAD_INFO_CLASS(2i32);
pub const UmsThreadAffinity: RTL_UMS_THREAD_INFO_CLASS = RTL_UMS_THREAD_INFO_CLASS(3i32);
pub const UmsThreadTeb: RTL_UMS_THREAD_INFO_CLASS = RTL_UMS_THREAD_INFO_CLASS(4i32);
pub const UmsThreadIsSuspended: RTL_UMS_THREAD_INFO_CLASS = RTL_UMS_THREAD_INFO_CLASS(5i32);
pub const UmsThreadIsTerminated: RTL_UMS_THREAD_INFO_CLASS = RTL_UMS_THREAD_INFO_CLASS(6i32);
pub const UmsThreadMaxInfoClass: RTL_UMS_THREAD_INFO_CLASS = RTL_UMS_THREAD_INFO_CLASS(7i32);
impl ::std::convert::From<i32> for RTL_UMS_THREAD_INFO_CLASS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for RTL_UMS_THREAD_INFO_CLASS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const RTL_UMS_VERSION: u32 = 256u32;
pub const RTL_VIRTUAL_UNWIND2_VALIDATE_PAC: u32 = 1u32;
pub const RUNTIME_FUNCTION_INDIRECT: u32 = 1u32;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Power"))]
pub unsafe fn RegisterDeviceNotificationA<
    'a,
    Param0: ::windows::runtime::IntoParam<'a, super::super::Foundation::HANDLE>,
>(
    hrecipient: Param0,
    notificationfilter: *const ::std::ffi::c_void,
    flags: super::Power::POWER_SETTING_REGISTER_NOTIFICATION_FLAGS,
) -> *mut ::std::ffi::c_void {
    #[cfg(windows)]
    {
        #[link(name = "user32")]
        extern "system" {
            fn RegisterDeviceNotificationA(
                hrecipient: super::super::Foundation::HANDLE,
                notificationfilter: *const ::std::ffi::c_void,
                flags: super::Power::POWER_SETTING_REGISTER_NOTIFICATION_FLAGS,
            ) -> *mut ::std::ffi::c_void;
        }
        ::std::mem::transmute(RegisterDeviceNotificationA(
            hrecipient.into_param().abi(),
            ::std::mem::transmute(notificationfilter),
            ::std::mem::transmute(flags),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Power"))]
pub unsafe fn RegisterDeviceNotificationW<
    'a,
    Param0: ::windows::runtime::IntoParam<'a, super::super::Foundation::HANDLE>,
>(
    hrecipient: Param0,
    notificationfilter: *const ::std::ffi::c_void,
    flags: super::Power::POWER_SETTING_REGISTER_NOTIFICATION_FLAGS,
) -> *mut ::std::ffi::c_void {
    #[cfg(windows)]
    {
        #[link(name = "user32")]
        extern "system" {
            fn RegisterDeviceNotificationW(
                hrecipient: super::super::Foundation::HANDLE,
                notificationfilter: *const ::std::ffi::c_void,
                flags: super::Power::POWER_SETTING_REGISTER_NOTIFICATION_FLAGS,
            ) -> *mut ::std::ffi::c_void;
        }
        ::std::mem::transmute(RegisterDeviceNotificationW(
            hrecipient.into_param().abi(),
            ::std::mem::transmute(notificationfilter),
            ::std::mem::transmute(flags),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct RemBRUSH {
    pub cbData: u32,
    pub data: [u8; 1],
}
impl RemBRUSH {}
impl ::std::default::Default for RemBRUSH {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for RemBRUSH {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RemBRUSH")
            .field("cbData", &self.cbData)
            .field("data", &self.data)
            .finish()
    }
}
impl ::std::cmp::PartialEq for RemBRUSH {
    fn eq(&self, other: &Self) -> bool {
        self.cbData == other.cbData && self.data == other.data
    }
}
impl ::std::cmp::Eq for RemBRUSH {}
unsafe impl ::windows::runtime::Abi for RemBRUSH {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct RemHBITMAP {
    pub cbData: u32,
    pub data: [u8; 1],
}
impl RemHBITMAP {}
impl ::std::default::Default for RemHBITMAP {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for RemHBITMAP {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RemHBITMAP")
            .field("cbData", &self.cbData)
            .field("data", &self.data)
            .finish()
    }
}
impl ::std::cmp::PartialEq for RemHBITMAP {
    fn eq(&self, other: &Self) -> bool {
        self.cbData == other.cbData && self.data == other.data
    }
}
impl ::std::cmp::Eq for RemHBITMAP {}
unsafe impl ::windows::runtime::Abi for RemHBITMAP {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct RemHENHMETAFILE {
    pub cbData: u32,
    pub data: [u8; 1],
}
impl RemHENHMETAFILE {}
impl ::std::default::Default for RemHENHMETAFILE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for RemHENHMETAFILE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RemHENHMETAFILE")
            .field("cbData", &self.cbData)
            .field("data", &self.data)
            .finish()
    }
}
impl ::std::cmp::PartialEq for RemHENHMETAFILE {
    fn eq(&self, other: &Self) -> bool {
        self.cbData == other.cbData && self.data == other.data
    }
}
impl ::std::cmp::Eq for RemHENHMETAFILE {}
unsafe impl ::windows::runtime::Abi for RemHENHMETAFILE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct RemHGLOBAL {
    pub fNullHGlobal: i32,
    pub cbData: u32,
    pub data: [u8; 1],
}
impl RemHGLOBAL {}
impl ::std::default::Default for RemHGLOBAL {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for RemHGLOBAL {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RemHGLOBAL")
            .field("fNullHGlobal", &self.fNullHGlobal)
            .field("cbData", &self.cbData)
            .field("data", &self.data)
            .finish()
    }
}
impl ::std::cmp::PartialEq for RemHGLOBAL {
    fn eq(&self, other: &Self) -> bool {
        self.fNullHGlobal == other.fNullHGlobal
            && self.cbData == other.cbData
            && self.data == other.data
    }
}
impl ::std::cmp::Eq for RemHGLOBAL {}
unsafe impl ::windows::runtime::Abi for RemHGLOBAL {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct RemHMETAFILEPICT {
    pub mm: i32,
    pub xExt: i32,
    pub yExt: i32,
    pub cbData: u32,
    pub data: [u8; 1],
}
impl RemHMETAFILEPICT {}
impl ::std::default::Default for RemHMETAFILEPICT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for RemHMETAFILEPICT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RemHMETAFILEPICT")
            .field("mm", &self.mm)
            .field("xExt", &self.xExt)
            .field("yExt", &self.yExt)
            .field("cbData", &self.cbData)
            .field("data", &self.data)
            .finish()
    }
}
impl ::std::cmp::PartialEq for RemHMETAFILEPICT {
    fn eq(&self, other: &Self) -> bool {
        self.mm == other.mm
            && self.xExt == other.xExt
            && self.yExt == other.yExt
            && self.cbData == other.cbData
            && self.data == other.data
    }
}
impl ::std::cmp::Eq for RemHMETAFILEPICT {}
unsafe impl ::windows::runtime::Abi for RemHMETAFILEPICT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct RemHPALETTE {
    pub cbData: u32,
    pub data: [u8; 1],
}
impl RemHPALETTE {}
impl ::std::default::Default for RemHPALETTE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for RemHPALETTE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("RemHPALETTE")
            .field("cbData", &self.cbData)
            .field("data", &self.data)
            .finish()
    }
}
impl ::std::cmp::PartialEq for RemHPALETTE {
    fn eq(&self, other: &Self) -> bool {
        self.cbData == other.cbData && self.data == other.data
    }
}
impl ::std::cmp::Eq for RemHPALETTE {}
unsafe impl ::windows::runtime::Abi for RemHPALETTE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct RemotableHandle {
    pub fContext: i32,
    pub u: RemotableHandle_0,
}
impl RemotableHandle {}
impl ::std::default::Default for RemotableHandle {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for RemotableHandle {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for RemotableHandle {}
unsafe impl ::windows::runtime::Abi for RemotableHandle {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union RemotableHandle_0 {
    pub hInproc: i32,
    pub hRemote: i32,
}
impl RemotableHandle_0 {}
impl ::std::default::Default for RemotableHandle_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for RemotableHandle_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for RemotableHandle_0 {}
unsafe impl ::windows::runtime::Abi for RemotableHandle_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct ReplacesCorHdrNumericDefines(pub i32);
pub const COMIMAGE_FLAGS_ILONLY: ReplacesCorHdrNumericDefines = ReplacesCorHdrNumericDefines(1i32);
pub const COMIMAGE_FLAGS_32BITREQUIRED: ReplacesCorHdrNumericDefines =
    ReplacesCorHdrNumericDefines(2i32);
pub const COMIMAGE_FLAGS_IL_LIBRARY: ReplacesCorHdrNumericDefines =
    ReplacesCorHdrNumericDefines(4i32);
pub const COMIMAGE_FLAGS_STRONGNAMESIGNED: ReplacesCorHdrNumericDefines =
    ReplacesCorHdrNumericDefines(8i32);
pub const COMIMAGE_FLAGS_NATIVE_ENTRYPOINT: ReplacesCorHdrNumericDefines =
    ReplacesCorHdrNumericDefines(16i32);
pub const COMIMAGE_FLAGS_TRACKDEBUGDATA: ReplacesCorHdrNumericDefines =
    ReplacesCorHdrNumericDefines(65536i32);
pub const COMIMAGE_FLAGS_32BITPREFERRED: ReplacesCorHdrNumericDefines =
    ReplacesCorHdrNumericDefines(131072i32);
pub const COR_VERSION_MAJOR_V2: ReplacesCorHdrNumericDefines = ReplacesCorHdrNumericDefines(2i32);
pub const COR_VERSION_MAJOR: ReplacesCorHdrNumericDefines = ReplacesCorHdrNumericDefines(2i32);
pub const COR_VERSION_MINOR: ReplacesCorHdrNumericDefines = ReplacesCorHdrNumericDefines(5i32);
pub const COR_DELETED_NAME_LENGTH: ReplacesCorHdrNumericDefines =
    ReplacesCorHdrNumericDefines(8i32);
pub const COR_VTABLEGAP_NAME_LENGTH: ReplacesCorHdrNumericDefines =
    ReplacesCorHdrNumericDefines(8i32);
pub const NATIVE_TYPE_MAX_CB: ReplacesCorHdrNumericDefines = ReplacesCorHdrNumericDefines(1i32);
pub const COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE: ReplacesCorHdrNumericDefines =
    ReplacesCorHdrNumericDefines(255i32);
pub const IMAGE_COR_MIH_METHODRVA: ReplacesCorHdrNumericDefines =
    ReplacesCorHdrNumericDefines(1i32);
pub const IMAGE_COR_MIH_EHRVA: ReplacesCorHdrNumericDefines = ReplacesCorHdrNumericDefines(2i32);
pub const IMAGE_COR_MIH_BASICBLOCK: ReplacesCorHdrNumericDefines =
    ReplacesCorHdrNumericDefines(8i32);
pub const COR_VTABLE_32BIT: ReplacesCorHdrNumericDefines = ReplacesCorHdrNumericDefines(1i32);
pub const COR_VTABLE_64BIT: ReplacesCorHdrNumericDefines = ReplacesCorHdrNumericDefines(2i32);
pub const COR_VTABLE_FROM_UNMANAGED: ReplacesCorHdrNumericDefines =
    ReplacesCorHdrNumericDefines(4i32);
pub const COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN: ReplacesCorHdrNumericDefines =
    ReplacesCorHdrNumericDefines(8i32);
pub const COR_VTABLE_CALL_MOST_DERIVED: ReplacesCorHdrNumericDefines =
    ReplacesCorHdrNumericDefines(16i32);
pub const IMAGE_COR_EATJ_THUNK_SIZE: ReplacesCorHdrNumericDefines =
    ReplacesCorHdrNumericDefines(32i32);
pub const MAX_CLASS_NAME: ReplacesCorHdrNumericDefines = ReplacesCorHdrNumericDefines(1024i32);
pub const MAX_PACKAGE_NAME: ReplacesCorHdrNumericDefines = ReplacesCorHdrNumericDefines(1024i32);
impl ::std::convert::From<i32> for ReplacesCorHdrNumericDefines {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for ReplacesCorHdrNumericDefines {
    type Abi = Self;
    type DefaultType = Self;
}
pub unsafe fn RtlCompareMemory(
    source1: *const ::std::ffi::c_void,
    source2: *const ::std::ffi::c_void,
    length: usize,
) -> usize {
    #[cfg(windows)]
    {
        #[link(name = "kernel32")]
        extern "system" {
            fn RtlCompareMemory(
                source1: *const ::std::ffi::c_void,
                source2: *const ::std::ffi::c_void,
                length: usize,
            ) -> usize;
        }
        ::std::mem::transmute(RtlCompareMemory(
            ::std::mem::transmute(source1),
            ::std::mem::transmute(source2),
            ::std::mem::transmute(length),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(feature = "Win32_Foundation")]
pub unsafe fn RtlConvertDeviceFamilyInfoToString(
    puldevicefamilybuffersize: *mut u32,
    puldeviceformbuffersize: *mut u32,
    devicefamily: super::super::Foundation::PWSTR,
    deviceform: super::super::Foundation::PWSTR,
) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlConvertDeviceFamilyInfoToString(
                puldevicefamilybuffersize: *mut u32,
                puldeviceformbuffersize: *mut u32,
                devicefamily: super::super::Foundation::PWSTR,
                deviceform: super::super::Foundation::PWSTR,
            ) -> u32;
        }
        ::std::mem::transmute(RtlConvertDeviceFamilyInfoToString(
            ::std::mem::transmute(puldevicefamilybuffersize),
            ::std::mem::transmute(puldeviceformbuffersize),
            ::std::mem::transmute(devicefamily),
            ::std::mem::transmute(deviceform),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn RtlCrc32(buffer: *const ::std::ffi::c_void, size: usize, initialcrc: u32) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlCrc32(buffer: *const ::std::ffi::c_void, size: usize, initialcrc: u32) -> u32;
        }
        ::std::mem::transmute(RtlCrc32(
            ::std::mem::transmute(buffer),
            ::std::mem::transmute(size),
            ::std::mem::transmute(initialcrc),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn RtlCrc64(buffer: *const ::std::ffi::c_void, size: usize, initialcrc: u64) -> u64 {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlCrc64(buffer: *const ::std::ffi::c_void, size: usize, initialcrc: u64) -> u64;
        }
        ::std::mem::transmute(RtlCrc64(
            ::std::mem::transmute(buffer),
            ::std::mem::transmute(size),
            ::std::mem::transmute(initialcrc),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn RtlDrainNonVolatileFlush(nvtoken: *const ::std::ffi::c_void) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlDrainNonVolatileFlush(nvtoken: *const ::std::ffi::c_void) -> u32;
        }
        ::std::mem::transmute(RtlDrainNonVolatileFlush(::std::mem::transmute(nvtoken)))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn RtlExtendCorrelationVector(correlationvector: *mut CORRELATION_VECTOR) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlExtendCorrelationVector(correlationvector: *mut CORRELATION_VECTOR) -> u32;
        }
        ::std::mem::transmute(RtlExtendCorrelationVector(::std::mem::transmute(
            correlationvector,
        )))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn RtlFillNonVolatileMemory(
    nvtoken: *const ::std::ffi::c_void,
    nvdestination: *mut ::std::ffi::c_void,
    size: usize,
    value: u8,
    flags: u32,
) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlFillNonVolatileMemory(
                nvtoken: *const ::std::ffi::c_void,
                nvdestination: *mut ::std::ffi::c_void,
                size: usize,
                value: u8,
                flags: u32,
            ) -> u32;
        }
        ::std::mem::transmute(RtlFillNonVolatileMemory(
            ::std::mem::transmute(nvtoken),
            ::std::mem::transmute(nvdestination),
            ::std::mem::transmute(size),
            ::std::mem::transmute(value),
            ::std::mem::transmute(flags),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(feature = "Win32_System_Kernel")]
pub unsafe fn RtlFirstEntrySList(
    listhead: *const super::Kernel::SLIST_HEADER,
) -> *mut super::Kernel::SLIST_ENTRY {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlFirstEntrySList(
                listhead: *const super::Kernel::SLIST_HEADER,
            ) -> *mut super::Kernel::SLIST_ENTRY;
        }
        ::std::mem::transmute(RtlFirstEntrySList(::std::mem::transmute(listhead)))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn RtlFlushNonVolatileMemory(
    nvtoken: *const ::std::ffi::c_void,
    nvbuffer: *const ::std::ffi::c_void,
    size: usize,
    flags: u32,
) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlFlushNonVolatileMemory(
                nvtoken: *const ::std::ffi::c_void,
                nvbuffer: *const ::std::ffi::c_void,
                size: usize,
                flags: u32,
            ) -> u32;
        }
        ::std::mem::transmute(RtlFlushNonVolatileMemory(
            ::std::mem::transmute(nvtoken),
            ::std::mem::transmute(nvbuffer),
            ::std::mem::transmute(size),
            ::std::mem::transmute(flags),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn RtlFlushNonVolatileMemoryRanges(
    nvtoken: *const ::std::ffi::c_void,
    nvranges: *const NV_MEMORY_RANGE,
    numranges: usize,
    flags: u32,
) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlFlushNonVolatileMemoryRanges(
                nvtoken: *const ::std::ffi::c_void,
                nvranges: *const NV_MEMORY_RANGE,
                numranges: usize,
                flags: u32,
            ) -> u32;
        }
        ::std::mem::transmute(RtlFlushNonVolatileMemoryRanges(
            ::std::mem::transmute(nvtoken),
            ::std::mem::transmute(nvranges),
            ::std::mem::transmute(numranges),
            ::std::mem::transmute(flags),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn RtlFreeNonVolatileToken(nvtoken: *const ::std::ffi::c_void) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlFreeNonVolatileToken(nvtoken: *const ::std::ffi::c_void) -> u32;
        }
        ::std::mem::transmute(RtlFreeNonVolatileToken(::std::mem::transmute(nvtoken)))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn RtlGetDeviceFamilyInfoEnum(
    pulluapinfo: *mut u64,
    puldevicefamily: *mut u32,
    puldeviceform: *mut u32,
) {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlGetDeviceFamilyInfoEnum(
                pulluapinfo: *mut u64,
                puldevicefamily: *mut u32,
                puldeviceform: *mut u32,
            );
        }
        ::std::mem::transmute(RtlGetDeviceFamilyInfoEnum(
            ::std::mem::transmute(pulluapinfo),
            ::std::mem::transmute(puldevicefamily),
            ::std::mem::transmute(puldeviceform),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn RtlGetNonVolatileToken(
    nvbuffer: *const ::std::ffi::c_void,
    size: usize,
    nvtoken: *mut *mut ::std::ffi::c_void,
) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlGetNonVolatileToken(
                nvbuffer: *const ::std::ffi::c_void,
                size: usize,
                nvtoken: *mut *mut ::std::ffi::c_void,
            ) -> u32;
        }
        ::std::mem::transmute(RtlGetNonVolatileToken(
            ::std::mem::transmute(nvbuffer),
            ::std::mem::transmute(size),
            ::std::mem::transmute(nvtoken),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(feature = "Win32_Foundation")]
pub unsafe fn RtlGetProductInfo(
    osmajorversion: u32,
    osminorversion: u32,
    spmajorversion: u32,
    spminorversion: u32,
    returnedproducttype: *mut u32,
) -> super::super::Foundation::BOOLEAN {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlGetProductInfo(
                osmajorversion: u32,
                osminorversion: u32,
                spmajorversion: u32,
                spminorversion: u32,
                returnedproducttype: *mut u32,
            ) -> super::super::Foundation::BOOLEAN;
        }
        ::std::mem::transmute(RtlGetProductInfo(
            ::std::mem::transmute(osmajorversion),
            ::std::mem::transmute(osminorversion),
            ::std::mem::transmute(spmajorversion),
            ::std::mem::transmute(spminorversion),
            ::std::mem::transmute(returnedproducttype),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn RtlGetReturnAddressHijackTarget() -> usize {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlGetReturnAddressHijackTarget() -> usize;
        }
        ::std::mem::transmute(RtlGetReturnAddressHijackTarget())
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn RtlGetSystemGlobalData(
    dataid: RTL_SYSTEM_GLOBAL_DATA_ID,
    buffer: *mut ::std::ffi::c_void,
    size: u32,
) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "ntdllk")]
        extern "system" {
            fn RtlGetSystemGlobalData(
                dataid: RTL_SYSTEM_GLOBAL_DATA_ID,
                buffer: *mut ::std::ffi::c_void,
                size: u32,
            ) -> u32;
        }
        ::std::mem::transmute(RtlGetSystemGlobalData(
            ::std::mem::transmute(dataid),
            ::std::mem::transmute(buffer),
            ::std::mem::transmute(size),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn RtlIncrementCorrelationVector(correlationvector: *mut CORRELATION_VECTOR) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlIncrementCorrelationVector(correlationvector: *mut CORRELATION_VECTOR) -> u32;
        }
        ::std::mem::transmute(RtlIncrementCorrelationVector(::std::mem::transmute(
            correlationvector,
        )))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn RtlInitializeCorrelationVector(
    correlationvector: *mut CORRELATION_VECTOR,
    version: i32,
    guid: *const ::windows::runtime::GUID,
) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlInitializeCorrelationVector(
                correlationvector: *mut CORRELATION_VECTOR,
                version: i32,
                guid: *const ::windows::runtime::GUID,
            ) -> u32;
        }
        ::std::mem::transmute(RtlInitializeCorrelationVector(
            ::std::mem::transmute(correlationvector),
            ::std::mem::transmute(version),
            ::std::mem::transmute(guid),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(feature = "Win32_System_Kernel")]
pub unsafe fn RtlInitializeSListHead(listhead: *mut super::Kernel::SLIST_HEADER) {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlInitializeSListHead(listhead: *mut super::Kernel::SLIST_HEADER);
        }
        ::std::mem::transmute(RtlInitializeSListHead(::std::mem::transmute(listhead)))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(feature = "Win32_System_Kernel")]
pub unsafe fn RtlInterlockedFlushSList(
    listhead: *mut super::Kernel::SLIST_HEADER,
) -> *mut super::Kernel::SLIST_ENTRY {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlInterlockedFlushSList(
                listhead: *mut super::Kernel::SLIST_HEADER,
            ) -> *mut super::Kernel::SLIST_ENTRY;
        }
        ::std::mem::transmute(RtlInterlockedFlushSList(::std::mem::transmute(listhead)))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(feature = "Win32_System_Kernel")]
pub unsafe fn RtlInterlockedPopEntrySList(
    listhead: *mut super::Kernel::SLIST_HEADER,
) -> *mut super::Kernel::SLIST_ENTRY {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlInterlockedPopEntrySList(
                listhead: *mut super::Kernel::SLIST_HEADER,
            ) -> *mut super::Kernel::SLIST_ENTRY;
        }
        ::std::mem::transmute(RtlInterlockedPopEntrySList(::std::mem::transmute(listhead)))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(feature = "Win32_System_Kernel")]
pub unsafe fn RtlInterlockedPushEntrySList(
    listhead: *mut super::Kernel::SLIST_HEADER,
    listentry: *mut super::Kernel::SLIST_ENTRY,
) -> *mut super::Kernel::SLIST_ENTRY {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlInterlockedPushEntrySList(
                listhead: *mut super::Kernel::SLIST_HEADER,
                listentry: *mut super::Kernel::SLIST_ENTRY,
            ) -> *mut super::Kernel::SLIST_ENTRY;
        }
        ::std::mem::transmute(RtlInterlockedPushEntrySList(
            ::std::mem::transmute(listhead),
            ::std::mem::transmute(listentry),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(feature = "Win32_System_Kernel")]
pub unsafe fn RtlInterlockedPushListSListEx(
    listhead: *mut super::Kernel::SLIST_HEADER,
    list: *mut super::Kernel::SLIST_ENTRY,
    listend: *mut super::Kernel::SLIST_ENTRY,
    count: u32,
) -> *mut super::Kernel::SLIST_ENTRY {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlInterlockedPushListSListEx(
                listhead: *mut super::Kernel::SLIST_HEADER,
                list: *mut super::Kernel::SLIST_ENTRY,
                listend: *mut super::Kernel::SLIST_ENTRY,
                count: u32,
            ) -> *mut super::Kernel::SLIST_ENTRY;
        }
        ::std::mem::transmute(RtlInterlockedPushListSListEx(
            ::std::mem::transmute(listhead),
            ::std::mem::transmute(list),
            ::std::mem::transmute(listend),
            ::std::mem::transmute(count),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(feature = "Win32_Foundation")]
pub unsafe fn RtlIsZeroMemory(
    buffer: *const ::std::ffi::c_void,
    length: usize,
) -> super::super::Foundation::BOOLEAN {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlIsZeroMemory(
                buffer: *const ::std::ffi::c_void,
                length: usize,
            ) -> super::super::Foundation::BOOLEAN;
        }
        ::std::mem::transmute(RtlIsZeroMemory(
            ::std::mem::transmute(buffer),
            ::std::mem::transmute(length),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
pub unsafe fn RtlNormalizeSecurityDescriptor<
    'a,
    Param4: ::windows::runtime::IntoParam<'a, super::super::Foundation::BOOLEAN>,
>(
    securitydescriptor: *mut *mut super::super::Security::SECURITY_DESCRIPTOR,
    securitydescriptorlength: u32,
    newsecuritydescriptor: *mut *mut super::super::Security::SECURITY_DESCRIPTOR,
    newsecuritydescriptorlength: *mut u32,
    checkonly: Param4,
) -> super::super::Foundation::BOOLEAN {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlNormalizeSecurityDescriptor(
                securitydescriptor: *mut *mut super::super::Security::SECURITY_DESCRIPTOR,
                securitydescriptorlength: u32,
                newsecuritydescriptor: *mut *mut super::super::Security::SECURITY_DESCRIPTOR,
                newsecuritydescriptorlength: *mut u32,
                checkonly: super::super::Foundation::BOOLEAN,
            ) -> super::super::Foundation::BOOLEAN;
        }
        ::std::mem::transmute(RtlNormalizeSecurityDescriptor(
            ::std::mem::transmute(securitydescriptor),
            ::std::mem::transmute(securitydescriptorlength),
            ::std::mem::transmute(newsecuritydescriptor),
            ::std::mem::transmute(newsecuritydescriptorlength),
            checkonly.into_param().abi(),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn RtlOsDeploymentState(flags: u32) -> OS_DEPLOYEMENT_STATE_VALUES {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlOsDeploymentState(flags: u32) -> OS_DEPLOYEMENT_STATE_VALUES;
        }
        ::std::mem::transmute(RtlOsDeploymentState(::std::mem::transmute(flags)))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(feature = "Win32_System_Kernel")]
pub unsafe fn RtlQueryDepthSList(listhead: *const super::Kernel::SLIST_HEADER) -> u16 {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlQueryDepthSList(listhead: *const super::Kernel::SLIST_HEADER) -> u16;
        }
        ::std::mem::transmute(RtlQueryDepthSList(::std::mem::transmute(listhead)))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(feature = "Win32_Foundation")]
pub unsafe fn RtlRaiseCustomSystemEventTrigger(
    triggerconfig: *const CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG,
) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlRaiseCustomSystemEventTrigger(
                triggerconfig: *const CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG,
            ) -> u32;
        }
        ::std::mem::transmute(RtlRaiseCustomSystemEventTrigger(::std::mem::transmute(
            triggerconfig,
        )))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(all(
    feature = "Win32_Foundation",
    feature = "Win32_System_Diagnostics_Debug"
))]
pub unsafe fn RtlRaiseException(
    exceptionrecord: *const super::Diagnostics::Debug::EXCEPTION_RECORD,
) {
    #[cfg(windows)]
    {
        #[link(name = "kernel32")]
        extern "system" {
            fn RtlRaiseException(
                exceptionrecord: *const super::Diagnostics::Debug::EXCEPTION_RECORD,
            );
        }
        ::std::mem::transmute(RtlRaiseException(::std::mem::transmute(exceptionrecord)))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[cfg(feature = "Win32_System_SystemInformation")]
pub unsafe fn RtlSwitchedVVI(
    versioninfo: *const super::SystemInformation::OSVERSIONINFOEXW,
    typemask: u32,
    conditionmask: u64,
) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlSwitchedVVI(
                versioninfo: *const super::SystemInformation::OSVERSIONINFOEXW,
                typemask: u32,
                conditionmask: u64,
            ) -> u32;
        }
        ::std::mem::transmute(RtlSwitchedVVI(
            ::std::mem::transmute(versioninfo),
            ::std::mem::transmute(typemask),
            ::std::mem::transmute(conditionmask),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn RtlValidateCorrelationVector(vector: *const CORRELATION_VECTOR) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlValidateCorrelationVector(vector: *const CORRELATION_VECTOR) -> u32;
        }
        ::std::mem::transmute(RtlValidateCorrelationVector(::std::mem::transmute(vector)))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn RtlWriteNonVolatileMemory(
    nvtoken: *const ::std::ffi::c_void,
    nvdestination: *mut ::std::ffi::c_void,
    source: *const ::std::ffi::c_void,
    size: usize,
    flags: u32,
) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "ntdll")]
        extern "system" {
            fn RtlWriteNonVolatileMemory(
                nvtoken: *const ::std::ffi::c_void,
                nvdestination: *mut ::std::ffi::c_void,
                source: *const ::std::ffi::c_void,
                size: usize,
                flags: u32,
            ) -> u32;
        }
        ::std::mem::transmute(RtlWriteNonVolatileMemory(
            ::std::mem::transmute(nvtoken),
            ::std::mem::transmute(nvdestination),
            ::std::mem::transmute(source),
            ::std::mem::transmute(size),
            ::std::mem::transmute(flags),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub const SAVE_ATTRIBUTE_VALUES: u32 = 211u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_BUS_DEDICATED_MEMORY_DEVICES_INFO {
    pub Version: u32,
    pub Size: u32,
    pub DeviceCount: u32,
    pub Devices: [SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO; 1],
}
impl SCM_BUS_DEDICATED_MEMORY_DEVICES_INFO {}
impl ::std::default::Default for SCM_BUS_DEDICATED_MEMORY_DEVICES_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_BUS_DEDICATED_MEMORY_DEVICES_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_BUS_DEDICATED_MEMORY_DEVICES_INFO")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("DeviceCount", &self.DeviceCount)
            .field("Devices", &self.Devices)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_BUS_DEDICATED_MEMORY_DEVICES_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.DeviceCount == other.DeviceCount
            && self.Devices == other.Devices
    }
}
impl ::std::cmp::Eq for SCM_BUS_DEDICATED_MEMORY_DEVICES_INFO {}
unsafe impl ::windows::runtime::Abi for SCM_BUS_DEDICATED_MEMORY_DEVICES_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO {
    pub DeviceGuid: ::windows::runtime::GUID,
    pub DeviceNumber: u32,
    pub Flags: SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO_0,
    pub DeviceSize: u64,
}
impl SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO {}
impl ::std::default::Default for SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO")
            .field("DeviceGuid", &self.DeviceGuid)
            .field("DeviceNumber", &self.DeviceNumber)
            .field("Flags", &self.Flags)
            .field("DeviceSize", &self.DeviceSize)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.DeviceGuid == other.DeviceGuid
            && self.DeviceNumber == other.DeviceNumber
            && self.Flags == other.Flags
            && self.DeviceSize == other.DeviceSize
    }
}
impl ::std::cmp::Eq for SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO {}
unsafe impl ::windows::runtime::Abi for SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO_0 {
    pub _bitfield: u32,
}
impl SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO_0 {}
impl ::std::default::Default for SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Flags_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO_0 {}
unsafe impl ::windows::runtime::Abi for SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct SCM_BUS_DEDICATED_MEMORY_STATE {
    pub ActivateState: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl SCM_BUS_DEDICATED_MEMORY_STATE {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for SCM_BUS_DEDICATED_MEMORY_STATE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for SCM_BUS_DEDICATED_MEMORY_STATE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_BUS_DEDICATED_MEMORY_STATE")
            .field("ActivateState", &self.ActivateState)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for SCM_BUS_DEDICATED_MEMORY_STATE {
    fn eq(&self, other: &Self) -> bool {
        self.ActivateState == other.ActivateState
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for SCM_BUS_DEDICATED_MEMORY_STATE {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for SCM_BUS_DEDICATED_MEMORY_STATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SCM_BUS_FIRMWARE_ACTIVATION_STATE(pub i32);
pub const ScmBusFirmwareActivationState_Idle: SCM_BUS_FIRMWARE_ACTIVATION_STATE =
    SCM_BUS_FIRMWARE_ACTIVATION_STATE(0i32);
pub const ScmBusFirmwareActivationState_Armed: SCM_BUS_FIRMWARE_ACTIVATION_STATE =
    SCM_BUS_FIRMWARE_ACTIVATION_STATE(1i32);
pub const ScmBusFirmwareActivationState_Busy: SCM_BUS_FIRMWARE_ACTIVATION_STATE =
    SCM_BUS_FIRMWARE_ACTIVATION_STATE(2i32);
impl ::std::convert::From<i32> for SCM_BUS_FIRMWARE_ACTIVATION_STATE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SCM_BUS_FIRMWARE_ACTIVATION_STATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SCM_BUS_PROPERTY_ID(pub i32);
pub const ScmBusProperty_RuntimeFwActivationInfo: SCM_BUS_PROPERTY_ID = SCM_BUS_PROPERTY_ID(0i32);
pub const ScmBusProperty_DedicatedMemoryInfo: SCM_BUS_PROPERTY_ID = SCM_BUS_PROPERTY_ID(1i32);
pub const ScmBusProperty_DedicatedMemoryState: SCM_BUS_PROPERTY_ID = SCM_BUS_PROPERTY_ID(2i32);
pub const ScmBusProperty_Max: SCM_BUS_PROPERTY_ID = SCM_BUS_PROPERTY_ID(3i32);
impl ::std::convert::From<i32> for SCM_BUS_PROPERTY_ID {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SCM_BUS_PROPERTY_ID {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_BUS_PROPERTY_QUERY {
    pub Version: u32,
    pub Size: u32,
    pub PropertyId: SCM_BUS_PROPERTY_ID,
    pub QueryType: SCM_BUS_QUERY_TYPE,
    pub AdditionalParameters: [u8; 1],
}
impl SCM_BUS_PROPERTY_QUERY {}
impl ::std::default::Default for SCM_BUS_PROPERTY_QUERY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_BUS_PROPERTY_QUERY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_BUS_PROPERTY_QUERY")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("PropertyId", &self.PropertyId)
            .field("QueryType", &self.QueryType)
            .field("AdditionalParameters", &self.AdditionalParameters)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_BUS_PROPERTY_QUERY {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.PropertyId == other.PropertyId
            && self.QueryType == other.QueryType
            && self.AdditionalParameters == other.AdditionalParameters
    }
}
impl ::std::cmp::Eq for SCM_BUS_PROPERTY_QUERY {}
unsafe impl ::windows::runtime::Abi for SCM_BUS_PROPERTY_QUERY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_BUS_PROPERTY_SET {
    pub Version: u32,
    pub Size: u32,
    pub PropertyId: SCM_BUS_PROPERTY_ID,
    pub SetType: SCM_BUS_SET_TYPE,
    pub AdditionalParameters: [u8; 1],
}
impl SCM_BUS_PROPERTY_SET {}
impl ::std::default::Default for SCM_BUS_PROPERTY_SET {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_BUS_PROPERTY_SET {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_BUS_PROPERTY_SET")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("PropertyId", &self.PropertyId)
            .field("SetType", &self.SetType)
            .field("AdditionalParameters", &self.AdditionalParameters)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_BUS_PROPERTY_SET {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.PropertyId == other.PropertyId
            && self.SetType == other.SetType
            && self.AdditionalParameters == other.AdditionalParameters
    }
}
impl ::std::cmp::Eq for SCM_BUS_PROPERTY_SET {}
unsafe impl ::windows::runtime::Abi for SCM_BUS_PROPERTY_SET {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SCM_BUS_QUERY_TYPE(pub i32);
pub const ScmBusQuery_Descriptor: SCM_BUS_QUERY_TYPE = SCM_BUS_QUERY_TYPE(0i32);
pub const ScmBusQuery_IsSupported: SCM_BUS_QUERY_TYPE = SCM_BUS_QUERY_TYPE(1i32);
pub const ScmBusQuery_Max: SCM_BUS_QUERY_TYPE = SCM_BUS_QUERY_TYPE(2i32);
impl ::std::convert::From<i32> for SCM_BUS_QUERY_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SCM_BUS_QUERY_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct SCM_BUS_RUNTIME_FW_ACTIVATION_INFO {
    pub Version: u32,
    pub Size: u32,
    pub RuntimeFwActivationSupported: super::super::Foundation::BOOLEAN,
    pub FirmwareActivationState: SCM_BUS_FIRMWARE_ACTIVATION_STATE,
    pub FirmwareActivationCapability: SCM_BUS_RUNTIME_FW_ACTIVATION_INFO_0,
    pub EstimatedFirmwareActivationTimeInUSecs: u64,
    pub EstimatedProcessorAccessQuiesceTimeInUSecs: u64,
    pub EstimatedIOAccessQuiesceTimeInUSecs: u64,
    pub PlatformSupportedMaxIOAccessQuiesceTimeInUSecs: u64,
}
#[cfg(feature = "Win32_Foundation")]
impl SCM_BUS_RUNTIME_FW_ACTIVATION_INFO {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for SCM_BUS_RUNTIME_FW_ACTIVATION_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for SCM_BUS_RUNTIME_FW_ACTIVATION_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_BUS_RUNTIME_FW_ACTIVATION_INFO")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field(
                "RuntimeFwActivationSupported",
                &self.RuntimeFwActivationSupported,
            )
            .field("FirmwareActivationState", &self.FirmwareActivationState)
            .field(
                "FirmwareActivationCapability",
                &self.FirmwareActivationCapability,
            )
            .field(
                "EstimatedFirmwareActivationTimeInUSecs",
                &self.EstimatedFirmwareActivationTimeInUSecs,
            )
            .field(
                "EstimatedProcessorAccessQuiesceTimeInUSecs",
                &self.EstimatedProcessorAccessQuiesceTimeInUSecs,
            )
            .field(
                "EstimatedIOAccessQuiesceTimeInUSecs",
                &self.EstimatedIOAccessQuiesceTimeInUSecs,
            )
            .field(
                "PlatformSupportedMaxIOAccessQuiesceTimeInUSecs",
                &self.PlatformSupportedMaxIOAccessQuiesceTimeInUSecs,
            )
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for SCM_BUS_RUNTIME_FW_ACTIVATION_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.RuntimeFwActivationSupported == other.RuntimeFwActivationSupported
            && self.FirmwareActivationState == other.FirmwareActivationState
            && self.FirmwareActivationCapability == other.FirmwareActivationCapability
            && self.EstimatedFirmwareActivationTimeInUSecs
                == other.EstimatedFirmwareActivationTimeInUSecs
            && self.EstimatedProcessorAccessQuiesceTimeInUSecs
                == other.EstimatedProcessorAccessQuiesceTimeInUSecs
            && self.EstimatedIOAccessQuiesceTimeInUSecs == other.EstimatedIOAccessQuiesceTimeInUSecs
            && self.PlatformSupportedMaxIOAccessQuiesceTimeInUSecs
                == other.PlatformSupportedMaxIOAccessQuiesceTimeInUSecs
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for SCM_BUS_RUNTIME_FW_ACTIVATION_INFO {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for SCM_BUS_RUNTIME_FW_ACTIVATION_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_BUS_RUNTIME_FW_ACTIVATION_INFO_0 {
    pub _bitfield: u32,
}
impl SCM_BUS_RUNTIME_FW_ACTIVATION_INFO_0 {}
impl ::std::default::Default for SCM_BUS_RUNTIME_FW_ACTIVATION_INFO_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_BUS_RUNTIME_FW_ACTIVATION_INFO_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_FirmwareActivationCapability_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_BUS_RUNTIME_FW_ACTIVATION_INFO_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for SCM_BUS_RUNTIME_FW_ACTIVATION_INFO_0 {}
unsafe impl ::windows::runtime::Abi for SCM_BUS_RUNTIME_FW_ACTIVATION_INFO_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SCM_BUS_SET_TYPE(pub i32);
pub const ScmBusSet_Descriptor: SCM_BUS_SET_TYPE = SCM_BUS_SET_TYPE(0i32);
pub const ScmBusSet_IsSupported: SCM_BUS_SET_TYPE = SCM_BUS_SET_TYPE(1i32);
pub const ScmBusSet_Max: SCM_BUS_SET_TYPE = SCM_BUS_SET_TYPE(2i32);
impl ::std::convert::From<i32> for SCM_BUS_SET_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SCM_BUS_SET_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_INTERLEAVED_PD_INFO {
    pub DeviceHandle: u32,
    pub DeviceGuid: ::windows::runtime::GUID,
}
impl SCM_INTERLEAVED_PD_INFO {}
impl ::std::default::Default for SCM_INTERLEAVED_PD_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_INTERLEAVED_PD_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_INTERLEAVED_PD_INFO")
            .field("DeviceHandle", &self.DeviceHandle)
            .field("DeviceGuid", &self.DeviceGuid)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_INTERLEAVED_PD_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.DeviceHandle == other.DeviceHandle && self.DeviceGuid == other.DeviceGuid
    }
}
impl ::std::cmp::Eq for SCM_INTERLEAVED_PD_INFO {}
unsafe impl ::windows::runtime::Abi for SCM_INTERLEAVED_PD_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_LD_INTERLEAVE_SET_INFO {
    pub Version: u32,
    pub Size: u32,
    pub InterleaveSetSize: u32,
    pub InterleaveSet: [SCM_INTERLEAVED_PD_INFO; 1],
}
impl SCM_LD_INTERLEAVE_SET_INFO {}
impl ::std::default::Default for SCM_LD_INTERLEAVE_SET_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_LD_INTERLEAVE_SET_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_LD_INTERLEAVE_SET_INFO")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("InterleaveSetSize", &self.InterleaveSetSize)
            .field("InterleaveSet", &self.InterleaveSet)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_LD_INTERLEAVE_SET_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.InterleaveSetSize == other.InterleaveSetSize
            && self.InterleaveSet == other.InterleaveSet
    }
}
impl ::std::cmp::Eq for SCM_LD_INTERLEAVE_SET_INFO {}
unsafe impl ::windows::runtime::Abi for SCM_LD_INTERLEAVE_SET_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_LOGICAL_DEVICES {
    pub Version: u32,
    pub Size: u32,
    pub DeviceCount: u32,
    pub Devices: [SCM_LOGICAL_DEVICE_INSTANCE; 1],
}
impl SCM_LOGICAL_DEVICES {}
impl ::std::default::Default for SCM_LOGICAL_DEVICES {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_LOGICAL_DEVICES {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_LOGICAL_DEVICES")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("DeviceCount", &self.DeviceCount)
            .field("Devices", &self.Devices)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_LOGICAL_DEVICES {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.DeviceCount == other.DeviceCount
            && self.Devices == other.Devices
    }
}
impl ::std::cmp::Eq for SCM_LOGICAL_DEVICES {}
unsafe impl ::windows::runtime::Abi for SCM_LOGICAL_DEVICES {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_LOGICAL_DEVICE_INSTANCE {
    pub Version: u32,
    pub Size: u32,
    pub DeviceGuid: ::windows::runtime::GUID,
    pub SymbolicLink: [u16; 256],
}
impl SCM_LOGICAL_DEVICE_INSTANCE {}
impl ::std::default::Default for SCM_LOGICAL_DEVICE_INSTANCE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_LOGICAL_DEVICE_INSTANCE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_LOGICAL_DEVICE_INSTANCE")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("DeviceGuid", &self.DeviceGuid)
            .field("SymbolicLink", &self.SymbolicLink)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_LOGICAL_DEVICE_INSTANCE {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.DeviceGuid == other.DeviceGuid
            && self.SymbolicLink == other.SymbolicLink
    }
}
impl ::std::cmp::Eq for SCM_LOGICAL_DEVICE_INSTANCE {}
unsafe impl ::windows::runtime::Abi for SCM_LOGICAL_DEVICE_INSTANCE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SCM_MAX_SYMLINK_LEN_IN_CHARS: u32 = 256u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_DESCRIPTOR_HEADER {
    pub Version: u32,
    pub Size: u32,
}
impl SCM_PD_DESCRIPTOR_HEADER {}
impl ::std::default::Default for SCM_PD_DESCRIPTOR_HEADER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_DESCRIPTOR_HEADER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_DESCRIPTOR_HEADER")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_DESCRIPTOR_HEADER {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Size == other.Size
    }
}
impl ::std::cmp::Eq for SCM_PD_DESCRIPTOR_HEADER {}
unsafe impl ::windows::runtime::Abi for SCM_PD_DESCRIPTOR_HEADER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_DEVICE_HANDLE {
    pub Version: u32,
    pub Size: u32,
    pub DeviceGuid: ::windows::runtime::GUID,
    pub DeviceHandle: u32,
}
impl SCM_PD_DEVICE_HANDLE {}
impl ::std::default::Default for SCM_PD_DEVICE_HANDLE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_DEVICE_HANDLE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_DEVICE_HANDLE")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("DeviceGuid", &self.DeviceGuid)
            .field("DeviceHandle", &self.DeviceHandle)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_DEVICE_HANDLE {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.DeviceGuid == other.DeviceGuid
            && self.DeviceHandle == other.DeviceHandle
    }
}
impl ::std::cmp::Eq for SCM_PD_DEVICE_HANDLE {}
unsafe impl ::windows::runtime::Abi for SCM_PD_DEVICE_HANDLE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_DEVICE_INFO {
    pub Version: u32,
    pub Size: u32,
    pub DeviceGuid: ::windows::runtime::GUID,
    pub UnsafeShutdownCount: u32,
    pub PersistentMemorySizeInBytes: u64,
    pub VolatileMemorySizeInBytes: u64,
    pub TotalMemorySizeInBytes: u64,
    pub SlotNumber: u32,
    pub DeviceHandle: u32,
    pub PhysicalId: u16,
    pub NumberOfFormatInterfaceCodes: u8,
    pub FormatInterfaceCodes: [u16; 8],
    pub VendorId: u32,
    pub ProductId: u32,
    pub SubsystemDeviceId: u32,
    pub SubsystemVendorId: u32,
    pub ManufacturingLocation: u8,
    pub ManufacturingWeek: u8,
    pub ManufacturingYear: u8,
    pub SerialNumber4Byte: u32,
    pub SerialNumberLengthInChars: u32,
    pub SerialNumber: [CHAR; 1],
}
impl SCM_PD_DEVICE_INFO {}
impl ::std::default::Default for SCM_PD_DEVICE_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_DEVICE_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_DEVICE_INFO")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("DeviceGuid", &self.DeviceGuid)
            .field("UnsafeShutdownCount", &self.UnsafeShutdownCount)
            .field(
                "PersistentMemorySizeInBytes",
                &self.PersistentMemorySizeInBytes,
            )
            .field("VolatileMemorySizeInBytes", &self.VolatileMemorySizeInBytes)
            .field("TotalMemorySizeInBytes", &self.TotalMemorySizeInBytes)
            .field("SlotNumber", &self.SlotNumber)
            .field("DeviceHandle", &self.DeviceHandle)
            .field("PhysicalId", &self.PhysicalId)
            .field(
                "NumberOfFormatInterfaceCodes",
                &self.NumberOfFormatInterfaceCodes,
            )
            .field("FormatInterfaceCodes", &self.FormatInterfaceCodes)
            .field("VendorId", &self.VendorId)
            .field("ProductId", &self.ProductId)
            .field("SubsystemDeviceId", &self.SubsystemDeviceId)
            .field("SubsystemVendorId", &self.SubsystemVendorId)
            .field("ManufacturingLocation", &self.ManufacturingLocation)
            .field("ManufacturingWeek", &self.ManufacturingWeek)
            .field("ManufacturingYear", &self.ManufacturingYear)
            .field("SerialNumber4Byte", &self.SerialNumber4Byte)
            .field("SerialNumberLengthInChars", &self.SerialNumberLengthInChars)
            .field("SerialNumber", &self.SerialNumber)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_DEVICE_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.DeviceGuid == other.DeviceGuid
            && self.UnsafeShutdownCount == other.UnsafeShutdownCount
            && self.PersistentMemorySizeInBytes == other.PersistentMemorySizeInBytes
            && self.VolatileMemorySizeInBytes == other.VolatileMemorySizeInBytes
            && self.TotalMemorySizeInBytes == other.TotalMemorySizeInBytes
            && self.SlotNumber == other.SlotNumber
            && self.DeviceHandle == other.DeviceHandle
            && self.PhysicalId == other.PhysicalId
            && self.NumberOfFormatInterfaceCodes == other.NumberOfFormatInterfaceCodes
            && self.FormatInterfaceCodes == other.FormatInterfaceCodes
            && self.VendorId == other.VendorId
            && self.ProductId == other.ProductId
            && self.SubsystemDeviceId == other.SubsystemDeviceId
            && self.SubsystemVendorId == other.SubsystemVendorId
            && self.ManufacturingLocation == other.ManufacturingLocation
            && self.ManufacturingWeek == other.ManufacturingWeek
            && self.ManufacturingYear == other.ManufacturingYear
            && self.SerialNumber4Byte == other.SerialNumber4Byte
            && self.SerialNumberLengthInChars == other.SerialNumberLengthInChars
            && self.SerialNumber == other.SerialNumber
    }
}
impl ::std::cmp::Eq for SCM_PD_DEVICE_INFO {}
unsafe impl ::windows::runtime::Abi for SCM_PD_DEVICE_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_DEVICE_SPECIFIC_INFO {
    pub Version: u32,
    pub Size: u32,
    pub NumberOfProperties: u32,
    pub DeviceSpecificProperties: [SCM_PD_DEVICE_SPECIFIC_PROPERTY; 1],
}
impl SCM_PD_DEVICE_SPECIFIC_INFO {}
impl ::std::default::Default for SCM_PD_DEVICE_SPECIFIC_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_DEVICE_SPECIFIC_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_DEVICE_SPECIFIC_INFO")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("NumberOfProperties", &self.NumberOfProperties)
            .field("DeviceSpecificProperties", &self.DeviceSpecificProperties)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_DEVICE_SPECIFIC_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.NumberOfProperties == other.NumberOfProperties
            && self.DeviceSpecificProperties == other.DeviceSpecificProperties
    }
}
impl ::std::cmp::Eq for SCM_PD_DEVICE_SPECIFIC_INFO {}
unsafe impl ::windows::runtime::Abi for SCM_PD_DEVICE_SPECIFIC_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_DEVICE_SPECIFIC_PROPERTY {
    pub Name: [u16; 128],
    pub Value: i64,
}
impl SCM_PD_DEVICE_SPECIFIC_PROPERTY {}
impl ::std::default::Default for SCM_PD_DEVICE_SPECIFIC_PROPERTY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_DEVICE_SPECIFIC_PROPERTY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_DEVICE_SPECIFIC_PROPERTY")
            .field("Name", &self.Name)
            .field("Value", &self.Value)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_DEVICE_SPECIFIC_PROPERTY {
    fn eq(&self, other: &Self) -> bool {
        self.Name == other.Name && self.Value == other.Value
    }
}
impl ::std::cmp::Eq for SCM_PD_DEVICE_SPECIFIC_PROPERTY {}
unsafe impl ::windows::runtime::Abi for SCM_PD_DEVICE_SPECIFIC_PROPERTY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_FIRMWARE_ACTIVATE {
    pub Version: u32,
    pub Size: u32,
    pub Flags: u32,
    pub Slot: u8,
}
impl SCM_PD_FIRMWARE_ACTIVATE {}
impl ::std::default::Default for SCM_PD_FIRMWARE_ACTIVATE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_FIRMWARE_ACTIVATE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_FIRMWARE_ACTIVATE")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("Slot", &self.Slot)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_FIRMWARE_ACTIVATE {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.Flags == other.Flags
            && self.Slot == other.Slot
    }
}
impl ::std::cmp::Eq for SCM_PD_FIRMWARE_ACTIVATE {}
unsafe impl ::windows::runtime::Abi for SCM_PD_FIRMWARE_ACTIVATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SCM_PD_FIRMWARE_ACTIVATION_STATE(pub i32);
pub const ScmPdFirmwareActivationState_Idle: SCM_PD_FIRMWARE_ACTIVATION_STATE =
    SCM_PD_FIRMWARE_ACTIVATION_STATE(0i32);
pub const ScmPdFirmwareActivationState_Armed: SCM_PD_FIRMWARE_ACTIVATION_STATE =
    SCM_PD_FIRMWARE_ACTIVATION_STATE(1i32);
pub const ScmPdFirmwareActivationState_Busy: SCM_PD_FIRMWARE_ACTIVATION_STATE =
    SCM_PD_FIRMWARE_ACTIVATION_STATE(2i32);
impl ::std::convert::From<i32> for SCM_PD_FIRMWARE_ACTIVATION_STATE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SCM_PD_FIRMWARE_ACTIVATION_STATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_FIRMWARE_DOWNLOAD {
    pub Version: u32,
    pub Size: u32,
    pub Flags: u32,
    pub Slot: u8,
    pub Reserved: [u8; 3],
    pub Offset: u64,
    pub FirmwareImageSizeInBytes: u32,
    pub FirmwareImage: [u8; 1],
}
impl SCM_PD_FIRMWARE_DOWNLOAD {}
impl ::std::default::Default for SCM_PD_FIRMWARE_DOWNLOAD {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_FIRMWARE_DOWNLOAD {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_FIRMWARE_DOWNLOAD")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("Slot", &self.Slot)
            .field("Reserved", &self.Reserved)
            .field("Offset", &self.Offset)
            .field("FirmwareImageSizeInBytes", &self.FirmwareImageSizeInBytes)
            .field("FirmwareImage", &self.FirmwareImage)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_FIRMWARE_DOWNLOAD {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.Flags == other.Flags
            && self.Slot == other.Slot
            && self.Reserved == other.Reserved
            && self.Offset == other.Offset
            && self.FirmwareImageSizeInBytes == other.FirmwareImageSizeInBytes
            && self.FirmwareImage == other.FirmwareImage
    }
}
impl ::std::cmp::Eq for SCM_PD_FIRMWARE_DOWNLOAD {}
unsafe impl ::windows::runtime::Abi for SCM_PD_FIRMWARE_DOWNLOAD {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_FIRMWARE_INFO {
    pub Version: u32,
    pub Size: u32,
    pub ActiveSlot: u8,
    pub NextActiveSlot: u8,
    pub SlotCount: u8,
    pub Slots: [SCM_PD_FIRMWARE_SLOT_INFO; 1],
}
impl SCM_PD_FIRMWARE_INFO {}
impl ::std::default::Default for SCM_PD_FIRMWARE_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_FIRMWARE_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_FIRMWARE_INFO")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("ActiveSlot", &self.ActiveSlot)
            .field("NextActiveSlot", &self.NextActiveSlot)
            .field("SlotCount", &self.SlotCount)
            .field("Slots", &self.Slots)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_FIRMWARE_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.ActiveSlot == other.ActiveSlot
            && self.NextActiveSlot == other.NextActiveSlot
            && self.SlotCount == other.SlotCount
            && self.Slots == other.Slots
    }
}
impl ::std::cmp::Eq for SCM_PD_FIRMWARE_INFO {}
unsafe impl ::windows::runtime::Abi for SCM_PD_FIRMWARE_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SCM_PD_FIRMWARE_LAST_DOWNLOAD: u32 = 1u32;
pub const SCM_PD_FIRMWARE_REVISION_LENGTH_BYTES: u32 = 32u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_FIRMWARE_SLOT_INFO {
    pub Version: u32,
    pub Size: u32,
    pub SlotNumber: u8,
    pub _bitfield: u8,
    pub Reserved1: [u8; 6],
    pub Revision: [u8; 32],
}
impl SCM_PD_FIRMWARE_SLOT_INFO {}
impl ::std::default::Default for SCM_PD_FIRMWARE_SLOT_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_FIRMWARE_SLOT_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_FIRMWARE_SLOT_INFO")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("SlotNumber", &self.SlotNumber)
            .field("_bitfield", &self._bitfield)
            .field("Reserved1", &self.Reserved1)
            .field("Revision", &self.Revision)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_FIRMWARE_SLOT_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.SlotNumber == other.SlotNumber
            && self._bitfield == other._bitfield
            && self.Reserved1 == other.Reserved1
            && self.Revision == other.Revision
    }
}
impl ::std::cmp::Eq for SCM_PD_FIRMWARE_SLOT_INFO {}
unsafe impl ::windows::runtime::Abi for SCM_PD_FIRMWARE_SLOT_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_FRU_ID_STRING {
    pub Version: u32,
    pub Size: u32,
    pub IdentifierSize: u32,
    pub Identifier: [u8; 1],
}
impl SCM_PD_FRU_ID_STRING {}
impl ::std::default::Default for SCM_PD_FRU_ID_STRING {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_FRU_ID_STRING {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_FRU_ID_STRING")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("IdentifierSize", &self.IdentifierSize)
            .field("Identifier", &self.Identifier)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_FRU_ID_STRING {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.IdentifierSize == other.IdentifierSize
            && self.Identifier == other.Identifier
    }
}
impl ::std::cmp::Eq for SCM_PD_FRU_ID_STRING {}
unsafe impl ::windows::runtime::Abi for SCM_PD_FRU_ID_STRING {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_HEALTH_NOTIFICATION_DATA {
    pub DeviceGuid: ::windows::runtime::GUID,
}
impl SCM_PD_HEALTH_NOTIFICATION_DATA {}
impl ::std::default::Default for SCM_PD_HEALTH_NOTIFICATION_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_HEALTH_NOTIFICATION_DATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_HEALTH_NOTIFICATION_DATA")
            .field("DeviceGuid", &self.DeviceGuid)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_HEALTH_NOTIFICATION_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.DeviceGuid == other.DeviceGuid
    }
}
impl ::std::cmp::Eq for SCM_PD_HEALTH_NOTIFICATION_DATA {}
unsafe impl ::windows::runtime::Abi for SCM_PD_HEALTH_NOTIFICATION_DATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SCM_PD_HEALTH_STATUS(pub i32);
pub const ScmPhysicalDeviceHealth_Unknown: SCM_PD_HEALTH_STATUS = SCM_PD_HEALTH_STATUS(0i32);
pub const ScmPhysicalDeviceHealth_Unhealthy: SCM_PD_HEALTH_STATUS = SCM_PD_HEALTH_STATUS(1i32);
pub const ScmPhysicalDeviceHealth_Warning: SCM_PD_HEALTH_STATUS = SCM_PD_HEALTH_STATUS(2i32);
pub const ScmPhysicalDeviceHealth_Healthy: SCM_PD_HEALTH_STATUS = SCM_PD_HEALTH_STATUS(3i32);
pub const ScmPhysicalDeviceHealth_Max: SCM_PD_HEALTH_STATUS = SCM_PD_HEALTH_STATUS(4i32);
impl ::std::convert::From<i32> for SCM_PD_HEALTH_STATUS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SCM_PD_HEALTH_STATUS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SCM_PD_LAST_FW_ACTIVATION_STATUS(pub i32);
pub const ScmPdLastFwActivationStatus_None: SCM_PD_LAST_FW_ACTIVATION_STATUS =
    SCM_PD_LAST_FW_ACTIVATION_STATUS(0i32);
pub const ScmPdLastFwActivationStatus_Success: SCM_PD_LAST_FW_ACTIVATION_STATUS =
    SCM_PD_LAST_FW_ACTIVATION_STATUS(1i32);
pub const ScmPdLastFwActivationStatus_FwNotFound: SCM_PD_LAST_FW_ACTIVATION_STATUS =
    SCM_PD_LAST_FW_ACTIVATION_STATUS(2i32);
pub const ScmPdLastFwActivationStatus_ColdRebootRequired: SCM_PD_LAST_FW_ACTIVATION_STATUS =
    SCM_PD_LAST_FW_ACTIVATION_STATUS(3i32);
pub const ScmPdLastFwActivaitonStatus_ActivationInProgress: SCM_PD_LAST_FW_ACTIVATION_STATUS =
    SCM_PD_LAST_FW_ACTIVATION_STATUS(4i32);
pub const ScmPdLastFwActivaitonStatus_Retry: SCM_PD_LAST_FW_ACTIVATION_STATUS =
    SCM_PD_LAST_FW_ACTIVATION_STATUS(5i32);
pub const ScmPdLastFwActivaitonStatus_FwUnsupported: SCM_PD_LAST_FW_ACTIVATION_STATUS =
    SCM_PD_LAST_FW_ACTIVATION_STATUS(6i32);
pub const ScmPdLastFwActivaitonStatus_UnknownError: SCM_PD_LAST_FW_ACTIVATION_STATUS =
    SCM_PD_LAST_FW_ACTIVATION_STATUS(7i32);
impl ::std::convert::From<i32> for SCM_PD_LAST_FW_ACTIVATION_STATUS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SCM_PD_LAST_FW_ACTIVATION_STATUS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_LOCATION_STRING {
    pub Version: u32,
    pub Size: u32,
    pub Location: [u16; 1],
}
impl SCM_PD_LOCATION_STRING {}
impl ::std::default::Default for SCM_PD_LOCATION_STRING {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_LOCATION_STRING {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_LOCATION_STRING")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Location", &self.Location)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_LOCATION_STRING {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Size == other.Size && self.Location == other.Location
    }
}
impl ::std::cmp::Eq for SCM_PD_LOCATION_STRING {}
unsafe impl ::windows::runtime::Abi for SCM_PD_LOCATION_STRING {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_MANAGEMENT_STATUS {
    pub Version: u32,
    pub Size: u32,
    pub Health: SCM_PD_HEALTH_STATUS,
    pub NumberOfOperationalStatus: u32,
    pub NumberOfAdditionalReasons: u32,
    pub OperationalStatus: [SCM_PD_OPERATIONAL_STATUS; 16],
    pub AdditionalReasons: [SCM_PD_OPERATIONAL_STATUS_REASON; 1],
}
impl SCM_PD_MANAGEMENT_STATUS {}
impl ::std::default::Default for SCM_PD_MANAGEMENT_STATUS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_MANAGEMENT_STATUS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_MANAGEMENT_STATUS")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Health", &self.Health)
            .field("NumberOfOperationalStatus", &self.NumberOfOperationalStatus)
            .field("NumberOfAdditionalReasons", &self.NumberOfAdditionalReasons)
            .field("OperationalStatus", &self.OperationalStatus)
            .field("AdditionalReasons", &self.AdditionalReasons)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_MANAGEMENT_STATUS {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.Health == other.Health
            && self.NumberOfOperationalStatus == other.NumberOfOperationalStatus
            && self.NumberOfAdditionalReasons == other.NumberOfAdditionalReasons
            && self.OperationalStatus == other.OperationalStatus
            && self.AdditionalReasons == other.AdditionalReasons
    }
}
impl ::std::cmp::Eq for SCM_PD_MANAGEMENT_STATUS {}
unsafe impl ::windows::runtime::Abi for SCM_PD_MANAGEMENT_STATUS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SCM_PD_MAX_OPERATIONAL_STATUS: u32 = 16u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SCM_PD_MEDIA_REINITIALIZATION_STATUS(pub i32);
pub const ScmPhysicalDeviceReinit_Success: SCM_PD_MEDIA_REINITIALIZATION_STATUS =
    SCM_PD_MEDIA_REINITIALIZATION_STATUS(0i32);
pub const ScmPhysicalDeviceReinit_RebootNeeded: SCM_PD_MEDIA_REINITIALIZATION_STATUS =
    SCM_PD_MEDIA_REINITIALIZATION_STATUS(1i32);
pub const ScmPhysicalDeviceReinit_ColdBootNeeded: SCM_PD_MEDIA_REINITIALIZATION_STATUS =
    SCM_PD_MEDIA_REINITIALIZATION_STATUS(2i32);
pub const ScmPhysicalDeviceReinit_Max: SCM_PD_MEDIA_REINITIALIZATION_STATUS =
    SCM_PD_MEDIA_REINITIALIZATION_STATUS(3i32);
impl ::std::convert::From<i32> for SCM_PD_MEDIA_REINITIALIZATION_STATUS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SCM_PD_MEDIA_REINITIALIZATION_STATUS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SCM_PD_OPERATIONAL_STATUS(pub i32);
pub const ScmPhysicalDeviceOpStatus_Unknown: SCM_PD_OPERATIONAL_STATUS =
    SCM_PD_OPERATIONAL_STATUS(0i32);
pub const ScmPhysicalDeviceOpStatus_Ok: SCM_PD_OPERATIONAL_STATUS = SCM_PD_OPERATIONAL_STATUS(1i32);
pub const ScmPhysicalDeviceOpStatus_PredictingFailure: SCM_PD_OPERATIONAL_STATUS =
    SCM_PD_OPERATIONAL_STATUS(2i32);
pub const ScmPhysicalDeviceOpStatus_InService: SCM_PD_OPERATIONAL_STATUS =
    SCM_PD_OPERATIONAL_STATUS(3i32);
pub const ScmPhysicalDeviceOpStatus_HardwareError: SCM_PD_OPERATIONAL_STATUS =
    SCM_PD_OPERATIONAL_STATUS(4i32);
pub const ScmPhysicalDeviceOpStatus_NotUsable: SCM_PD_OPERATIONAL_STATUS =
    SCM_PD_OPERATIONAL_STATUS(5i32);
pub const ScmPhysicalDeviceOpStatus_TransientError: SCM_PD_OPERATIONAL_STATUS =
    SCM_PD_OPERATIONAL_STATUS(6i32);
pub const ScmPhysicalDeviceOpStatus_Missing: SCM_PD_OPERATIONAL_STATUS =
    SCM_PD_OPERATIONAL_STATUS(7i32);
pub const ScmPhysicalDeviceOpStatus_Max: SCM_PD_OPERATIONAL_STATUS =
    SCM_PD_OPERATIONAL_STATUS(8i32);
impl ::std::convert::From<i32> for SCM_PD_OPERATIONAL_STATUS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SCM_PD_OPERATIONAL_STATUS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SCM_PD_OPERATIONAL_STATUS_REASON(pub i32);
pub const ScmPhysicalDeviceOpReason_Unknown: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(0i32);
pub const ScmPhysicalDeviceOpReason_Media: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(1i32);
pub const ScmPhysicalDeviceOpReason_ThresholdExceeded: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(2i32);
pub const ScmPhysicalDeviceOpReason_LostData: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(3i32);
pub const ScmPhysicalDeviceOpReason_EnergySource: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(4i32);
pub const ScmPhysicalDeviceOpReason_Configuration: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(5i32);
pub const ScmPhysicalDeviceOpReason_DeviceController: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(6i32);
pub const ScmPhysicalDeviceOpReason_MediaController: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(7i32);
pub const ScmPhysicalDeviceOpReason_Component: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(8i32);
pub const ScmPhysicalDeviceOpReason_BackgroundOperation: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(9i32);
pub const ScmPhysicalDeviceOpReason_InvalidFirmware: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(10i32);
pub const ScmPhysicalDeviceOpReason_HealthCheck: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(11i32);
pub const ScmPhysicalDeviceOpReason_LostDataPersistence: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(12i32);
pub const ScmPhysicalDeviceOpReason_DisabledByPlatform: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(13i32);
pub const ScmPhysicalDeviceOpReason_PermanentError: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(14i32);
pub const ScmPhysicalDeviceOpReason_LostWritePersistence: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(15i32);
pub const ScmPhysicalDeviceOpReason_FatalError: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(16i32);
pub const ScmPhysicalDeviceOpReason_DataPersistenceLossImminent: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(17i32);
pub const ScmPhysicalDeviceOpReason_WritePersistenceLossImminent: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(18i32);
pub const ScmPhysicalDeviceOpReason_MediaRemainingSpareBlock: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(19i32);
pub const ScmPhysicalDeviceOpReason_PerformanceDegradation: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(20i32);
pub const ScmPhysicalDeviceOpReason_ExcessiveTemperature: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(21i32);
pub const ScmPhysicalDeviceOpReason_InternalFailure: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(22i32);
pub const ScmPhysicalDeviceOpReason_Max: SCM_PD_OPERATIONAL_STATUS_REASON =
    SCM_PD_OPERATIONAL_STATUS_REASON(23i32);
impl ::std::convert::From<i32> for SCM_PD_OPERATIONAL_STATUS_REASON {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SCM_PD_OPERATIONAL_STATUS_REASON {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_PASSTHROUGH_INPUT {
    pub Version: u32,
    pub Size: u32,
    pub ProtocolGuid: ::windows::runtime::GUID,
    pub DataSize: u32,
    pub Data: [u8; 1],
}
impl SCM_PD_PASSTHROUGH_INPUT {}
impl ::std::default::Default for SCM_PD_PASSTHROUGH_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_PASSTHROUGH_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_PASSTHROUGH_INPUT")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("ProtocolGuid", &self.ProtocolGuid)
            .field("DataSize", &self.DataSize)
            .field("Data", &self.Data)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_PASSTHROUGH_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.ProtocolGuid == other.ProtocolGuid
            && self.DataSize == other.DataSize
            && self.Data == other.Data
    }
}
impl ::std::cmp::Eq for SCM_PD_PASSTHROUGH_INPUT {}
unsafe impl ::windows::runtime::Abi for SCM_PD_PASSTHROUGH_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_PASSTHROUGH_INVDIMM_INPUT {
    pub Opcode: u32,
    pub OpcodeParametersLength: u32,
    pub OpcodeParameters: [u8; 1],
}
impl SCM_PD_PASSTHROUGH_INVDIMM_INPUT {}
impl ::std::default::Default for SCM_PD_PASSTHROUGH_INVDIMM_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_PASSTHROUGH_INVDIMM_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_PASSTHROUGH_INVDIMM_INPUT")
            .field("Opcode", &self.Opcode)
            .field("OpcodeParametersLength", &self.OpcodeParametersLength)
            .field("OpcodeParameters", &self.OpcodeParameters)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_PASSTHROUGH_INVDIMM_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Opcode == other.Opcode
            && self.OpcodeParametersLength == other.OpcodeParametersLength
            && self.OpcodeParameters == other.OpcodeParameters
    }
}
impl ::std::cmp::Eq for SCM_PD_PASSTHROUGH_INVDIMM_INPUT {}
unsafe impl ::windows::runtime::Abi for SCM_PD_PASSTHROUGH_INVDIMM_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT {
    pub GeneralStatus: u16,
    pub ExtendedStatus: u16,
    pub OutputDataLength: u32,
    pub OutputData: [u8; 1],
}
impl SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT {}
impl ::std::default::Default for SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT")
            .field("GeneralStatus", &self.GeneralStatus)
            .field("ExtendedStatus", &self.ExtendedStatus)
            .field("OutputDataLength", &self.OutputDataLength)
            .field("OutputData", &self.OutputData)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.GeneralStatus == other.GeneralStatus
            && self.ExtendedStatus == other.ExtendedStatus
            && self.OutputDataLength == other.OutputDataLength
            && self.OutputData == other.OutputData
    }
}
impl ::std::cmp::Eq for SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT {}
unsafe impl ::windows::runtime::Abi for SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_PASSTHROUGH_OUTPUT {
    pub Version: u32,
    pub Size: u32,
    pub ProtocolGuid: ::windows::runtime::GUID,
    pub DataSize: u32,
    pub Data: [u8; 1],
}
impl SCM_PD_PASSTHROUGH_OUTPUT {}
impl ::std::default::Default for SCM_PD_PASSTHROUGH_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_PASSTHROUGH_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_PASSTHROUGH_OUTPUT")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("ProtocolGuid", &self.ProtocolGuid)
            .field("DataSize", &self.DataSize)
            .field("Data", &self.Data)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_PASSTHROUGH_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.ProtocolGuid == other.ProtocolGuid
            && self.DataSize == other.DataSize
            && self.Data == other.Data
    }
}
impl ::std::cmp::Eq for SCM_PD_PASSTHROUGH_OUTPUT {}
unsafe impl ::windows::runtime::Abi for SCM_PD_PASSTHROUGH_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SCM_PD_PROPERTY_ID(pub i32);
pub const ScmPhysicalDeviceProperty_DeviceInfo: SCM_PD_PROPERTY_ID = SCM_PD_PROPERTY_ID(0i32);
pub const ScmPhysicalDeviceProperty_ManagementStatus: SCM_PD_PROPERTY_ID = SCM_PD_PROPERTY_ID(1i32);
pub const ScmPhysicalDeviceProperty_FirmwareInfo: SCM_PD_PROPERTY_ID = SCM_PD_PROPERTY_ID(2i32);
pub const ScmPhysicalDeviceProperty_LocationString: SCM_PD_PROPERTY_ID = SCM_PD_PROPERTY_ID(3i32);
pub const ScmPhysicalDeviceProperty_DeviceSpecificInfo: SCM_PD_PROPERTY_ID =
    SCM_PD_PROPERTY_ID(4i32);
pub const ScmPhysicalDeviceProperty_DeviceHandle: SCM_PD_PROPERTY_ID = SCM_PD_PROPERTY_ID(5i32);
pub const ScmPhysicalDeviceProperty_FruIdString: SCM_PD_PROPERTY_ID = SCM_PD_PROPERTY_ID(6i32);
pub const ScmPhysicalDeviceProperty_RuntimeFwActivationInfo: SCM_PD_PROPERTY_ID =
    SCM_PD_PROPERTY_ID(7i32);
pub const ScmPhysicalDeviceProperty_RuntimeFwActivationArmState: SCM_PD_PROPERTY_ID =
    SCM_PD_PROPERTY_ID(8i32);
pub const ScmPhysicalDeviceProperty_Max: SCM_PD_PROPERTY_ID = SCM_PD_PROPERTY_ID(9i32);
impl ::std::convert::From<i32> for SCM_PD_PROPERTY_ID {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SCM_PD_PROPERTY_ID {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SCM_PD_PROPERTY_NAME_LENGTH_IN_CHARS: u32 = 128u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_PROPERTY_QUERY {
    pub Version: u32,
    pub Size: u32,
    pub PropertyId: SCM_PD_PROPERTY_ID,
    pub QueryType: SCM_PD_QUERY_TYPE,
    pub AdditionalParameters: [u8; 1],
}
impl SCM_PD_PROPERTY_QUERY {}
impl ::std::default::Default for SCM_PD_PROPERTY_QUERY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_PROPERTY_QUERY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_PROPERTY_QUERY")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("PropertyId", &self.PropertyId)
            .field("QueryType", &self.QueryType)
            .field("AdditionalParameters", &self.AdditionalParameters)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_PROPERTY_QUERY {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.PropertyId == other.PropertyId
            && self.QueryType == other.QueryType
            && self.AdditionalParameters == other.AdditionalParameters
    }
}
impl ::std::cmp::Eq for SCM_PD_PROPERTY_QUERY {}
unsafe impl ::windows::runtime::Abi for SCM_PD_PROPERTY_QUERY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_PROPERTY_SET {
    pub Version: u32,
    pub Size: u32,
    pub PropertyId: SCM_PD_PROPERTY_ID,
    pub SetType: SCM_PD_SET_TYPE,
    pub AdditionalParameters: [u8; 1],
}
impl SCM_PD_PROPERTY_SET {}
impl ::std::default::Default for SCM_PD_PROPERTY_SET {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_PROPERTY_SET {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_PROPERTY_SET")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("PropertyId", &self.PropertyId)
            .field("SetType", &self.SetType)
            .field("AdditionalParameters", &self.AdditionalParameters)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_PROPERTY_SET {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.PropertyId == other.PropertyId
            && self.SetType == other.SetType
            && self.AdditionalParameters == other.AdditionalParameters
    }
}
impl ::std::cmp::Eq for SCM_PD_PROPERTY_SET {}
unsafe impl ::windows::runtime::Abi for SCM_PD_PROPERTY_SET {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SCM_PD_QUERY_TYPE(pub i32);
pub const ScmPhysicalDeviceQuery_Descriptor: SCM_PD_QUERY_TYPE = SCM_PD_QUERY_TYPE(0i32);
pub const ScmPhysicalDeviceQuery_IsSupported: SCM_PD_QUERY_TYPE = SCM_PD_QUERY_TYPE(1i32);
pub const ScmPhysicalDeviceQuery_Max: SCM_PD_QUERY_TYPE = SCM_PD_QUERY_TYPE(2i32);
impl ::std::convert::From<i32> for SCM_PD_QUERY_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SCM_PD_QUERY_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_REINITIALIZE_MEDIA_INPUT {
    pub Version: u32,
    pub Size: u32,
    pub Options: SCM_PD_REINITIALIZE_MEDIA_INPUT_0,
}
impl SCM_PD_REINITIALIZE_MEDIA_INPUT {}
impl ::std::default::Default for SCM_PD_REINITIALIZE_MEDIA_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_REINITIALIZE_MEDIA_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_REINITIALIZE_MEDIA_INPUT")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Options", &self.Options)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_REINITIALIZE_MEDIA_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Size == other.Size && self.Options == other.Options
    }
}
impl ::std::cmp::Eq for SCM_PD_REINITIALIZE_MEDIA_INPUT {}
unsafe impl ::windows::runtime::Abi for SCM_PD_REINITIALIZE_MEDIA_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_REINITIALIZE_MEDIA_INPUT_0 {
    pub _bitfield: u32,
}
impl SCM_PD_REINITIALIZE_MEDIA_INPUT_0 {}
impl ::std::default::Default for SCM_PD_REINITIALIZE_MEDIA_INPUT_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_REINITIALIZE_MEDIA_INPUT_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Options_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_REINITIALIZE_MEDIA_INPUT_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for SCM_PD_REINITIALIZE_MEDIA_INPUT_0 {}
unsafe impl ::windows::runtime::Abi for SCM_PD_REINITIALIZE_MEDIA_INPUT_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_REINITIALIZE_MEDIA_OUTPUT {
    pub Version: u32,
    pub Size: u32,
    pub Status: SCM_PD_MEDIA_REINITIALIZATION_STATUS,
}
impl SCM_PD_REINITIALIZE_MEDIA_OUTPUT {}
impl ::std::default::Default for SCM_PD_REINITIALIZE_MEDIA_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_REINITIALIZE_MEDIA_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_REINITIALIZE_MEDIA_OUTPUT")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Status", &self.Status)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_REINITIALIZE_MEDIA_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Size == other.Size && self.Status == other.Status
    }
}
impl ::std::cmp::Eq for SCM_PD_REINITIALIZE_MEDIA_OUTPUT {}
unsafe impl ::windows::runtime::Abi for SCM_PD_REINITIALIZE_MEDIA_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct SCM_PD_RUNTIME_FW_ACTIVATION_ARM_STATE {
    pub ArmState: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl SCM_PD_RUNTIME_FW_ACTIVATION_ARM_STATE {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for SCM_PD_RUNTIME_FW_ACTIVATION_ARM_STATE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for SCM_PD_RUNTIME_FW_ACTIVATION_ARM_STATE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_RUNTIME_FW_ACTIVATION_ARM_STATE")
            .field("ArmState", &self.ArmState)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for SCM_PD_RUNTIME_FW_ACTIVATION_ARM_STATE {
    fn eq(&self, other: &Self) -> bool {
        self.ArmState == other.ArmState
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for SCM_PD_RUNTIME_FW_ACTIVATION_ARM_STATE {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for SCM_PD_RUNTIME_FW_ACTIVATION_ARM_STATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PD_RUNTIME_FW_ACTIVATION_INFO {
    pub Version: u32,
    pub Size: u32,
    pub LastFirmwareActivationStatus: SCM_PD_LAST_FW_ACTIVATION_STATUS,
    pub FirmwareActivationState: SCM_PD_FIRMWARE_ACTIVATION_STATE,
}
impl SCM_PD_RUNTIME_FW_ACTIVATION_INFO {}
impl ::std::default::Default for SCM_PD_RUNTIME_FW_ACTIVATION_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PD_RUNTIME_FW_ACTIVATION_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PD_RUNTIME_FW_ACTIVATION_INFO")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field(
                "LastFirmwareActivationStatus",
                &self.LastFirmwareActivationStatus,
            )
            .field("FirmwareActivationState", &self.FirmwareActivationState)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PD_RUNTIME_FW_ACTIVATION_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.LastFirmwareActivationStatus == other.LastFirmwareActivationStatus
            && self.FirmwareActivationState == other.FirmwareActivationState
    }
}
impl ::std::cmp::Eq for SCM_PD_RUNTIME_FW_ACTIVATION_INFO {}
unsafe impl ::windows::runtime::Abi for SCM_PD_RUNTIME_FW_ACTIVATION_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SCM_PD_SET_TYPE(pub i32);
pub const ScmPhysicalDeviceSet_Descriptor: SCM_PD_SET_TYPE = SCM_PD_SET_TYPE(0i32);
pub const ScmPhysicalDeviceSet_IsSupported: SCM_PD_SET_TYPE = SCM_PD_SET_TYPE(1i32);
pub const ScmPhysicalDeviceSet_Max: SCM_PD_SET_TYPE = SCM_PD_SET_TYPE(2i32);
impl ::std::convert::From<i32> for SCM_PD_SET_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SCM_PD_SET_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PHYSICAL_DEVICES {
    pub Version: u32,
    pub Size: u32,
    pub DeviceCount: u32,
    pub Devices: [SCM_PHYSICAL_DEVICE_INSTANCE; 1],
}
impl SCM_PHYSICAL_DEVICES {}
impl ::std::default::Default for SCM_PHYSICAL_DEVICES {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PHYSICAL_DEVICES {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PHYSICAL_DEVICES")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("DeviceCount", &self.DeviceCount)
            .field("Devices", &self.Devices)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PHYSICAL_DEVICES {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.DeviceCount == other.DeviceCount
            && self.Devices == other.Devices
    }
}
impl ::std::cmp::Eq for SCM_PHYSICAL_DEVICES {}
unsafe impl ::windows::runtime::Abi for SCM_PHYSICAL_DEVICES {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_PHYSICAL_DEVICE_INSTANCE {
    pub Version: u32,
    pub Size: u32,
    pub NfitHandle: u32,
    pub SymbolicLink: [u16; 256],
}
impl SCM_PHYSICAL_DEVICE_INSTANCE {}
impl ::std::default::Default for SCM_PHYSICAL_DEVICE_INSTANCE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_PHYSICAL_DEVICE_INSTANCE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_PHYSICAL_DEVICE_INSTANCE")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("NfitHandle", &self.NfitHandle)
            .field("SymbolicLink", &self.SymbolicLink)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_PHYSICAL_DEVICE_INSTANCE {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.NfitHandle == other.NfitHandle
            && self.SymbolicLink == other.SymbolicLink
    }
}
impl ::std::cmp::Eq for SCM_PHYSICAL_DEVICE_INSTANCE {}
unsafe impl ::windows::runtime::Abi for SCM_PHYSICAL_DEVICE_INSTANCE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_REGION {
    pub Version: u32,
    pub Size: u32,
    pub Flags: u32,
    pub NfitHandle: u32,
    pub LogicalDeviceGuid: ::windows::runtime::GUID,
    pub AddressRangeType: ::windows::runtime::GUID,
    pub AssociatedId: u32,
    pub Length: u64,
    pub StartingDPA: u64,
    pub BaseSPA: u64,
    pub SPAOffset: u64,
    pub RegionOffset: u64,
}
impl SCM_REGION {}
impl ::std::default::Default for SCM_REGION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_REGION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_REGION")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("NfitHandle", &self.NfitHandle)
            .field("LogicalDeviceGuid", &self.LogicalDeviceGuid)
            .field("AddressRangeType", &self.AddressRangeType)
            .field("AssociatedId", &self.AssociatedId)
            .field("Length", &self.Length)
            .field("StartingDPA", &self.StartingDPA)
            .field("BaseSPA", &self.BaseSPA)
            .field("SPAOffset", &self.SPAOffset)
            .field("RegionOffset", &self.RegionOffset)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_REGION {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.Flags == other.Flags
            && self.NfitHandle == other.NfitHandle
            && self.LogicalDeviceGuid == other.LogicalDeviceGuid
            && self.AddressRangeType == other.AddressRangeType
            && self.AssociatedId == other.AssociatedId
            && self.Length == other.Length
            && self.StartingDPA == other.StartingDPA
            && self.BaseSPA == other.BaseSPA
            && self.SPAOffset == other.SPAOffset
            && self.RegionOffset == other.RegionOffset
    }
}
impl ::std::cmp::Eq for SCM_REGION {}
unsafe impl ::windows::runtime::Abi for SCM_REGION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCM_REGIONS {
    pub Version: u32,
    pub Size: u32,
    pub RegionCount: u32,
    pub Regions: [SCM_REGION; 1],
}
impl SCM_REGIONS {}
impl ::std::default::Default for SCM_REGIONS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCM_REGIONS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCM_REGIONS")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("RegionCount", &self.RegionCount)
            .field("Regions", &self.Regions)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCM_REGIONS {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.RegionCount == other.RegionCount
            && self.Regions == other.Regions
    }
}
impl ::std::cmp::Eq for SCM_REGIONS {}
unsafe impl ::windows::runtime::Abi for SCM_REGIONS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SCM_REGION_FLAG(pub i32);
pub const ScmRegionFlagNone: SCM_REGION_FLAG = SCM_REGION_FLAG(0i32);
pub const ScmRegionFlagLabel: SCM_REGION_FLAG = SCM_REGION_FLAG(1i32);
impl ::std::convert::From<i32> for SCM_REGION_FLAG {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SCM_REGION_FLAG {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCOPE_TABLE_AMD64 {
    pub Count: u32,
    pub ScopeRecord: [SCOPE_TABLE_AMD64_0; 1],
}
impl SCOPE_TABLE_AMD64 {}
impl ::std::default::Default for SCOPE_TABLE_AMD64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCOPE_TABLE_AMD64 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCOPE_TABLE_AMD64")
            .field("Count", &self.Count)
            .field("ScopeRecord", &self.ScopeRecord)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCOPE_TABLE_AMD64 {
    fn eq(&self, other: &Self) -> bool {
        self.Count == other.Count && self.ScopeRecord == other.ScopeRecord
    }
}
impl ::std::cmp::Eq for SCOPE_TABLE_AMD64 {}
unsafe impl ::windows::runtime::Abi for SCOPE_TABLE_AMD64 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCOPE_TABLE_AMD64_0 {
    pub BeginAddress: u32,
    pub EndAddress: u32,
    pub HandlerAddress: u32,
    pub JumpTarget: u32,
}
impl SCOPE_TABLE_AMD64_0 {}
impl ::std::default::Default for SCOPE_TABLE_AMD64_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCOPE_TABLE_AMD64_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("BeginAddress", &self.BeginAddress)
            .field("EndAddress", &self.EndAddress)
            .field("HandlerAddress", &self.HandlerAddress)
            .field("JumpTarget", &self.JumpTarget)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCOPE_TABLE_AMD64_0 {
    fn eq(&self, other: &Self) -> bool {
        self.BeginAddress == other.BeginAddress
            && self.EndAddress == other.EndAddress
            && self.HandlerAddress == other.HandlerAddress
            && self.JumpTarget == other.JumpTarget
    }
}
impl ::std::cmp::Eq for SCOPE_TABLE_AMD64_0 {}
unsafe impl ::windows::runtime::Abi for SCOPE_TABLE_AMD64_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCOPE_TABLE_ARM {
    pub Count: u32,
    pub ScopeRecord: [SCOPE_TABLE_ARM_0; 1],
}
impl SCOPE_TABLE_ARM {}
impl ::std::default::Default for SCOPE_TABLE_ARM {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCOPE_TABLE_ARM {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCOPE_TABLE_ARM")
            .field("Count", &self.Count)
            .field("ScopeRecord", &self.ScopeRecord)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCOPE_TABLE_ARM {
    fn eq(&self, other: &Self) -> bool {
        self.Count == other.Count && self.ScopeRecord == other.ScopeRecord
    }
}
impl ::std::cmp::Eq for SCOPE_TABLE_ARM {}
unsafe impl ::windows::runtime::Abi for SCOPE_TABLE_ARM {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCOPE_TABLE_ARM_0 {
    pub BeginAddress: u32,
    pub EndAddress: u32,
    pub HandlerAddress: u32,
    pub JumpTarget: u32,
}
impl SCOPE_TABLE_ARM_0 {}
impl ::std::default::Default for SCOPE_TABLE_ARM_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCOPE_TABLE_ARM_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("BeginAddress", &self.BeginAddress)
            .field("EndAddress", &self.EndAddress)
            .field("HandlerAddress", &self.HandlerAddress)
            .field("JumpTarget", &self.JumpTarget)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCOPE_TABLE_ARM_0 {
    fn eq(&self, other: &Self) -> bool {
        self.BeginAddress == other.BeginAddress
            && self.EndAddress == other.EndAddress
            && self.HandlerAddress == other.HandlerAddress
            && self.JumpTarget == other.JumpTarget
    }
}
impl ::std::cmp::Eq for SCOPE_TABLE_ARM_0 {}
unsafe impl ::windows::runtime::Abi for SCOPE_TABLE_ARM_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCOPE_TABLE_ARM64 {
    pub Count: u32,
    pub ScopeRecord: [SCOPE_TABLE_ARM64_0; 1],
}
impl SCOPE_TABLE_ARM64 {}
impl ::std::default::Default for SCOPE_TABLE_ARM64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCOPE_TABLE_ARM64 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCOPE_TABLE_ARM64")
            .field("Count", &self.Count)
            .field("ScopeRecord", &self.ScopeRecord)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCOPE_TABLE_ARM64 {
    fn eq(&self, other: &Self) -> bool {
        self.Count == other.Count && self.ScopeRecord == other.ScopeRecord
    }
}
impl ::std::cmp::Eq for SCOPE_TABLE_ARM64 {}
unsafe impl ::windows::runtime::Abi for SCOPE_TABLE_ARM64 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCOPE_TABLE_ARM64_0 {
    pub BeginAddress: u32,
    pub EndAddress: u32,
    pub HandlerAddress: u32,
    pub JumpTarget: u32,
}
impl SCOPE_TABLE_ARM64_0 {}
impl ::std::default::Default for SCOPE_TABLE_ARM64_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCOPE_TABLE_ARM64_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("BeginAddress", &self.BeginAddress)
            .field("EndAddress", &self.EndAddress)
            .field("HandlerAddress", &self.HandlerAddress)
            .field("JumpTarget", &self.JumpTarget)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCOPE_TABLE_ARM64_0 {
    fn eq(&self, other: &Self) -> bool {
        self.BeginAddress == other.BeginAddress
            && self.EndAddress == other.EndAddress
            && self.HandlerAddress == other.HandlerAddress
            && self.JumpTarget == other.JumpTarget
    }
}
impl ::std::cmp::Eq for SCOPE_TABLE_ARM64_0 {}
unsafe impl ::windows::runtime::Abi for SCOPE_TABLE_ARM64_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCRUB_DATA_INPUT {
    pub Size: u32,
    pub Flags: u32,
    pub MaximumIos: u32,
    pub ObjectId: [u32; 4],
    pub Reserved: [u32; 41],
    pub ResumeContext: [u8; 1040],
}
impl SCRUB_DATA_INPUT {}
impl ::std::default::Default for SCRUB_DATA_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCRUB_DATA_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCRUB_DATA_INPUT")
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("MaximumIos", &self.MaximumIos)
            .field("ObjectId", &self.ObjectId)
            .field("Reserved", &self.Reserved)
            .field("ResumeContext", &self.ResumeContext)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCRUB_DATA_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.Flags == other.Flags
            && self.MaximumIos == other.MaximumIos
            && self.ObjectId == other.ObjectId
            && self.Reserved == other.Reserved
            && self.ResumeContext == other.ResumeContext
    }
}
impl ::std::cmp::Eq for SCRUB_DATA_INPUT {}
unsafe impl ::windows::runtime::Abi for SCRUB_DATA_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SCRUB_DATA_INPUT_FLAG_IGNORE_REDUNDANCY: u32 = 8u32;
pub const SCRUB_DATA_INPUT_FLAG_OPLOCK_NOT_ACQUIRED: u32 = 64u32;
pub const SCRUB_DATA_INPUT_FLAG_RESUME: u32 = 1u32;
pub const SCRUB_DATA_INPUT_FLAG_SCRUB_BY_OBJECT_ID: u32 = 32u32;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_DATA: u32 = 16u32;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_IN_SYNC: u32 = 2u32;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_NON_INTEGRITY_DATA: u32 = 4u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCRUB_DATA_OUTPUT {
    pub Size: u32,
    pub Flags: u32,
    pub Status: u32,
    pub ErrorFileOffset: u64,
    pub ErrorLength: u64,
    pub NumberOfBytesRepaired: u64,
    pub NumberOfBytesFailed: u64,
    pub InternalFileReference: u64,
    pub ResumeContextLength: u16,
    pub ParityExtentDataOffset: u16,
    pub Reserved: [u32; 9],
    pub NumberOfMetadataBytesProcessed: u64,
    pub NumberOfDataBytesProcessed: u64,
    pub TotalNumberOfMetadataBytesInUse: u64,
    pub TotalNumberOfDataBytesInUse: u64,
    pub DataBytesSkippedDueToNoAllocation: u64,
    pub DataBytesSkippedDueToInvalidRun: u64,
    pub DataBytesSkippedDueToIntegrityStream: u64,
    pub DataBytesSkippedDueToRegionBeingClean: u64,
    pub DataBytesSkippedDueToLockConflict: u64,
    pub DataBytesSkippedDueToNoScrubDataFlag: u64,
    pub DataBytesSkippedDueToNoScrubNonIntegrityStreamFlag: u64,
    pub DataBytesScrubbed: u64,
    pub ResumeContext: [u8; 1040],
}
impl SCRUB_DATA_OUTPUT {}
impl ::std::default::Default for SCRUB_DATA_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCRUB_DATA_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCRUB_DATA_OUTPUT")
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("Status", &self.Status)
            .field("ErrorFileOffset", &self.ErrorFileOffset)
            .field("ErrorLength", &self.ErrorLength)
            .field("NumberOfBytesRepaired", &self.NumberOfBytesRepaired)
            .field("NumberOfBytesFailed", &self.NumberOfBytesFailed)
            .field("InternalFileReference", &self.InternalFileReference)
            .field("ResumeContextLength", &self.ResumeContextLength)
            .field("ParityExtentDataOffset", &self.ParityExtentDataOffset)
            .field("Reserved", &self.Reserved)
            .field(
                "NumberOfMetadataBytesProcessed",
                &self.NumberOfMetadataBytesProcessed,
            )
            .field(
                "NumberOfDataBytesProcessed",
                &self.NumberOfDataBytesProcessed,
            )
            .field(
                "TotalNumberOfMetadataBytesInUse",
                &self.TotalNumberOfMetadataBytesInUse,
            )
            .field(
                "TotalNumberOfDataBytesInUse",
                &self.TotalNumberOfDataBytesInUse,
            )
            .field(
                "DataBytesSkippedDueToNoAllocation",
                &self.DataBytesSkippedDueToNoAllocation,
            )
            .field(
                "DataBytesSkippedDueToInvalidRun",
                &self.DataBytesSkippedDueToInvalidRun,
            )
            .field(
                "DataBytesSkippedDueToIntegrityStream",
                &self.DataBytesSkippedDueToIntegrityStream,
            )
            .field(
                "DataBytesSkippedDueToRegionBeingClean",
                &self.DataBytesSkippedDueToRegionBeingClean,
            )
            .field(
                "DataBytesSkippedDueToLockConflict",
                &self.DataBytesSkippedDueToLockConflict,
            )
            .field(
                "DataBytesSkippedDueToNoScrubDataFlag",
                &self.DataBytesSkippedDueToNoScrubDataFlag,
            )
            .field(
                "DataBytesSkippedDueToNoScrubNonIntegrityStreamFlag",
                &self.DataBytesSkippedDueToNoScrubNonIntegrityStreamFlag,
            )
            .field("DataBytesScrubbed", &self.DataBytesScrubbed)
            .field("ResumeContext", &self.ResumeContext)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCRUB_DATA_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.Flags == other.Flags
            && self.Status == other.Status
            && self.ErrorFileOffset == other.ErrorFileOffset
            && self.ErrorLength == other.ErrorLength
            && self.NumberOfBytesRepaired == other.NumberOfBytesRepaired
            && self.NumberOfBytesFailed == other.NumberOfBytesFailed
            && self.InternalFileReference == other.InternalFileReference
            && self.ResumeContextLength == other.ResumeContextLength
            && self.ParityExtentDataOffset == other.ParityExtentDataOffset
            && self.Reserved == other.Reserved
            && self.NumberOfMetadataBytesProcessed == other.NumberOfMetadataBytesProcessed
            && self.NumberOfDataBytesProcessed == other.NumberOfDataBytesProcessed
            && self.TotalNumberOfMetadataBytesInUse == other.TotalNumberOfMetadataBytesInUse
            && self.TotalNumberOfDataBytesInUse == other.TotalNumberOfDataBytesInUse
            && self.DataBytesSkippedDueToNoAllocation == other.DataBytesSkippedDueToNoAllocation
            && self.DataBytesSkippedDueToInvalidRun == other.DataBytesSkippedDueToInvalidRun
            && self.DataBytesSkippedDueToIntegrityStream
                == other.DataBytesSkippedDueToIntegrityStream
            && self.DataBytesSkippedDueToRegionBeingClean
                == other.DataBytesSkippedDueToRegionBeingClean
            && self.DataBytesSkippedDueToLockConflict == other.DataBytesSkippedDueToLockConflict
            && self.DataBytesSkippedDueToNoScrubDataFlag
                == other.DataBytesSkippedDueToNoScrubDataFlag
            && self.DataBytesSkippedDueToNoScrubNonIntegrityStreamFlag
                == other.DataBytesSkippedDueToNoScrubNonIntegrityStreamFlag
            && self.DataBytesScrubbed == other.DataBytesScrubbed
            && self.ResumeContext == other.ResumeContext
    }
}
impl ::std::cmp::Eq for SCRUB_DATA_OUTPUT {}
unsafe impl ::windows::runtime::Abi for SCRUB_DATA_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SCRUB_DATA_OUTPUT_FLAG_INCOMPLETE: u32 = 1u32;
pub const SCRUB_DATA_OUTPUT_FLAG_NON_USER_DATA_RANGE: u32 = 65536u32;
pub const SCRUB_DATA_OUTPUT_FLAG_PARITY_EXTENT_DATA_RETURNED: u32 = 131072u32;
pub const SCRUB_DATA_OUTPUT_FLAG_RESUME_CONTEXT_LENGTH_SPECIFIED: u32 = 262144u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCRUB_PARITY_EXTENT {
    pub Offset: i64,
    pub Length: u64,
}
impl SCRUB_PARITY_EXTENT {}
impl ::std::default::Default for SCRUB_PARITY_EXTENT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCRUB_PARITY_EXTENT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCRUB_PARITY_EXTENT")
            .field("Offset", &self.Offset)
            .field("Length", &self.Length)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCRUB_PARITY_EXTENT {
    fn eq(&self, other: &Self) -> bool {
        self.Offset == other.Offset && self.Length == other.Length
    }
}
impl ::std::cmp::Eq for SCRUB_PARITY_EXTENT {}
unsafe impl ::windows::runtime::Abi for SCRUB_PARITY_EXTENT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SCRUB_PARITY_EXTENT_DATA {
    pub Size: u16,
    pub Flags: u16,
    pub NumberOfParityExtents: u16,
    pub MaximumNumberOfParityExtents: u16,
    pub ParityExtents: [SCRUB_PARITY_EXTENT; 1],
}
impl SCRUB_PARITY_EXTENT_DATA {}
impl ::std::default::Default for SCRUB_PARITY_EXTENT_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SCRUB_PARITY_EXTENT_DATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SCRUB_PARITY_EXTENT_DATA")
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("NumberOfParityExtents", &self.NumberOfParityExtents)
            .field(
                "MaximumNumberOfParityExtents",
                &self.MaximumNumberOfParityExtents,
            )
            .field("ParityExtents", &self.ParityExtents)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SCRUB_PARITY_EXTENT_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.Flags == other.Flags
            && self.NumberOfParityExtents == other.NumberOfParityExtents
            && self.MaximumNumberOfParityExtents == other.MaximumNumberOfParityExtents
            && self.ParityExtents == other.ParityExtents
    }
}
impl ::std::cmp::Eq for SCRUB_PARITY_EXTENT_DATA {}
unsafe impl ::windows::runtime::Abi for SCRUB_PARITY_EXTENT_DATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SD_CHANGE_MACHINE_SID_INPUT {
    pub CurrentMachineSIDOffset: u16,
    pub CurrentMachineSIDLength: u16,
    pub NewMachineSIDOffset: u16,
    pub NewMachineSIDLength: u16,
}
impl SD_CHANGE_MACHINE_SID_INPUT {}
impl ::std::default::Default for SD_CHANGE_MACHINE_SID_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SD_CHANGE_MACHINE_SID_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SD_CHANGE_MACHINE_SID_INPUT")
            .field("CurrentMachineSIDOffset", &self.CurrentMachineSIDOffset)
            .field("CurrentMachineSIDLength", &self.CurrentMachineSIDLength)
            .field("NewMachineSIDOffset", &self.NewMachineSIDOffset)
            .field("NewMachineSIDLength", &self.NewMachineSIDLength)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SD_CHANGE_MACHINE_SID_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.CurrentMachineSIDOffset == other.CurrentMachineSIDOffset
            && self.CurrentMachineSIDLength == other.CurrentMachineSIDLength
            && self.NewMachineSIDOffset == other.NewMachineSIDOffset
            && self.NewMachineSIDLength == other.NewMachineSIDLength
    }
}
impl ::std::cmp::Eq for SD_CHANGE_MACHINE_SID_INPUT {}
unsafe impl ::windows::runtime::Abi for SD_CHANGE_MACHINE_SID_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SD_CHANGE_MACHINE_SID_OUTPUT {
    pub NumSDChangedSuccess: u64,
    pub NumSDChangedFail: u64,
    pub NumSDUnused: u64,
    pub NumSDTotal: u64,
    pub NumMftSDChangedSuccess: u64,
    pub NumMftSDChangedFail: u64,
    pub NumMftSDTotal: u64,
}
impl SD_CHANGE_MACHINE_SID_OUTPUT {}
impl ::std::default::Default for SD_CHANGE_MACHINE_SID_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SD_CHANGE_MACHINE_SID_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SD_CHANGE_MACHINE_SID_OUTPUT")
            .field("NumSDChangedSuccess", &self.NumSDChangedSuccess)
            .field("NumSDChangedFail", &self.NumSDChangedFail)
            .field("NumSDUnused", &self.NumSDUnused)
            .field("NumSDTotal", &self.NumSDTotal)
            .field("NumMftSDChangedSuccess", &self.NumMftSDChangedSuccess)
            .field("NumMftSDChangedFail", &self.NumMftSDChangedFail)
            .field("NumMftSDTotal", &self.NumMftSDTotal)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SD_CHANGE_MACHINE_SID_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.NumSDChangedSuccess == other.NumSDChangedSuccess
            && self.NumSDChangedFail == other.NumSDChangedFail
            && self.NumSDUnused == other.NumSDUnused
            && self.NumSDTotal == other.NumSDTotal
            && self.NumMftSDChangedSuccess == other.NumMftSDChangedSuccess
            && self.NumMftSDChangedFail == other.NumMftSDChangedFail
            && self.NumMftSDTotal == other.NumMftSDTotal
    }
}
impl ::std::cmp::Eq for SD_CHANGE_MACHINE_SID_OUTPUT {}
unsafe impl ::windows::runtime::Abi for SD_CHANGE_MACHINE_SID_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SD_ENUM_SDS_ENTRY {
    pub Hash: u32,
    pub SecurityId: u32,
    pub Offset: u64,
    pub Length: u32,
    pub Descriptor: [u8; 1],
}
impl SD_ENUM_SDS_ENTRY {}
impl ::std::default::Default for SD_ENUM_SDS_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SD_ENUM_SDS_ENTRY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SD_ENUM_SDS_ENTRY")
            .field("Hash", &self.Hash)
            .field("SecurityId", &self.SecurityId)
            .field("Offset", &self.Offset)
            .field("Length", &self.Length)
            .field("Descriptor", &self.Descriptor)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SD_ENUM_SDS_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.Hash == other.Hash
            && self.SecurityId == other.SecurityId
            && self.Offset == other.Offset
            && self.Length == other.Length
            && self.Descriptor == other.Descriptor
    }
}
impl ::std::cmp::Eq for SD_ENUM_SDS_ENTRY {}
unsafe impl ::windows::runtime::Abi for SD_ENUM_SDS_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SD_ENUM_SDS_INPUT {
    pub StartingOffset: u64,
    pub MaxSDEntriesToReturn: u64,
}
impl SD_ENUM_SDS_INPUT {}
impl ::std::default::Default for SD_ENUM_SDS_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SD_ENUM_SDS_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SD_ENUM_SDS_INPUT")
            .field("StartingOffset", &self.StartingOffset)
            .field("MaxSDEntriesToReturn", &self.MaxSDEntriesToReturn)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SD_ENUM_SDS_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.StartingOffset == other.StartingOffset
            && self.MaxSDEntriesToReturn == other.MaxSDEntriesToReturn
    }
}
impl ::std::cmp::Eq for SD_ENUM_SDS_INPUT {}
unsafe impl ::windows::runtime::Abi for SD_ENUM_SDS_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SD_ENUM_SDS_OUTPUT {
    pub NextOffset: u64,
    pub NumSDEntriesReturned: u64,
    pub NumSDBytesReturned: u64,
    pub SDEntry: [SD_ENUM_SDS_ENTRY; 1],
}
impl SD_ENUM_SDS_OUTPUT {}
impl ::std::default::Default for SD_ENUM_SDS_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SD_ENUM_SDS_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SD_ENUM_SDS_OUTPUT")
            .field("NextOffset", &self.NextOffset)
            .field("NumSDEntriesReturned", &self.NumSDEntriesReturned)
            .field("NumSDBytesReturned", &self.NumSDBytesReturned)
            .field("SDEntry", &self.SDEntry)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SD_ENUM_SDS_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.NextOffset == other.NextOffset
            && self.NumSDEntriesReturned == other.NumSDEntriesReturned
            && self.NumSDBytesReturned == other.NumSDBytesReturned
            && self.SDEntry == other.SDEntry
    }
}
impl ::std::cmp::Eq for SD_ENUM_SDS_OUTPUT {}
unsafe impl ::windows::runtime::Abi for SD_ENUM_SDS_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SD_GLOBAL_CHANGE_INPUT {
    pub Flags: u32,
    pub ChangeType: u32,
    pub Anonymous: SD_GLOBAL_CHANGE_INPUT_0,
}
impl SD_GLOBAL_CHANGE_INPUT {}
impl ::std::default::Default for SD_GLOBAL_CHANGE_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for SD_GLOBAL_CHANGE_INPUT {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for SD_GLOBAL_CHANGE_INPUT {}
unsafe impl ::windows::runtime::Abi for SD_GLOBAL_CHANGE_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union SD_GLOBAL_CHANGE_INPUT_0 {
    pub SdChange: SD_CHANGE_MACHINE_SID_INPUT,
    pub SdQueryStats: SD_QUERY_STATS_INPUT,
    pub SdEnumSds: SD_ENUM_SDS_INPUT,
}
impl SD_GLOBAL_CHANGE_INPUT_0 {}
impl ::std::default::Default for SD_GLOBAL_CHANGE_INPUT_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for SD_GLOBAL_CHANGE_INPUT_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for SD_GLOBAL_CHANGE_INPUT_0 {}
unsafe impl ::windows::runtime::Abi for SD_GLOBAL_CHANGE_INPUT_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SD_GLOBAL_CHANGE_OUTPUT {
    pub Flags: u32,
    pub ChangeType: u32,
    pub Anonymous: SD_GLOBAL_CHANGE_OUTPUT_0,
}
impl SD_GLOBAL_CHANGE_OUTPUT {}
impl ::std::default::Default for SD_GLOBAL_CHANGE_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for SD_GLOBAL_CHANGE_OUTPUT {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for SD_GLOBAL_CHANGE_OUTPUT {}
unsafe impl ::windows::runtime::Abi for SD_GLOBAL_CHANGE_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union SD_GLOBAL_CHANGE_OUTPUT_0 {
    pub SdChange: SD_CHANGE_MACHINE_SID_OUTPUT,
    pub SdQueryStats: SD_QUERY_STATS_OUTPUT,
    pub SdEnumSds: SD_ENUM_SDS_OUTPUT,
}
impl SD_GLOBAL_CHANGE_OUTPUT_0 {}
impl ::std::default::Default for SD_GLOBAL_CHANGE_OUTPUT_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for SD_GLOBAL_CHANGE_OUTPUT_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for SD_GLOBAL_CHANGE_OUTPUT_0 {}
unsafe impl ::windows::runtime::Abi for SD_GLOBAL_CHANGE_OUTPUT_0 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SD_GLOBAL_CHANGE_TYPE_ENUM_SDS: u32 = 131072u32;
pub const SD_GLOBAL_CHANGE_TYPE_MACHINE_SID: u32 = 1u32;
pub const SD_GLOBAL_CHANGE_TYPE_QUERY_STATS: u32 = 65536u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SD_QUERY_STATS_INPUT {
    pub Reserved: u32,
}
impl SD_QUERY_STATS_INPUT {}
impl ::std::default::Default for SD_QUERY_STATS_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SD_QUERY_STATS_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SD_QUERY_STATS_INPUT")
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SD_QUERY_STATS_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for SD_QUERY_STATS_INPUT {}
unsafe impl ::windows::runtime::Abi for SD_QUERY_STATS_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SD_QUERY_STATS_OUTPUT {
    pub SdsStreamSize: u64,
    pub SdsAllocationSize: u64,
    pub SiiStreamSize: u64,
    pub SiiAllocationSize: u64,
    pub SdhStreamSize: u64,
    pub SdhAllocationSize: u64,
    pub NumSDTotal: u64,
    pub NumSDUnused: u64,
}
impl SD_QUERY_STATS_OUTPUT {}
impl ::std::default::Default for SD_QUERY_STATS_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SD_QUERY_STATS_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SD_QUERY_STATS_OUTPUT")
            .field("SdsStreamSize", &self.SdsStreamSize)
            .field("SdsAllocationSize", &self.SdsAllocationSize)
            .field("SiiStreamSize", &self.SiiStreamSize)
            .field("SiiAllocationSize", &self.SiiAllocationSize)
            .field("SdhStreamSize", &self.SdhStreamSize)
            .field("SdhAllocationSize", &self.SdhAllocationSize)
            .field("NumSDTotal", &self.NumSDTotal)
            .field("NumSDUnused", &self.NumSDUnused)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SD_QUERY_STATS_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.SdsStreamSize == other.SdsStreamSize
            && self.SdsAllocationSize == other.SdsAllocationSize
            && self.SiiStreamSize == other.SiiStreamSize
            && self.SiiAllocationSize == other.SiiAllocationSize
            && self.SdhStreamSize == other.SdhStreamSize
            && self.SdhAllocationSize == other.SdhAllocationSize
            && self.NumSDTotal == other.NumSDTotal
            && self.NumSDUnused == other.NumSDUnused
    }
}
impl ::std::cmp::Eq for SD_QUERY_STATS_OUTPUT {}
unsafe impl ::windows::runtime::Abi for SD_QUERY_STATS_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SEARCH_ALL: u32 = 0u32;
pub const SEARCH_ALL_NO_SEQ: u32 = 4u32;
pub const SEARCH_ALTERNATE: u32 = 2u32;
pub const SEARCH_ALT_NO_SEQ: u32 = 6u32;
pub const SEARCH_PRIMARY: u32 = 1u32;
pub const SEARCH_PRI_NO_SEQ: u32 = 5u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SECTION_FLAGS(pub u32);
pub const SECTION_ALL_ACCESS: SECTION_FLAGS = SECTION_FLAGS(983071u32);
pub const SECTION_QUERY: SECTION_FLAGS = SECTION_FLAGS(1u32);
pub const SECTION_MAP_WRITE: SECTION_FLAGS = SECTION_FLAGS(2u32);
pub const SECTION_MAP_READ: SECTION_FLAGS = SECTION_FLAGS(4u32);
pub const SECTION_MAP_EXECUTE: SECTION_FLAGS = SECTION_FLAGS(8u32);
pub const SECTION_EXTEND_SIZE: SECTION_FLAGS = SECTION_FLAGS(16u32);
pub const SECTION_MAP_EXECUTE_EXPLICIT: SECTION_FLAGS = SECTION_FLAGS(32u32);
impl ::std::convert::From<u32> for SECTION_FLAGS {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SECTION_FLAGS {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for SECTION_FLAGS {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for SECTION_FLAGS {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for SECTION_FLAGS {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for SECTION_FLAGS {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for SECTION_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const SECURITY_ANONYMOUS_LOGON_RID: i32 = 7i32;
pub const SECURITY_APPPOOL_ID_BASE_RID: i32 = 82i32;
pub const SECURITY_APPPOOL_ID_RID_COUNT: i32 = 6i32;
pub const SECURITY_APP_PACKAGE_BASE_RID: i32 = 2i32;
pub const SECURITY_APP_PACKAGE_RID_COUNT: i32 = 8i32;
pub const SECURITY_AUTHENTICATED_USER_RID: i32 = 11i32;
pub const SECURITY_AUTHENTICATION_AUTHORITY_ASSERTED_RID: i32 = 1i32;
pub const SECURITY_AUTHENTICATION_AUTHORITY_RID_COUNT: i32 = 1i32;
pub const SECURITY_AUTHENTICATION_FRESH_KEY_AUTH_RID: i32 = 3i32;
pub const SECURITY_AUTHENTICATION_KEY_PROPERTY_ATTESTATION_RID: i32 = 6i32;
pub const SECURITY_AUTHENTICATION_KEY_PROPERTY_MFA_RID: i32 = 5i32;
pub const SECURITY_AUTHENTICATION_KEY_TRUST_RID: i32 = 4i32;
pub const SECURITY_AUTHENTICATION_SERVICE_ASSERTED_RID: i32 = 2i32;
pub const SECURITY_BATCH_RID: i32 = 3i32;
pub const SECURITY_BUILTIN_APP_PACKAGE_RID_COUNT: i32 = 2i32;
pub const SECURITY_BUILTIN_CAPABILITY_RID_COUNT: i32 = 2i32;
pub const SECURITY_BUILTIN_DOMAIN_RID: i32 = 32i32;
pub const SECURITY_BUILTIN_PACKAGE_ANY_PACKAGE: i32 = 1i32;
pub const SECURITY_BUILTIN_PACKAGE_ANY_RESTRICTED_PACKAGE: i32 = 2i32;
pub const SECURITY_CAPABILITY_APPOINTMENTS: i32 = 11i32;
pub const SECURITY_CAPABILITY_APP_RID: u64 = 1024u64;
pub const SECURITY_CAPABILITY_BASE_RID: i32 = 3i32;
pub const SECURITY_CAPABILITY_CONTACTS: i32 = 12i32;
pub const SECURITY_CAPABILITY_DOCUMENTS_LIBRARY: i32 = 7i32;
pub const SECURITY_CAPABILITY_ENTERPRISE_AUTHENTICATION: i32 = 8i32;
pub const SECURITY_CAPABILITY_INTERNET_CLIENT: i32 = 1i32;
pub const SECURITY_CAPABILITY_INTERNET_CLIENT_SERVER: i32 = 2i32;
pub const SECURITY_CAPABILITY_INTERNET_EXPLORER: i32 = 4096i32;
pub const SECURITY_CAPABILITY_MUSIC_LIBRARY: i32 = 6i32;
pub const SECURITY_CAPABILITY_PICTURES_LIBRARY: i32 = 4i32;
pub const SECURITY_CAPABILITY_PRIVATE_NETWORK_CLIENT_SERVER: i32 = 3i32;
pub const SECURITY_CAPABILITY_REMOVABLE_STORAGE: i32 = 10i32;
pub const SECURITY_CAPABILITY_RID_COUNT: i32 = 5i32;
pub const SECURITY_CAPABILITY_SHARED_USER_CERTIFICATES: i32 = 9i32;
pub const SECURITY_CAPABILITY_VIDEOS_LIBRARY: i32 = 5i32;
pub const SECURITY_CCG_ID_BASE_RID: i32 = 95i32;
pub const SECURITY_CHILD_PACKAGE_RID_COUNT: i32 = 12i32;
pub const SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_BASE_RID: i32 = 85i32;
pub const SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_RID_COUNT: i32 = 6i32;
pub const SECURITY_COM_ID_BASE_RID: i32 = 89i32;
pub const SECURITY_CREATOR_GROUP_RID: i32 = 1i32;
pub const SECURITY_CREATOR_GROUP_SERVER_RID: i32 = 3i32;
pub const SECURITY_CREATOR_OWNER_RID: i32 = 0i32;
pub const SECURITY_CREATOR_OWNER_RIGHTS_RID: i32 = 4i32;
pub const SECURITY_CREATOR_OWNER_SERVER_RID: i32 = 2i32;
pub const SECURITY_CRED_TYPE_BASE_RID: i32 = 65i32;
pub const SECURITY_CRED_TYPE_RID_COUNT: i32 = 2i32;
pub const SECURITY_CRED_TYPE_THIS_ORG_CERT_RID: i32 = 1i32;
pub const SECURITY_DASHOST_ID_BASE_RID: i32 = 92i32;
pub const SECURITY_DASHOST_ID_RID_COUNT: i32 = 6i32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SECURITY_DESCRIPTOR_RELATIVE {
    pub Revision: u8,
    pub Sbz1: u8,
    pub Control: u16,
    pub Owner: u32,
    pub Group: u32,
    pub Sacl: u32,
    pub Dacl: u32,
}
impl SECURITY_DESCRIPTOR_RELATIVE {}
impl ::std::default::Default for SECURITY_DESCRIPTOR_RELATIVE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SECURITY_DESCRIPTOR_RELATIVE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SECURITY_DESCRIPTOR_RELATIVE")
            .field("Revision", &self.Revision)
            .field("Sbz1", &self.Sbz1)
            .field("Control", &self.Control)
            .field("Owner", &self.Owner)
            .field("Group", &self.Group)
            .field("Sacl", &self.Sacl)
            .field("Dacl", &self.Dacl)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SECURITY_DESCRIPTOR_RELATIVE {
    fn eq(&self, other: &Self) -> bool {
        self.Revision == other.Revision
            && self.Sbz1 == other.Sbz1
            && self.Control == other.Control
            && self.Owner == other.Owner
            && self.Group == other.Group
            && self.Sacl == other.Sacl
            && self.Dacl == other.Dacl
    }
}
impl ::std::cmp::Eq for SECURITY_DESCRIPTOR_RELATIVE {}
unsafe impl ::windows::runtime::Abi for SECURITY_DESCRIPTOR_RELATIVE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SECURITY_DESCRIPTOR_REVISION: u32 = 1u32;
pub const SECURITY_DESCRIPTOR_REVISION1: u32 = 1u32;
pub const SECURITY_DIALUP_RID: i32 = 1i32;
pub const SECURITY_ENTERPRISE_CONTROLLERS_RID: i32 = 9i32;
pub const SECURITY_ENTERPRISE_READONLY_CONTROLLERS_RID: i32 = 22i32;
pub const SECURITY_INSTALLER_CAPABILITY_RID_COUNT: u32 = 10u32;
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_BASE: u32 = 32u32;
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_RID_COUNT: u32 = 9u32;
pub const SECURITY_INTERACTIVE_RID: i32 = 4i32;
pub const SECURITY_IUSER_RID: i32 = 17i32;
pub const SECURITY_LOCAL_ACCOUNT_AND_ADMIN_RID: i32 = 114i32;
pub const SECURITY_LOCAL_ACCOUNT_RID: i32 = 113i32;
pub const SECURITY_LOCAL_LOGON_RID: i32 = 1i32;
pub const SECURITY_LOCAL_RID: i32 = 0i32;
pub const SECURITY_LOCAL_SERVICE_RID: i32 = 19i32;
pub const SECURITY_LOCAL_SYSTEM_RID: i32 = 18i32;
pub const SECURITY_LOGON_IDS_RID: i32 = 5i32;
pub const SECURITY_LOGON_IDS_RID_COUNT: i32 = 3i32;
pub const SECURITY_MANDATORY_HIGH_RID: i32 = 12288i32;
pub const SECURITY_MANDATORY_LOW_RID: i32 = 4096i32;
pub const SECURITY_MANDATORY_MAXIMUM_USER_RID: i32 = 16384i32;
pub const SECURITY_MANDATORY_MEDIUM_PLUS_RID: u32 = 8448u32;
pub const SECURITY_MANDATORY_MEDIUM_RID: i32 = 8192i32;
pub const SECURITY_MANDATORY_PROTECTED_PROCESS_RID: i32 = 20480i32;
pub const SECURITY_MANDATORY_SYSTEM_RID: i32 = 16384i32;
pub const SECURITY_MANDATORY_UNTRUSTED_RID: i32 = 0i32;
pub const SECURITY_MAX_ALWAYS_FILTERED: i32 = 999i32;
pub const SECURITY_MAX_BASE_RID: i32 = 111i32;
pub const SECURITY_MIN_BASE_RID: i32 = 80i32;
pub const SECURITY_MIN_NEVER_FILTERED: i32 = 1000i32;
pub const SECURITY_NETWORK_RID: i32 = 2i32;
pub const SECURITY_NETWORK_SERVICE_RID: i32 = 20i32;
pub const SECURITY_NFS_ID_BASE_RID: i32 = 88i32;
pub const SECURITY_NT_NON_UNIQUE: i32 = 21i32;
pub const SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT: i32 = 3i32;
pub const SECURITY_NULL_RID: i32 = 0i32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SECURITY_OBJECT_AI_PARAMS {
    pub Size: u32,
    pub ConstraintMask: u32,
}
impl SECURITY_OBJECT_AI_PARAMS {}
impl ::std::default::Default for SECURITY_OBJECT_AI_PARAMS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SECURITY_OBJECT_AI_PARAMS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SECURITY_OBJECT_AI_PARAMS")
            .field("Size", &self.Size)
            .field("ConstraintMask", &self.ConstraintMask)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SECURITY_OBJECT_AI_PARAMS {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.ConstraintMask == other.ConstraintMask
    }
}
impl ::std::cmp::Eq for SECURITY_OBJECT_AI_PARAMS {}
unsafe impl ::windows::runtime::Abi for SECURITY_OBJECT_AI_PARAMS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SECURITY_OTHER_ORGANIZATION_RID: i32 = 1000i32;
pub const SECURITY_PACKAGE_BASE_RID: i32 = 64i32;
pub const SECURITY_PACKAGE_DIGEST_RID: i32 = 21i32;
pub const SECURITY_PACKAGE_NTLM_RID: i32 = 10i32;
pub const SECURITY_PACKAGE_RID_COUNT: i32 = 2i32;
pub const SECURITY_PACKAGE_SCHANNEL_RID: i32 = 14i32;
pub const SECURITY_PARENT_PACKAGE_RID_COUNT: i32 = 8i32;
pub const SECURITY_PRINCIPAL_SELF_RID: i32 = 10i32;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_ANTIMALWARE_RID: i32 = 1536i32;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_APP_RID: i32 = 2048i32;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_AUTHENTICODE_RID: i32 = 1024i32;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_NONE_RID: i32 = 0i32;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_WINDOWS_RID: i32 = 4096i32;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_WINTCB_RID: i32 = 8192i32;
pub const SECURITY_PROCESS_PROTECTION_TYPE_FULL_RID: i32 = 1024i32;
pub const SECURITY_PROCESS_PROTECTION_TYPE_LITE_RID: i32 = 512i32;
pub const SECURITY_PROCESS_PROTECTION_TYPE_NONE_RID: i32 = 0i32;
pub const SECURITY_PROCESS_TRUST_AUTHORITY_RID_COUNT: i32 = 2i32;
pub const SECURITY_PROXY_RID: i32 = 8i32;
pub const SECURITY_RDV_GFX_BASE_RID: i32 = 91i32;
pub const SECURITY_REMOTE_LOGON_RID: i32 = 14i32;
pub const SECURITY_RESERVED_ID_BASE_RID: i32 = 81i32;
pub const SECURITY_RESTRICTED_CODE_RID: i32 = 12i32;
pub const SECURITY_SERVER_LOGON_RID: i32 = 9i32;
pub const SECURITY_SERVICE_ID_BASE_RID: i32 = 80i32;
pub const SECURITY_SERVICE_ID_RID_COUNT: i32 = 6i32;
pub const SECURITY_SERVICE_RID: i32 = 6i32;
pub const SECURITY_TASK_ID_BASE_RID: i32 = 87i32;
pub const SECURITY_TERMINAL_SERVER_RID: i32 = 13i32;
pub const SECURITY_THIS_ORGANIZATION_RID: i32 = 15i32;
pub const SECURITY_TRUSTED_INSTALLER_RID1: u32 = 956008885u32;
pub const SECURITY_TRUSTED_INSTALLER_RID2: u32 = 3418522649u32;
pub const SECURITY_TRUSTED_INSTALLER_RID3: u32 = 1831038044u32;
pub const SECURITY_TRUSTED_INSTALLER_RID4: u32 = 1853292631u32;
pub const SECURITY_TRUSTED_INSTALLER_RID5: u32 = 2271478464u32;
pub const SECURITY_UMFD_BASE_RID: i32 = 96i32;
pub const SECURITY_USERMANAGER_ID_BASE_RID: i32 = 93i32;
pub const SECURITY_USERMANAGER_ID_RID_COUNT: i32 = 6i32;
pub const SECURITY_USERMODEDRIVERHOST_ID_BASE_RID: i32 = 84i32;
pub const SECURITY_USERMODEDRIVERHOST_ID_RID_COUNT: i32 = 6i32;
pub const SECURITY_VIRTUALACCOUNT_ID_RID_COUNT: i32 = 6i32;
pub const SECURITY_VIRTUALSERVER_ID_BASE_RID: i32 = 83i32;
pub const SECURITY_VIRTUALSERVER_ID_RID_COUNT: i32 = 6i32;
pub const SECURITY_WINDOWSMOBILE_ID_BASE_RID: i32 = 112i32;
pub const SECURITY_WINDOW_MANAGER_BASE_RID: i32 = 90i32;
pub const SECURITY_WINRM_ID_BASE_RID: i32 = 94i32;
pub const SECURITY_WINRM_ID_RID_COUNT: i32 = 6i32;
pub const SECURITY_WMIHOST_ID_BASE_RID: i32 = 86i32;
pub const SECURITY_WMIHOST_ID_RID_COUNT: i32 = 6i32;
pub const SECURITY_WORLD_RID: i32 = 0i32;
pub const SECURITY_WRITE_RESTRICTED_CODE_RID: i32 = 33i32;
pub const SEC_HUGE_PAGES: u32 = 131072u32;
pub const SEF_AI_USE_EXTRA_PARAMS: u32 = 2048u32;
pub const SEF_FORCE_USER_MODE: u32 = 8192u32;
pub const SEMAPHORE_MODIFY_STATE: u32 = 2u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct SENDCMDINPARAMS {
    pub cBufferSize: u32,
    pub irDriveRegs: IDEREGS,
    pub bDriveNumber: u8,
    pub bReserved: [u8; 3],
    pub dwReserved: [u32; 4],
    pub bBuffer: [u8; 1],
}
impl SENDCMDINPARAMS {}
impl ::std::default::Default for SENDCMDINPARAMS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for SENDCMDINPARAMS {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for SENDCMDINPARAMS {}
unsafe impl ::windows::runtime::Abi for SENDCMDINPARAMS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C, packed(1))]
pub struct SENDCMDOUTPARAMS {
    pub cBufferSize: u32,
    pub DriverStatus: DRIVERSTATUS,
    pub bBuffer: [u8; 1],
}
impl SENDCMDOUTPARAMS {}
impl ::std::default::Default for SENDCMDOUTPARAMS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for SENDCMDOUTPARAMS {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for SENDCMDOUTPARAMS {}
unsafe impl ::windows::runtime::Abi for SENDCMDOUTPARAMS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SERIAL_NUMBER_LENGTH: u32 = 32u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct SERVERSILO_BASIC_INFORMATION {
    pub ServiceSessionId: u32,
    pub State: SERVERSILO_STATE,
    pub ExitStatus: u32,
    pub IsDownlevelContainer: super::super::Foundation::BOOLEAN,
    pub ApiSetSchema: *mut ::std::ffi::c_void,
    pub HostApiSetSchema: *mut ::std::ffi::c_void,
}
#[cfg(feature = "Win32_Foundation")]
impl SERVERSILO_BASIC_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for SERVERSILO_BASIC_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for SERVERSILO_BASIC_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SERVERSILO_BASIC_INFORMATION")
            .field("ServiceSessionId", &self.ServiceSessionId)
            .field("State", &self.State)
            .field("ExitStatus", &self.ExitStatus)
            .field("IsDownlevelContainer", &self.IsDownlevelContainer)
            .field("ApiSetSchema", &self.ApiSetSchema)
            .field("HostApiSetSchema", &self.HostApiSetSchema)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for SERVERSILO_BASIC_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.ServiceSessionId == other.ServiceSessionId
            && self.State == other.State
            && self.ExitStatus == other.ExitStatus
            && self.IsDownlevelContainer == other.IsDownlevelContainer
            && self.ApiSetSchema == other.ApiSetSchema
            && self.HostApiSetSchema == other.HostApiSetSchema
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for SERVERSILO_BASIC_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for SERVERSILO_BASIC_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SERVERSILO_STATE(pub i32);
pub const SERVERSILO_INITING: SERVERSILO_STATE = SERVERSILO_STATE(0i32);
pub const SERVERSILO_STARTED: SERVERSILO_STATE = SERVERSILO_STATE(1i32);
pub const SERVERSILO_SHUTTING_DOWN: SERVERSILO_STATE = SERVERSILO_STATE(2i32);
pub const SERVERSILO_TERMINATING: SERVERSILO_STATE = SERVERSILO_STATE(3i32);
pub const SERVERSILO_TERMINATED: SERVERSILO_STATE = SERVERSILO_STATE(4i32);
impl ::std::convert::From<i32> for SERVERSILO_STATE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SERVERSILO_STATE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SERVICE_INTERACTIVE_PROCESS: u32 = 256u32;
pub const SERVICE_PKG_SERVICE: u32 = 512u32;
pub const SERVICE_USERSERVICE_INSTANCE: u32 = 128u32;
pub const SERVICE_USER_SERVICE: u32 = 64u32;
pub const SESSION_MODIFY_ACCESS: u32 = 2u32;
pub const SESSION_QUERY_ACCESS: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {
    pub Flags: u32,
    pub AlignmentShift: u32,
    pub FileOffsetToAlign: u64,
    pub FallbackAlignmentShift: u32,
}
impl SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {}
impl ::std::default::Default for SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT")
            .field("Flags", &self.Flags)
            .field("AlignmentShift", &self.AlignmentShift)
            .field("FileOffsetToAlign", &self.FileOffsetToAlign)
            .field("FallbackAlignmentShift", &self.FallbackAlignmentShift)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
            && self.AlignmentShift == other.AlignmentShift
            && self.FileOffsetToAlign == other.FileOffsetToAlign
            && self.FallbackAlignmentShift == other.FallbackAlignmentShift
    }
}
impl ::std::cmp::Eq for SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {}
unsafe impl ::windows::runtime::Abi for SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Storage_FileSystem")]
pub struct SET_PARTITION_INFORMATION_EX {
    pub PartitionStyle: super::super::Storage::FileSystem::PARTITION_STYLE,
    pub Anonymous: SET_PARTITION_INFORMATION_EX_0,
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl SET_PARTITION_INFORMATION_EX {}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::default::Default for SET_PARTITION_INFORMATION_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::PartialEq for SET_PARTITION_INFORMATION_EX {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::Eq for SET_PARTITION_INFORMATION_EX {}
#[cfg(feature = "Win32_Storage_FileSystem")]
unsafe impl ::windows::runtime::Abi for SET_PARTITION_INFORMATION_EX {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Storage_FileSystem")]
pub union SET_PARTITION_INFORMATION_EX_0 {
    pub Mbr: super::super::Storage::FileSystem::SET_PARTITION_INFORMATION,
    pub Gpt: super::super::Storage::FileSystem::PARTITION_INFORMATION_GPT,
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl SET_PARTITION_INFORMATION_EX_0 {}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::default::Default for SET_PARTITION_INFORMATION_EX_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::PartialEq for SET_PARTITION_INFORMATION_EX_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::Eq for SET_PARTITION_INFORMATION_EX_0 {}
#[cfg(feature = "Win32_Storage_FileSystem")]
unsafe impl ::windows::runtime::Abi for SET_PARTITION_INFORMATION_EX_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Power")]
pub struct SET_POWER_SETTING_VALUE {
    pub Version: u32,
    pub Guid: ::windows::runtime::GUID,
    pub PowerCondition: super::Power::SYSTEM_POWER_CONDITION,
    pub DataLength: u32,
    pub Data: [u8; 1],
}
#[cfg(feature = "Win32_System_Power")]
impl SET_POWER_SETTING_VALUE {}
#[cfg(feature = "Win32_System_Power")]
impl ::std::default::Default for SET_POWER_SETTING_VALUE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Power")]
impl ::std::fmt::Debug for SET_POWER_SETTING_VALUE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SET_POWER_SETTING_VALUE")
            .field("Version", &self.Version)
            .field("Guid", &self.Guid)
            .field("PowerCondition", &self.PowerCondition)
            .field("DataLength", &self.DataLength)
            .field("Data", &self.Data)
            .finish()
    }
}
#[cfg(feature = "Win32_System_Power")]
impl ::std::cmp::PartialEq for SET_POWER_SETTING_VALUE {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Guid == other.Guid
            && self.PowerCondition == other.PowerCondition
            && self.DataLength == other.DataLength
            && self.Data == other.Data
    }
}
#[cfg(feature = "Win32_System_Power")]
impl ::std::cmp::Eq for SET_POWER_SETTING_VALUE {}
#[cfg(feature = "Win32_System_Power")]
unsafe impl ::windows::runtime::Abi for SET_POWER_SETTING_VALUE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SET_PURGE_FAILURE_MODE_DISABLED: u32 = 2u32;
pub const SET_PURGE_FAILURE_MODE_ENABLED: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SET_PURGE_FAILURE_MODE_INPUT {
    pub Flags: u32,
}
impl SET_PURGE_FAILURE_MODE_INPUT {}
impl ::std::default::Default for SET_PURGE_FAILURE_MODE_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SET_PURGE_FAILURE_MODE_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SET_PURGE_FAILURE_MODE_INPUT")
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SET_PURGE_FAILURE_MODE_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for SET_PURGE_FAILURE_MODE_INPUT {}
unsafe impl ::windows::runtime::Abi for SET_PURGE_FAILURE_MODE_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SET_REPAIR_DISABLED_AND_BUGCHECK_ON_CORRUPT: u32 = 16u32;
pub const SET_REPAIR_ENABLED: u32 = 1u32;
pub const SET_REPAIR_VALID_MASK: u32 = 25u32;
pub const SET_REPAIR_WARN_ABOUT_DATA_LOSS: u32 = 8u32;
pub const SE_ACCESS_CHECK_FLAG_NO_LEARNING_MODE_LOGGING: u32 = 8u32;
pub const SE_ACCESS_CHECK_VALID_FLAGS: u32 = 8u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Security")]
pub struct SE_ACCESS_REPLY {
    pub Size: u32,
    pub ResultListCount: u32,
    pub GrantedAccess: *mut u32,
    pub AccessStatus: *mut u32,
    pub AccessReason: *mut ACCESS_REASONS,
    pub Privileges: *mut *mut super::super::Security::PRIVILEGE_SET,
}
#[cfg(feature = "Win32_Security")]
impl SE_ACCESS_REPLY {}
#[cfg(feature = "Win32_Security")]
impl ::std::default::Default for SE_ACCESS_REPLY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Security")]
impl ::std::fmt::Debug for SE_ACCESS_REPLY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SE_ACCESS_REPLY")
            .field("Size", &self.Size)
            .field("ResultListCount", &self.ResultListCount)
            .field("GrantedAccess", &self.GrantedAccess)
            .field("AccessStatus", &self.AccessStatus)
            .field("AccessReason", &self.AccessReason)
            .field("Privileges", &self.Privileges)
            .finish()
    }
}
#[cfg(feature = "Win32_Security")]
impl ::std::cmp::PartialEq for SE_ACCESS_REPLY {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.ResultListCount == other.ResultListCount
            && self.GrantedAccess == other.GrantedAccess
            && self.AccessStatus == other.AccessStatus
            && self.AccessReason == other.AccessReason
            && self.Privileges == other.Privileges
    }
}
#[cfg(feature = "Win32_Security")]
impl ::std::cmp::Eq for SE_ACCESS_REPLY {}
#[cfg(feature = "Win32_Security")]
unsafe impl ::windows::runtime::Abi for SE_ACCESS_REPLY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
pub struct SE_ACCESS_REQUEST {
    pub Size: u32,
    pub SeSecurityDescriptor: *mut SE_SECURITY_DESCRIPTOR,
    pub DesiredAccess: u32,
    pub PreviouslyGrantedAccess: u32,
    pub PrincipalSelfSid: super::super::Foundation::PSID,
    pub GenericMapping: *mut super::super::Security::GENERIC_MAPPING,
    pub ObjectTypeListCount: u32,
    pub ObjectTypeList: *mut super::super::Security::OBJECT_TYPE_LIST,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl SE_ACCESS_REQUEST {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::default::Default for SE_ACCESS_REQUEST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::fmt::Debug for SE_ACCESS_REQUEST {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SE_ACCESS_REQUEST")
            .field("Size", &self.Size)
            .field("SeSecurityDescriptor", &self.SeSecurityDescriptor)
            .field("DesiredAccess", &self.DesiredAccess)
            .field("PreviouslyGrantedAccess", &self.PreviouslyGrantedAccess)
            .field("PrincipalSelfSid", &self.PrincipalSelfSid)
            .field("GenericMapping", &self.GenericMapping)
            .field("ObjectTypeListCount", &self.ObjectTypeListCount)
            .field("ObjectTypeList", &self.ObjectTypeList)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::cmp::PartialEq for SE_ACCESS_REQUEST {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.SeSecurityDescriptor == other.SeSecurityDescriptor
            && self.DesiredAccess == other.DesiredAccess
            && self.PreviouslyGrantedAccess == other.PreviouslyGrantedAccess
            && self.PrincipalSelfSid == other.PrincipalSelfSid
            && self.GenericMapping == other.GenericMapping
            && self.ObjectTypeListCount == other.ObjectTypeListCount
            && self.ObjectTypeList == other.ObjectTypeList
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::cmp::Eq for SE_ACCESS_REQUEST {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
unsafe impl ::windows::runtime::Abi for SE_ACCESS_REQUEST {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SE_DACL_AUTO_INHERITED: u32 = 1024u32;
pub const SE_DACL_AUTO_INHERIT_REQ: u32 = 256u32;
pub const SE_DACL_DEFAULTED: u32 = 8u32;
pub const SE_DACL_PRESENT: u32 = 4u32;
pub const SE_DACL_PROTECTED: u32 = 4096u32;
pub const SE_GROUP_DEFAULTED: u32 = 2u32;
pub const SE_GROUP_ENABLED: i32 = 4i32;
pub const SE_GROUP_ENABLED_BY_DEFAULT: i32 = 2i32;
pub const SE_GROUP_INTEGRITY: i32 = 32i32;
pub const SE_GROUP_INTEGRITY_ENABLED: i32 = 64i32;
pub const SE_GROUP_LOGON_ID: i32 = -1073741824i32;
pub const SE_GROUP_MANDATORY: i32 = 1i32;
pub const SE_GROUP_OWNER: i32 = 8i32;
pub const SE_GROUP_RESOURCE: i32 = 536870912i32;
pub const SE_GROUP_USE_FOR_DENY_ONLY: i32 = 16i32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SE_IMAGE_SIGNATURE_TYPE(pub i32);
pub const SeImageSignatureNone: SE_IMAGE_SIGNATURE_TYPE = SE_IMAGE_SIGNATURE_TYPE(0i32);
pub const SeImageSignatureEmbedded: SE_IMAGE_SIGNATURE_TYPE = SE_IMAGE_SIGNATURE_TYPE(1i32);
pub const SeImageSignatureCache: SE_IMAGE_SIGNATURE_TYPE = SE_IMAGE_SIGNATURE_TYPE(2i32);
pub const SeImageSignatureCatalogCached: SE_IMAGE_SIGNATURE_TYPE = SE_IMAGE_SIGNATURE_TYPE(3i32);
pub const SeImageSignatureCatalogNotCached: SE_IMAGE_SIGNATURE_TYPE = SE_IMAGE_SIGNATURE_TYPE(4i32);
pub const SeImageSignatureCatalogHint: SE_IMAGE_SIGNATURE_TYPE = SE_IMAGE_SIGNATURE_TYPE(5i32);
pub const SeImageSignaturePackageCatalog: SE_IMAGE_SIGNATURE_TYPE = SE_IMAGE_SIGNATURE_TYPE(6i32);
pub const SeImageSignaturePplMitigated: SE_IMAGE_SIGNATURE_TYPE = SE_IMAGE_SIGNATURE_TYPE(7i32);
impl ::std::convert::From<i32> for SE_IMAGE_SIGNATURE_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SE_IMAGE_SIGNATURE_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
pub struct SE_IMPERSONATION_STATE {
    pub Token: *mut ::std::ffi::c_void,
    pub CopyOnOpen: super::super::Foundation::BOOLEAN,
    pub EffectiveOnly: super::super::Foundation::BOOLEAN,
    pub Level: super::super::Security::SECURITY_IMPERSONATION_LEVEL,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl SE_IMPERSONATION_STATE {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::default::Default for SE_IMPERSONATION_STATE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::fmt::Debug for SE_IMPERSONATION_STATE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SE_IMPERSONATION_STATE")
            .field("Token", &self.Token)
            .field("CopyOnOpen", &self.CopyOnOpen)
            .field("EffectiveOnly", &self.EffectiveOnly)
            .field("Level", &self.Level)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::cmp::PartialEq for SE_IMPERSONATION_STATE {
    fn eq(&self, other: &Self) -> bool {
        self.Token == other.Token
            && self.CopyOnOpen == other.CopyOnOpen
            && self.EffectiveOnly == other.EffectiveOnly
            && self.Level == other.Level
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::cmp::Eq for SE_IMPERSONATION_STATE {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
unsafe impl ::windows::runtime::Abi for SE_IMPERSONATION_STATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SE_LEARNING_MODE_DATA_TYPE(pub i32);
pub const SeLearningModeInvalidType: SE_LEARNING_MODE_DATA_TYPE = SE_LEARNING_MODE_DATA_TYPE(0i32);
pub const SeLearningModeSettings: SE_LEARNING_MODE_DATA_TYPE = SE_LEARNING_MODE_DATA_TYPE(1i32);
pub const SeLearningModeMax: SE_LEARNING_MODE_DATA_TYPE = SE_LEARNING_MODE_DATA_TYPE(2i32);
impl ::std::convert::From<i32> for SE_LEARNING_MODE_DATA_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SE_LEARNING_MODE_DATA_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SE_LEARNING_MODE_FLAG_PERMISSIVE: u32 = 1u32;
pub const SE_OWNER_DEFAULTED: u32 = 1u32;
pub const SE_RM_CONTROL_VALID: u32 = 16384u32;
pub const SE_SACL_AUTO_INHERITED: u32 = 2048u32;
pub const SE_SACL_AUTO_INHERIT_REQ: u32 = 512u32;
pub const SE_SACL_DEFAULTED: u32 = 32u32;
pub const SE_SACL_PRESENT: u32 = 16u32;
pub const SE_SACL_PROTECTED: u32 = 8192u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
pub struct SE_SECURITY_DESCRIPTOR {
    pub Size: u32,
    pub Flags: u32,
    pub SecurityDescriptor: *mut super::super::Security::SECURITY_DESCRIPTOR,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl SE_SECURITY_DESCRIPTOR {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::default::Default for SE_SECURITY_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::fmt::Debug for SE_SECURITY_DESCRIPTOR {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SE_SECURITY_DESCRIPTOR")
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("SecurityDescriptor", &self.SecurityDescriptor)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::cmp::PartialEq for SE_SECURITY_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.Flags == other.Flags
            && self.SecurityDescriptor == other.SecurityDescriptor
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::cmp::Eq for SE_SECURITY_DESCRIPTOR {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
unsafe impl ::windows::runtime::Abi for SE_SECURITY_DESCRIPTOR {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_ACCESS_FILTER_ACE: u32 = 4u32;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_LABEL_ACE: u32 = 2u32;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_OWNER_ACE: u32 = 1u32;
pub const SE_SECURITY_DESCRIPTOR_VALID_FLAGS: u32 = 7u32;
pub const SE_SELF_RELATIVE: u32 = 32768u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Security")]
pub union SE_SID {
    pub Sid: super::super::Security::SID,
    pub Buffer: [u8; 68],
}
#[cfg(feature = "Win32_Security")]
impl SE_SID {}
#[cfg(feature = "Win32_Security")]
impl ::std::default::Default for SE_SID {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Security")]
impl ::std::cmp::PartialEq for SE_SID {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Security")]
impl ::std::cmp::Eq for SE_SID {}
#[cfg(feature = "Win32_Security")]
unsafe impl ::windows::runtime::Abi for SE_SID {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SE_SIGNING_LEVEL_ANTIMALWARE: u32 = 7u32;
pub const SE_SIGNING_LEVEL_AUTHENTICODE: u32 = 4u32;
pub const SE_SIGNING_LEVEL_CUSTOM_1: u32 = 3u32;
pub const SE_SIGNING_LEVEL_CUSTOM_2: u32 = 5u32;
pub const SE_SIGNING_LEVEL_CUSTOM_3: u32 = 7u32;
pub const SE_SIGNING_LEVEL_CUSTOM_4: u32 = 9u32;
pub const SE_SIGNING_LEVEL_CUSTOM_5: u32 = 10u32;
pub const SE_SIGNING_LEVEL_CUSTOM_6: u32 = 15u32;
pub const SE_SIGNING_LEVEL_CUSTOM_7: u32 = 13u32;
pub const SE_SIGNING_LEVEL_DEVELOPER: u32 = 3u32;
pub const SE_SIGNING_LEVEL_DYNAMIC_CODEGEN: u32 = 11u32;
pub const SE_SIGNING_LEVEL_ENTERPRISE: u32 = 2u32;
pub const SE_SIGNING_LEVEL_MICROSOFT: u32 = 8u32;
pub const SE_SIGNING_LEVEL_STORE: u32 = 6u32;
pub const SE_SIGNING_LEVEL_UNCHECKED: u32 = 0u32;
pub const SE_SIGNING_LEVEL_UNSIGNED: u32 = 1u32;
pub const SE_SIGNING_LEVEL_WINDOWS: u32 = 12u32;
pub const SE_SIGNING_LEVEL_WINDOWS_TCB: u32 = 14u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
pub struct SE_TOKEN_USER {
    pub Anonymous1: SE_TOKEN_USER_0,
    pub Anonymous2: SE_TOKEN_USER_1,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl SE_TOKEN_USER {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::default::Default for SE_TOKEN_USER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::cmp::PartialEq for SE_TOKEN_USER {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::cmp::Eq for SE_TOKEN_USER {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
unsafe impl ::windows::runtime::Abi for SE_TOKEN_USER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
pub union SE_TOKEN_USER_0 {
    pub TokenUser: super::super::Security::TOKEN_USER,
    pub User: super::super::Security::SID_AND_ATTRIBUTES,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl SE_TOKEN_USER_0 {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::default::Default for SE_TOKEN_USER_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::cmp::PartialEq for SE_TOKEN_USER_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::std::cmp::Eq for SE_TOKEN_USER_0 {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
unsafe impl ::windows::runtime::Abi for SE_TOKEN_USER_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Security")]
pub union SE_TOKEN_USER_1 {
    pub Sid: super::super::Security::SID,
    pub Buffer: [u8; 68],
}
#[cfg(feature = "Win32_Security")]
impl SE_TOKEN_USER_1 {}
#[cfg(feature = "Win32_Security")]
impl ::std::default::Default for SE_TOKEN_USER_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Security")]
impl ::std::cmp::PartialEq for SE_TOKEN_USER_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Security")]
impl ::std::cmp::Eq for SE_TOKEN_USER_1 {}
#[cfg(feature = "Win32_Security")]
unsafe impl ::windows::runtime::Abi for SE_TOKEN_USER_1 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SGI_EXTRASPACE: u32 = 0u32;
#[derive(
    :: std :: clone :: Clone,
    :: std :: marker :: Copy,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
)]
#[repr(transparent)]
pub struct SHANDLE_PTR(pub isize);
impl ::std::default::Default for SHANDLE_PTR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
unsafe impl ::windows::runtime::Handle for SHANDLE_PTR {}
unsafe impl ::windows::runtime::Abi for SHANDLE_PTR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SHARED_VIRTUAL_DISK_SUPPORT {
    pub SharedVirtualDiskSupport: SharedVirtualDiskSupportType,
    pub HandleState: SharedVirtualDiskHandleState,
}
impl SHARED_VIRTUAL_DISK_SUPPORT {}
impl ::std::default::Default for SHARED_VIRTUAL_DISK_SUPPORT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SHARED_VIRTUAL_DISK_SUPPORT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SHARED_VIRTUAL_DISK_SUPPORT")
            .field("SharedVirtualDiskSupport", &self.SharedVirtualDiskSupport)
            .field("HandleState", &self.HandleState)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SHARED_VIRTUAL_DISK_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.SharedVirtualDiskSupport == other.SharedVirtualDiskSupport
            && self.HandleState == other.HandleState
    }
}
impl ::std::cmp::Eq for SHARED_VIRTUAL_DISK_SUPPORT {}
unsafe impl ::windows::runtime::Abi for SHARED_VIRTUAL_DISK_SUPPORT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SHRINK_VOLUME_REQUEST_TYPES(pub i32);
pub const ShrinkPrepare: SHRINK_VOLUME_REQUEST_TYPES = SHRINK_VOLUME_REQUEST_TYPES(1i32);
pub const ShrinkCommit: SHRINK_VOLUME_REQUEST_TYPES = SHRINK_VOLUME_REQUEST_TYPES(2i32);
pub const ShrinkAbort: SHRINK_VOLUME_REQUEST_TYPES = SHRINK_VOLUME_REQUEST_TYPES(3i32);
impl ::std::convert::From<i32> for SHRINK_VOLUME_REQUEST_TYPES {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SHRINK_VOLUME_REQUEST_TYPES {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SHUFFLE_FILE_DATA {
    pub StartingOffset: i64,
    pub Length: i64,
    pub Flags: u32,
}
impl SHUFFLE_FILE_DATA {}
impl ::std::default::Default for SHUFFLE_FILE_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SHUFFLE_FILE_DATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SHUFFLE_FILE_DATA")
            .field("StartingOffset", &self.StartingOffset)
            .field("Length", &self.Length)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SHUFFLE_FILE_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.StartingOffset == other.StartingOffset
            && self.Length == other.Length
            && self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for SHUFFLE_FILE_DATA {}
unsafe impl ::windows::runtime::Abi for SHUFFLE_FILE_DATA {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SHUFFLE_FILE_FLAG_SKIP_INITIALIZING_NEW_CLUSTERS: u32 = 1u32;
pub const SID_HASH_SIZE: u32 = 32u32;
pub const SID_MAX_SUB_AUTHORITIES: u32 = 15u32;
pub const SID_RECOMMENDED_SUB_AUTHORITIES: u32 = 1u32;
pub const SID_REVISION: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct SILOOBJECT_BASIC_INFORMATION {
    pub SiloId: u32,
    pub SiloParentId: u32,
    pub NumberOfProcesses: u32,
    pub IsInServerSilo: super::super::Foundation::BOOLEAN,
    pub Reserved: [u8; 3],
}
#[cfg(feature = "Win32_Foundation")]
impl SILOOBJECT_BASIC_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for SILOOBJECT_BASIC_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for SILOOBJECT_BASIC_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SILOOBJECT_BASIC_INFORMATION")
            .field("SiloId", &self.SiloId)
            .field("SiloParentId", &self.SiloParentId)
            .field("NumberOfProcesses", &self.NumberOfProcesses)
            .field("IsInServerSilo", &self.IsInServerSilo)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for SILOOBJECT_BASIC_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.SiloId == other.SiloId
            && self.SiloParentId == other.SiloParentId
            && self.NumberOfProcesses == other.NumberOfProcesses
            && self.IsInServerSilo == other.IsInServerSilo
            && self.Reserved == other.Reserved
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for SILOOBJECT_BASIC_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for SILOOBJECT_BASIC_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SIZEOF_RFPO_DATA: u32 = 16u32;
pub const SIZE_OF_80387_REGISTERS: u32 = 80u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SI_COPYFILE {
    pub SourceFileNameLength: u32,
    pub DestinationFileNameLength: u32,
    pub Flags: u32,
    pub FileNameBuffer: [u16; 1],
}
impl SI_COPYFILE {}
impl ::std::default::Default for SI_COPYFILE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SI_COPYFILE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SI_COPYFILE")
            .field("SourceFileNameLength", &self.SourceFileNameLength)
            .field("DestinationFileNameLength", &self.DestinationFileNameLength)
            .field("Flags", &self.Flags)
            .field("FileNameBuffer", &self.FileNameBuffer)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SI_COPYFILE {
    fn eq(&self, other: &Self) -> bool {
        self.SourceFileNameLength == other.SourceFileNameLength
            && self.DestinationFileNameLength == other.DestinationFileNameLength
            && self.Flags == other.Flags
            && self.FileNameBuffer == other.FileNameBuffer
    }
}
impl ::std::cmp::Eq for SI_COPYFILE {}
unsafe impl ::windows::runtime::Abi for SI_COPYFILE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SMART_ABORT_OFFLINE_SELFTEST: u32 = 127u32;
pub const SMART_CMD: u32 = 176u32;
pub const SMART_CYL_HI: u32 = 194u32;
pub const SMART_CYL_LOW: u32 = 79u32;
pub const SMART_ERROR_NO_MEM: u32 = 7u32;
pub const SMART_EXTENDED_SELFTEST_CAPTIVE: u32 = 130u32;
pub const SMART_EXTENDED_SELFTEST_OFFLINE: u32 = 2u32;
pub const SMART_GET_VERSION: u32 = 475264u32;
pub const SMART_IDE_ERROR: u32 = 1u32;
pub const SMART_INVALID_BUFFER: u32 = 4u32;
pub const SMART_INVALID_COMMAND: u32 = 3u32;
pub const SMART_INVALID_DRIVE: u32 = 5u32;
pub const SMART_INVALID_FLAG: u32 = 2u32;
pub const SMART_INVALID_IOCTL: u32 = 6u32;
pub const SMART_INVALID_REGISTER: u32 = 8u32;
pub const SMART_LOG_SECTOR_SIZE: u32 = 512u32;
pub const SMART_NOT_SUPPORTED: u32 = 9u32;
pub const SMART_NO_ERROR: u32 = 0u32;
pub const SMART_NO_IDE_DEVICE: u32 = 10u32;
pub const SMART_OFFLINE_ROUTINE_OFFLINE: u32 = 0u32;
pub const SMART_RCV_DRIVE_DATA: u32 = 508040u32;
pub const SMART_RCV_DRIVE_DATA_EX: u32 = 458892u32;
pub const SMART_READ_LOG: u32 = 213u32;
pub const SMART_SEND_DRIVE_COMMAND: u32 = 508036u32;
pub const SMART_SHORT_SELFTEST_CAPTIVE: u32 = 129u32;
pub const SMART_SHORT_SELFTEST_OFFLINE: u32 = 1u32;
pub const SMART_WRITE_LOG: u32 = 214u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SMB_SHARE_FLUSH_AND_PURGE_INPUT {
    pub Version: u16,
}
impl SMB_SHARE_FLUSH_AND_PURGE_INPUT {}
impl ::std::default::Default for SMB_SHARE_FLUSH_AND_PURGE_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SMB_SHARE_FLUSH_AND_PURGE_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SMB_SHARE_FLUSH_AND_PURGE_INPUT")
            .field("Version", &self.Version)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SMB_SHARE_FLUSH_AND_PURGE_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
    }
}
impl ::std::cmp::Eq for SMB_SHARE_FLUSH_AND_PURGE_INPUT {}
unsafe impl ::windows::runtime::Abi for SMB_SHARE_FLUSH_AND_PURGE_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SMB_SHARE_FLUSH_AND_PURGE_OUTPUT {
    pub cEntriesPurged: u32,
}
impl SMB_SHARE_FLUSH_AND_PURGE_OUTPUT {}
impl ::std::default::Default for SMB_SHARE_FLUSH_AND_PURGE_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SMB_SHARE_FLUSH_AND_PURGE_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SMB_SHARE_FLUSH_AND_PURGE_OUTPUT")
            .field("cEntriesPurged", &self.cEntriesPurged)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SMB_SHARE_FLUSH_AND_PURGE_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.cEntriesPurged == other.cEntriesPurged
    }
}
impl ::std::cmp::Eq for SMB_SHARE_FLUSH_AND_PURGE_OUTPUT {}
unsafe impl ::windows::runtime::Abi for SMB_SHARE_FLUSH_AND_PURGE_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub type SORTCOMP = unsafe extern "system" fn(
    pv1: *const ::std::ffi::c_void,
    pv2: *const ::std::ffi::c_void,
) -> i32;
pub const SORT_CHINESE_BIG5: u32 = 0u32;
pub const SORT_CHINESE_BOPOMOFO: u32 = 3u32;
pub const SORT_CHINESE_PRC: u32 = 2u32;
pub const SORT_CHINESE_PRCP: u32 = 0u32;
pub const SORT_CHINESE_RADICALSTROKE: u32 = 4u32;
pub const SORT_CHINESE_UNICODE: u32 = 1u32;
pub const SORT_DEFAULT: u32 = 0u32;
pub const SORT_GEORGIAN_MODERN: u32 = 1u32;
pub const SORT_GEORGIAN_TRADITIONAL: u32 = 0u32;
pub const SORT_GERMAN_PHONE_BOOK: u32 = 1u32;
pub const SORT_HUNGARIAN_DEFAULT: u32 = 0u32;
pub const SORT_HUNGARIAN_TECHNICAL: u32 = 1u32;
pub const SORT_INVARIANT_MATH: u32 = 1u32;
pub const SORT_JAPANESE_RADICALSTROKE: u32 = 4u32;
pub const SORT_JAPANESE_UNICODE: u32 = 1u32;
pub const SORT_JAPANESE_XJIS: u32 = 0u32;
pub const SORT_KOREAN_KSC: u32 = 0u32;
pub const SORT_KOREAN_UNICODE: u32 = 1u32;
pub const SO_BREAK_EXTRA: u32 = 4096u32;
pub const SO_CHARACTER_EXTRA: u32 = 2048u32;
pub const SO_CHAR_INC_EQUAL_BM_BASE: u32 = 32u32;
pub const SO_DO_NOT_SUBSTITUTE_DEVICE_FONT: u32 = 128u32;
pub const SO_DXDY: u32 = 1024u32;
pub const SO_ESC_NOT_ORIENT: u32 = 512u32;
pub const SO_FLAG_DEFAULT_PLACEMENT: u32 = 1u32;
pub const SO_GLYPHINDEX_TEXTOUT: u32 = 256u32;
pub const SO_HORIZONTAL: u32 = 2u32;
pub const SO_MAXEXT_EQUAL_BM_SIDE: u32 = 64u32;
pub const SO_REVERSED: u32 = 8u32;
pub const SO_VERTICAL: u32 = 4u32;
pub const SO_ZERO_BEARINGS: u32 = 16u32;
pub const SPACES_TRACKED_OFFSET_HEADER_FLAG: u32 = 2u32;
pub const SPS_ACCEPT_EXCLUDE: u32 = 3u32;
pub const SPS_ACCEPT_NOEXCLUDE: u32 = 2u32;
pub const SPS_ACCEPT_SYNCHRONOUS: u32 = 4u32;
pub const SPS_ALPHA: i32 = 16i32;
pub const SPS_ANIMATESTART: i32 = 4i32;
pub const SPS_ANIMATEUPDATE: i32 = 8i32;
pub const SPS_ASYNCCHANGE: i32 = 2i32;
pub const SPS_CHANGE: i32 = 1i32;
pub const SPS_DECLINE: u32 = 1u32;
pub const SPS_ERROR: u32 = 0u32;
pub const SPS_FLAGSMASK: i32 = 255i32;
pub const SPS_FREQMASK: i32 = 1044480i32;
pub const SPS_LENGTHMASK: i32 = 3840i32;
pub const SPS_RESERVED: i32 = 32i32;
pub const SPS_RESERVED1: i32 = 64i32;
pub const SRB_TYPE_SCSI_REQUEST_BLOCK: u32 = 0u32;
pub const SRB_TYPE_STORAGE_REQUEST_BLOCK: u32 = 1u32;
pub const SS_FREE: u32 = 2u32;
pub const SS_RESTORE: u32 = 1u32;
pub const SS_SAVE: u32 = 0u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STARTING_LCN_INPUT_BUFFER_EX {
    pub StartingLcn: i64,
    pub Flags: u32,
}
impl STARTING_LCN_INPUT_BUFFER_EX {}
impl ::std::default::Default for STARTING_LCN_INPUT_BUFFER_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STARTING_LCN_INPUT_BUFFER_EX {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STARTING_LCN_INPUT_BUFFER_EX")
            .field("StartingLcn", &self.StartingLcn)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STARTING_LCN_INPUT_BUFFER_EX {
    fn eq(&self, other: &Self) -> bool {
        self.StartingLcn == other.StartingLcn && self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for STARTING_LCN_INPUT_BUFFER_EX {}
unsafe impl ::windows::runtime::Abi for STARTING_LCN_INPUT_BUFFER_EX {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_ADAPTER_SERIAL_NUMBER_V1_MAX_LENGTH: u32 = 128u32;
pub const STORAGE_ADDRESS_TYPE_BTL8: u32 = 0u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct STORAGE_ALLOCATE_BC_STREAM_INPUT {
    pub Version: u32,
    pub RequestsPerPeriod: u32,
    pub Period: u32,
    pub RetryFailures: super::super::Foundation::BOOLEAN,
    pub Discardable: super::super::Foundation::BOOLEAN,
    pub Reserved1: [super::super::Foundation::BOOLEAN; 2],
    pub AccessType: u32,
    pub AccessMode: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl STORAGE_ALLOCATE_BC_STREAM_INPUT {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for STORAGE_ALLOCATE_BC_STREAM_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for STORAGE_ALLOCATE_BC_STREAM_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_ALLOCATE_BC_STREAM_INPUT")
            .field("Version", &self.Version)
            .field("RequestsPerPeriod", &self.RequestsPerPeriod)
            .field("Period", &self.Period)
            .field("RetryFailures", &self.RetryFailures)
            .field("Discardable", &self.Discardable)
            .field("Reserved1", &self.Reserved1)
            .field("AccessType", &self.AccessType)
            .field("AccessMode", &self.AccessMode)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for STORAGE_ALLOCATE_BC_STREAM_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.RequestsPerPeriod == other.RequestsPerPeriod
            && self.Period == other.Period
            && self.RetryFailures == other.RetryFailures
            && self.Discardable == other.Discardable
            && self.Reserved1 == other.Reserved1
            && self.AccessType == other.AccessType
            && self.AccessMode == other.AccessMode
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for STORAGE_ALLOCATE_BC_STREAM_INPUT {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for STORAGE_ALLOCATE_BC_STREAM_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_ALLOCATE_BC_STREAM_OUTPUT {
    pub RequestSize: u64,
    pub NumOutStandingRequests: u32,
}
impl STORAGE_ALLOCATE_BC_STREAM_OUTPUT {}
impl ::std::default::Default for STORAGE_ALLOCATE_BC_STREAM_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_ALLOCATE_BC_STREAM_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_ALLOCATE_BC_STREAM_OUTPUT")
            .field("RequestSize", &self.RequestSize)
            .field("NumOutStandingRequests", &self.NumOutStandingRequests)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_ALLOCATE_BC_STREAM_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.RequestSize == other.RequestSize
            && self.NumOutStandingRequests == other.NumOutStandingRequests
    }
}
impl ::std::cmp::Eq for STORAGE_ALLOCATE_BC_STREAM_OUTPUT {}
unsafe impl ::windows::runtime::Abi for STORAGE_ALLOCATE_BC_STREAM_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_ASSOCIATION_TYPE(pub i32);
pub const StorageIdAssocDevice: STORAGE_ASSOCIATION_TYPE = STORAGE_ASSOCIATION_TYPE(0i32);
pub const StorageIdAssocPort: STORAGE_ASSOCIATION_TYPE = STORAGE_ASSOCIATION_TYPE(1i32);
pub const StorageIdAssocTarget: STORAGE_ASSOCIATION_TYPE = STORAGE_ASSOCIATION_TYPE(2i32);
impl ::std::convert::From<i32> for STORAGE_ASSOCIATION_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_ASSOCIATION_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_ATTRIBUTE_ASYNC_EVENT_NOTIFICATION: u32 = 16u32;
pub const STORAGE_ATTRIBUTE_BLOCK_IO: u32 = 2u32;
pub const STORAGE_ATTRIBUTE_BYTE_ADDRESSABLE_IO: u32 = 1u32;
pub const STORAGE_ATTRIBUTE_DYNAMIC_PERSISTENCE: u32 = 4u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_ATTRIBUTE_MGMT {
    pub Version: u32,
    pub Size: u32,
    pub Action: STORAGE_ATTRIBUTE_MGMT_ACTION,
    pub Attribute: u32,
}
impl STORAGE_ATTRIBUTE_MGMT {}
impl ::std::default::Default for STORAGE_ATTRIBUTE_MGMT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_ATTRIBUTE_MGMT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_ATTRIBUTE_MGMT")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Action", &self.Action)
            .field("Attribute", &self.Attribute)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_ATTRIBUTE_MGMT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.Action == other.Action
            && self.Attribute == other.Attribute
    }
}
impl ::std::cmp::Eq for STORAGE_ATTRIBUTE_MGMT {}
unsafe impl ::windows::runtime::Abi for STORAGE_ATTRIBUTE_MGMT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_ATTRIBUTE_MGMT_ACTION(pub i32);
pub const StorAttributeMgmt_ClearAttribute: STORAGE_ATTRIBUTE_MGMT_ACTION =
    STORAGE_ATTRIBUTE_MGMT_ACTION(0i32);
pub const StorAttributeMgmt_SetAttribute: STORAGE_ATTRIBUTE_MGMT_ACTION =
    STORAGE_ATTRIBUTE_MGMT_ACTION(1i32);
pub const StorAttributeMgmt_ResetAttribute: STORAGE_ATTRIBUTE_MGMT_ACTION =
    STORAGE_ATTRIBUTE_MGMT_ACTION(2i32);
impl ::std::convert::From<i32> for STORAGE_ATTRIBUTE_MGMT_ACTION {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_ATTRIBUTE_MGMT_ACTION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_ATTRIBUTE_PERF_SIZE_INDEPENDENT: u32 = 32u32;
pub const STORAGE_ATTRIBUTE_VOLATILE: u32 = 8u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_BREAK_RESERVATION_REQUEST {
    pub Length: u32,
    pub _unused: u8,
    pub PathId: u8,
    pub TargetId: u8,
    pub Lun: u8,
}
impl STORAGE_BREAK_RESERVATION_REQUEST {}
impl ::std::default::Default for STORAGE_BREAK_RESERVATION_REQUEST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_BREAK_RESERVATION_REQUEST {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_BREAK_RESERVATION_REQUEST")
            .field("Length", &self.Length)
            .field("_unused", &self._unused)
            .field("PathId", &self.PathId)
            .field("TargetId", &self.TargetId)
            .field("Lun", &self.Lun)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_BREAK_RESERVATION_REQUEST {
    fn eq(&self, other: &Self) -> bool {
        self.Length == other.Length
            && self._unused == other._unused
            && self.PathId == other.PathId
            && self.TargetId == other.TargetId
            && self.Lun == other.Lun
    }
}
impl ::std::cmp::Eq for STORAGE_BREAK_RESERVATION_REQUEST {}
unsafe impl ::windows::runtime::Abi for STORAGE_BREAK_RESERVATION_REQUEST {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_BUS_RESET_REQUEST {
    pub PathId: u8,
}
impl STORAGE_BUS_RESET_REQUEST {}
impl ::std::default::Default for STORAGE_BUS_RESET_REQUEST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_BUS_RESET_REQUEST {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_BUS_RESET_REQUEST")
            .field("PathId", &self.PathId)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_BUS_RESET_REQUEST {
    fn eq(&self, other: &Self) -> bool {
        self.PathId == other.PathId
    }
}
impl ::std::cmp::Eq for STORAGE_BUS_RESET_REQUEST {}
unsafe impl ::windows::runtime::Abi for STORAGE_BUS_RESET_REQUEST {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_BUS_TYPE(pub i32);
pub const BusTypeUnknown: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(0i32);
pub const BusTypeScsi: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(1i32);
pub const BusTypeAtapi: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(2i32);
pub const BusTypeAta: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(3i32);
pub const BusType1394: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(4i32);
pub const BusTypeSsa: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(5i32);
pub const BusTypeFibre: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(6i32);
pub const BusTypeUsb: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(7i32);
pub const BusTypeRAID: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(8i32);
pub const BusTypeiScsi: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(9i32);
pub const BusTypeSas: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(10i32);
pub const BusTypeSata: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(11i32);
pub const BusTypeSd: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(12i32);
pub const BusTypeMmc: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(13i32);
pub const BusTypeVirtual: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(14i32);
pub const BusTypeFileBackedVirtual: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(15i32);
pub const BusTypeSpaces: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(16i32);
pub const BusTypeNvme: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(17i32);
pub const BusTypeSCM: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(18i32);
pub const BusTypeUfs: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(19i32);
pub const BusTypeMax: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(20i32);
pub const BusTypeMaxReserved: STORAGE_BUS_TYPE = STORAGE_BUS_TYPE(127i32);
impl ::std::convert::From<i32> for STORAGE_BUS_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_BUS_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_COMPONENT_ROLE_CACHE: u32 = 1u32;
pub const STORAGE_COMPONENT_ROLE_DATA: u32 = 4u32;
pub const STORAGE_COMPONENT_ROLE_TIERING: u32 = 2u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_COUNTER {
    pub Type: STORAGE_COUNTER_TYPE,
    pub Value: STORAGE_COUNTER_0,
}
impl STORAGE_COUNTER {}
impl ::std::default::Default for STORAGE_COUNTER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for STORAGE_COUNTER {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for STORAGE_COUNTER {}
unsafe impl ::windows::runtime::Abi for STORAGE_COUNTER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union STORAGE_COUNTER_0 {
    pub ManufactureDate: STORAGE_COUNTER_0_0,
    pub AsUlonglong: u64,
}
impl STORAGE_COUNTER_0 {}
impl ::std::default::Default for STORAGE_COUNTER_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for STORAGE_COUNTER_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for STORAGE_COUNTER_0 {}
unsafe impl ::windows::runtime::Abi for STORAGE_COUNTER_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_COUNTER_0_0 {
    pub Week: u32,
    pub Year: u32,
}
impl STORAGE_COUNTER_0_0 {}
impl ::std::default::Default for STORAGE_COUNTER_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_COUNTER_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_ManufactureDate_e__Struct")
            .field("Week", &self.Week)
            .field("Year", &self.Year)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_COUNTER_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Week == other.Week && self.Year == other.Year
    }
}
impl ::std::cmp::Eq for STORAGE_COUNTER_0_0 {}
unsafe impl ::windows::runtime::Abi for STORAGE_COUNTER_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_COUNTERS {
    pub Version: u32,
    pub Size: u32,
    pub NumberOfCounters: u32,
    pub Counters: [STORAGE_COUNTER; 1],
}
impl STORAGE_COUNTERS {}
impl ::std::default::Default for STORAGE_COUNTERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for STORAGE_COUNTERS {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for STORAGE_COUNTERS {}
unsafe impl ::windows::runtime::Abi for STORAGE_COUNTERS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_COUNTER_TYPE(pub i32);
pub const StorageCounterTypeUnknown: STORAGE_COUNTER_TYPE = STORAGE_COUNTER_TYPE(0i32);
pub const StorageCounterTypeTemperatureCelsius: STORAGE_COUNTER_TYPE = STORAGE_COUNTER_TYPE(1i32);
pub const StorageCounterTypeTemperatureCelsiusMax: STORAGE_COUNTER_TYPE =
    STORAGE_COUNTER_TYPE(2i32);
pub const StorageCounterTypeReadErrorsTotal: STORAGE_COUNTER_TYPE = STORAGE_COUNTER_TYPE(3i32);
pub const StorageCounterTypeReadErrorsCorrected: STORAGE_COUNTER_TYPE = STORAGE_COUNTER_TYPE(4i32);
pub const StorageCounterTypeReadErrorsUncorrected: STORAGE_COUNTER_TYPE =
    STORAGE_COUNTER_TYPE(5i32);
pub const StorageCounterTypeWriteErrorsTotal: STORAGE_COUNTER_TYPE = STORAGE_COUNTER_TYPE(6i32);
pub const StorageCounterTypeWriteErrorsCorrected: STORAGE_COUNTER_TYPE = STORAGE_COUNTER_TYPE(7i32);
pub const StorageCounterTypeWriteErrorsUncorrected: STORAGE_COUNTER_TYPE =
    STORAGE_COUNTER_TYPE(8i32);
pub const StorageCounterTypeManufactureDate: STORAGE_COUNTER_TYPE = STORAGE_COUNTER_TYPE(9i32);
pub const StorageCounterTypeStartStopCycleCount: STORAGE_COUNTER_TYPE = STORAGE_COUNTER_TYPE(10i32);
pub const StorageCounterTypeStartStopCycleCountMax: STORAGE_COUNTER_TYPE =
    STORAGE_COUNTER_TYPE(11i32);
pub const StorageCounterTypeLoadUnloadCycleCount: STORAGE_COUNTER_TYPE =
    STORAGE_COUNTER_TYPE(12i32);
pub const StorageCounterTypeLoadUnloadCycleCountMax: STORAGE_COUNTER_TYPE =
    STORAGE_COUNTER_TYPE(13i32);
pub const StorageCounterTypeWearPercentage: STORAGE_COUNTER_TYPE = STORAGE_COUNTER_TYPE(14i32);
pub const StorageCounterTypeWearPercentageWarning: STORAGE_COUNTER_TYPE =
    STORAGE_COUNTER_TYPE(15i32);
pub const StorageCounterTypeWearPercentageMax: STORAGE_COUNTER_TYPE = STORAGE_COUNTER_TYPE(16i32);
pub const StorageCounterTypePowerOnHours: STORAGE_COUNTER_TYPE = STORAGE_COUNTER_TYPE(17i32);
pub const StorageCounterTypeReadLatency100NSMax: STORAGE_COUNTER_TYPE = STORAGE_COUNTER_TYPE(18i32);
pub const StorageCounterTypeWriteLatency100NSMax: STORAGE_COUNTER_TYPE =
    STORAGE_COUNTER_TYPE(19i32);
pub const StorageCounterTypeFlushLatency100NSMax: STORAGE_COUNTER_TYPE =
    STORAGE_COUNTER_TYPE(20i32);
pub const StorageCounterTypeMax: STORAGE_COUNTER_TYPE = STORAGE_COUNTER_TYPE(21i32);
impl ::std::convert::From<i32> for STORAGE_COUNTER_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_COUNTER_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_CRYPTO_ALGORITHM_ID(pub i32);
pub const StorageCryptoAlgorithmUnknown: STORAGE_CRYPTO_ALGORITHM_ID =
    STORAGE_CRYPTO_ALGORITHM_ID(0i32);
pub const StorageCryptoAlgorithmXTSAES: STORAGE_CRYPTO_ALGORITHM_ID =
    STORAGE_CRYPTO_ALGORITHM_ID(1i32);
pub const StorageCryptoAlgorithmBitlockerAESCBC: STORAGE_CRYPTO_ALGORITHM_ID =
    STORAGE_CRYPTO_ALGORITHM_ID(2i32);
pub const StorageCryptoAlgorithmAESECB: STORAGE_CRYPTO_ALGORITHM_ID =
    STORAGE_CRYPTO_ALGORITHM_ID(3i32);
pub const StorageCryptoAlgorithmESSIVAESCBC: STORAGE_CRYPTO_ALGORITHM_ID =
    STORAGE_CRYPTO_ALGORITHM_ID(4i32);
pub const StorageCryptoAlgorithmMax: STORAGE_CRYPTO_ALGORITHM_ID =
    STORAGE_CRYPTO_ALGORITHM_ID(5i32);
impl ::std::convert::From<i32> for STORAGE_CRYPTO_ALGORITHM_ID {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_CRYPTO_ALGORITHM_ID {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_CRYPTO_CAPABILITY {
    pub Version: u32,
    pub Size: u32,
    pub CryptoCapabilityIndex: u32,
    pub AlgorithmId: STORAGE_CRYPTO_ALGORITHM_ID,
    pub KeySize: STORAGE_CRYPTO_KEY_SIZE,
    pub DataUnitSizeBitmask: u32,
}
impl STORAGE_CRYPTO_CAPABILITY {}
impl ::std::default::Default for STORAGE_CRYPTO_CAPABILITY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_CRYPTO_CAPABILITY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_CRYPTO_CAPABILITY")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("CryptoCapabilityIndex", &self.CryptoCapabilityIndex)
            .field("AlgorithmId", &self.AlgorithmId)
            .field("KeySize", &self.KeySize)
            .field("DataUnitSizeBitmask", &self.DataUnitSizeBitmask)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_CRYPTO_CAPABILITY {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.CryptoCapabilityIndex == other.CryptoCapabilityIndex
            && self.AlgorithmId == other.AlgorithmId
            && self.KeySize == other.KeySize
            && self.DataUnitSizeBitmask == other.DataUnitSizeBitmask
    }
}
impl ::std::cmp::Eq for STORAGE_CRYPTO_CAPABILITY {}
unsafe impl ::windows::runtime::Abi for STORAGE_CRYPTO_CAPABILITY {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_CRYPTO_CAPABILITY_VERSION_1: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_CRYPTO_DESCRIPTOR {
    pub Version: u32,
    pub Size: u32,
    pub NumKeysSupported: u32,
    pub NumCryptoCapabilities: u32,
    pub CryptoCapabilities: [STORAGE_CRYPTO_CAPABILITY; 1],
}
impl STORAGE_CRYPTO_DESCRIPTOR {}
impl ::std::default::Default for STORAGE_CRYPTO_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_CRYPTO_DESCRIPTOR {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_CRYPTO_DESCRIPTOR")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("NumKeysSupported", &self.NumKeysSupported)
            .field("NumCryptoCapabilities", &self.NumCryptoCapabilities)
            .field("CryptoCapabilities", &self.CryptoCapabilities)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_CRYPTO_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.NumKeysSupported == other.NumKeysSupported
            && self.NumCryptoCapabilities == other.NumCryptoCapabilities
            && self.CryptoCapabilities == other.CryptoCapabilities
    }
}
impl ::std::cmp::Eq for STORAGE_CRYPTO_DESCRIPTOR {}
unsafe impl ::windows::runtime::Abi for STORAGE_CRYPTO_DESCRIPTOR {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_CRYPTO_DESCRIPTOR_VERSION_1: u32 = 1u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_CRYPTO_KEY_SIZE(pub i32);
pub const StorageCryptoKeySizeUnknown: STORAGE_CRYPTO_KEY_SIZE = STORAGE_CRYPTO_KEY_SIZE(0i32);
pub const StorageCryptoKeySize128Bits: STORAGE_CRYPTO_KEY_SIZE = STORAGE_CRYPTO_KEY_SIZE(1i32);
pub const StorageCryptoKeySize192Bits: STORAGE_CRYPTO_KEY_SIZE = STORAGE_CRYPTO_KEY_SIZE(2i32);
pub const StorageCryptoKeySize256Bits: STORAGE_CRYPTO_KEY_SIZE = STORAGE_CRYPTO_KEY_SIZE(3i32);
pub const StorageCryptoKeySize512Bits: STORAGE_CRYPTO_KEY_SIZE = STORAGE_CRYPTO_KEY_SIZE(4i32);
impl ::std::convert::From<i32> for STORAGE_CRYPTO_KEY_SIZE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_CRYPTO_KEY_SIZE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR {
    pub Version: u32,
    pub Size: u32,
    pub NumberOfFaultDomains: u32,
    pub FaultDomainIds: [::windows::runtime::GUID; 1],
}
impl STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR {}
impl ::std::default::Default for STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("NumberOfFaultDomains", &self.NumberOfFaultDomains)
            .field("FaultDomainIds", &self.FaultDomainIds)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.NumberOfFaultDomains == other.NumberOfFaultDomains
            && self.FaultDomainIds == other.FaultDomainIds
    }
}
impl ::std::cmp::Eq for STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR {}
unsafe impl ::windows::runtime::Abi for STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_DEVICE_FLAGS_PAGE_83_DEVICEGUID: u32 = 4u32;
pub const STORAGE_DEVICE_FLAGS_RANDOM_DEVICEGUID_REASON_CONFLICT: u32 = 1u32;
pub const STORAGE_DEVICE_FLAGS_RANDOM_DEVICEGUID_REASON_NOHWID: u32 = 2u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_DEVICE_LED_STATE_DESCRIPTOR {
    pub Version: u32,
    pub Size: u32,
    pub State: u64,
}
impl STORAGE_DEVICE_LED_STATE_DESCRIPTOR {}
impl ::std::default::Default for STORAGE_DEVICE_LED_STATE_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_DEVICE_LED_STATE_DESCRIPTOR {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_DEVICE_LED_STATE_DESCRIPTOR")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("State", &self.State)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_DEVICE_LED_STATE_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Size == other.Size && self.State == other.State
    }
}
impl ::std::cmp::Eq for STORAGE_DEVICE_LED_STATE_DESCRIPTOR {}
unsafe impl ::windows::runtime::Abi for STORAGE_DEVICE_LED_STATE_DESCRIPTOR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_DEVICE_LOCATION_DESCRIPTOR {
    pub Version: u32,
    pub Size: u32,
    pub Location: DEVICE_LOCATION,
    pub StringOffset: u32,
}
impl STORAGE_DEVICE_LOCATION_DESCRIPTOR {}
impl ::std::default::Default for STORAGE_DEVICE_LOCATION_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for STORAGE_DEVICE_LOCATION_DESCRIPTOR {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for STORAGE_DEVICE_LOCATION_DESCRIPTOR {}
unsafe impl ::windows::runtime::Abi for STORAGE_DEVICE_LOCATION_DESCRIPTOR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_DEVICE_MANAGEMENT_STATUS {
    pub Version: u32,
    pub Size: u32,
    pub Health: STORAGE_DISK_HEALTH_STATUS,
    pub NumberOfOperationalStatus: u32,
    pub NumberOfAdditionalReasons: u32,
    pub OperationalStatus: [STORAGE_DISK_OPERATIONAL_STATUS; 16],
    pub AdditionalReasons: [STORAGE_OPERATIONAL_REASON; 1],
}
impl STORAGE_DEVICE_MANAGEMENT_STATUS {}
impl ::std::default::Default for STORAGE_DEVICE_MANAGEMENT_STATUS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for STORAGE_DEVICE_MANAGEMENT_STATUS {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for STORAGE_DEVICE_MANAGEMENT_STATUS {}
unsafe impl ::windows::runtime::Abi for STORAGE_DEVICE_MANAGEMENT_STATUS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_DEVICE_MAX_OPERATIONAL_STATUS: u32 = 16u32;
pub const STORAGE_DEVICE_NUMA_NODE_UNKNOWN: u32 = 4294967295u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_DEVICE_NUMA_PROPERTY {
    pub Version: u32,
    pub Size: u32,
    pub NumaNode: u32,
}
impl STORAGE_DEVICE_NUMA_PROPERTY {}
impl ::std::default::Default for STORAGE_DEVICE_NUMA_PROPERTY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_DEVICE_NUMA_PROPERTY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_DEVICE_NUMA_PROPERTY")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("NumaNode", &self.NumaNode)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_DEVICE_NUMA_PROPERTY {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Size == other.Size && self.NumaNode == other.NumaNode
    }
}
impl ::std::cmp::Eq for STORAGE_DEVICE_NUMA_PROPERTY {}
unsafe impl ::windows::runtime::Abi for STORAGE_DEVICE_NUMA_PROPERTY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_DEVICE_NUMBER {
    pub DeviceType: u32,
    pub DeviceNumber: u32,
    pub PartitionNumber: u32,
}
impl STORAGE_DEVICE_NUMBER {}
impl ::std::default::Default for STORAGE_DEVICE_NUMBER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_DEVICE_NUMBER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_DEVICE_NUMBER")
            .field("DeviceType", &self.DeviceType)
            .field("DeviceNumber", &self.DeviceNumber)
            .field("PartitionNumber", &self.PartitionNumber)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_DEVICE_NUMBER {
    fn eq(&self, other: &Self) -> bool {
        self.DeviceType == other.DeviceType
            && self.DeviceNumber == other.DeviceNumber
            && self.PartitionNumber == other.PartitionNumber
    }
}
impl ::std::cmp::Eq for STORAGE_DEVICE_NUMBER {}
unsafe impl ::windows::runtime::Abi for STORAGE_DEVICE_NUMBER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_DEVICE_NUMBERS {
    pub Version: u32,
    pub Size: u32,
    pub NumberOfDevices: u32,
    pub Devices: [STORAGE_DEVICE_NUMBER; 1],
}
impl STORAGE_DEVICE_NUMBERS {}
impl ::std::default::Default for STORAGE_DEVICE_NUMBERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_DEVICE_NUMBERS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_DEVICE_NUMBERS")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("NumberOfDevices", &self.NumberOfDevices)
            .field("Devices", &self.Devices)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_DEVICE_NUMBERS {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.NumberOfDevices == other.NumberOfDevices
            && self.Devices == other.Devices
    }
}
impl ::std::cmp::Eq for STORAGE_DEVICE_NUMBERS {}
unsafe impl ::windows::runtime::Abi for STORAGE_DEVICE_NUMBERS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_DEVICE_NUMBER_EX {
    pub Version: u32,
    pub Size: u32,
    pub Flags: u32,
    pub DeviceType: u32,
    pub DeviceNumber: u32,
    pub DeviceGuid: ::windows::runtime::GUID,
    pub PartitionNumber: u32,
}
impl STORAGE_DEVICE_NUMBER_EX {}
impl ::std::default::Default for STORAGE_DEVICE_NUMBER_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_DEVICE_NUMBER_EX {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_DEVICE_NUMBER_EX")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("DeviceType", &self.DeviceType)
            .field("DeviceNumber", &self.DeviceNumber)
            .field("DeviceGuid", &self.DeviceGuid)
            .field("PartitionNumber", &self.PartitionNumber)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_DEVICE_NUMBER_EX {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.Flags == other.Flags
            && self.DeviceType == other.DeviceType
            && self.DeviceNumber == other.DeviceNumber
            && self.DeviceGuid == other.DeviceGuid
            && self.PartitionNumber == other.PartitionNumber
    }
}
impl ::std::cmp::Eq for STORAGE_DEVICE_NUMBER_EX {}
unsafe impl ::windows::runtime::Abi for STORAGE_DEVICE_NUMBER_EX {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_DEVICE_POWER_CAP_VERSION_V1: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY {
    pub Version: u32,
    pub Size: u32,
    pub SupportsSelfEncryption: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("SupportsSelfEncryption", &self.SupportsSelfEncryption)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.SupportsSelfEncryption == other.SupportsSelfEncryption
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_DEVICE_TIERING_DESCRIPTOR {
    pub Version: u32,
    pub Size: u32,
    pub Flags: u32,
    pub TotalNumberOfTiers: u32,
    pub NumberOfTiersReturned: u32,
    pub Tiers: [STORAGE_TIER; 1],
}
impl STORAGE_DEVICE_TIERING_DESCRIPTOR {}
impl ::std::default::Default for STORAGE_DEVICE_TIERING_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_DEVICE_TIERING_DESCRIPTOR {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_DEVICE_TIERING_DESCRIPTOR")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("TotalNumberOfTiers", &self.TotalNumberOfTiers)
            .field("NumberOfTiersReturned", &self.NumberOfTiersReturned)
            .field("Tiers", &self.Tiers)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_DEVICE_TIERING_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.Flags == other.Flags
            && self.TotalNumberOfTiers == other.TotalNumberOfTiers
            && self.NumberOfTiersReturned == other.NumberOfTiersReturned
            && self.Tiers == other.Tiers
    }
}
impl ::std::cmp::Eq for STORAGE_DEVICE_TIERING_DESCRIPTOR {}
unsafe impl ::windows::runtime::Abi for STORAGE_DEVICE_TIERING_DESCRIPTOR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT {
    pub Version: u32,
    pub Size: u32,
    pub UnsafeShutdownCount: u32,
}
impl STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT {}
impl ::std::default::Default for STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("UnsafeShutdownCount", &self.UnsafeShutdownCount)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.UnsafeShutdownCount == other.UnsafeShutdownCount
    }
}
impl ::std::cmp::Eq for STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT {}
unsafe impl ::windows::runtime::Abi for STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_DIAGNOSTIC_DATA {
    pub Version: u32,
    pub Size: u32,
    pub ProviderId: ::windows::runtime::GUID,
    pub BufferSize: u32,
    pub Reserved: u32,
    pub DiagnosticDataBuffer: [u8; 1],
}
impl STORAGE_DIAGNOSTIC_DATA {}
impl ::std::default::Default for STORAGE_DIAGNOSTIC_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_DIAGNOSTIC_DATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_DIAGNOSTIC_DATA")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("ProviderId", &self.ProviderId)
            .field("BufferSize", &self.BufferSize)
            .field("Reserved", &self.Reserved)
            .field("DiagnosticDataBuffer", &self.DiagnosticDataBuffer)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_DIAGNOSTIC_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.ProviderId == other.ProviderId
            && self.BufferSize == other.BufferSize
            && self.Reserved == other.Reserved
            && self.DiagnosticDataBuffer == other.DiagnosticDataBuffer
    }
}
impl ::std::cmp::Eq for STORAGE_DIAGNOSTIC_DATA {}
unsafe impl ::windows::runtime::Abi for STORAGE_DIAGNOSTIC_DATA {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_DIAGNOSTIC_FLAG_ADAPTER_REQUEST: u32 = 1u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_DIAGNOSTIC_LEVEL(pub i32);
pub const StorageDiagnosticLevelDefault: STORAGE_DIAGNOSTIC_LEVEL = STORAGE_DIAGNOSTIC_LEVEL(0i32);
pub const StorageDiagnosticLevelMax: STORAGE_DIAGNOSTIC_LEVEL = STORAGE_DIAGNOSTIC_LEVEL(1i32);
impl ::std::convert::From<i32> for STORAGE_DIAGNOSTIC_LEVEL {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_DIAGNOSTIC_LEVEL {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_DIAGNOSTIC_REQUEST {
    pub Version: u32,
    pub Size: u32,
    pub Flags: u32,
    pub TargetType: STORAGE_DIAGNOSTIC_TARGET_TYPE,
    pub Level: STORAGE_DIAGNOSTIC_LEVEL,
}
impl STORAGE_DIAGNOSTIC_REQUEST {}
impl ::std::default::Default for STORAGE_DIAGNOSTIC_REQUEST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_DIAGNOSTIC_REQUEST {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_DIAGNOSTIC_REQUEST")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("TargetType", &self.TargetType)
            .field("Level", &self.Level)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_DIAGNOSTIC_REQUEST {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.Flags == other.Flags
            && self.TargetType == other.TargetType
            && self.Level == other.Level
    }
}
impl ::std::cmp::Eq for STORAGE_DIAGNOSTIC_REQUEST {}
unsafe impl ::windows::runtime::Abi for STORAGE_DIAGNOSTIC_REQUEST {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_DIAGNOSTIC_TARGET_TYPE(pub i32);
pub const StorageDiagnosticTargetTypeUndefined: STORAGE_DIAGNOSTIC_TARGET_TYPE =
    STORAGE_DIAGNOSTIC_TARGET_TYPE(0i32);
pub const StorageDiagnosticTargetTypePort: STORAGE_DIAGNOSTIC_TARGET_TYPE =
    STORAGE_DIAGNOSTIC_TARGET_TYPE(1i32);
pub const StorageDiagnosticTargetTypeMiniport: STORAGE_DIAGNOSTIC_TARGET_TYPE =
    STORAGE_DIAGNOSTIC_TARGET_TYPE(2i32);
pub const StorageDiagnosticTargetTypeHbaFirmware: STORAGE_DIAGNOSTIC_TARGET_TYPE =
    STORAGE_DIAGNOSTIC_TARGET_TYPE(3i32);
pub const StorageDiagnosticTargetTypeMax: STORAGE_DIAGNOSTIC_TARGET_TYPE =
    STORAGE_DIAGNOSTIC_TARGET_TYPE(4i32);
impl ::std::convert::From<i32> for STORAGE_DIAGNOSTIC_TARGET_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_DIAGNOSTIC_TARGET_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_DISK_HEALTH_STATUS(pub i32);
pub const DiskHealthUnknown: STORAGE_DISK_HEALTH_STATUS = STORAGE_DISK_HEALTH_STATUS(0i32);
pub const DiskHealthUnhealthy: STORAGE_DISK_HEALTH_STATUS = STORAGE_DISK_HEALTH_STATUS(1i32);
pub const DiskHealthWarning: STORAGE_DISK_HEALTH_STATUS = STORAGE_DISK_HEALTH_STATUS(2i32);
pub const DiskHealthHealthy: STORAGE_DISK_HEALTH_STATUS = STORAGE_DISK_HEALTH_STATUS(3i32);
pub const DiskHealthMax: STORAGE_DISK_HEALTH_STATUS = STORAGE_DISK_HEALTH_STATUS(4i32);
impl ::std::convert::From<i32> for STORAGE_DISK_HEALTH_STATUS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_DISK_HEALTH_STATUS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_DISK_OPERATIONAL_STATUS(pub i32);
pub const DiskOpStatusNone: STORAGE_DISK_OPERATIONAL_STATUS = STORAGE_DISK_OPERATIONAL_STATUS(0i32);
pub const DiskOpStatusUnknown: STORAGE_DISK_OPERATIONAL_STATUS =
    STORAGE_DISK_OPERATIONAL_STATUS(1i32);
pub const DiskOpStatusOk: STORAGE_DISK_OPERATIONAL_STATUS = STORAGE_DISK_OPERATIONAL_STATUS(2i32);
pub const DiskOpStatusPredictingFailure: STORAGE_DISK_OPERATIONAL_STATUS =
    STORAGE_DISK_OPERATIONAL_STATUS(3i32);
pub const DiskOpStatusInService: STORAGE_DISK_OPERATIONAL_STATUS =
    STORAGE_DISK_OPERATIONAL_STATUS(4i32);
pub const DiskOpStatusHardwareError: STORAGE_DISK_OPERATIONAL_STATUS =
    STORAGE_DISK_OPERATIONAL_STATUS(5i32);
pub const DiskOpStatusNotUsable: STORAGE_DISK_OPERATIONAL_STATUS =
    STORAGE_DISK_OPERATIONAL_STATUS(6i32);
pub const DiskOpStatusTransientError: STORAGE_DISK_OPERATIONAL_STATUS =
    STORAGE_DISK_OPERATIONAL_STATUS(7i32);
pub const DiskOpStatusMissing: STORAGE_DISK_OPERATIONAL_STATUS =
    STORAGE_DISK_OPERATIONAL_STATUS(8i32);
impl ::std::convert::From<i32> for STORAGE_DISK_OPERATIONAL_STATUS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_DISK_OPERATIONAL_STATUS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_EVENT_DEVICE_OPERATION: u64 = 4u64;
pub const STORAGE_EVENT_DEVICE_STATUS: u64 = 2u64;
pub const STORAGE_EVENT_MEDIA_STATUS: u64 = 1u64;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_EVENT_NOTIFICATION {
    pub Version: u32,
    pub Size: u32,
    pub Events: u64,
}
impl STORAGE_EVENT_NOTIFICATION {}
impl ::std::default::Default for STORAGE_EVENT_NOTIFICATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_EVENT_NOTIFICATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_EVENT_NOTIFICATION")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Events", &self.Events)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_EVENT_NOTIFICATION {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Size == other.Size && self.Events == other.Events
    }
}
impl ::std::cmp::Eq for STORAGE_EVENT_NOTIFICATION {}
unsafe impl ::windows::runtime::Abi for STORAGE_EVENT_NOTIFICATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_EVENT_NOTIFICATION_VERSION_V1: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct STORAGE_FAILURE_PREDICTION_CONFIG {
    pub Version: u32,
    pub Size: u32,
    pub Set: super::super::Foundation::BOOLEAN,
    pub Enabled: super::super::Foundation::BOOLEAN,
    pub Reserved: u16,
}
#[cfg(feature = "Win32_Foundation")]
impl STORAGE_FAILURE_PREDICTION_CONFIG {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for STORAGE_FAILURE_PREDICTION_CONFIG {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for STORAGE_FAILURE_PREDICTION_CONFIG {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_FAILURE_PREDICTION_CONFIG")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Set", &self.Set)
            .field("Enabled", &self.Enabled)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for STORAGE_FAILURE_PREDICTION_CONFIG {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.Set == other.Set
            && self.Enabled == other.Enabled
            && self.Reserved == other.Reserved
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for STORAGE_FAILURE_PREDICTION_CONFIG {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for STORAGE_FAILURE_PREDICTION_CONFIG {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_FAILURE_PREDICTION_CONFIG_V1: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_FRU_ID_DESCRIPTOR {
    pub Version: u32,
    pub Size: u32,
    pub IdentifierSize: u32,
    pub Identifier: [u8; 1],
}
impl STORAGE_FRU_ID_DESCRIPTOR {}
impl ::std::default::Default for STORAGE_FRU_ID_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_FRU_ID_DESCRIPTOR {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_FRU_ID_DESCRIPTOR")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("IdentifierSize", &self.IdentifierSize)
            .field("Identifier", &self.Identifier)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_FRU_ID_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.IdentifierSize == other.IdentifierSize
            && self.Identifier == other.Identifier
    }
}
impl ::std::cmp::Eq for STORAGE_FRU_ID_DESCRIPTOR {}
unsafe impl ::windows::runtime::Abi for STORAGE_FRU_ID_DESCRIPTOR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_GET_BC_PROPERTIES_OUTPUT {
    pub MaximumRequestsPerPeriod: u32,
    pub MinimumPeriod: u32,
    pub MaximumRequestSize: u64,
    pub EstimatedTimePerRequest: u32,
    pub NumOutStandingRequests: u32,
    pub RequestSize: u64,
}
impl STORAGE_GET_BC_PROPERTIES_OUTPUT {}
impl ::std::default::Default for STORAGE_GET_BC_PROPERTIES_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_GET_BC_PROPERTIES_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_GET_BC_PROPERTIES_OUTPUT")
            .field("MaximumRequestsPerPeriod", &self.MaximumRequestsPerPeriod)
            .field("MinimumPeriod", &self.MinimumPeriod)
            .field("MaximumRequestSize", &self.MaximumRequestSize)
            .field("EstimatedTimePerRequest", &self.EstimatedTimePerRequest)
            .field("NumOutStandingRequests", &self.NumOutStandingRequests)
            .field("RequestSize", &self.RequestSize)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_GET_BC_PROPERTIES_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.MaximumRequestsPerPeriod == other.MaximumRequestsPerPeriod
            && self.MinimumPeriod == other.MinimumPeriod
            && self.MaximumRequestSize == other.MaximumRequestSize
            && self.EstimatedTimePerRequest == other.EstimatedTimePerRequest
            && self.NumOutStandingRequests == other.NumOutStandingRequests
            && self.RequestSize == other.RequestSize
    }
}
impl ::std::cmp::Eq for STORAGE_GET_BC_PROPERTIES_OUTPUT {}
unsafe impl ::windows::runtime::Abi for STORAGE_GET_BC_PROPERTIES_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct STORAGE_HOTPLUG_INFO {
    pub Size: u32,
    pub MediaRemovable: super::super::Foundation::BOOLEAN,
    pub MediaHotplug: super::super::Foundation::BOOLEAN,
    pub DeviceHotplug: super::super::Foundation::BOOLEAN,
    pub WriteCacheEnableOverride: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl STORAGE_HOTPLUG_INFO {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for STORAGE_HOTPLUG_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for STORAGE_HOTPLUG_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_HOTPLUG_INFO")
            .field("Size", &self.Size)
            .field("MediaRemovable", &self.MediaRemovable)
            .field("MediaHotplug", &self.MediaHotplug)
            .field("DeviceHotplug", &self.DeviceHotplug)
            .field("WriteCacheEnableOverride", &self.WriteCacheEnableOverride)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for STORAGE_HOTPLUG_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.MediaRemovable == other.MediaRemovable
            && self.MediaHotplug == other.MediaHotplug
            && self.DeviceHotplug == other.DeviceHotplug
            && self.WriteCacheEnableOverride == other.WriteCacheEnableOverride
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for STORAGE_HOTPLUG_INFO {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for STORAGE_HOTPLUG_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR {
    pub Version: u32,
    pub Size: u32,
    pub EnduranceInfo: STORAGE_HW_ENDURANCE_INFO,
}
impl STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR {}
impl ::std::default::Default for STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("EnduranceInfo", &self.EnduranceInfo)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.EnduranceInfo == other.EnduranceInfo
    }
}
impl ::std::cmp::Eq for STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR {}
unsafe impl ::windows::runtime::Abi for STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_HW_ENDURANCE_INFO {
    pub ValidFields: u32,
    pub GroupId: u32,
    pub Flags: STORAGE_HW_ENDURANCE_INFO_0,
    pub LifePercentage: u32,
    pub BytesReadCount: [u8; 16],
    pub ByteWriteCount: [u8; 16],
}
impl STORAGE_HW_ENDURANCE_INFO {}
impl ::std::default::Default for STORAGE_HW_ENDURANCE_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_HW_ENDURANCE_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_HW_ENDURANCE_INFO")
            .field("ValidFields", &self.ValidFields)
            .field("GroupId", &self.GroupId)
            .field("Flags", &self.Flags)
            .field("LifePercentage", &self.LifePercentage)
            .field("BytesReadCount", &self.BytesReadCount)
            .field("ByteWriteCount", &self.ByteWriteCount)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_HW_ENDURANCE_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.ValidFields == other.ValidFields
            && self.GroupId == other.GroupId
            && self.Flags == other.Flags
            && self.LifePercentage == other.LifePercentage
            && self.BytesReadCount == other.BytesReadCount
            && self.ByteWriteCount == other.ByteWriteCount
    }
}
impl ::std::cmp::Eq for STORAGE_HW_ENDURANCE_INFO {}
unsafe impl ::windows::runtime::Abi for STORAGE_HW_ENDURANCE_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_HW_ENDURANCE_INFO_0 {
    pub _bitfield: u32,
}
impl STORAGE_HW_ENDURANCE_INFO_0 {}
impl ::std::default::Default for STORAGE_HW_ENDURANCE_INFO_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_HW_ENDURANCE_INFO_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Flags_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_HW_ENDURANCE_INFO_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for STORAGE_HW_ENDURANCE_INFO_0 {}
unsafe impl ::windows::runtime::Abi for STORAGE_HW_ENDURANCE_INFO_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_HW_FIRMWARE_DOWNLOAD_V2 {
    pub Version: u32,
    pub Size: u32,
    pub Flags: u32,
    pub Slot: u8,
    pub Reserved: [u8; 3],
    pub Offset: u64,
    pub BufferSize: u64,
    pub ImageSize: u32,
    pub Reserved2: u32,
    pub ImageBuffer: [u8; 1],
}
impl STORAGE_HW_FIRMWARE_DOWNLOAD_V2 {}
impl ::std::default::Default for STORAGE_HW_FIRMWARE_DOWNLOAD_V2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_HW_FIRMWARE_DOWNLOAD_V2 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_HW_FIRMWARE_DOWNLOAD_V2")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("Slot", &self.Slot)
            .field("Reserved", &self.Reserved)
            .field("Offset", &self.Offset)
            .field("BufferSize", &self.BufferSize)
            .field("ImageSize", &self.ImageSize)
            .field("Reserved2", &self.Reserved2)
            .field("ImageBuffer", &self.ImageBuffer)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_HW_FIRMWARE_DOWNLOAD_V2 {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.Flags == other.Flags
            && self.Slot == other.Slot
            && self.Reserved == other.Reserved
            && self.Offset == other.Offset
            && self.BufferSize == other.BufferSize
            && self.ImageSize == other.ImageSize
            && self.Reserved2 == other.Reserved2
            && self.ImageBuffer == other.ImageBuffer
    }
}
impl ::std::cmp::Eq for STORAGE_HW_FIRMWARE_DOWNLOAD_V2 {}
unsafe impl ::windows::runtime::Abi for STORAGE_HW_FIRMWARE_DOWNLOAD_V2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct STORAGE_HW_FIRMWARE_INFO {
    pub Version: u32,
    pub Size: u32,
    pub _bitfield: u8,
    pub SlotCount: u8,
    pub ActiveSlot: u8,
    pub PendingActivateSlot: u8,
    pub FirmwareShared: super::super::Foundation::BOOLEAN,
    pub Reserved: [u8; 3],
    pub ImagePayloadAlignment: u32,
    pub ImagePayloadMaxSize: u32,
    pub Slot: [STORAGE_HW_FIRMWARE_SLOT_INFO; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl STORAGE_HW_FIRMWARE_INFO {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for STORAGE_HW_FIRMWARE_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for STORAGE_HW_FIRMWARE_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_HW_FIRMWARE_INFO")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("_bitfield", &self._bitfield)
            .field("SlotCount", &self.SlotCount)
            .field("ActiveSlot", &self.ActiveSlot)
            .field("PendingActivateSlot", &self.PendingActivateSlot)
            .field("FirmwareShared", &self.FirmwareShared)
            .field("Reserved", &self.Reserved)
            .field("ImagePayloadAlignment", &self.ImagePayloadAlignment)
            .field("ImagePayloadMaxSize", &self.ImagePayloadMaxSize)
            .field("Slot", &self.Slot)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for STORAGE_HW_FIRMWARE_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self._bitfield == other._bitfield
            && self.SlotCount == other.SlotCount
            && self.ActiveSlot == other.ActiveSlot
            && self.PendingActivateSlot == other.PendingActivateSlot
            && self.FirmwareShared == other.FirmwareShared
            && self.Reserved == other.Reserved
            && self.ImagePayloadAlignment == other.ImagePayloadAlignment
            && self.ImagePayloadMaxSize == other.ImagePayloadMaxSize
            && self.Slot == other.Slot
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for STORAGE_HW_FIRMWARE_INFO {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for STORAGE_HW_FIRMWARE_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_HW_FIRMWARE_INFO_QUERY {
    pub Version: u32,
    pub Size: u32,
    pub Flags: u32,
    pub Reserved: u32,
}
impl STORAGE_HW_FIRMWARE_INFO_QUERY {}
impl ::std::default::Default for STORAGE_HW_FIRMWARE_INFO_QUERY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_HW_FIRMWARE_INFO_QUERY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_HW_FIRMWARE_INFO_QUERY")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_HW_FIRMWARE_INFO_QUERY {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.Flags == other.Flags
            && self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for STORAGE_HW_FIRMWARE_INFO_QUERY {}
unsafe impl ::windows::runtime::Abi for STORAGE_HW_FIRMWARE_INFO_QUERY {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_HW_FIRMWARE_INVALID_SLOT: u32 = 255u32;
pub const STORAGE_HW_FIRMWARE_REQUEST_FLAG_CONTROLLER: u32 = 1u32;
pub const STORAGE_HW_FIRMWARE_REQUEST_FLAG_FIRST_SEGMENT: u32 = 4u32;
pub const STORAGE_HW_FIRMWARE_REQUEST_FLAG_LAST_SEGMENT: u32 = 2u32;
pub const STORAGE_HW_FIRMWARE_REQUEST_FLAG_SWITCH_TO_EXISTING_FIRMWARE: u32 = 2147483648u32;
pub const STORAGE_HW_FIRMWARE_REVISION_LENGTH: u32 = 16u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_HW_FIRMWARE_SLOT_INFO {
    pub Version: u32,
    pub Size: u32,
    pub SlotNumber: u8,
    pub _bitfield: u8,
    pub Reserved1: [u8; 6],
    pub Revision: [u8; 16],
}
impl STORAGE_HW_FIRMWARE_SLOT_INFO {}
impl ::std::default::Default for STORAGE_HW_FIRMWARE_SLOT_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_HW_FIRMWARE_SLOT_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_HW_FIRMWARE_SLOT_INFO")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("SlotNumber", &self.SlotNumber)
            .field("_bitfield", &self._bitfield)
            .field("Reserved1", &self.Reserved1)
            .field("Revision", &self.Revision)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_HW_FIRMWARE_SLOT_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.SlotNumber == other.SlotNumber
            && self._bitfield == other._bitfield
            && self.Reserved1 == other.Reserved1
            && self.Revision == other.Revision
    }
}
impl ::std::cmp::Eq for STORAGE_HW_FIRMWARE_SLOT_INFO {}
unsafe impl ::windows::runtime::Abi for STORAGE_HW_FIRMWARE_SLOT_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_IDENTIFIER {
    pub CodeSet: STORAGE_IDENTIFIER_CODE_SET,
    pub Type: STORAGE_IDENTIFIER_TYPE,
    pub IdentifierSize: u16,
    pub NextOffset: u16,
    pub Association: STORAGE_ASSOCIATION_TYPE,
    pub Identifier: [u8; 1],
}
impl STORAGE_IDENTIFIER {}
impl ::std::default::Default for STORAGE_IDENTIFIER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_IDENTIFIER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_IDENTIFIER")
            .field("CodeSet", &self.CodeSet)
            .field("Type", &self.Type)
            .field("IdentifierSize", &self.IdentifierSize)
            .field("NextOffset", &self.NextOffset)
            .field("Association", &self.Association)
            .field("Identifier", &self.Identifier)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_IDENTIFIER {
    fn eq(&self, other: &Self) -> bool {
        self.CodeSet == other.CodeSet
            && self.Type == other.Type
            && self.IdentifierSize == other.IdentifierSize
            && self.NextOffset == other.NextOffset
            && self.Association == other.Association
            && self.Identifier == other.Identifier
    }
}
impl ::std::cmp::Eq for STORAGE_IDENTIFIER {}
unsafe impl ::windows::runtime::Abi for STORAGE_IDENTIFIER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_IDENTIFIER_CODE_SET(pub i32);
pub const StorageIdCodeSetReserved: STORAGE_IDENTIFIER_CODE_SET = STORAGE_IDENTIFIER_CODE_SET(0i32);
pub const StorageIdCodeSetBinary: STORAGE_IDENTIFIER_CODE_SET = STORAGE_IDENTIFIER_CODE_SET(1i32);
pub const StorageIdCodeSetAscii: STORAGE_IDENTIFIER_CODE_SET = STORAGE_IDENTIFIER_CODE_SET(2i32);
pub const StorageIdCodeSetUtf8: STORAGE_IDENTIFIER_CODE_SET = STORAGE_IDENTIFIER_CODE_SET(3i32);
impl ::std::convert::From<i32> for STORAGE_IDENTIFIER_CODE_SET {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_IDENTIFIER_CODE_SET {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_IDENTIFIER_TYPE(pub i32);
pub const StorageIdTypeVendorSpecific: STORAGE_IDENTIFIER_TYPE = STORAGE_IDENTIFIER_TYPE(0i32);
pub const StorageIdTypeVendorId: STORAGE_IDENTIFIER_TYPE = STORAGE_IDENTIFIER_TYPE(1i32);
pub const StorageIdTypeEUI64: STORAGE_IDENTIFIER_TYPE = STORAGE_IDENTIFIER_TYPE(2i32);
pub const StorageIdTypeFCPHName: STORAGE_IDENTIFIER_TYPE = STORAGE_IDENTIFIER_TYPE(3i32);
pub const StorageIdTypePortRelative: STORAGE_IDENTIFIER_TYPE = STORAGE_IDENTIFIER_TYPE(4i32);
pub const StorageIdTypeTargetPortGroup: STORAGE_IDENTIFIER_TYPE = STORAGE_IDENTIFIER_TYPE(5i32);
pub const StorageIdTypeLogicalUnitGroup: STORAGE_IDENTIFIER_TYPE = STORAGE_IDENTIFIER_TYPE(6i32);
pub const StorageIdTypeMD5LogicalUnitIdentifier: STORAGE_IDENTIFIER_TYPE =
    STORAGE_IDENTIFIER_TYPE(7i32);
pub const StorageIdTypeScsiNameString: STORAGE_IDENTIFIER_TYPE = STORAGE_IDENTIFIER_TYPE(8i32);
impl ::std::convert::From<i32> for STORAGE_IDENTIFIER_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_IDENTIFIER_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_IDLE_POWER {
    pub Version: u32,
    pub Size: u32,
    pub _bitfield: u32,
    pub D3IdleTimeout: u32,
}
impl STORAGE_IDLE_POWER {}
impl ::std::default::Default for STORAGE_IDLE_POWER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_IDLE_POWER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_IDLE_POWER")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("_bitfield", &self._bitfield)
            .field("D3IdleTimeout", &self.D3IdleTimeout)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_IDLE_POWER {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self._bitfield == other._bitfield
            && self.D3IdleTimeout == other.D3IdleTimeout
    }
}
impl ::std::cmp::Eq for STORAGE_IDLE_POWER {}
unsafe impl ::windows::runtime::Abi for STORAGE_IDLE_POWER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_IDLE_POWERUP_REASON {
    pub Version: u32,
    pub Size: u32,
    pub PowerupReason: STORAGE_POWERUP_REASON_TYPE,
}
impl STORAGE_IDLE_POWERUP_REASON {}
impl ::std::default::Default for STORAGE_IDLE_POWERUP_REASON {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_IDLE_POWERUP_REASON {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_IDLE_POWERUP_REASON")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("PowerupReason", &self.PowerupReason)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_IDLE_POWERUP_REASON {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.PowerupReason == other.PowerupReason
    }
}
impl ::std::cmp::Eq for STORAGE_IDLE_POWERUP_REASON {}
unsafe impl ::windows::runtime::Abi for STORAGE_IDLE_POWERUP_REASON {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_IDLE_POWERUP_REASON_VERSION_V1: u32 = 1u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_ID_NAA_FORMAT(pub i32);
pub const StorageIdNAAFormatIEEEExtended: STORAGE_ID_NAA_FORMAT = STORAGE_ID_NAA_FORMAT(2i32);
pub const StorageIdNAAFormatIEEERegistered: STORAGE_ID_NAA_FORMAT = STORAGE_ID_NAA_FORMAT(3i32);
pub const StorageIdNAAFormatIEEEERegisteredExtended: STORAGE_ID_NAA_FORMAT =
    STORAGE_ID_NAA_FORMAT(5i32);
impl ::std::convert::From<i32> for STORAGE_ID_NAA_FORMAT {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_ID_NAA_FORMAT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_LB_PROVISIONING_MAP_RESOURCES {
    pub Size: u32,
    pub Version: u32,
    pub _bitfield1: u8,
    pub Reserved1: [u8; 3],
    pub _bitfield2: u8,
    pub Reserved3: [u8; 3],
    pub AvailableMappingResources: u64,
    pub UsedMappingResources: u64,
}
impl STORAGE_LB_PROVISIONING_MAP_RESOURCES {}
impl ::std::default::Default for STORAGE_LB_PROVISIONING_MAP_RESOURCES {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_LB_PROVISIONING_MAP_RESOURCES {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_LB_PROVISIONING_MAP_RESOURCES")
            .field("Size", &self.Size)
            .field("Version", &self.Version)
            .field("_bitfield1", &self._bitfield1)
            .field("Reserved1", &self.Reserved1)
            .field("_bitfield2", &self._bitfield2)
            .field("Reserved3", &self.Reserved3)
            .field("AvailableMappingResources", &self.AvailableMappingResources)
            .field("UsedMappingResources", &self.UsedMappingResources)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_LB_PROVISIONING_MAP_RESOURCES {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.Version == other.Version
            && self._bitfield1 == other._bitfield1
            && self.Reserved1 == other.Reserved1
            && self._bitfield2 == other._bitfield2
            && self.Reserved3 == other.Reserved3
            && self.AvailableMappingResources == other.AvailableMappingResources
            && self.UsedMappingResources == other.UsedMappingResources
    }
}
impl ::std::cmp::Eq for STORAGE_LB_PROVISIONING_MAP_RESOURCES {}
unsafe impl ::windows::runtime::Abi for STORAGE_LB_PROVISIONING_MAP_RESOURCES {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_MEDIA_SERIAL_NUMBER_DATA {
    pub Reserved: u16,
    pub SerialNumberLength: u16,
    pub SerialNumber: [u8; 1],
}
impl STORAGE_MEDIA_SERIAL_NUMBER_DATA {}
impl ::std::default::Default for STORAGE_MEDIA_SERIAL_NUMBER_DATA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_MEDIA_SERIAL_NUMBER_DATA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_MEDIA_SERIAL_NUMBER_DATA")
            .field("Reserved", &self.Reserved)
            .field("SerialNumberLength", &self.SerialNumberLength)
            .field("SerialNumber", &self.SerialNumber)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_MEDIA_SERIAL_NUMBER_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Reserved == other.Reserved
            && self.SerialNumberLength == other.SerialNumberLength
            && self.SerialNumber == other.SerialNumber
    }
}
impl ::std::cmp::Eq for STORAGE_MEDIA_SERIAL_NUMBER_DATA {}
unsafe impl ::windows::runtime::Abi for STORAGE_MEDIA_SERIAL_NUMBER_DATA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_MEDIA_TYPE(pub i32);
pub const DDS_4mm: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(32i32);
pub const MiniQic: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(33i32);
pub const Travan: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(34i32);
pub const QIC: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(35i32);
pub const MP_8mm: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(36i32);
pub const AME_8mm: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(37i32);
pub const AIT1_8mm: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(38i32);
pub const DLT: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(39i32);
pub const NCTP: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(40i32);
pub const IBM_3480: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(41i32);
pub const IBM_3490E: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(42i32);
pub const IBM_Magstar_3590: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(43i32);
pub const IBM_Magstar_MP: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(44i32);
pub const STK_DATA_D3: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(45i32);
pub const SONY_DTF: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(46i32);
pub const DV_6mm: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(47i32);
pub const DMI: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(48i32);
pub const SONY_D2: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(49i32);
pub const CLEANER_CARTRIDGE: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(50i32);
pub const CD_ROM: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(51i32);
pub const CD_R: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(52i32);
pub const CD_RW: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(53i32);
pub const DVD_ROM: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(54i32);
pub const DVD_R: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(55i32);
pub const DVD_RW: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(56i32);
pub const MO_3_RW: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(57i32);
pub const MO_5_WO: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(58i32);
pub const MO_5_RW: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(59i32);
pub const MO_5_LIMDOW: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(60i32);
pub const PC_5_WO: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(61i32);
pub const PC_5_RW: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(62i32);
pub const PD_5_RW: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(63i32);
pub const ABL_5_WO: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(64i32);
pub const PINNACLE_APEX_5_RW: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(65i32);
pub const SONY_12_WO: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(66i32);
pub const PHILIPS_12_WO: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(67i32);
pub const HITACHI_12_WO: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(68i32);
pub const CYGNET_12_WO: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(69i32);
pub const KODAK_14_WO: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(70i32);
pub const MO_NFR_525: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(71i32);
pub const NIKON_12_RW: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(72i32);
pub const IOMEGA_ZIP: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(73i32);
pub const IOMEGA_JAZ: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(74i32);
pub const SYQUEST_EZ135: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(75i32);
pub const SYQUEST_EZFLYER: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(76i32);
pub const SYQUEST_SYJET: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(77i32);
pub const AVATAR_F2: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(78i32);
pub const MP2_8mm: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(79i32);
pub const DST_S: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(80i32);
pub const DST_M: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(81i32);
pub const DST_L: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(82i32);
pub const VXATape_1: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(83i32);
pub const VXATape_2: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(84i32);
pub const STK_9840: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(85i32);
pub const LTO_Ultrium: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(86i32);
pub const LTO_Accelis: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(87i32);
pub const DVD_RAM: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(88i32);
pub const AIT_8mm: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(89i32);
pub const ADR_1: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(90i32);
pub const ADR_2: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(91i32);
pub const STK_9940: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(92i32);
pub const SAIT: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(93i32);
pub const VXATape: STORAGE_MEDIA_TYPE = STORAGE_MEDIA_TYPE(94i32);
impl ::std::convert::From<i32> for STORAGE_MEDIA_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_MEDIA_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_OFFLOAD_MAX_TOKEN_LENGTH: u32 = 512u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_OFFLOAD_READ_OUTPUT {
    pub OffloadReadFlags: u32,
    pub Reserved: u32,
    pub LengthProtected: u64,
    pub TokenLength: u32,
    pub Token: STORAGE_OFFLOAD_TOKEN,
}
impl STORAGE_OFFLOAD_READ_OUTPUT {}
impl ::std::default::Default for STORAGE_OFFLOAD_READ_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for STORAGE_OFFLOAD_READ_OUTPUT {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for STORAGE_OFFLOAD_READ_OUTPUT {}
unsafe impl ::windows::runtime::Abi for STORAGE_OFFLOAD_READ_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_OFFLOAD_READ_RANGE_TRUNCATED: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_OFFLOAD_TOKEN {
    pub TokenType: [u8; 4],
    pub Reserved: [u8; 2],
    pub TokenIdLength: [u8; 2],
    pub Anonymous: STORAGE_OFFLOAD_TOKEN_0,
}
impl STORAGE_OFFLOAD_TOKEN {}
impl ::std::default::Default for STORAGE_OFFLOAD_TOKEN {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for STORAGE_OFFLOAD_TOKEN {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for STORAGE_OFFLOAD_TOKEN {}
unsafe impl ::windows::runtime::Abi for STORAGE_OFFLOAD_TOKEN {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union STORAGE_OFFLOAD_TOKEN_0 {
    pub StorageOffloadZeroDataToken: STORAGE_OFFLOAD_TOKEN_0_0,
    pub Token: [u8; 504],
}
impl STORAGE_OFFLOAD_TOKEN_0 {}
impl ::std::default::Default for STORAGE_OFFLOAD_TOKEN_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for STORAGE_OFFLOAD_TOKEN_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for STORAGE_OFFLOAD_TOKEN_0 {}
unsafe impl ::windows::runtime::Abi for STORAGE_OFFLOAD_TOKEN_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_OFFLOAD_TOKEN_0_0 {
    pub Reserved2: [u8; 504],
}
impl STORAGE_OFFLOAD_TOKEN_0_0 {}
impl ::std::default::Default for STORAGE_OFFLOAD_TOKEN_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_OFFLOAD_TOKEN_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_StorageOffloadZeroDataToken_e__Struct")
            .field("Reserved2", &self.Reserved2)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_OFFLOAD_TOKEN_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Reserved2 == other.Reserved2
    }
}
impl ::std::cmp::Eq for STORAGE_OFFLOAD_TOKEN_0_0 {}
unsafe impl ::windows::runtime::Abi for STORAGE_OFFLOAD_TOKEN_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_OFFLOAD_TOKEN_ID_LENGTH: u32 = 504u32;
pub const STORAGE_OFFLOAD_TOKEN_INVALID: u32 = 2u32;
pub const STORAGE_OFFLOAD_TOKEN_TYPE_ZERO_DATA: u32 = 4294901761u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_OFFLOAD_WRITE_OUTPUT {
    pub OffloadWriteFlags: u32,
    pub Reserved: u32,
    pub LengthCopied: u64,
}
impl STORAGE_OFFLOAD_WRITE_OUTPUT {}
impl ::std::default::Default for STORAGE_OFFLOAD_WRITE_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_OFFLOAD_WRITE_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_OFFLOAD_WRITE_OUTPUT")
            .field("OffloadWriteFlags", &self.OffloadWriteFlags)
            .field("Reserved", &self.Reserved)
            .field("LengthCopied", &self.LengthCopied)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_OFFLOAD_WRITE_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.OffloadWriteFlags == other.OffloadWriteFlags
            && self.Reserved == other.Reserved
            && self.LengthCopied == other.LengthCopied
    }
}
impl ::std::cmp::Eq for STORAGE_OFFLOAD_WRITE_OUTPUT {}
unsafe impl ::windows::runtime::Abi for STORAGE_OFFLOAD_WRITE_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_OFFLOAD_WRITE_RANGE_TRUNCATED: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_OPERATIONAL_REASON {
    pub Version: u32,
    pub Size: u32,
    pub Reason: STORAGE_OPERATIONAL_STATUS_REASON,
    pub RawBytes: STORAGE_OPERATIONAL_REASON_0,
}
impl STORAGE_OPERATIONAL_REASON {}
impl ::std::default::Default for STORAGE_OPERATIONAL_REASON {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for STORAGE_OPERATIONAL_REASON {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for STORAGE_OPERATIONAL_REASON {}
unsafe impl ::windows::runtime::Abi for STORAGE_OPERATIONAL_REASON {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union STORAGE_OPERATIONAL_REASON_0 {
    pub ScsiSenseKey: STORAGE_OPERATIONAL_REASON_0_1,
    pub NVDIMM_N: STORAGE_OPERATIONAL_REASON_0_0,
    pub AsUlong: u32,
}
impl STORAGE_OPERATIONAL_REASON_0 {}
impl ::std::default::Default for STORAGE_OPERATIONAL_REASON_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for STORAGE_OPERATIONAL_REASON_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for STORAGE_OPERATIONAL_REASON_0 {}
unsafe impl ::windows::runtime::Abi for STORAGE_OPERATIONAL_REASON_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_OPERATIONAL_REASON_0_0 {
    pub CriticalHealth: u8,
    pub ModuleHealth: [u8; 2],
    pub ErrorThresholdStatus: u8,
}
impl STORAGE_OPERATIONAL_REASON_0_0 {}
impl ::std::default::Default for STORAGE_OPERATIONAL_REASON_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_OPERATIONAL_REASON_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_NVDIMM_N_e__Struct")
            .field("CriticalHealth", &self.CriticalHealth)
            .field("ModuleHealth", &self.ModuleHealth)
            .field("ErrorThresholdStatus", &self.ErrorThresholdStatus)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_OPERATIONAL_REASON_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.CriticalHealth == other.CriticalHealth
            && self.ModuleHealth == other.ModuleHealth
            && self.ErrorThresholdStatus == other.ErrorThresholdStatus
    }
}
impl ::std::cmp::Eq for STORAGE_OPERATIONAL_REASON_0_0 {}
unsafe impl ::windows::runtime::Abi for STORAGE_OPERATIONAL_REASON_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_OPERATIONAL_REASON_0_1 {
    pub SenseKey: u8,
    pub ASC: u8,
    pub ASCQ: u8,
    pub Reserved: u8,
}
impl STORAGE_OPERATIONAL_REASON_0_1 {}
impl ::std::default::Default for STORAGE_OPERATIONAL_REASON_0_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_OPERATIONAL_REASON_0_1 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_ScsiSenseKey_e__Struct")
            .field("SenseKey", &self.SenseKey)
            .field("ASC", &self.ASC)
            .field("ASCQ", &self.ASCQ)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_OPERATIONAL_REASON_0_1 {
    fn eq(&self, other: &Self) -> bool {
        self.SenseKey == other.SenseKey
            && self.ASC == other.ASC
            && self.ASCQ == other.ASCQ
            && self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for STORAGE_OPERATIONAL_REASON_0_1 {}
unsafe impl ::windows::runtime::Abi for STORAGE_OPERATIONAL_REASON_0_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_OPERATIONAL_STATUS_REASON(pub i32);
pub const DiskOpReasonUnknown: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(0i32);
pub const DiskOpReasonScsiSenseCode: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(1i32);
pub const DiskOpReasonMedia: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(2i32);
pub const DiskOpReasonIo: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(3i32);
pub const DiskOpReasonThresholdExceeded: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(4i32);
pub const DiskOpReasonLostData: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(5i32);
pub const DiskOpReasonEnergySource: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(6i32);
pub const DiskOpReasonConfiguration: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(7i32);
pub const DiskOpReasonDeviceController: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(8i32);
pub const DiskOpReasonMediaController: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(9i32);
pub const DiskOpReasonComponent: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(10i32);
pub const DiskOpReasonNVDIMM_N: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(11i32);
pub const DiskOpReasonBackgroundOperation: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(12i32);
pub const DiskOpReasonInvalidFirmware: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(13i32);
pub const DiskOpReasonHealthCheck: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(14i32);
pub const DiskOpReasonLostDataPersistence: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(15i32);
pub const DiskOpReasonDisabledByPlatform: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(16i32);
pub const DiskOpReasonLostWritePersistence: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(17i32);
pub const DiskOpReasonDataPersistenceLossImminent: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(18i32);
pub const DiskOpReasonWritePersistenceLossImminent: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(19i32);
pub const DiskOpReasonMax: STORAGE_OPERATIONAL_STATUS_REASON =
    STORAGE_OPERATIONAL_STATUS_REASON(20i32);
impl ::std::convert::From<i32> for STORAGE_OPERATIONAL_STATUS_REASON {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_OPERATIONAL_STATUS_REASON {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_POWERUP_REASON_TYPE(pub i32);
pub const StoragePowerupUnknown: STORAGE_POWERUP_REASON_TYPE = STORAGE_POWERUP_REASON_TYPE(0i32);
pub const StoragePowerupIO: STORAGE_POWERUP_REASON_TYPE = STORAGE_POWERUP_REASON_TYPE(1i32);
pub const StoragePowerupDeviceAttention: STORAGE_POWERUP_REASON_TYPE =
    STORAGE_POWERUP_REASON_TYPE(2i32);
impl ::std::convert::From<i32> for STORAGE_POWERUP_REASON_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_POWERUP_REASON_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_PREDICT_FAILURE {
    pub PredictFailure: u32,
    pub VendorSpecific: [u8; 512],
}
impl STORAGE_PREDICT_FAILURE {}
impl ::std::default::Default for STORAGE_PREDICT_FAILURE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_PREDICT_FAILURE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_PREDICT_FAILURE")
            .field("PredictFailure", &self.PredictFailure)
            .field("VendorSpecific", &self.VendorSpecific)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_PREDICT_FAILURE {
    fn eq(&self, other: &Self) -> bool {
        self.PredictFailure == other.PredictFailure && self.VendorSpecific == other.VendorSpecific
    }
}
impl ::std::cmp::Eq for STORAGE_PREDICT_FAILURE {}
unsafe impl ::windows::runtime::Abi for STORAGE_PREDICT_FAILURE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_PRIORITY_HINT_SUPPORT {
    pub SupportFlags: u32,
}
impl STORAGE_PRIORITY_HINT_SUPPORT {}
impl ::std::default::Default for STORAGE_PRIORITY_HINT_SUPPORT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_PRIORITY_HINT_SUPPORT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_PRIORITY_HINT_SUPPORT")
            .field("SupportFlags", &self.SupportFlags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_PRIORITY_HINT_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.SupportFlags == other.SupportFlags
    }
}
impl ::std::cmp::Eq for STORAGE_PRIORITY_HINT_SUPPORT {}
unsafe impl ::windows::runtime::Abi for STORAGE_PRIORITY_HINT_SUPPORT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_PRIORITY_HINT_SUPPORTED: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Storage_FileSystem")]
pub struct STORAGE_PROPERTY_SET {
    pub PropertyId: super::super::Storage::FileSystem::STORAGE_PROPERTY_ID,
    pub SetType: STORAGE_SET_TYPE,
    pub AdditionalParameters: [u8; 1],
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl STORAGE_PROPERTY_SET {}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::default::Default for STORAGE_PROPERTY_SET {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::fmt::Debug for STORAGE_PROPERTY_SET {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_PROPERTY_SET")
            .field("PropertyId", &self.PropertyId)
            .field("SetType", &self.SetType)
            .field("AdditionalParameters", &self.AdditionalParameters)
            .finish()
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::PartialEq for STORAGE_PROPERTY_SET {
    fn eq(&self, other: &Self) -> bool {
        self.PropertyId == other.PropertyId
            && self.SetType == other.SetType
            && self.AdditionalParameters == other.AdditionalParameters
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::Eq for STORAGE_PROPERTY_SET {}
#[cfg(feature = "Win32_Storage_FileSystem")]
unsafe impl ::windows::runtime::Abi for STORAGE_PROPERTY_SET {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_PROTOCOL_COMMAND_FLAG_ADAPTER_REQUEST: u32 = 2147483648u32;
pub const STORAGE_PROTOCOL_COMMAND_LENGTH_NVME: u32 = 64u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Storage_FileSystem")]
pub struct STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT {
    pub Version: u32,
    pub Size: u32,
    pub ProtocolSpecificData: STORAGE_PROTOCOL_SPECIFIC_DATA_EXT,
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT {}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::default::Default for STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::fmt::Debug for STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("ProtocolSpecificData", &self.ProtocolSpecificData)
            .finish()
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::PartialEq for STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.ProtocolSpecificData == other.ProtocolSpecificData
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::Eq for STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT {}
#[cfg(feature = "Win32_Storage_FileSystem")]
unsafe impl ::windows::runtime::Abi for STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE {
    pub Anonymous: STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE_0,
    pub AsUlong: u32,
}
impl STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE {}
impl ::std::default::Default for STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE {}
unsafe impl ::windows::runtime::Abi for STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE_0 {
    pub _bitfield: u32,
}
impl STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE_0 {}
impl ::std::default::Default for STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE_0 {}
unsafe impl ::windows::runtime::Abi for STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Storage_FileSystem")]
pub struct STORAGE_PROTOCOL_SPECIFIC_DATA_EXT {
    pub ProtocolType: super::super::Storage::FileSystem::STORAGE_PROTOCOL_TYPE,
    pub DataType: u32,
    pub ProtocolDataValue: u32,
    pub ProtocolDataSubValue: u32,
    pub ProtocolDataOffset: u32,
    pub ProtocolDataLength: u32,
    pub FixedProtocolReturnData: u32,
    pub ProtocolDataSubValue2: u32,
    pub ProtocolDataSubValue3: u32,
    pub ProtocolDataSubValue4: u32,
    pub ProtocolDataSubValue5: u32,
    pub Reserved: [u32; 5],
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl STORAGE_PROTOCOL_SPECIFIC_DATA_EXT {}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::default::Default for STORAGE_PROTOCOL_SPECIFIC_DATA_EXT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::fmt::Debug for STORAGE_PROTOCOL_SPECIFIC_DATA_EXT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_PROTOCOL_SPECIFIC_DATA_EXT")
            .field("ProtocolType", &self.ProtocolType)
            .field("DataType", &self.DataType)
            .field("ProtocolDataValue", &self.ProtocolDataValue)
            .field("ProtocolDataSubValue", &self.ProtocolDataSubValue)
            .field("ProtocolDataOffset", &self.ProtocolDataOffset)
            .field("ProtocolDataLength", &self.ProtocolDataLength)
            .field("FixedProtocolReturnData", &self.FixedProtocolReturnData)
            .field("ProtocolDataSubValue2", &self.ProtocolDataSubValue2)
            .field("ProtocolDataSubValue3", &self.ProtocolDataSubValue3)
            .field("ProtocolDataSubValue4", &self.ProtocolDataSubValue4)
            .field("ProtocolDataSubValue5", &self.ProtocolDataSubValue5)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::PartialEq for STORAGE_PROTOCOL_SPECIFIC_DATA_EXT {
    fn eq(&self, other: &Self) -> bool {
        self.ProtocolType == other.ProtocolType
            && self.DataType == other.DataType
            && self.ProtocolDataValue == other.ProtocolDataValue
            && self.ProtocolDataSubValue == other.ProtocolDataSubValue
            && self.ProtocolDataOffset == other.ProtocolDataOffset
            && self.ProtocolDataLength == other.ProtocolDataLength
            && self.FixedProtocolReturnData == other.FixedProtocolReturnData
            && self.ProtocolDataSubValue2 == other.ProtocolDataSubValue2
            && self.ProtocolDataSubValue3 == other.ProtocolDataSubValue3
            && self.ProtocolDataSubValue4 == other.ProtocolDataSubValue4
            && self.ProtocolDataSubValue5 == other.ProtocolDataSubValue5
            && self.Reserved == other.Reserved
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::Eq for STORAGE_PROTOCOL_SPECIFIC_DATA_EXT {}
#[cfg(feature = "Win32_Storage_FileSystem")]
unsafe impl ::windows::runtime::Abi for STORAGE_PROTOCOL_SPECIFIC_DATA_EXT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_PROTOCOL_SPECIFIC_NVME_ADMIN_COMMAND: u32 = 1u32;
pub const STORAGE_PROTOCOL_SPECIFIC_NVME_NVM_COMMAND: u32 = 2u32;
pub const STORAGE_PROTOCOL_STATUS_BUSY: u32 = 5u32;
pub const STORAGE_PROTOCOL_STATUS_DATA_OVERRUN: u32 = 6u32;
pub const STORAGE_PROTOCOL_STATUS_ERROR: u32 = 2u32;
pub const STORAGE_PROTOCOL_STATUS_INSUFFICIENT_RESOURCES: u32 = 7u32;
pub const STORAGE_PROTOCOL_STATUS_INVALID_REQUEST: u32 = 3u32;
pub const STORAGE_PROTOCOL_STATUS_NOT_SUPPORTED: u32 = 255u32;
pub const STORAGE_PROTOCOL_STATUS_NO_DEVICE: u32 = 4u32;
pub const STORAGE_PROTOCOL_STATUS_PENDING: u32 = 0u32;
pub const STORAGE_PROTOCOL_STATUS_SUCCESS: u32 = 1u32;
pub const STORAGE_PROTOCOL_STATUS_THROTTLED_REQUEST: u32 = 8u32;
pub const STORAGE_PROTOCOL_STRUCTURE_VERSION: u32 = 1u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_PROTOCOL_UFS_DATA_TYPE(pub i32);
pub const UfsDataTypeUnknown: STORAGE_PROTOCOL_UFS_DATA_TYPE = STORAGE_PROTOCOL_UFS_DATA_TYPE(0i32);
pub const UfsDataTypeQueryDescriptor: STORAGE_PROTOCOL_UFS_DATA_TYPE =
    STORAGE_PROTOCOL_UFS_DATA_TYPE(1i32);
pub const UfsDataTypeQueryAttribute: STORAGE_PROTOCOL_UFS_DATA_TYPE =
    STORAGE_PROTOCOL_UFS_DATA_TYPE(2i32);
pub const UfsDataTypeQueryFlag: STORAGE_PROTOCOL_UFS_DATA_TYPE =
    STORAGE_PROTOCOL_UFS_DATA_TYPE(3i32);
pub const UfsDataTypeQueryDmeAttribute: STORAGE_PROTOCOL_UFS_DATA_TYPE =
    STORAGE_PROTOCOL_UFS_DATA_TYPE(4i32);
pub const UfsDataTypeQueryDmePeerAttribute: STORAGE_PROTOCOL_UFS_DATA_TYPE =
    STORAGE_PROTOCOL_UFS_DATA_TYPE(5i32);
pub const UfsDataTypeMax: STORAGE_PROTOCOL_UFS_DATA_TYPE = STORAGE_PROTOCOL_UFS_DATA_TYPE(6i32);
impl ::std::convert::From<i32> for STORAGE_PROTOCOL_UFS_DATA_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_PROTOCOL_UFS_DATA_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Storage_Vhd")]
pub struct STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {
    pub EntryLength: u32,
    pub DependencyTypeFlags: u32,
    pub ProviderSpecificFlags: u32,
    pub VirtualStorageType: super::super::Storage::Vhd::VIRTUAL_STORAGE_TYPE,
}
#[cfg(feature = "Win32_Storage_Vhd")]
impl STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {}
#[cfg(feature = "Win32_Storage_Vhd")]
impl ::std::default::Default for STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Storage_Vhd")]
impl ::std::fmt::Debug for STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY")
            .field("EntryLength", &self.EntryLength)
            .field("DependencyTypeFlags", &self.DependencyTypeFlags)
            .field("ProviderSpecificFlags", &self.ProviderSpecificFlags)
            .field("VirtualStorageType", &self.VirtualStorageType)
            .finish()
    }
}
#[cfg(feature = "Win32_Storage_Vhd")]
impl ::std::cmp::PartialEq for STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.EntryLength == other.EntryLength
            && self.DependencyTypeFlags == other.DependencyTypeFlags
            && self.ProviderSpecificFlags == other.ProviderSpecificFlags
            && self.VirtualStorageType == other.VirtualStorageType
    }
}
#[cfg(feature = "Win32_Storage_Vhd")]
impl ::std::cmp::Eq for STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {}
#[cfg(feature = "Win32_Storage_Vhd")]
unsafe impl ::windows::runtime::Abi for STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Storage_Vhd")]
pub struct STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {
    pub EntryLength: u32,
    pub DependencyTypeFlags: u32,
    pub ProviderSpecificFlags: u32,
    pub VirtualStorageType: super::super::Storage::Vhd::VIRTUAL_STORAGE_TYPE,
    pub AncestorLevel: u32,
    pub HostVolumeNameOffset: u32,
    pub HostVolumeNameSize: u32,
    pub DependentVolumeNameOffset: u32,
    pub DependentVolumeNameSize: u32,
    pub RelativePathOffset: u32,
    pub RelativePathSize: u32,
    pub DependentDeviceNameOffset: u32,
    pub DependentDeviceNameSize: u32,
}
#[cfg(feature = "Win32_Storage_Vhd")]
impl STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {}
#[cfg(feature = "Win32_Storage_Vhd")]
impl ::std::default::Default for STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Storage_Vhd")]
impl ::std::fmt::Debug for STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY")
            .field("EntryLength", &self.EntryLength)
            .field("DependencyTypeFlags", &self.DependencyTypeFlags)
            .field("ProviderSpecificFlags", &self.ProviderSpecificFlags)
            .field("VirtualStorageType", &self.VirtualStorageType)
            .field("AncestorLevel", &self.AncestorLevel)
            .field("HostVolumeNameOffset", &self.HostVolumeNameOffset)
            .field("HostVolumeNameSize", &self.HostVolumeNameSize)
            .field("DependentVolumeNameOffset", &self.DependentVolumeNameOffset)
            .field("DependentVolumeNameSize", &self.DependentVolumeNameSize)
            .field("RelativePathOffset", &self.RelativePathOffset)
            .field("RelativePathSize", &self.RelativePathSize)
            .field("DependentDeviceNameOffset", &self.DependentDeviceNameOffset)
            .field("DependentDeviceNameSize", &self.DependentDeviceNameSize)
            .finish()
    }
}
#[cfg(feature = "Win32_Storage_Vhd")]
impl ::std::cmp::PartialEq for STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.EntryLength == other.EntryLength
            && self.DependencyTypeFlags == other.DependencyTypeFlags
            && self.ProviderSpecificFlags == other.ProviderSpecificFlags
            && self.VirtualStorageType == other.VirtualStorageType
            && self.AncestorLevel == other.AncestorLevel
            && self.HostVolumeNameOffset == other.HostVolumeNameOffset
            && self.HostVolumeNameSize == other.HostVolumeNameSize
            && self.DependentVolumeNameOffset == other.DependentVolumeNameOffset
            && self.DependentVolumeNameSize == other.DependentVolumeNameSize
            && self.RelativePathOffset == other.RelativePathOffset
            && self.RelativePathSize == other.RelativePathSize
            && self.DependentDeviceNameOffset == other.DependentDeviceNameOffset
            && self.DependentDeviceNameSize == other.DependentDeviceNameSize
    }
}
#[cfg(feature = "Win32_Storage_Vhd")]
impl ::std::cmp::Eq for STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {}
#[cfg(feature = "Win32_Storage_Vhd")]
unsafe impl ::windows::runtime::Abi for STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {
    pub RequestLevel: u32,
    pub RequestFlags: u32,
}
impl STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {}
impl ::std::default::Default for STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST")
            .field("RequestLevel", &self.RequestLevel)
            .field("RequestFlags", &self.RequestFlags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {
    fn eq(&self, other: &Self) -> bool {
        self.RequestLevel == other.RequestLevel && self.RequestFlags == other.RequestFlags
    }
}
impl ::std::cmp::Eq for STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {}
unsafe impl ::windows::runtime::Abi for STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Storage_Vhd")]
pub struct STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE {
    pub ResponseLevel: u32,
    pub NumberEntries: u32,
    pub Anonymous: STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE_0,
}
#[cfg(feature = "Win32_Storage_Vhd")]
impl STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE {}
#[cfg(feature = "Win32_Storage_Vhd")]
impl ::std::default::Default for STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Storage_Vhd")]
impl ::std::cmp::PartialEq for STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Storage_Vhd")]
impl ::std::cmp::Eq for STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE {}
#[cfg(feature = "Win32_Storage_Vhd")]
unsafe impl ::windows::runtime::Abi for STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Storage_Vhd")]
pub union STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE_0 {
    pub Lev1Depends: [STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY; 1],
    pub Lev2Depends: [STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY; 1],
}
#[cfg(feature = "Win32_Storage_Vhd")]
impl STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE_0 {}
#[cfg(feature = "Win32_Storage_Vhd")]
impl ::std::default::Default for STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Storage_Vhd")]
impl ::std::cmp::PartialEq for STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Storage_Vhd")]
impl ::std::cmp::Eq for STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE_0 {}
#[cfg(feature = "Win32_Storage_Vhd")]
unsafe impl ::windows::runtime::Abi for STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_READ_CAPACITY {
    pub Version: u32,
    pub Size: u32,
    pub BlockLength: u32,
    pub NumberOfBlocks: i64,
    pub DiskLength: i64,
}
impl STORAGE_READ_CAPACITY {}
impl ::std::default::Default for STORAGE_READ_CAPACITY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_READ_CAPACITY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_READ_CAPACITY")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("BlockLength", &self.BlockLength)
            .field("NumberOfBlocks", &self.NumberOfBlocks)
            .field("DiskLength", &self.DiskLength)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_READ_CAPACITY {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.BlockLength == other.BlockLength
            && self.NumberOfBlocks == other.NumberOfBlocks
            && self.DiskLength == other.DiskLength
    }
}
impl ::std::cmp::Eq for STORAGE_READ_CAPACITY {}
unsafe impl ::windows::runtime::Abi for STORAGE_READ_CAPACITY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_REINITIALIZE_MEDIA {
    pub Version: u32,
    pub Size: u32,
    pub TimeoutInSeconds: u32,
    pub SanitizeOption: STORAGE_REINITIALIZE_MEDIA_0,
}
impl STORAGE_REINITIALIZE_MEDIA {}
impl ::std::default::Default for STORAGE_REINITIALIZE_MEDIA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_REINITIALIZE_MEDIA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_REINITIALIZE_MEDIA")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("TimeoutInSeconds", &self.TimeoutInSeconds)
            .field("SanitizeOption", &self.SanitizeOption)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_REINITIALIZE_MEDIA {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.TimeoutInSeconds == other.TimeoutInSeconds
            && self.SanitizeOption == other.SanitizeOption
    }
}
impl ::std::cmp::Eq for STORAGE_REINITIALIZE_MEDIA {}
unsafe impl ::windows::runtime::Abi for STORAGE_REINITIALIZE_MEDIA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_REINITIALIZE_MEDIA_0 {
    pub _bitfield: u32,
}
impl STORAGE_REINITIALIZE_MEDIA_0 {}
impl ::std::default::Default for STORAGE_REINITIALIZE_MEDIA_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_REINITIALIZE_MEDIA_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_SanitizeOption_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_REINITIALIZE_MEDIA_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for STORAGE_REINITIALIZE_MEDIA_0 {}
unsafe impl ::windows::runtime::Abi for STORAGE_REINITIALIZE_MEDIA_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_RESERVE_ID(pub i32);
pub const StorageReserveIdNone: STORAGE_RESERVE_ID = STORAGE_RESERVE_ID(0i32);
pub const StorageReserveIdHard: STORAGE_RESERVE_ID = STORAGE_RESERVE_ID(1i32);
pub const StorageReserveIdSoft: STORAGE_RESERVE_ID = STORAGE_RESERVE_ID(2i32);
pub const StorageReserveIdUpdateScratch: STORAGE_RESERVE_ID = STORAGE_RESERVE_ID(3i32);
pub const StorageReserveIdMax: STORAGE_RESERVE_ID = STORAGE_RESERVE_ID(4i32);
impl ::std::convert::From<i32> for STORAGE_RESERVE_ID {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_RESERVE_ID {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_RPMB_COMMAND_TYPE(pub i32);
pub const StorRpmbProgramAuthKey: STORAGE_RPMB_COMMAND_TYPE = STORAGE_RPMB_COMMAND_TYPE(1i32);
pub const StorRpmbQueryWriteCounter: STORAGE_RPMB_COMMAND_TYPE = STORAGE_RPMB_COMMAND_TYPE(2i32);
pub const StorRpmbAuthenticatedWrite: STORAGE_RPMB_COMMAND_TYPE = STORAGE_RPMB_COMMAND_TYPE(3i32);
pub const StorRpmbAuthenticatedRead: STORAGE_RPMB_COMMAND_TYPE = STORAGE_RPMB_COMMAND_TYPE(4i32);
pub const StorRpmbReadResultRequest: STORAGE_RPMB_COMMAND_TYPE = STORAGE_RPMB_COMMAND_TYPE(5i32);
pub const StorRpmbAuthenticatedDeviceConfigWrite: STORAGE_RPMB_COMMAND_TYPE =
    STORAGE_RPMB_COMMAND_TYPE(6i32);
pub const StorRpmbAuthenticatedDeviceConfigRead: STORAGE_RPMB_COMMAND_TYPE =
    STORAGE_RPMB_COMMAND_TYPE(7i32);
impl ::std::convert::From<i32> for STORAGE_RPMB_COMMAND_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_RPMB_COMMAND_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_RPMB_DATA_FRAME {
    pub Stuff: [u8; 196],
    pub KeyOrMAC: [u8; 32],
    pub Data: [u8; 256],
    pub Nonce: [u8; 16],
    pub WriteCounter: [u8; 4],
    pub Address: [u8; 2],
    pub BlockCount: [u8; 2],
    pub OperationResult: [u8; 2],
    pub RequestOrResponseType: [u8; 2],
}
impl STORAGE_RPMB_DATA_FRAME {}
impl ::std::default::Default for STORAGE_RPMB_DATA_FRAME {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_RPMB_DATA_FRAME {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_RPMB_DATA_FRAME")
            .field("Stuff", &self.Stuff)
            .field("KeyOrMAC", &self.KeyOrMAC)
            .field("Data", &self.Data)
            .field("Nonce", &self.Nonce)
            .field("WriteCounter", &self.WriteCounter)
            .field("Address", &self.Address)
            .field("BlockCount", &self.BlockCount)
            .field("OperationResult", &self.OperationResult)
            .field("RequestOrResponseType", &self.RequestOrResponseType)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_RPMB_DATA_FRAME {
    fn eq(&self, other: &Self) -> bool {
        self.Stuff == other.Stuff
            && self.KeyOrMAC == other.KeyOrMAC
            && self.Data == other.Data
            && self.Nonce == other.Nonce
            && self.WriteCounter == other.WriteCounter
            && self.Address == other.Address
            && self.BlockCount == other.BlockCount
            && self.OperationResult == other.OperationResult
            && self.RequestOrResponseType == other.RequestOrResponseType
    }
}
impl ::std::cmp::Eq for STORAGE_RPMB_DATA_FRAME {}
unsafe impl ::windows::runtime::Abi for STORAGE_RPMB_DATA_FRAME {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_RPMB_DESCRIPTOR {
    pub Version: u32,
    pub Size: u32,
    pub SizeInBytes: u32,
    pub MaxReliableWriteSizeInBytes: u32,
    pub FrameFormat: STORAGE_RPMB_FRAME_TYPE,
}
impl STORAGE_RPMB_DESCRIPTOR {}
impl ::std::default::Default for STORAGE_RPMB_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_RPMB_DESCRIPTOR {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_RPMB_DESCRIPTOR")
            .field("Version", &self.Version)
            .field("Size", &self.Size)
            .field("SizeInBytes", &self.SizeInBytes)
            .field(
                "MaxReliableWriteSizeInBytes",
                &self.MaxReliableWriteSizeInBytes,
            )
            .field("FrameFormat", &self.FrameFormat)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_RPMB_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Size == other.Size
            && self.SizeInBytes == other.SizeInBytes
            && self.MaxReliableWriteSizeInBytes == other.MaxReliableWriteSizeInBytes
            && self.FrameFormat == other.FrameFormat
    }
}
impl ::std::cmp::Eq for STORAGE_RPMB_DESCRIPTOR {}
unsafe impl ::windows::runtime::Abi for STORAGE_RPMB_DESCRIPTOR {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_RPMB_DESCRIPTOR_VERSION_1: u32 = 1u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_RPMB_FRAME_TYPE(pub i32);
pub const StorageRpmbFrameTypeUnknown: STORAGE_RPMB_FRAME_TYPE = STORAGE_RPMB_FRAME_TYPE(0i32);
pub const StorageRpmbFrameTypeStandard: STORAGE_RPMB_FRAME_TYPE = STORAGE_RPMB_FRAME_TYPE(1i32);
pub const StorageRpmbFrameTypeMax: STORAGE_RPMB_FRAME_TYPE = STORAGE_RPMB_FRAME_TYPE(2i32);
impl ::std::convert::From<i32> for STORAGE_RPMB_FRAME_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_RPMB_FRAME_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_RPMB_MINIMUM_RELIABLE_WRITE_SIZE: u32 = 512u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_SANITIZE_METHOD(pub i32);
pub const StorageSanitizeMethodDefault: STORAGE_SANITIZE_METHOD = STORAGE_SANITIZE_METHOD(0i32);
pub const StorageSanitizeMethodBlockErase: STORAGE_SANITIZE_METHOD = STORAGE_SANITIZE_METHOD(1i32);
pub const StorageSanitizeMethodCryptoErase: STORAGE_SANITIZE_METHOD = STORAGE_SANITIZE_METHOD(2i32);
impl ::std::convert::From<i32> for STORAGE_SANITIZE_METHOD {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_SANITIZE_METHOD {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_SET_TYPE(pub i32);
pub const PropertyStandardSet: STORAGE_SET_TYPE = STORAGE_SET_TYPE(0i32);
pub const PropertyExistsSet: STORAGE_SET_TYPE = STORAGE_SET_TYPE(1i32);
pub const PropertySetMaxDefined: STORAGE_SET_TYPE = STORAGE_SET_TYPE(2i32);
impl ::std::convert::From<i32> for STORAGE_SET_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_SET_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_SUPPORTED_FEATURES_BYPASS_IO: u32 = 1u32;
pub const STORAGE_SUPPORTED_FEATURES_MASK: u32 = 1u32;
pub const STORAGE_TEMPERATURE_THRESHOLD_FLAG_ADAPTER_REQUEST: u32 = 1u32;
pub const STORAGE_TEMPERATURE_VALUE_NOT_REPORTED: u32 = 32768u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_TIER {
    pub Id: ::windows::runtime::GUID,
    pub Name: [u16; 256],
    pub Description: [u16; 256],
    pub Flags: u64,
    pub ProvisionedCapacity: u64,
    pub MediaType: STORAGE_TIER_MEDIA_TYPE,
    pub Class: STORAGE_TIER_CLASS,
}
impl STORAGE_TIER {}
impl ::std::default::Default for STORAGE_TIER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_TIER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_TIER")
            .field("Id", &self.Id)
            .field("Name", &self.Name)
            .field("Description", &self.Description)
            .field("Flags", &self.Flags)
            .field("ProvisionedCapacity", &self.ProvisionedCapacity)
            .field("MediaType", &self.MediaType)
            .field("Class", &self.Class)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_TIER {
    fn eq(&self, other: &Self) -> bool {
        self.Id == other.Id
            && self.Name == other.Name
            && self.Description == other.Description
            && self.Flags == other.Flags
            && self.ProvisionedCapacity == other.ProvisionedCapacity
            && self.MediaType == other.MediaType
            && self.Class == other.Class
    }
}
impl ::std::cmp::Eq for STORAGE_TIER {}
unsafe impl ::windows::runtime::Abi for STORAGE_TIER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_TIER_CLASS(pub i32);
pub const StorageTierClassUnspecified: STORAGE_TIER_CLASS = STORAGE_TIER_CLASS(0i32);
pub const StorageTierClassCapacity: STORAGE_TIER_CLASS = STORAGE_TIER_CLASS(1i32);
pub const StorageTierClassPerformance: STORAGE_TIER_CLASS = STORAGE_TIER_CLASS(2i32);
pub const StorageTierClassMax: STORAGE_TIER_CLASS = STORAGE_TIER_CLASS(3i32);
impl ::std::convert::From<i32> for STORAGE_TIER_CLASS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_TIER_CLASS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_TIER_DESCRIPTION_LENGTH: u32 = 512u32;
pub const STORAGE_TIER_FLAG_NO_SEEK_PENALTY: u32 = 131072u32;
pub const STORAGE_TIER_FLAG_PARITY: u32 = 8388608u32;
pub const STORAGE_TIER_FLAG_READ_CACHE: u32 = 4194304u32;
pub const STORAGE_TIER_FLAG_SMR: u32 = 16777216u32;
pub const STORAGE_TIER_FLAG_WRITE_BACK_CACHE: u32 = 2097152u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_TIER_MEDIA_TYPE(pub i32);
pub const StorageTierMediaTypeUnspecified: STORAGE_TIER_MEDIA_TYPE = STORAGE_TIER_MEDIA_TYPE(0i32);
pub const StorageTierMediaTypeDisk: STORAGE_TIER_MEDIA_TYPE = STORAGE_TIER_MEDIA_TYPE(1i32);
pub const StorageTierMediaTypeSsd: STORAGE_TIER_MEDIA_TYPE = STORAGE_TIER_MEDIA_TYPE(2i32);
pub const StorageTierMediaTypeScm: STORAGE_TIER_MEDIA_TYPE = STORAGE_TIER_MEDIA_TYPE(4i32);
pub const StorageTierMediaTypeMax: STORAGE_TIER_MEDIA_TYPE = STORAGE_TIER_MEDIA_TYPE(5i32);
impl ::std::convert::From<i32> for STORAGE_TIER_MEDIA_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_TIER_MEDIA_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORAGE_TIER_NAME_LENGTH: u32 = 256u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_TIER_REGION {
    pub TierId: ::windows::runtime::GUID,
    pub Offset: u64,
    pub Length: u64,
}
impl STORAGE_TIER_REGION {}
impl ::std::default::Default for STORAGE_TIER_REGION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_TIER_REGION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_TIER_REGION")
            .field("TierId", &self.TierId)
            .field("Offset", &self.Offset)
            .field("Length", &self.Length)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_TIER_REGION {
    fn eq(&self, other: &Self) -> bool {
        self.TierId == other.TierId && self.Offset == other.Offset && self.Length == other.Length
    }
}
impl ::std::cmp::Eq for STORAGE_TIER_REGION {}
unsafe impl ::windows::runtime::Abi for STORAGE_TIER_REGION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct STORAGE_ZONED_DEVICE_DESCRIPTOR {
    pub Version: u32,
    pub Size: u32,
    pub DeviceType: STORAGE_ZONED_DEVICE_TYPES,
    pub ZoneCount: u32,
    pub ZoneAttributes: STORAGE_ZONED_DEVICE_DESCRIPTOR_0,
    pub ZoneGroupCount: u32,
    pub ZoneGroup: [STORAGE_ZONE_GROUP; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl STORAGE_ZONED_DEVICE_DESCRIPTOR {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for STORAGE_ZONED_DEVICE_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for STORAGE_ZONED_DEVICE_DESCRIPTOR {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for STORAGE_ZONED_DEVICE_DESCRIPTOR {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for STORAGE_ZONED_DEVICE_DESCRIPTOR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub union STORAGE_ZONED_DEVICE_DESCRIPTOR_0 {
    pub SequentialRequiredZone: STORAGE_ZONED_DEVICE_DESCRIPTOR_0_1,
    pub SequentialPreferredZone: STORAGE_ZONED_DEVICE_DESCRIPTOR_0_0,
}
#[cfg(feature = "Win32_Foundation")]
impl STORAGE_ZONED_DEVICE_DESCRIPTOR_0 {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for STORAGE_ZONED_DEVICE_DESCRIPTOR_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for STORAGE_ZONED_DEVICE_DESCRIPTOR_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for STORAGE_ZONED_DEVICE_DESCRIPTOR_0 {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for STORAGE_ZONED_DEVICE_DESCRIPTOR_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_ZONED_DEVICE_DESCRIPTOR_0_0 {
    pub OptimalOpenZoneCount: u32,
    pub Reserved: u32,
}
impl STORAGE_ZONED_DEVICE_DESCRIPTOR_0_0 {}
impl ::std::default::Default for STORAGE_ZONED_DEVICE_DESCRIPTOR_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_ZONED_DEVICE_DESCRIPTOR_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_SequentialPreferredZone_e__Struct")
            .field("OptimalOpenZoneCount", &self.OptimalOpenZoneCount)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_ZONED_DEVICE_DESCRIPTOR_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.OptimalOpenZoneCount == other.OptimalOpenZoneCount && self.Reserved == other.Reserved
    }
}
impl ::std::cmp::Eq for STORAGE_ZONED_DEVICE_DESCRIPTOR_0_0 {}
unsafe impl ::windows::runtime::Abi for STORAGE_ZONED_DEVICE_DESCRIPTOR_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct STORAGE_ZONED_DEVICE_DESCRIPTOR_0_1 {
    pub MaxOpenZoneCount: u32,
    pub UnrestrictedRead: super::super::Foundation::BOOLEAN,
    pub Reserved: [u8; 3],
}
#[cfg(feature = "Win32_Foundation")]
impl STORAGE_ZONED_DEVICE_DESCRIPTOR_0_1 {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for STORAGE_ZONED_DEVICE_DESCRIPTOR_0_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for STORAGE_ZONED_DEVICE_DESCRIPTOR_0_1 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_SequentialRequiredZone_e__Struct")
            .field("MaxOpenZoneCount", &self.MaxOpenZoneCount)
            .field("UnrestrictedRead", &self.UnrestrictedRead)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for STORAGE_ZONED_DEVICE_DESCRIPTOR_0_1 {
    fn eq(&self, other: &Self) -> bool {
        self.MaxOpenZoneCount == other.MaxOpenZoneCount
            && self.UnrestrictedRead == other.UnrestrictedRead
            && self.Reserved == other.Reserved
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for STORAGE_ZONED_DEVICE_DESCRIPTOR_0_1 {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for STORAGE_ZONED_DEVICE_DESCRIPTOR_0_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_ZONED_DEVICE_TYPES(pub i32);
pub const ZonedDeviceTypeUnknown: STORAGE_ZONED_DEVICE_TYPES = STORAGE_ZONED_DEVICE_TYPES(0i32);
pub const ZonedDeviceTypeHostManaged: STORAGE_ZONED_DEVICE_TYPES = STORAGE_ZONED_DEVICE_TYPES(1i32);
pub const ZonedDeviceTypeHostAware: STORAGE_ZONED_DEVICE_TYPES = STORAGE_ZONED_DEVICE_TYPES(2i32);
pub const ZonedDeviceTypeDeviceManaged: STORAGE_ZONED_DEVICE_TYPES =
    STORAGE_ZONED_DEVICE_TYPES(3i32);
impl ::std::convert::From<i32> for STORAGE_ZONED_DEVICE_TYPES {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_ZONED_DEVICE_TYPES {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_ZONES_ATTRIBUTES(pub i32);
pub const ZonesAttributeTypeAndLengthMayDifferent: STORAGE_ZONES_ATTRIBUTES =
    STORAGE_ZONES_ATTRIBUTES(0i32);
pub const ZonesAttributeTypeSameLengthSame: STORAGE_ZONES_ATTRIBUTES =
    STORAGE_ZONES_ATTRIBUTES(1i32);
pub const ZonesAttributeTypeSameLastZoneLengthDifferent: STORAGE_ZONES_ATTRIBUTES =
    STORAGE_ZONES_ATTRIBUTES(2i32);
pub const ZonesAttributeTypeMayDifferentLengthSame: STORAGE_ZONES_ATTRIBUTES =
    STORAGE_ZONES_ATTRIBUTES(3i32);
impl ::std::convert::From<i32> for STORAGE_ZONES_ATTRIBUTES {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_ZONES_ATTRIBUTES {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_ZONE_CONDITION(pub i32);
pub const ZoneConditionConventional: STORAGE_ZONE_CONDITION = STORAGE_ZONE_CONDITION(0i32);
pub const ZoneConditionEmpty: STORAGE_ZONE_CONDITION = STORAGE_ZONE_CONDITION(1i32);
pub const ZoneConditionImplicitlyOpened: STORAGE_ZONE_CONDITION = STORAGE_ZONE_CONDITION(2i32);
pub const ZoneConditionExplicitlyOpened: STORAGE_ZONE_CONDITION = STORAGE_ZONE_CONDITION(3i32);
pub const ZoneConditionClosed: STORAGE_ZONE_CONDITION = STORAGE_ZONE_CONDITION(4i32);
pub const ZoneConditionReadOnly: STORAGE_ZONE_CONDITION = STORAGE_ZONE_CONDITION(13i32);
pub const ZoneConditionFull: STORAGE_ZONE_CONDITION = STORAGE_ZONE_CONDITION(14i32);
pub const ZoneConditionOffline: STORAGE_ZONE_CONDITION = STORAGE_ZONE_CONDITION(15i32);
impl ::std::convert::From<i32> for STORAGE_ZONE_CONDITION {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_ZONE_CONDITION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct STORAGE_ZONE_DESCRIPTOR {
    pub Size: u32,
    pub ZoneType: STORAGE_ZONE_TYPES,
    pub ZoneCondition: STORAGE_ZONE_CONDITION,
    pub ResetWritePointerRecommend: super::super::Foundation::BOOLEAN,
    pub Reserved0: [u8; 3],
    pub ZoneSize: u64,
    pub WritePointerOffset: u64,
}
#[cfg(feature = "Win32_Foundation")]
impl STORAGE_ZONE_DESCRIPTOR {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for STORAGE_ZONE_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for STORAGE_ZONE_DESCRIPTOR {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_ZONE_DESCRIPTOR")
            .field("Size", &self.Size)
            .field("ZoneType", &self.ZoneType)
            .field("ZoneCondition", &self.ZoneCondition)
            .field(
                "ResetWritePointerRecommend",
                &self.ResetWritePointerRecommend,
            )
            .field("Reserved0", &self.Reserved0)
            .field("ZoneSize", &self.ZoneSize)
            .field("WritePointerOffset", &self.WritePointerOffset)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for STORAGE_ZONE_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.ZoneType == other.ZoneType
            && self.ZoneCondition == other.ZoneCondition
            && self.ResetWritePointerRecommend == other.ResetWritePointerRecommend
            && self.Reserved0 == other.Reserved0
            && self.ZoneSize == other.ZoneSize
            && self.WritePointerOffset == other.WritePointerOffset
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for STORAGE_ZONE_DESCRIPTOR {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for STORAGE_ZONE_DESCRIPTOR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STORAGE_ZONE_GROUP {
    pub ZoneCount: u32,
    pub ZoneType: STORAGE_ZONE_TYPES,
    pub ZoneSize: u64,
}
impl STORAGE_ZONE_GROUP {}
impl ::std::default::Default for STORAGE_ZONE_GROUP {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STORAGE_ZONE_GROUP {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STORAGE_ZONE_GROUP")
            .field("ZoneCount", &self.ZoneCount)
            .field("ZoneType", &self.ZoneType)
            .field("ZoneSize", &self.ZoneSize)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STORAGE_ZONE_GROUP {
    fn eq(&self, other: &Self) -> bool {
        self.ZoneCount == other.ZoneCount
            && self.ZoneType == other.ZoneType
            && self.ZoneSize == other.ZoneSize
    }
}
impl ::std::cmp::Eq for STORAGE_ZONE_GROUP {}
unsafe impl ::windows::runtime::Abi for STORAGE_ZONE_GROUP {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct STORAGE_ZONE_TYPES(pub i32);
pub const ZoneTypeUnknown: STORAGE_ZONE_TYPES = STORAGE_ZONE_TYPES(0i32);
pub const ZoneTypeConventional: STORAGE_ZONE_TYPES = STORAGE_ZONE_TYPES(1i32);
pub const ZoneTypeSequentialWriteRequired: STORAGE_ZONE_TYPES = STORAGE_ZONE_TYPES(2i32);
pub const ZoneTypeSequentialWritePreferred: STORAGE_ZONE_TYPES = STORAGE_ZONE_TYPES(3i32);
pub const ZoneTypeMax: STORAGE_ZONE_TYPES = STORAGE_ZONE_TYPES(4i32);
impl ::std::convert::From<i32> for STORAGE_ZONE_TYPES {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for STORAGE_ZONE_TYPES {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STORATTRIBUTE_MANAGEMENT_STATE: u32 = 1u32;
pub const STORATTRIBUTE_NONE: u32 = 0u32;
pub const STREAMS_ASSOCIATE_ID_CLEAR: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STREAMS_ASSOCIATE_ID_INPUT_BUFFER {
    pub Flags: u32,
    pub StreamId: u32,
}
impl STREAMS_ASSOCIATE_ID_INPUT_BUFFER {}
impl ::std::default::Default for STREAMS_ASSOCIATE_ID_INPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STREAMS_ASSOCIATE_ID_INPUT_BUFFER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STREAMS_ASSOCIATE_ID_INPUT_BUFFER")
            .field("Flags", &self.Flags)
            .field("StreamId", &self.StreamId)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STREAMS_ASSOCIATE_ID_INPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags && self.StreamId == other.StreamId
    }
}
impl ::std::cmp::Eq for STREAMS_ASSOCIATE_ID_INPUT_BUFFER {}
unsafe impl ::windows::runtime::Abi for STREAMS_ASSOCIATE_ID_INPUT_BUFFER {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STREAMS_ASSOCIATE_ID_SET: u32 = 2u32;
pub const STREAMS_INVALID_ID: u32 = 0u32;
pub const STREAMS_MAX_ID: u32 = 65535u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STREAMS_QUERY_ID_OUTPUT_BUFFER {
    pub StreamId: u32,
}
impl STREAMS_QUERY_ID_OUTPUT_BUFFER {}
impl ::std::default::Default for STREAMS_QUERY_ID_OUTPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STREAMS_QUERY_ID_OUTPUT_BUFFER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STREAMS_QUERY_ID_OUTPUT_BUFFER")
            .field("StreamId", &self.StreamId)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STREAMS_QUERY_ID_OUTPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.StreamId == other.StreamId
    }
}
impl ::std::cmp::Eq for STREAMS_QUERY_ID_OUTPUT_BUFFER {}
unsafe impl ::windows::runtime::Abi for STREAMS_QUERY_ID_OUTPUT_BUFFER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {
    pub OptimalWriteSize: u32,
    pub StreamGranularitySize: u32,
    pub StreamIdMin: u32,
    pub StreamIdMax: u32,
}
impl STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {}
impl ::std::default::Default for STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER")
            .field("OptimalWriteSize", &self.OptimalWriteSize)
            .field("StreamGranularitySize", &self.StreamGranularitySize)
            .field("StreamIdMin", &self.StreamIdMin)
            .field("StreamIdMax", &self.StreamIdMax)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.OptimalWriteSize == other.OptimalWriteSize
            && self.StreamGranularitySize == other.StreamGranularitySize
            && self.StreamIdMin == other.StreamIdMin
            && self.StreamIdMax == other.StreamIdMax
    }
}
impl ::std::cmp::Eq for STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {}
unsafe impl ::windows::runtime::Abi for STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STREAM_CLEAR_ENCRYPTION: u32 = 4u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Storage_FileSystem")]
pub struct STREAM_EXTENT_ENTRY {
    pub Flags: u32,
    pub ExtentInformation: STREAM_EXTENT_ENTRY_0,
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl STREAM_EXTENT_ENTRY {}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::default::Default for STREAM_EXTENT_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::PartialEq for STREAM_EXTENT_ENTRY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::Eq for STREAM_EXTENT_ENTRY {}
#[cfg(feature = "Win32_Storage_FileSystem")]
unsafe impl ::windows::runtime::Abi for STREAM_EXTENT_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Storage_FileSystem")]
pub union STREAM_EXTENT_ENTRY_0 {
    pub RetrievalPointers: super::super::Storage::FileSystem::RETRIEVAL_POINTERS_BUFFER,
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl STREAM_EXTENT_ENTRY_0 {}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::default::Default for STREAM_EXTENT_ENTRY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::PartialEq for STREAM_EXTENT_ENTRY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::Eq for STREAM_EXTENT_ENTRY_0 {}
#[cfg(feature = "Win32_Storage_FileSystem")]
unsafe impl ::windows::runtime::Abi for STREAM_EXTENT_ENTRY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STREAM_EXTENT_ENTRY_ALL_EXTENTS: u32 = 2u32;
pub const STREAM_EXTENT_ENTRY_AS_RETRIEVAL_POINTERS: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STREAM_INFORMATION_ENTRY {
    pub Version: u32,
    pub Flags: u32,
    pub StreamInformation: STREAM_INFORMATION_ENTRY_0,
}
impl STREAM_INFORMATION_ENTRY {}
impl ::std::default::Default for STREAM_INFORMATION_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for STREAM_INFORMATION_ENTRY {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for STREAM_INFORMATION_ENTRY {}
unsafe impl ::windows::runtime::Abi for STREAM_INFORMATION_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union STREAM_INFORMATION_ENTRY_0 {
    pub DesiredStorageClass: STREAM_INFORMATION_ENTRY_0_1,
    pub DataStream: STREAM_INFORMATION_ENTRY_0_0,
    pub Reparse: STREAM_INFORMATION_ENTRY_0_3,
    pub Ea: STREAM_INFORMATION_ENTRY_0_2,
}
impl STREAM_INFORMATION_ENTRY_0 {}
impl ::std::default::Default for STREAM_INFORMATION_ENTRY_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for STREAM_INFORMATION_ENTRY_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for STREAM_INFORMATION_ENTRY_0 {}
unsafe impl ::windows::runtime::Abi for STREAM_INFORMATION_ENTRY_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STREAM_INFORMATION_ENTRY_0_0 {
    pub Length: u16,
    pub Flags: u16,
    pub Reserved: u32,
    pub Vdl: u64,
}
impl STREAM_INFORMATION_ENTRY_0_0 {}
impl ::std::default::Default for STREAM_INFORMATION_ENTRY_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STREAM_INFORMATION_ENTRY_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_DataStream")
            .field("Length", &self.Length)
            .field("Flags", &self.Flags)
            .field("Reserved", &self.Reserved)
            .field("Vdl", &self.Vdl)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STREAM_INFORMATION_ENTRY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Length == other.Length
            && self.Flags == other.Flags
            && self.Reserved == other.Reserved
            && self.Vdl == other.Vdl
    }
}
impl ::std::cmp::Eq for STREAM_INFORMATION_ENTRY_0_0 {}
unsafe impl ::windows::runtime::Abi for STREAM_INFORMATION_ENTRY_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STREAM_INFORMATION_ENTRY_0_1 {
    pub Class: FILE_STORAGE_TIER_CLASS,
    pub Flags: u32,
}
impl STREAM_INFORMATION_ENTRY_0_1 {}
impl ::std::default::Default for STREAM_INFORMATION_ENTRY_0_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STREAM_INFORMATION_ENTRY_0_1 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_DesiredStorageClass")
            .field("Class", &self.Class)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STREAM_INFORMATION_ENTRY_0_1 {
    fn eq(&self, other: &Self) -> bool {
        self.Class == other.Class && self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for STREAM_INFORMATION_ENTRY_0_1 {}
unsafe impl ::windows::runtime::Abi for STREAM_INFORMATION_ENTRY_0_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STREAM_INFORMATION_ENTRY_0_2 {
    pub Length: u16,
    pub Flags: u16,
    pub EaSize: u32,
    pub EaInformationOffset: u32,
}
impl STREAM_INFORMATION_ENTRY_0_2 {}
impl ::std::default::Default for STREAM_INFORMATION_ENTRY_0_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STREAM_INFORMATION_ENTRY_0_2 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Ea")
            .field("Length", &self.Length)
            .field("Flags", &self.Flags)
            .field("EaSize", &self.EaSize)
            .field("EaInformationOffset", &self.EaInformationOffset)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STREAM_INFORMATION_ENTRY_0_2 {
    fn eq(&self, other: &Self) -> bool {
        self.Length == other.Length
            && self.Flags == other.Flags
            && self.EaSize == other.EaSize
            && self.EaInformationOffset == other.EaInformationOffset
    }
}
impl ::std::cmp::Eq for STREAM_INFORMATION_ENTRY_0_2 {}
unsafe impl ::windows::runtime::Abi for STREAM_INFORMATION_ENTRY_0_2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STREAM_INFORMATION_ENTRY_0_3 {
    pub Length: u16,
    pub Flags: u16,
    pub ReparseDataSize: u32,
    pub ReparseDataOffset: u32,
}
impl STREAM_INFORMATION_ENTRY_0_3 {}
impl ::std::default::Default for STREAM_INFORMATION_ENTRY_0_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STREAM_INFORMATION_ENTRY_0_3 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Reparse")
            .field("Length", &self.Length)
            .field("Flags", &self.Flags)
            .field("ReparseDataSize", &self.ReparseDataSize)
            .field("ReparseDataOffset", &self.ReparseDataOffset)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STREAM_INFORMATION_ENTRY_0_3 {
    fn eq(&self, other: &Self) -> bool {
        self.Length == other.Length
            && self.Flags == other.Flags
            && self.ReparseDataSize == other.ReparseDataSize
            && self.ReparseDataOffset == other.ReparseDataOffset
    }
}
impl ::std::cmp::Eq for STREAM_INFORMATION_ENTRY_0_3 {}
unsafe impl ::windows::runtime::Abi for STREAM_INFORMATION_ENTRY_0_3 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct STREAM_LAYOUT_ENTRY {
    pub Version: u32,
    pub NextStreamOffset: u32,
    pub Flags: u32,
    pub ExtentInformationOffset: u32,
    pub AllocationSize: i64,
    pub EndOfFile: i64,
    pub StreamInformationOffset: u32,
    pub AttributeTypeCode: u32,
    pub AttributeFlags: u32,
    pub StreamIdentifierLength: u32,
    pub StreamIdentifier: [u16; 1],
}
impl STREAM_LAYOUT_ENTRY {}
impl ::std::default::Default for STREAM_LAYOUT_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for STREAM_LAYOUT_ENTRY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("STREAM_LAYOUT_ENTRY")
            .field("Version", &self.Version)
            .field("NextStreamOffset", &self.NextStreamOffset)
            .field("Flags", &self.Flags)
            .field("ExtentInformationOffset", &self.ExtentInformationOffset)
            .field("AllocationSize", &self.AllocationSize)
            .field("EndOfFile", &self.EndOfFile)
            .field("StreamInformationOffset", &self.StreamInformationOffset)
            .field("AttributeTypeCode", &self.AttributeTypeCode)
            .field("AttributeFlags", &self.AttributeFlags)
            .field("StreamIdentifierLength", &self.StreamIdentifierLength)
            .field("StreamIdentifier", &self.StreamIdentifier)
            .finish()
    }
}
impl ::std::cmp::PartialEq for STREAM_LAYOUT_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.NextStreamOffset == other.NextStreamOffset
            && self.Flags == other.Flags
            && self.ExtentInformationOffset == other.ExtentInformationOffset
            && self.AllocationSize == other.AllocationSize
            && self.EndOfFile == other.EndOfFile
            && self.StreamInformationOffset == other.StreamInformationOffset
            && self.AttributeTypeCode == other.AttributeTypeCode
            && self.AttributeFlags == other.AttributeFlags
            && self.StreamIdentifierLength == other.StreamIdentifierLength
            && self.StreamIdentifier == other.StreamIdentifier
    }
}
impl ::std::cmp::Eq for STREAM_LAYOUT_ENTRY {}
unsafe impl ::windows::runtime::Abi for STREAM_LAYOUT_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
pub const STREAM_LAYOUT_ENTRY_HAS_INFORMATION: u32 = 16u32;
pub const STREAM_LAYOUT_ENTRY_IMMOVABLE: u32 = 1u32;
pub const STREAM_LAYOUT_ENTRY_NO_CLUSTERS_ALLOCATED: u32 = 8u32;
pub const STREAM_LAYOUT_ENTRY_PINNED: u32 = 2u32;
pub const STREAM_LAYOUT_ENTRY_RESIDENT: u32 = 4u32;
pub const STREAM_SET_ENCRYPTION: u32 = 3u32;
pub const STYPE_BITMAP: i32 = 0i32;
pub const STYPE_DEVBITMAP: i32 = 3i32;
pub const SUBLANG_AFRIKAANS_SOUTH_AFRICA: u32 = 1u32;
pub const SUBLANG_ALBANIAN_ALBANIA: u32 = 1u32;
pub const SUBLANG_ALSATIAN_FRANCE: u32 = 1u32;
pub const SUBLANG_AMHARIC_ETHIOPIA: u32 = 1u32;
pub const SUBLANG_ARABIC_ALGERIA: u32 = 5u32;
pub const SUBLANG_ARABIC_BAHRAIN: u32 = 15u32;
pub const SUBLANG_ARABIC_EGYPT: u32 = 3u32;
pub const SUBLANG_ARABIC_IRAQ: u32 = 2u32;
pub const SUBLANG_ARABIC_JORDAN: u32 = 11u32;
pub const SUBLANG_ARABIC_KUWAIT: u32 = 13u32;
pub const SUBLANG_ARABIC_LEBANON: u32 = 12u32;
pub const SUBLANG_ARABIC_LIBYA: u32 = 4u32;
pub const SUBLANG_ARABIC_MOROCCO: u32 = 6u32;
pub const SUBLANG_ARABIC_OMAN: u32 = 8u32;
pub const SUBLANG_ARABIC_QATAR: u32 = 16u32;
pub const SUBLANG_ARABIC_SAUDI_ARABIA: u32 = 1u32;
pub const SUBLANG_ARABIC_SYRIA: u32 = 10u32;
pub const SUBLANG_ARABIC_TUNISIA: u32 = 7u32;
pub const SUBLANG_ARABIC_UAE: u32 = 14u32;
pub const SUBLANG_ARABIC_YEMEN: u32 = 9u32;
pub const SUBLANG_ARMENIAN_ARMENIA: u32 = 1u32;
pub const SUBLANG_ASSAMESE_INDIA: u32 = 1u32;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC: u32 = 2u32;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN: u32 = 1u32;
pub const SUBLANG_AZERI_CYRILLIC: u32 = 2u32;
pub const SUBLANG_AZERI_LATIN: u32 = 1u32;
pub const SUBLANG_BANGLA_BANGLADESH: u32 = 2u32;
pub const SUBLANG_BANGLA_INDIA: u32 = 1u32;
pub const SUBLANG_BASHKIR_RUSSIA: u32 = 1u32;
pub const SUBLANG_BASQUE_BASQUE: u32 = 1u32;
pub const SUBLANG_BELARUSIAN_BELARUS: u32 = 1u32;
pub const SUBLANG_BENGALI_BANGLADESH: u32 = 2u32;
pub const SUBLANG_BENGALI_INDIA: u32 = 1u32;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC: u32 = 8u32;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 5u32;
pub const SUBLANG_BRETON_FRANCE: u32 = 1u32;
pub const SUBLANG_BULGARIAN_BULGARIA: u32 = 1u32;
pub const SUBLANG_CATALAN_CATALAN: u32 = 1u32;
pub const SUBLANG_CENTRAL_KURDISH_IRAQ: u32 = 1u32;
pub const SUBLANG_CHEROKEE_CHEROKEE: u32 = 1u32;
pub const SUBLANG_CHINESE_HONGKONG: u32 = 3u32;
pub const SUBLANG_CHINESE_MACAU: u32 = 5u32;
pub const SUBLANG_CHINESE_SIMPLIFIED: u32 = 2u32;
pub const SUBLANG_CHINESE_SINGAPORE: u32 = 4u32;
pub const SUBLANG_CHINESE_TRADITIONAL: u32 = 1u32;
pub const SUBLANG_CORSICAN_FRANCE: u32 = 1u32;
pub const SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 4u32;
pub const SUBLANG_CROATIAN_CROATIA: u32 = 1u32;
pub const SUBLANG_CUSTOM_DEFAULT: u32 = 3u32;
pub const SUBLANG_CUSTOM_UNSPECIFIED: u32 = 4u32;
pub const SUBLANG_CZECH_CZECH_REPUBLIC: u32 = 1u32;
pub const SUBLANG_DANISH_DENMARK: u32 = 1u32;
pub const SUBLANG_DARI_AFGHANISTAN: u32 = 1u32;
pub const SUBLANG_DEFAULT: u32 = 1u32;
pub const SUBLANG_DIVEHI_MALDIVES: u32 = 1u32;
pub const SUBLANG_DUTCH: u32 = 1u32;
pub const SUBLANG_DUTCH_BELGIAN: u32 = 2u32;
pub const SUBLANG_ENGLISH_AUS: u32 = 3u32;
pub const SUBLANG_ENGLISH_BELIZE: u32 = 10u32;
pub const SUBLANG_ENGLISH_CAN: u32 = 4u32;
pub const SUBLANG_ENGLISH_CARIBBEAN: u32 = 9u32;
pub const SUBLANG_ENGLISH_EIRE: u32 = 6u32;
pub const SUBLANG_ENGLISH_INDIA: u32 = 16u32;
pub const SUBLANG_ENGLISH_JAMAICA: u32 = 8u32;
pub const SUBLANG_ENGLISH_MALAYSIA: u32 = 17u32;
pub const SUBLANG_ENGLISH_NZ: u32 = 5u32;
pub const SUBLANG_ENGLISH_PHILIPPINES: u32 = 13u32;
pub const SUBLANG_ENGLISH_SINGAPORE: u32 = 18u32;
pub const SUBLANG_ENGLISH_SOUTH_AFRICA: u32 = 7u32;
pub const SUBLANG_ENGLISH_TRINIDAD: u32 = 11u32;
pub const SUBLANG_ENGLISH_UK: u32 = 2u32;
pub const SUBLANG_ENGLISH_US: u32 = 1u32;
pub const SUBLANG_ENGLISH_ZIMBABWE: u32 = 12u32;
pub const SUBLANG_ESTONIAN_ESTONIA: u32 = 1u32;
pub const SUBLANG_FAEROESE_FAROE_ISLANDS: u32 = 1u32;
pub const SUBLANG_FILIPINO_PHILIPPINES: u32 = 1u32;
pub const SUBLANG_FINNISH_FINLAND: u32 = 1u32;
pub const SUBLANG_FRENCH: u32 = 1u32;
pub const SUBLANG_FRENCH_BELGIAN: u32 = 2u32;
pub const SUBLANG_FRENCH_CANADIAN: u32 = 3u32;
pub const SUBLANG_FRENCH_LUXEMBOURG: u32 = 5u32;
pub const SUBLANG_FRENCH_MONACO: u32 = 6u32;
pub const SUBLANG_FRENCH_SWISS: u32 = 4u32;
pub const SUBLANG_FRISIAN_NETHERLANDS: u32 = 1u32;
pub const SUBLANG_FULAH_SENEGAL: u32 = 2u32;
pub const SUBLANG_GALICIAN_GALICIAN: u32 = 1u32;
pub const SUBLANG_GEORGIAN_GEORGIA: u32 = 1u32;
pub const SUBLANG_GERMAN: u32 = 1u32;
pub const SUBLANG_GERMAN_AUSTRIAN: u32 = 3u32;
pub const SUBLANG_GERMAN_LIECHTENSTEIN: u32 = 5u32;
pub const SUBLANG_GERMAN_LUXEMBOURG: u32 = 4u32;
pub const SUBLANG_GERMAN_SWISS: u32 = 2u32;
pub const SUBLANG_GREEK_GREECE: u32 = 1u32;
pub const SUBLANG_GREENLANDIC_GREENLAND: u32 = 1u32;
pub const SUBLANG_GUJARATI_INDIA: u32 = 1u32;
pub const SUBLANG_HAUSA_NIGERIA_LATIN: u32 = 1u32;
pub const SUBLANG_HAWAIIAN_US: u32 = 1u32;
pub const SUBLANG_HEBREW_ISRAEL: u32 = 1u32;
pub const SUBLANG_HINDI_INDIA: u32 = 1u32;
pub const SUBLANG_HUNGARIAN_HUNGARY: u32 = 1u32;
pub const SUBLANG_ICELANDIC_ICELAND: u32 = 1u32;
pub const SUBLANG_IGBO_NIGERIA: u32 = 1u32;
pub const SUBLANG_INDONESIAN_INDONESIA: u32 = 1u32;
pub const SUBLANG_INUKTITUT_CANADA: u32 = 1u32;
pub const SUBLANG_INUKTITUT_CANADA_LATIN: u32 = 2u32;
pub const SUBLANG_IRISH_IRELAND: u32 = 2u32;
pub const SUBLANG_ITALIAN: u32 = 1u32;
pub const SUBLANG_ITALIAN_SWISS: u32 = 2u32;
pub const SUBLANG_JAPANESE_JAPAN: u32 = 1u32;
pub const SUBLANG_KANNADA_INDIA: u32 = 1u32;
pub const SUBLANG_KASHMIRI_INDIA: u32 = 2u32;
pub const SUBLANG_KASHMIRI_SASIA: u32 = 2u32;
pub const SUBLANG_KAZAK_KAZAKHSTAN: u32 = 1u32;
pub const SUBLANG_KHMER_CAMBODIA: u32 = 1u32;
pub const SUBLANG_KICHE_GUATEMALA: u32 = 1u32;
pub const SUBLANG_KINYARWANDA_RWANDA: u32 = 1u32;
pub const SUBLANG_KONKANI_INDIA: u32 = 1u32;
pub const SUBLANG_KOREAN: u32 = 1u32;
pub const SUBLANG_KYRGYZ_KYRGYZSTAN: u32 = 1u32;
pub const SUBLANG_LAO_LAO: u32 = 1u32;
pub const SUBLANG_LATVIAN_LATVIA: u32 = 1u32;
pub const SUBLANG_LITHUANIAN: u32 = 1u32;
pub const SUBLANG_LOWER_SORBIAN_GERMANY: u32 = 2u32;
pub const SUBLANG_LUXEMBOURGISH_LUXEMBOURG: u32 = 1u32;
pub const SUBLANG_MACEDONIAN_MACEDONIA: u32 = 1u32;
pub const SUBLANG_MALAYALAM_INDIA: u32 = 1u32;
pub const SUBLANG_MALAY_BRUNEI_DARUSSALAM: u32 = 2u32;
pub const SUBLANG_MALAY_MALAYSIA: u32 = 1u32;
pub const SUBLANG_MALTESE_MALTA: u32 = 1u32;
pub const SUBLANG_MAORI_NEW_ZEALAND: u32 = 1u32;
pub const SUBLANG_MAPUDUNGUN_CHILE: u32 = 1u32;
pub const SUBLANG_MARATHI_INDIA: u32 = 1u32;
pub const SUBLANG_MOHAWK_MOHAWK: u32 = 1u32;
pub const SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA: u32 = 1u32;
pub const SUBLANG_MONGOLIAN_PRC: u32 = 2u32;
pub const SUBLANG_NEPALI_INDIA: u32 = 2u32;
pub const SUBLANG_NEPALI_NEPAL: u32 = 1u32;
pub const SUBLANG_NEUTRAL: u32 = 0u32;
pub const SUBLANG_NORWEGIAN_BOKMAL: u32 = 1u32;
pub const SUBLANG_NORWEGIAN_NYNORSK: u32 = 2u32;
pub const SUBLANG_OCCITAN_FRANCE: u32 = 1u32;
pub const SUBLANG_ODIA_INDIA: u32 = 1u32;
pub const SUBLANG_ORIYA_INDIA: u32 = 1u32;
pub const SUBLANG_PASHTO_AFGHANISTAN: u32 = 1u32;
pub const SUBLANG_PERSIAN_IRAN: u32 = 1u32;
pub const SUBLANG_POLISH_POLAND: u32 = 1u32;
pub const SUBLANG_PORTUGUESE: u32 = 2u32;
pub const SUBLANG_PORTUGUESE_BRAZILIAN: u32 = 1u32;
pub const SUBLANG_PULAR_SENEGAL: u32 = 2u32;
pub const SUBLANG_PUNJABI_INDIA: u32 = 1u32;
pub const SUBLANG_PUNJABI_PAKISTAN: u32 = 2u32;
pub const SUBLANG_QUECHUA_BOLIVIA: u32 = 1u32;
pub const SUBLANG_QUECHUA_ECUADOR: u32 = 2u32;
pub const SUBLANG_QUECHUA_PERU: u32 = 3u32;
pub const SUBLANG_ROMANIAN_ROMANIA: u32 = 1u32;
pub const SUBLANG_ROMANSH_SWITZERLAND: u32 = 1u32;
pub const SUBLANG_RUSSIAN_RUSSIA: u32 = 1u32;
pub const SUBLANG_SAKHA_RUSSIA: u32 = 1u32;
pub const SUBLANG_SAMI_INARI_FINLAND: u32 = 9u32;
pub const SUBLANG_SAMI_LULE_NORWAY: u32 = 4u32;
pub const SUBLANG_SAMI_LULE_SWEDEN: u32 = 5u32;
pub const SUBLANG_SAMI_NORTHERN_FINLAND: u32 = 3u32;
pub const SUBLANG_SAMI_NORTHERN_NORWAY: u32 = 1u32;
pub const SUBLANG_SAMI_NORTHERN_SWEDEN: u32 = 2u32;
pub const SUBLANG_SAMI_SKOLT_FINLAND: u32 = 8u32;
pub const SUBLANG_SAMI_SOUTHERN_NORWAY: u32 = 6u32;
pub const SUBLANG_SAMI_SOUTHERN_SWEDEN: u32 = 7u32;
pub const SUBLANG_SANSKRIT_INDIA: u32 = 1u32;
pub const SUBLANG_SCOTTISH_GAELIC: u32 = 1u32;
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC: u32 = 7u32;
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 6u32;
pub const SUBLANG_SERBIAN_CROATIA: u32 = 1u32;
pub const SUBLANG_SERBIAN_CYRILLIC: u32 = 3u32;
pub const SUBLANG_SERBIAN_LATIN: u32 = 2u32;
pub const SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC: u32 = 12u32;
pub const SUBLANG_SERBIAN_MONTENEGRO_LATIN: u32 = 11u32;
pub const SUBLANG_SERBIAN_SERBIA_CYRILLIC: u32 = 10u32;
pub const SUBLANG_SERBIAN_SERBIA_LATIN: u32 = 9u32;
pub const SUBLANG_SINDHI_AFGHANISTAN: u32 = 2u32;
pub const SUBLANG_SINDHI_INDIA: u32 = 1u32;
pub const SUBLANG_SINDHI_PAKISTAN: u32 = 2u32;
pub const SUBLANG_SINHALESE_SRI_LANKA: u32 = 1u32;
pub const SUBLANG_SLOVAK_SLOVAKIA: u32 = 1u32;
pub const SUBLANG_SLOVENIAN_SLOVENIA: u32 = 1u32;
pub const SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA: u32 = 1u32;
pub const SUBLANG_SPANISH: u32 = 1u32;
pub const SUBLANG_SPANISH_ARGENTINA: u32 = 11u32;
pub const SUBLANG_SPANISH_BOLIVIA: u32 = 16u32;
pub const SUBLANG_SPANISH_CHILE: u32 = 13u32;
pub const SUBLANG_SPANISH_COLOMBIA: u32 = 9u32;
pub const SUBLANG_SPANISH_COSTA_RICA: u32 = 5u32;
pub const SUBLANG_SPANISH_DOMINICAN_REPUBLIC: u32 = 7u32;
pub const SUBLANG_SPANISH_ECUADOR: u32 = 12u32;
pub const SUBLANG_SPANISH_EL_SALVADOR: u32 = 17u32;
pub const SUBLANG_SPANISH_GUATEMALA: u32 = 4u32;
pub const SUBLANG_SPANISH_HONDURAS: u32 = 18u32;
pub const SUBLANG_SPANISH_MEXICAN: u32 = 2u32;
pub const SUBLANG_SPANISH_MODERN: u32 = 3u32;
pub const SUBLANG_SPANISH_NICARAGUA: u32 = 19u32;
pub const SUBLANG_SPANISH_PANAMA: u32 = 6u32;
pub const SUBLANG_SPANISH_PARAGUAY: u32 = 15u32;
pub const SUBLANG_SPANISH_PERU: u32 = 10u32;
pub const SUBLANG_SPANISH_PUERTO_RICO: u32 = 20u32;
pub const SUBLANG_SPANISH_URUGUAY: u32 = 14u32;
pub const SUBLANG_SPANISH_US: u32 = 21u32;
pub const SUBLANG_SPANISH_VENEZUELA: u32 = 8u32;
pub const SUBLANG_SWAHILI_KENYA: u32 = 1u32;
pub const SUBLANG_SWEDISH: u32 = 1u32;
pub const SUBLANG_SWEDISH_FINLAND: u32 = 2u32;
pub const SUBLANG_SYRIAC_SYRIA: u32 = 1u32;
pub const SUBLANG_SYS_DEFAULT: u32 = 2u32;
pub const SUBLANG_TAJIK_TAJIKISTAN: u32 = 1u32;
pub const SUBLANG_TAMAZIGHT_ALGERIA_LATIN: u32 = 2u32;
pub const SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH: u32 = 4u32;
pub const SUBLANG_TAMIL_INDIA: u32 = 1u32;
pub const SUBLANG_TAMIL_SRI_LANKA: u32 = 2u32;
pub const SUBLANG_TATAR_RUSSIA: u32 = 1u32;
pub const SUBLANG_TELUGU_INDIA: u32 = 1u32;
pub const SUBLANG_THAI_THAILAND: u32 = 1u32;
pub const SUBLANG_TIBETAN_PRC: u32 = 1u32;
pub const SUBLANG_TIGRIGNA_ERITREA: u32 = 2u32;
pub const SUBLANG_TIGRINYA_ERITREA: u32 = 2u32;
pub const SUBLANG_TIGRINYA_ETHIOPIA: u32 = 1u32;
pub const SUBLANG_TSWANA_BOTSWANA: u32 = 2u32;
pub const SUBLANG_TSWANA_SOUTH_AFRICA: u32 = 1u32;
pub const SUBLANG_TURKISH_TURKEY: u32 = 1u32;
pub const SUBLANG_TURKMEN_TURKMENISTAN: u32 = 1u32;
pub const SUBLANG_UIGHUR_PRC: u32 = 1u32;
pub const SUBLANG_UI_CUSTOM_DEFAULT: u32 = 5u32;
pub const SUBLANG_UKRAINIAN_UKRAINE: u32 = 1u32;
pub const SUBLANG_UPPER_SORBIAN_GERMANY: u32 = 1u32;
pub const SUBLANG_URDU_INDIA: u32 = 2u32;
pub const SUBLANG_URDU_PAKISTAN: u32 = 1u32;
pub const SUBLANG_UZBEK_CYRILLIC: u32 = 2u32;
pub const SUBLANG_UZBEK_LATIN: u32 = 1u32;
pub const SUBLANG_VALENCIAN_VALENCIA: u32 = 2u32;
pub const SUBLANG_VIETNAMESE_VIETNAM: u32 = 1u32;
pub const SUBLANG_WELSH_UNITED_KINGDOM: u32 = 1u32;
pub const SUBLANG_WOLOF_SENEGAL: u32 = 1u32;
pub const SUBLANG_XHOSA_SOUTH_AFRICA: u32 = 1u32;
pub const SUBLANG_YAKUT_RUSSIA: u32 = 1u32;
pub const SUBLANG_YI_PRC: u32 = 1u32;
pub const SUBLANG_YORUBA_NIGERIA: u32 = 1u32;
pub const SUBLANG_ZULU_SOUTH_AFRICA: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SUPPORTED_OS_INFO {
    pub MajorVersion: u16,
    pub MinorVersion: u16,
}
impl SUPPORTED_OS_INFO {}
impl ::std::default::Default for SUPPORTED_OS_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SUPPORTED_OS_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SUPPORTED_OS_INFO")
            .field("MajorVersion", &self.MajorVersion)
            .field("MinorVersion", &self.MinorVersion)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SUPPORTED_OS_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.MajorVersion == other.MajorVersion && self.MinorVersion == other.MinorVersion
    }
}
impl ::std::cmp::Eq for SUPPORTED_OS_INFO {}
unsafe impl ::windows::runtime::Abi for SUPPORTED_OS_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Security")]
pub struct SYSTEM_ACCESS_FILTER_ACE {
    pub Header: super::super::Security::ACE_HEADER,
    pub Mask: u32,
    pub SidStart: u32,
}
#[cfg(feature = "Win32_Security")]
impl SYSTEM_ACCESS_FILTER_ACE {}
#[cfg(feature = "Win32_Security")]
impl ::std::default::Default for SYSTEM_ACCESS_FILTER_ACE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Security")]
impl ::std::fmt::Debug for SYSTEM_ACCESS_FILTER_ACE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SYSTEM_ACCESS_FILTER_ACE")
            .field("Header", &self.Header)
            .field("Mask", &self.Mask)
            .field("SidStart", &self.SidStart)
            .finish()
    }
}
#[cfg(feature = "Win32_Security")]
impl ::std::cmp::PartialEq for SYSTEM_ACCESS_FILTER_ACE {
    fn eq(&self, other: &Self) -> bool {
        self.Header == other.Header && self.Mask == other.Mask && self.SidStart == other.SidStart
    }
}
#[cfg(feature = "Win32_Security")]
impl ::std::cmp::Eq for SYSTEM_ACCESS_FILTER_ACE {}
#[cfg(feature = "Win32_Security")]
unsafe impl ::windows::runtime::Abi for SYSTEM_ACCESS_FILTER_ACE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SYSTEM_ACCESS_FILTER_ACE_TYPE: u32 = 21u32;
pub const SYSTEM_ACCESS_FILTER_NOCONSTRAINT_MASK: u32 = 4294967295u32;
pub const SYSTEM_ACCESS_FILTER_VALID_MASK: u32 = 16777215u32;
pub const SYSTEM_ALARM_ACE_TYPE: u32 = 3u32;
pub const SYSTEM_ALARM_CALLBACK_ACE_TYPE: u32 = 14u32;
pub const SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE: u32 = 16u32;
pub const SYSTEM_ALARM_OBJECT_ACE_TYPE: u32 = 8u32;
pub const SYSTEM_AUDIT_ACE_TYPE: u32 = 2u32;
pub const SYSTEM_AUDIT_CALLBACK_ACE_TYPE: u32 = 13u32;
pub const SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE: u32 = 15u32;
pub const SYSTEM_AUDIT_OBJECT_ACE_TYPE: u32 = 7u32;
pub const SYSTEM_CACHE_ALIGNMENT_SIZE: u32 = 64u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SYSTEM_CPU_SET_INFORMATION {
    pub Size: u32,
    pub Type: CPU_SET_INFORMATION_TYPE,
    pub Anonymous: SYSTEM_CPU_SET_INFORMATION_0,
}
impl SYSTEM_CPU_SET_INFORMATION {}
impl ::std::default::Default for SYSTEM_CPU_SET_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for SYSTEM_CPU_SET_INFORMATION {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for SYSTEM_CPU_SET_INFORMATION {}
unsafe impl ::windows::runtime::Abi for SYSTEM_CPU_SET_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union SYSTEM_CPU_SET_INFORMATION_0 {
    pub CpuSet: SYSTEM_CPU_SET_INFORMATION_0_0,
}
impl SYSTEM_CPU_SET_INFORMATION_0 {}
impl ::std::default::Default for SYSTEM_CPU_SET_INFORMATION_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for SYSTEM_CPU_SET_INFORMATION_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for SYSTEM_CPU_SET_INFORMATION_0 {}
unsafe impl ::windows::runtime::Abi for SYSTEM_CPU_SET_INFORMATION_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SYSTEM_CPU_SET_INFORMATION_0_0 {
    pub Id: u32,
    pub Group: u16,
    pub LogicalProcessorIndex: u8,
    pub CoreIndex: u8,
    pub LastLevelCacheIndex: u8,
    pub NumaNodeIndex: u8,
    pub EfficiencyClass: u8,
    pub Anonymous1: SYSTEM_CPU_SET_INFORMATION_0_0_0,
    pub Anonymous2: SYSTEM_CPU_SET_INFORMATION_0_0_1,
    pub AllocationTag: u64,
}
impl SYSTEM_CPU_SET_INFORMATION_0_0 {}
impl ::std::default::Default for SYSTEM_CPU_SET_INFORMATION_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for SYSTEM_CPU_SET_INFORMATION_0_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for SYSTEM_CPU_SET_INFORMATION_0_0 {}
unsafe impl ::windows::runtime::Abi for SYSTEM_CPU_SET_INFORMATION_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union SYSTEM_CPU_SET_INFORMATION_0_0_0 {
    pub AllFlags: u8,
    pub Anonymous: SYSTEM_CPU_SET_INFORMATION_0_0_0_0,
}
impl SYSTEM_CPU_SET_INFORMATION_0_0_0 {}
impl ::std::default::Default for SYSTEM_CPU_SET_INFORMATION_0_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for SYSTEM_CPU_SET_INFORMATION_0_0_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for SYSTEM_CPU_SET_INFORMATION_0_0_0 {}
unsafe impl ::windows::runtime::Abi for SYSTEM_CPU_SET_INFORMATION_0_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SYSTEM_CPU_SET_INFORMATION_0_0_0_0 {
    pub _bitfield: u8,
}
impl SYSTEM_CPU_SET_INFORMATION_0_0_0_0 {}
impl ::std::default::Default for SYSTEM_CPU_SET_INFORMATION_0_0_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SYSTEM_CPU_SET_INFORMATION_0_0_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SYSTEM_CPU_SET_INFORMATION_0_0_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for SYSTEM_CPU_SET_INFORMATION_0_0_0_0 {}
unsafe impl ::windows::runtime::Abi for SYSTEM_CPU_SET_INFORMATION_0_0_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union SYSTEM_CPU_SET_INFORMATION_0_0_1 {
    pub Reserved: u32,
    pub SchedulingClass: u8,
}
impl SYSTEM_CPU_SET_INFORMATION_0_0_1 {}
impl ::std::default::Default for SYSTEM_CPU_SET_INFORMATION_0_0_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for SYSTEM_CPU_SET_INFORMATION_0_0_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for SYSTEM_CPU_SET_INFORMATION_0_0_1 {}
unsafe impl ::windows::runtime::Abi for SYSTEM_CPU_SET_INFORMATION_0_0_1 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED: u32 = 2u32;
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED_TO_TARGET_PROCESS: u32 = 4u32;
pub const SYSTEM_CPU_SET_INFORMATION_PARKED: u32 = 1u32;
pub const SYSTEM_CPU_SET_INFORMATION_REALTIME: u32 = 8u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(
    feature = "Win32_System_Kernel",
    feature = "Win32_System_SystemInformation"
))]
pub struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    pub Relationship: super::SystemInformation::LOGICAL_PROCESSOR_RELATIONSHIP,
    pub Size: u32,
    pub Anonymous: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX_0,
}
#[cfg(all(
    feature = "Win32_System_Kernel",
    feature = "Win32_System_SystemInformation"
))]
impl SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {}
#[cfg(all(
    feature = "Win32_System_Kernel",
    feature = "Win32_System_SystemInformation"
))]
impl ::std::default::Default for SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(
    feature = "Win32_System_Kernel",
    feature = "Win32_System_SystemInformation"
))]
impl ::std::cmp::PartialEq for SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(all(
    feature = "Win32_System_Kernel",
    feature = "Win32_System_SystemInformation"
))]
impl ::std::cmp::Eq for SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {}
#[cfg(all(
    feature = "Win32_System_Kernel",
    feature = "Win32_System_SystemInformation"
))]
unsafe impl ::windows::runtime::Abi for SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Kernel")]
pub union SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX_0 {
    pub Processor: PROCESSOR_RELATIONSHIP,
    pub NumaNode: NUMA_NODE_RELATIONSHIP,
    pub Cache: CACHE_RELATIONSHIP,
    pub Group: GROUP_RELATIONSHIP,
}
#[cfg(feature = "Win32_System_Kernel")]
impl SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX_0 {}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::default::Default for SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::cmp::PartialEq for SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::std::cmp::Eq for SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX_0 {}
#[cfg(feature = "Win32_System_Kernel")]
unsafe impl ::windows::runtime::Abi for SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX_0 {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SYSTEM_MANDATORY_LABEL_ACE_TYPE: u32 = 17u32;
pub const SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP: u32 = 4u32;
pub const SYSTEM_MANDATORY_LABEL_NO_READ_UP: u32 = 2u32;
pub const SYSTEM_MANDATORY_LABEL_NO_WRITE_UP: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct SYSTEM_POOL_ZEROING_INFORMATION {
    pub PoolZeroingSupportPresent: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl SYSTEM_POOL_ZEROING_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for SYSTEM_POOL_ZEROING_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for SYSTEM_POOL_ZEROING_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SYSTEM_POOL_ZEROING_INFORMATION")
            .field("PoolZeroingSupportPresent", &self.PoolZeroingSupportPresent)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for SYSTEM_POOL_ZEROING_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.PoolZeroingSupportPresent == other.PoolZeroingSupportPresent
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for SYSTEM_POOL_ZEROING_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for SYSTEM_POOL_ZEROING_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Security")]
pub struct SYSTEM_PROCESS_TRUST_LABEL_ACE {
    pub Header: super::super::Security::ACE_HEADER,
    pub Mask: u32,
    pub SidStart: u32,
}
#[cfg(feature = "Win32_Security")]
impl SYSTEM_PROCESS_TRUST_LABEL_ACE {}
#[cfg(feature = "Win32_Security")]
impl ::std::default::Default for SYSTEM_PROCESS_TRUST_LABEL_ACE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Security")]
impl ::std::fmt::Debug for SYSTEM_PROCESS_TRUST_LABEL_ACE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SYSTEM_PROCESS_TRUST_LABEL_ACE")
            .field("Header", &self.Header)
            .field("Mask", &self.Mask)
            .field("SidStart", &self.SidStart)
            .finish()
    }
}
#[cfg(feature = "Win32_Security")]
impl ::std::cmp::PartialEq for SYSTEM_PROCESS_TRUST_LABEL_ACE {
    fn eq(&self, other: &Self) -> bool {
        self.Header == other.Header && self.Mask == other.Mask && self.SidStart == other.SidStart
    }
}
#[cfg(feature = "Win32_Security")]
impl ::std::cmp::Eq for SYSTEM_PROCESS_TRUST_LABEL_ACE {}
#[cfg(feature = "Win32_Security")]
unsafe impl ::windows::runtime::Abi for SYSTEM_PROCESS_TRUST_LABEL_ACE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const SYSTEM_PROCESS_TRUST_LABEL_ACE_TYPE: u32 = 20u32;
pub const SYSTEM_PROCESS_TRUST_LABEL_VALID_MASK: u32 = 16777215u32;
pub const SYSTEM_PROCESS_TRUST_NOCONSTRAINT_MASK: u32 = 4294967295u32;
pub const SYSTEM_RESOURCE_ATTRIBUTE_ACE_TYPE: u32 = 18u32;
pub const SYSTEM_SCOPED_POLICY_ID_ACE_TYPE: u32 = 19u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION {
    pub _bitfield: u32,
}
impl SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION {}
impl ::std::default::Default for SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION {}
unsafe impl ::windows::runtime::Abi for SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SharedVirtualDiskHandleState(pub i32);
pub const SharedVirtualDiskHandleStateNone: SharedVirtualDiskHandleState =
    SharedVirtualDiskHandleState(0i32);
pub const SharedVirtualDiskHandleStateFileShared: SharedVirtualDiskHandleState =
    SharedVirtualDiskHandleState(1i32);
pub const SharedVirtualDiskHandleStateHandleShared: SharedVirtualDiskHandleState =
    SharedVirtualDiskHandleState(3i32);
impl ::std::convert::From<i32> for SharedVirtualDiskHandleState {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SharedVirtualDiskHandleState {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct SharedVirtualDiskSupportType(pub i32);
pub const SharedVirtualDisksUnsupported: SharedVirtualDiskSupportType =
    SharedVirtualDiskSupportType(0i32);
pub const SharedVirtualDisksSupported: SharedVirtualDiskSupportType =
    SharedVirtualDiskSupportType(1i32);
pub const SharedVirtualDiskSnapshotsSupported: SharedVirtualDiskSupportType =
    SharedVirtualDiskSupportType(3i32);
pub const SharedVirtualDiskCDPSnapshotsSupported: SharedVirtualDiskSupportType =
    SharedVirtualDiskSupportType(7i32);
impl ::std::convert::From<i32> for SharedVirtualDiskSupportType {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for SharedVirtualDiskSupportType {
    type Abi = Self;
    type DefaultType = Self;
}
pub const TAPE_CHECK_FOR_DRIVE_PROBLEM: i32 = 2i32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TAPE_CREATE_PARTITION {
    pub Method: u32,
    pub Count: u32,
    pub Size: u32,
}
impl TAPE_CREATE_PARTITION {}
impl ::std::default::Default for TAPE_CREATE_PARTITION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TAPE_CREATE_PARTITION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TAPE_CREATE_PARTITION")
            .field("Method", &self.Method)
            .field("Count", &self.Count)
            .field("Size", &self.Size)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TAPE_CREATE_PARTITION {
    fn eq(&self, other: &Self) -> bool {
        self.Method == other.Method && self.Count == other.Count && self.Size == other.Size
    }
}
impl ::std::cmp::Eq for TAPE_CREATE_PARTITION {}
unsafe impl ::windows::runtime::Abi for TAPE_CREATE_PARTITION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const TAPE_DRIVE_CLEAN_REQUESTS: u32 = 33554432u32;
pub const TAPE_DRIVE_COMPRESSION: u32 = 131072u32;
pub const TAPE_DRIVE_ECC: u32 = 65536u32;
pub const TAPE_DRIVE_EJECT_MEDIA: u32 = 16777216u32;
pub const TAPE_DRIVE_EOT_WZ_SIZE: u32 = 8192u32;
pub const TAPE_DRIVE_ERASE_BOP_ONLY: u32 = 64u32;
pub const TAPE_DRIVE_ERASE_IMMEDIATE: u32 = 128u32;
pub const TAPE_DRIVE_ERASE_LONG: u32 = 32u32;
pub const TAPE_DRIVE_ERASE_SHORT: u32 = 16u32;
pub const TAPE_DRIVE_FIXED: u32 = 1u32;
pub const TAPE_DRIVE_FIXED_BLOCK: u32 = 1024u32;
pub const TAPE_DRIVE_FORMAT: u32 = 2684354560u32;
pub const TAPE_DRIVE_FORMAT_IMMEDIATE: u32 = 3221225472u32;
pub const TAPE_DRIVE_GET_ABSOLUTE_BLK: u32 = 1048576u32;
pub const TAPE_DRIVE_GET_LOGICAL_BLK: u32 = 2097152u32;
pub const TAPE_DRIVE_HIGH_FEATURES: u32 = 2147483648u32;
pub const TAPE_DRIVE_INITIATOR: u32 = 4u32;
pub const TAPE_DRIVE_PADDING: u32 = 262144u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct TAPE_DRIVE_PROBLEM_TYPE(pub i32);
pub const TapeDriveProblemNone: TAPE_DRIVE_PROBLEM_TYPE = TAPE_DRIVE_PROBLEM_TYPE(0i32);
pub const TapeDriveReadWriteWarning: TAPE_DRIVE_PROBLEM_TYPE = TAPE_DRIVE_PROBLEM_TYPE(1i32);
pub const TapeDriveReadWriteError: TAPE_DRIVE_PROBLEM_TYPE = TAPE_DRIVE_PROBLEM_TYPE(2i32);
pub const TapeDriveReadWarning: TAPE_DRIVE_PROBLEM_TYPE = TAPE_DRIVE_PROBLEM_TYPE(3i32);
pub const TapeDriveWriteWarning: TAPE_DRIVE_PROBLEM_TYPE = TAPE_DRIVE_PROBLEM_TYPE(4i32);
pub const TapeDriveReadError: TAPE_DRIVE_PROBLEM_TYPE = TAPE_DRIVE_PROBLEM_TYPE(5i32);
pub const TapeDriveWriteError: TAPE_DRIVE_PROBLEM_TYPE = TAPE_DRIVE_PROBLEM_TYPE(6i32);
pub const TapeDriveHardwareError: TAPE_DRIVE_PROBLEM_TYPE = TAPE_DRIVE_PROBLEM_TYPE(7i32);
pub const TapeDriveUnsupportedMedia: TAPE_DRIVE_PROBLEM_TYPE = TAPE_DRIVE_PROBLEM_TYPE(8i32);
pub const TapeDriveScsiConnectionError: TAPE_DRIVE_PROBLEM_TYPE = TAPE_DRIVE_PROBLEM_TYPE(9i32);
pub const TapeDriveTimetoClean: TAPE_DRIVE_PROBLEM_TYPE = TAPE_DRIVE_PROBLEM_TYPE(10i32);
pub const TapeDriveCleanDriveNow: TAPE_DRIVE_PROBLEM_TYPE = TAPE_DRIVE_PROBLEM_TYPE(11i32);
pub const TapeDriveMediaLifeExpired: TAPE_DRIVE_PROBLEM_TYPE = TAPE_DRIVE_PROBLEM_TYPE(12i32);
pub const TapeDriveSnappedTape: TAPE_DRIVE_PROBLEM_TYPE = TAPE_DRIVE_PROBLEM_TYPE(13i32);
impl ::std::convert::From<i32> for TAPE_DRIVE_PROBLEM_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for TAPE_DRIVE_PROBLEM_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const TAPE_DRIVE_REPORT_SMKS: u32 = 524288u32;
pub const TAPE_DRIVE_RESERVED_BIT: u32 = 2147483648u32;
pub const TAPE_DRIVE_SELECT: u32 = 2u32;
pub const TAPE_DRIVE_SET_CMP_BOP_ONLY: u32 = 67108864u32;
pub const TAPE_DRIVE_SET_EOT_WZ_SIZE: u32 = 4194304u32;
pub const TAPE_DRIVE_TAPE_CAPACITY: u32 = 256u32;
pub const TAPE_DRIVE_TAPE_REMAINING: u32 = 512u32;
pub const TAPE_DRIVE_VARIABLE_BLOCK: u32 = 2048u32;
pub const TAPE_DRIVE_WRITE_PROTECT: u32 = 4096u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
pub struct TAPE_ERASE {
    pub Type: super::super::Storage::FileSystem::ERASE_TAPE_TYPE,
    pub Immediate: super::super::Foundation::BOOLEAN,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl TAPE_ERASE {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl ::std::default::Default for TAPE_ERASE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl ::std::fmt::Debug for TAPE_ERASE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TAPE_ERASE")
            .field("Type", &self.Type)
            .field("Immediate", &self.Immediate)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl ::std::cmp::PartialEq for TAPE_ERASE {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type && self.Immediate == other.Immediate
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl ::std::cmp::Eq for TAPE_ERASE {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
unsafe impl ::windows::runtime::Abi for TAPE_ERASE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct TAPE_GET_DRIVE_PARAMETERS {
    pub ECC: super::super::Foundation::BOOLEAN,
    pub Compression: super::super::Foundation::BOOLEAN,
    pub DataPadding: super::super::Foundation::BOOLEAN,
    pub ReportSetmarks: super::super::Foundation::BOOLEAN,
    pub DefaultBlockSize: u32,
    pub MaximumBlockSize: u32,
    pub MinimumBlockSize: u32,
    pub MaximumPartitionCount: u32,
    pub FeaturesLow: u32,
    pub FeaturesHigh: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH,
    pub EOTWarningZoneSize: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl TAPE_GET_DRIVE_PARAMETERS {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for TAPE_GET_DRIVE_PARAMETERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for TAPE_GET_DRIVE_PARAMETERS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TAPE_GET_DRIVE_PARAMETERS")
            .field("ECC", &self.ECC)
            .field("Compression", &self.Compression)
            .field("DataPadding", &self.DataPadding)
            .field("ReportSetmarks", &self.ReportSetmarks)
            .field("DefaultBlockSize", &self.DefaultBlockSize)
            .field("MaximumBlockSize", &self.MaximumBlockSize)
            .field("MinimumBlockSize", &self.MinimumBlockSize)
            .field("MaximumPartitionCount", &self.MaximumPartitionCount)
            .field("FeaturesLow", &self.FeaturesLow)
            .field("FeaturesHigh", &self.FeaturesHigh)
            .field("EOTWarningZoneSize", &self.EOTWarningZoneSize)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for TAPE_GET_DRIVE_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.ECC == other.ECC
            && self.Compression == other.Compression
            && self.DataPadding == other.DataPadding
            && self.ReportSetmarks == other.ReportSetmarks
            && self.DefaultBlockSize == other.DefaultBlockSize
            && self.MaximumBlockSize == other.MaximumBlockSize
            && self.MinimumBlockSize == other.MinimumBlockSize
            && self.MaximumPartitionCount == other.MaximumPartitionCount
            && self.FeaturesLow == other.FeaturesLow
            && self.FeaturesHigh == other.FeaturesHigh
            && self.EOTWarningZoneSize == other.EOTWarningZoneSize
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for TAPE_GET_DRIVE_PARAMETERS {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for TAPE_GET_DRIVE_PARAMETERS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(pub u32);
pub const TAPE_DRIVE_ABS_BLK_IMMED: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147491840u32);
pub const TAPE_DRIVE_ABSOLUTE_BLK: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147487744u32);
pub const TAPE_DRIVE_END_OF_DATA: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147549184u32);
pub const TAPE_DRIVE_FILEMARKS: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147745792u32);
pub const TAPE_DRIVE_LOAD_UNLOAD: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147483649u32);
pub const TAPE_DRIVE_LOAD_UNLD_IMMED: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147483680u32);
pub const TAPE_DRIVE_LOCK_UNLOCK: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147483652u32);
pub const TAPE_DRIVE_LOCK_UNLK_IMMED: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147483776u32);
pub const TAPE_DRIVE_LOG_BLK_IMMED: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147516416u32);
pub const TAPE_DRIVE_LOGICAL_BLK: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147500032u32);
pub const TAPE_DRIVE_RELATIVE_BLKS: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147614720u32);
pub const TAPE_DRIVE_REVERSE_POSITION: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2151677952u32);
pub const TAPE_DRIVE_REWIND_IMMEDIATE: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147483656u32);
pub const TAPE_DRIVE_SEQUENTIAL_FMKS: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2148007936u32);
pub const TAPE_DRIVE_SEQUENTIAL_SMKS: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2149580800u32);
pub const TAPE_DRIVE_SET_BLOCK_SIZE: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147483664u32);
pub const TAPE_DRIVE_SET_COMPRESSION: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147484160u32);
pub const TAPE_DRIVE_SET_ECC: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147483904u32);
pub const TAPE_DRIVE_SET_PADDING: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147484672u32);
pub const TAPE_DRIVE_SET_REPORT_SMKS: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147485696u32);
pub const TAPE_DRIVE_SETMARKS: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2148532224u32);
pub const TAPE_DRIVE_SPACE_IMMEDIATE: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2155872256u32);
pub const TAPE_DRIVE_TENSION: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147483650u32);
pub const TAPE_DRIVE_TENSION_IMMED: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2147483712u32);
pub const TAPE_DRIVE_WRITE_FILEMARKS: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2181038080u32);
pub const TAPE_DRIVE_WRITE_LONG_FMKS: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2281701376u32);
pub const TAPE_DRIVE_WRITE_MARK_IMMED: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2415919104u32);
pub const TAPE_DRIVE_WRITE_SETMARKS: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2164260864u32);
pub const TAPE_DRIVE_WRITE_SHORT_FMKS: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH =
    TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH(2214592512u32);
impl ::std::convert::From<u32> for TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct TAPE_GET_MEDIA_PARAMETERS {
    pub Capacity: i64,
    pub Remaining: i64,
    pub BlockSize: u32,
    pub PartitionCount: u32,
    pub WriteProtected: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl TAPE_GET_MEDIA_PARAMETERS {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for TAPE_GET_MEDIA_PARAMETERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for TAPE_GET_MEDIA_PARAMETERS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TAPE_GET_MEDIA_PARAMETERS")
            .field("Capacity", &self.Capacity)
            .field("Remaining", &self.Remaining)
            .field("BlockSize", &self.BlockSize)
            .field("PartitionCount", &self.PartitionCount)
            .field("WriteProtected", &self.WriteProtected)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for TAPE_GET_MEDIA_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.Capacity == other.Capacity
            && self.Remaining == other.Remaining
            && self.BlockSize == other.BlockSize
            && self.PartitionCount == other.PartitionCount
            && self.WriteProtected == other.WriteProtected
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for TAPE_GET_MEDIA_PARAMETERS {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for TAPE_GET_MEDIA_PARAMETERS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Storage_FileSystem")]
pub struct TAPE_GET_POSITION {
    pub Type: super::super::Storage::FileSystem::TAPE_POSITION_TYPE,
    pub Partition: u32,
    pub Offset: i64,
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl TAPE_GET_POSITION {}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::default::Default for TAPE_GET_POSITION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::fmt::Debug for TAPE_GET_POSITION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TAPE_GET_POSITION")
            .field("Type", &self.Type)
            .field("Partition", &self.Partition)
            .field("Offset", &self.Offset)
            .finish()
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::PartialEq for TAPE_GET_POSITION {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type && self.Partition == other.Partition && self.Offset == other.Offset
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::Eq for TAPE_GET_POSITION {}
#[cfg(feature = "Win32_Storage_FileSystem")]
unsafe impl ::windows::runtime::Abi for TAPE_GET_POSITION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TAPE_GET_STATISTICS {
    pub Operation: u32,
}
impl TAPE_GET_STATISTICS {}
impl ::std::default::Default for TAPE_GET_STATISTICS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TAPE_GET_STATISTICS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TAPE_GET_STATISTICS")
            .field("Operation", &self.Operation)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TAPE_GET_STATISTICS {
    fn eq(&self, other: &Self) -> bool {
        self.Operation == other.Operation
    }
}
impl ::std::cmp::Eq for TAPE_GET_STATISTICS {}
unsafe impl ::windows::runtime::Abi for TAPE_GET_STATISTICS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
pub struct TAPE_PREPARE {
    pub Operation: super::super::Storage::FileSystem::PREPARE_TAPE_OPERATION,
    pub Immediate: super::super::Foundation::BOOLEAN,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl TAPE_PREPARE {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl ::std::default::Default for TAPE_PREPARE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl ::std::fmt::Debug for TAPE_PREPARE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TAPE_PREPARE")
            .field("Operation", &self.Operation)
            .field("Immediate", &self.Immediate)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl ::std::cmp::PartialEq for TAPE_PREPARE {
    fn eq(&self, other: &Self) -> bool {
        self.Operation == other.Operation && self.Immediate == other.Immediate
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl ::std::cmp::Eq for TAPE_PREPARE {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
unsafe impl ::windows::runtime::Abi for TAPE_PREPARE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const TAPE_PSEUDO_LOGICAL_BLOCK: i32 = 3i32;
pub const TAPE_PSEUDO_LOGICAL_POSITION: i32 = 2i32;
pub const TAPE_QUERY_DEVICE_ERROR_DATA: i32 = 4i32;
pub const TAPE_QUERY_DRIVE_PARAMETERS: i32 = 0i32;
pub const TAPE_QUERY_IO_ERROR_DATA: i32 = 3i32;
pub const TAPE_QUERY_MEDIA_CAPACITY: i32 = 1i32;
pub const TAPE_RESET_STATISTICS: i32 = 2i32;
pub const TAPE_RETURN_ENV_INFO: i32 = 1i32;
pub const TAPE_RETURN_STATISTICS: i32 = 0i32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct TAPE_SET_DRIVE_PARAMETERS {
    pub ECC: super::super::Foundation::BOOLEAN,
    pub Compression: super::super::Foundation::BOOLEAN,
    pub DataPadding: super::super::Foundation::BOOLEAN,
    pub ReportSetmarks: super::super::Foundation::BOOLEAN,
    pub EOTWarningZoneSize: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl TAPE_SET_DRIVE_PARAMETERS {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for TAPE_SET_DRIVE_PARAMETERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for TAPE_SET_DRIVE_PARAMETERS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TAPE_SET_DRIVE_PARAMETERS")
            .field("ECC", &self.ECC)
            .field("Compression", &self.Compression)
            .field("DataPadding", &self.DataPadding)
            .field("ReportSetmarks", &self.ReportSetmarks)
            .field("EOTWarningZoneSize", &self.EOTWarningZoneSize)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for TAPE_SET_DRIVE_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.ECC == other.ECC
            && self.Compression == other.Compression
            && self.DataPadding == other.DataPadding
            && self.ReportSetmarks == other.ReportSetmarks
            && self.EOTWarningZoneSize == other.EOTWarningZoneSize
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for TAPE_SET_DRIVE_PARAMETERS {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for TAPE_SET_DRIVE_PARAMETERS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TAPE_SET_MEDIA_PARAMETERS {
    pub BlockSize: u32,
}
impl TAPE_SET_MEDIA_PARAMETERS {}
impl ::std::default::Default for TAPE_SET_MEDIA_PARAMETERS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TAPE_SET_MEDIA_PARAMETERS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TAPE_SET_MEDIA_PARAMETERS")
            .field("BlockSize", &self.BlockSize)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TAPE_SET_MEDIA_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.BlockSize == other.BlockSize
    }
}
impl ::std::cmp::Eq for TAPE_SET_MEDIA_PARAMETERS {}
unsafe impl ::windows::runtime::Abi for TAPE_SET_MEDIA_PARAMETERS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
pub struct TAPE_SET_POSITION {
    pub Method: super::super::Storage::FileSystem::TAPE_POSITION_METHOD,
    pub Partition: u32,
    pub Offset: i64,
    pub Immediate: super::super::Foundation::BOOLEAN,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl TAPE_SET_POSITION {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl ::std::default::Default for TAPE_SET_POSITION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl ::std::fmt::Debug for TAPE_SET_POSITION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TAPE_SET_POSITION")
            .field("Method", &self.Method)
            .field("Partition", &self.Partition)
            .field("Offset", &self.Offset)
            .field("Immediate", &self.Immediate)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl ::std::cmp::PartialEq for TAPE_SET_POSITION {
    fn eq(&self, other: &Self) -> bool {
        self.Method == other.Method
            && self.Partition == other.Partition
            && self.Offset == other.Offset
            && self.Immediate == other.Immediate
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl ::std::cmp::Eq for TAPE_SET_POSITION {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
unsafe impl ::windows::runtime::Abi for TAPE_SET_POSITION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TAPE_STATISTICS {
    pub Version: u32,
    pub Flags: u32,
    pub RecoveredWrites: i64,
    pub UnrecoveredWrites: i64,
    pub RecoveredReads: i64,
    pub UnrecoveredReads: i64,
    pub CompressionRatioReads: u8,
    pub CompressionRatioWrites: u8,
}
impl TAPE_STATISTICS {}
impl ::std::default::Default for TAPE_STATISTICS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TAPE_STATISTICS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TAPE_STATISTICS")
            .field("Version", &self.Version)
            .field("Flags", &self.Flags)
            .field("RecoveredWrites", &self.RecoveredWrites)
            .field("UnrecoveredWrites", &self.UnrecoveredWrites)
            .field("RecoveredReads", &self.RecoveredReads)
            .field("UnrecoveredReads", &self.UnrecoveredReads)
            .field("CompressionRatioReads", &self.CompressionRatioReads)
            .field("CompressionRatioWrites", &self.CompressionRatioWrites)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TAPE_STATISTICS {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Flags == other.Flags
            && self.RecoveredWrites == other.RecoveredWrites
            && self.UnrecoveredWrites == other.UnrecoveredWrites
            && self.RecoveredReads == other.RecoveredReads
            && self.UnrecoveredReads == other.UnrecoveredReads
            && self.CompressionRatioReads == other.CompressionRatioReads
            && self.CompressionRatioWrites == other.CompressionRatioWrites
    }
}
impl ::std::cmp::Eq for TAPE_STATISTICS {}
unsafe impl ::windows::runtime::Abi for TAPE_STATISTICS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TAPE_WMI_OPERATIONS {
    pub Method: u32,
    pub DataBufferSize: u32,
    pub DataBuffer: *mut ::std::ffi::c_void,
}
impl TAPE_WMI_OPERATIONS {}
impl ::std::default::Default for TAPE_WMI_OPERATIONS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TAPE_WMI_OPERATIONS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TAPE_WMI_OPERATIONS")
            .field("Method", &self.Method)
            .field("DataBufferSize", &self.DataBufferSize)
            .field("DataBuffer", &self.DataBuffer)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TAPE_WMI_OPERATIONS {
    fn eq(&self, other: &Self) -> bool {
        self.Method == other.Method
            && self.DataBufferSize == other.DataBufferSize
            && self.DataBuffer == other.DataBuffer
    }
}
impl ::std::cmp::Eq for TAPE_WMI_OPERATIONS {}
unsafe impl ::windows::runtime::Abi for TAPE_WMI_OPERATIONS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
pub struct TAPE_WRITE_MARKS {
    pub Type: super::super::Storage::FileSystem::TAPEMARK_TYPE,
    pub Count: u32,
    pub Immediate: super::super::Foundation::BOOLEAN,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl TAPE_WRITE_MARKS {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl ::std::default::Default for TAPE_WRITE_MARKS {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl ::std::fmt::Debug for TAPE_WRITE_MARKS {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TAPE_WRITE_MARKS")
            .field("Type", &self.Type)
            .field("Count", &self.Count)
            .field("Immediate", &self.Immediate)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl ::std::cmp::PartialEq for TAPE_WRITE_MARKS {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type && self.Count == other.Count && self.Immediate == other.Immediate
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
impl ::std::cmp::Eq for TAPE_WRITE_MARKS {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem"))]
unsafe impl ::windows::runtime::Abi for TAPE_WRITE_MARKS {
    type Abi = Self;
    type DefaultType = Self;
}
pub const TC_DEVICEDUMP_SUBSECTION_DESC_LENGTH: u32 = 16u32;
pub const TC_PATHOBJ: u32 = 2u32;
pub const TC_PUBLIC_DEVICEDUMP_CONTENT_GPLOG: u32 = 2u32;
pub const TC_PUBLIC_DEVICEDUMP_CONTENT_GPLOG_MAX: u32 = 16u32;
pub const TC_PUBLIC_DEVICEDUMP_CONTENT_SMART: u32 = 1u32;
pub const TC_RECTANGLES: u32 = 0u32;
#[repr(C)]
#[derive(
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
)]
pub struct TEB(pub u8);
pub const TELEMETRY_COMMAND_SIZE: u32 = 16u32;
pub const THREAD_BASE_PRIORITY_IDLE: i32 = -15i32;
pub const THREAD_BASE_PRIORITY_LOWRT: u32 = 15u32;
pub const THREAD_BASE_PRIORITY_MAX: u32 = 2u32;
pub const THREAD_BASE_PRIORITY_MIN: i32 = -2i32;
pub const THREAD_DYNAMIC_CODE_ALLOW: u32 = 1u32;
pub const THREAD_PROFILING_FLAG_DISPATCH: u32 = 1u32;
pub const TIMER_MODIFY_STATE: u32 = 2u32;
pub const TIMER_QUERY_STATE: u32 = 1u32;
pub const TIME_CALLBACK_EVENT_PULSE: u32 = 32u32;
pub const TIME_CALLBACK_EVENT_SET: u32 = 16u32;
pub const TIME_CALLBACK_FUNCTION: u32 = 0u32;
pub const TIME_KILL_SYNCHRONOUS: u32 = 256u32;
pub const TIME_ONESHOT: u32 = 0u32;
pub const TIME_PERIODIC: u32 = 1u32;
pub const TIME_ZONE_ID_DAYLIGHT: u32 = 2u32;
pub const TIME_ZONE_ID_STANDARD: u32 = 1u32;
pub const TIME_ZONE_ID_UNKNOWN: u32 = 0u32;
pub const TLS_MINIMUM_AVAILABLE: u32 = 64u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct TOKEN_BNO_ISOLATION_INFORMATION {
    pub IsolationPrefix: super::super::Foundation::PWSTR,
    pub IsolationEnabled: super::super::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl TOKEN_BNO_ISOLATION_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for TOKEN_BNO_ISOLATION_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for TOKEN_BNO_ISOLATION_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TOKEN_BNO_ISOLATION_INFORMATION")
            .field("IsolationPrefix", &self.IsolationPrefix)
            .field("IsolationEnabled", &self.IsolationEnabled)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for TOKEN_BNO_ISOLATION_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.IsolationPrefix == other.IsolationPrefix
            && self.IsolationEnabled == other.IsolationEnabled
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for TOKEN_BNO_ISOLATION_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for TOKEN_BNO_ISOLATION_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct TOKEN_SID_INFORMATION {
    pub Sid: super::super::Foundation::PSID,
}
#[cfg(feature = "Win32_Foundation")]
impl TOKEN_SID_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for TOKEN_SID_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for TOKEN_SID_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TOKEN_SID_INFORMATION")
            .field("Sid", &self.Sid)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for TOKEN_SID_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.Sid == other.Sid
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for TOKEN_SID_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for TOKEN_SID_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const TOKEN_SOURCE_LENGTH: u32 = 8u32;
#[cfg(feature = "Win32_System_Threading")]
impl ::std::clone::Clone for TP_CALLBACK_ENVIRON_V3 {
    fn clone(&self) -> Self {
        unimplemented!()
    }
}
#[repr(C)]
#[cfg(feature = "Win32_System_Threading")]
pub struct TP_CALLBACK_ENVIRON_V3 {
    pub Version: u32,
    pub Pool: super::Threading::PTP_POOL,
    pub CleanupGroup: isize,
    pub CleanupGroupCancelCallback: ::std::option::Option<PTP_CLEANUP_GROUP_CANCEL_CALLBACK>,
    pub RaceDll: *mut ::std::ffi::c_void,
    pub ActivationContext: isize,
    pub FinalizationCallback: ::std::option::Option<PTP_SIMPLE_CALLBACK>,
    pub u: TP_CALLBACK_ENVIRON_V3_1,
    pub CallbackPriority: TP_CALLBACK_PRIORITY,
    pub Size: u32,
}
#[cfg(feature = "Win32_System_Threading")]
impl TP_CALLBACK_ENVIRON_V3 {}
#[cfg(feature = "Win32_System_Threading")]
impl ::std::default::Default for TP_CALLBACK_ENVIRON_V3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Threading")]
impl ::std::cmp::PartialEq for TP_CALLBACK_ENVIRON_V3 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_Threading")]
impl ::std::cmp::Eq for TP_CALLBACK_ENVIRON_V3 {}
#[cfg(feature = "Win32_System_Threading")]
unsafe impl ::windows::runtime::Abi for TP_CALLBACK_ENVIRON_V3 {
    type Abi = ::std::mem::ManuallyDrop<Self>;
    type DefaultType = Self;
}
#[repr(C)]
#[derive(
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
)]
pub struct TP_CALLBACK_ENVIRON_V3_0(pub u8);
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union TP_CALLBACK_ENVIRON_V3_1 {
    pub Flags: u32,
    pub s: TP_CALLBACK_ENVIRON_V3_1_0,
}
impl TP_CALLBACK_ENVIRON_V3_1 {}
impl ::std::default::Default for TP_CALLBACK_ENVIRON_V3_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for TP_CALLBACK_ENVIRON_V3_1 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for TP_CALLBACK_ENVIRON_V3_1 {}
unsafe impl ::windows::runtime::Abi for TP_CALLBACK_ENVIRON_V3_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TP_CALLBACK_ENVIRON_V3_1_0 {
    pub _bitfield: u32,
}
impl TP_CALLBACK_ENVIRON_V3_1_0 {}
impl ::std::default::Default for TP_CALLBACK_ENVIRON_V3_1_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TP_CALLBACK_ENVIRON_V3_1_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_s_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TP_CALLBACK_ENVIRON_V3_1_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for TP_CALLBACK_ENVIRON_V3_1_0 {}
unsafe impl ::windows::runtime::Abi for TP_CALLBACK_ENVIRON_V3_1_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[repr(C)]
#[derive(
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
)]
pub struct TP_CALLBACK_INSTANCE(pub u8);
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct TP_CALLBACK_PRIORITY(pub i32);
pub const TP_CALLBACK_PRIORITY_HIGH: TP_CALLBACK_PRIORITY = TP_CALLBACK_PRIORITY(0i32);
pub const TP_CALLBACK_PRIORITY_NORMAL: TP_CALLBACK_PRIORITY = TP_CALLBACK_PRIORITY(1i32);
pub const TP_CALLBACK_PRIORITY_LOW: TP_CALLBACK_PRIORITY = TP_CALLBACK_PRIORITY(2i32);
pub const TP_CALLBACK_PRIORITY_INVALID: TP_CALLBACK_PRIORITY = TP_CALLBACK_PRIORITY(3i32);
pub const TP_CALLBACK_PRIORITY_COUNT: TP_CALLBACK_PRIORITY = TP_CALLBACK_PRIORITY(3i32);
impl ::std::convert::From<i32> for TP_CALLBACK_PRIORITY {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for TP_CALLBACK_PRIORITY {
    type Abi = Self;
    type DefaultType = Self;
}
#[repr(C)]
#[derive(
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
)]
pub struct TP_CLEANUP_GROUP(pub u8);
#[repr(C)]
#[derive(
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
)]
pub struct TP_IO(pub u8);
#[repr(C)]
#[derive(
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
)]
pub struct TP_POOL(pub u8);
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TP_POOL_STACK_INFORMATION {
    pub StackReserve: usize,
    pub StackCommit: usize,
}
impl TP_POOL_STACK_INFORMATION {}
impl ::std::default::Default for TP_POOL_STACK_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TP_POOL_STACK_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TP_POOL_STACK_INFORMATION")
            .field("StackReserve", &self.StackReserve)
            .field("StackCommit", &self.StackCommit)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TP_POOL_STACK_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.StackReserve == other.StackReserve && self.StackCommit == other.StackCommit
    }
}
impl ::std::cmp::Eq for TP_POOL_STACK_INFORMATION {}
unsafe impl ::windows::runtime::Abi for TP_POOL_STACK_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[repr(C)]
#[derive(
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
)]
pub struct TP_TIMER(pub u8);
#[repr(C)]
#[derive(
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
)]
pub struct TP_WAIT(pub u8);
#[repr(C)]
#[derive(
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
)]
pub struct TP_WORK(pub u8);
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TRANSACTIONMANAGER_BASIC_INFORMATION {
    pub TmIdentity: ::windows::runtime::GUID,
    pub VirtualClock: i64,
}
impl TRANSACTIONMANAGER_BASIC_INFORMATION {}
impl ::std::default::Default for TRANSACTIONMANAGER_BASIC_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TRANSACTIONMANAGER_BASIC_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TRANSACTIONMANAGER_BASIC_INFORMATION")
            .field("TmIdentity", &self.TmIdentity)
            .field("VirtualClock", &self.VirtualClock)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TRANSACTIONMANAGER_BASIC_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.TmIdentity == other.TmIdentity && self.VirtualClock == other.VirtualClock
    }
}
impl ::std::cmp::Eq for TRANSACTIONMANAGER_BASIC_INFORMATION {}
unsafe impl ::windows::runtime::Abi for TRANSACTIONMANAGER_BASIC_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const TRANSACTIONMANAGER_BIND_TRANSACTION: u32 = 32u32;
pub const TRANSACTIONMANAGER_CREATE_RM: u32 = 16u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct TRANSACTIONMANAGER_INFORMATION_CLASS(pub i32);
pub const TransactionManagerBasicInformation: TRANSACTIONMANAGER_INFORMATION_CLASS =
    TRANSACTIONMANAGER_INFORMATION_CLASS(0i32);
pub const TransactionManagerLogInformation: TRANSACTIONMANAGER_INFORMATION_CLASS =
    TRANSACTIONMANAGER_INFORMATION_CLASS(1i32);
pub const TransactionManagerLogPathInformation: TRANSACTIONMANAGER_INFORMATION_CLASS =
    TRANSACTIONMANAGER_INFORMATION_CLASS(2i32);
pub const TransactionManagerRecoveryInformation: TRANSACTIONMANAGER_INFORMATION_CLASS =
    TRANSACTIONMANAGER_INFORMATION_CLASS(4i32);
pub const TransactionManagerOnlineProbeInformation: TRANSACTIONMANAGER_INFORMATION_CLASS =
    TRANSACTIONMANAGER_INFORMATION_CLASS(3i32);
pub const TransactionManagerOldestTransactionInformation: TRANSACTIONMANAGER_INFORMATION_CLASS =
    TRANSACTIONMANAGER_INFORMATION_CLASS(5i32);
impl ::std::convert::From<i32> for TRANSACTIONMANAGER_INFORMATION_CLASS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for TRANSACTIONMANAGER_INFORMATION_CLASS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    pub LogPathLength: u32,
    pub LogPath: [u16; 1],
}
impl TRANSACTIONMANAGER_LOGPATH_INFORMATION {}
impl ::std::default::Default for TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TRANSACTIONMANAGER_LOGPATH_INFORMATION")
            .field("LogPathLength", &self.LogPathLength)
            .field("LogPath", &self.LogPath)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.LogPathLength == other.LogPathLength && self.LogPath == other.LogPath
    }
}
impl ::std::cmp::Eq for TRANSACTIONMANAGER_LOGPATH_INFORMATION {}
unsafe impl ::windows::runtime::Abi for TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TRANSACTIONMANAGER_LOG_INFORMATION {
    pub LogIdentity: ::windows::runtime::GUID,
}
impl TRANSACTIONMANAGER_LOG_INFORMATION {}
impl ::std::default::Default for TRANSACTIONMANAGER_LOG_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TRANSACTIONMANAGER_LOG_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TRANSACTIONMANAGER_LOG_INFORMATION")
            .field("LogIdentity", &self.LogIdentity)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TRANSACTIONMANAGER_LOG_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.LogIdentity == other.LogIdentity
    }
}
impl ::std::cmp::Eq for TRANSACTIONMANAGER_LOG_INFORMATION {}
unsafe impl ::windows::runtime::Abi for TRANSACTIONMANAGER_LOG_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TRANSACTIONMANAGER_OLDEST_INFORMATION {
    pub OldestTransactionGuid: ::windows::runtime::GUID,
}
impl TRANSACTIONMANAGER_OLDEST_INFORMATION {}
impl ::std::default::Default for TRANSACTIONMANAGER_OLDEST_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TRANSACTIONMANAGER_OLDEST_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TRANSACTIONMANAGER_OLDEST_INFORMATION")
            .field("OldestTransactionGuid", &self.OldestTransactionGuid)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TRANSACTIONMANAGER_OLDEST_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.OldestTransactionGuid == other.OldestTransactionGuid
    }
}
impl ::std::cmp::Eq for TRANSACTIONMANAGER_OLDEST_INFORMATION {}
unsafe impl ::windows::runtime::Abi for TRANSACTIONMANAGER_OLDEST_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const TRANSACTIONMANAGER_QUERY_INFORMATION: u32 = 1u32;
pub const TRANSACTIONMANAGER_RECOVER: u32 = 4u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    pub LastRecoveredLsn: u64,
}
impl TRANSACTIONMANAGER_RECOVERY_INFORMATION {}
impl ::std::default::Default for TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TRANSACTIONMANAGER_RECOVERY_INFORMATION")
            .field("LastRecoveredLsn", &self.LastRecoveredLsn)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.LastRecoveredLsn == other.LastRecoveredLsn
    }
}
impl ::std::cmp::Eq for TRANSACTIONMANAGER_RECOVERY_INFORMATION {}
unsafe impl ::windows::runtime::Abi for TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const TRANSACTIONMANAGER_RENAME: u32 = 8u32;
pub const TRANSACTIONMANAGER_SET_INFORMATION: u32 = 2u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TRANSACTION_BASIC_INFORMATION {
    pub TransactionId: ::windows::runtime::GUID,
    pub State: u32,
    pub Outcome: u32,
}
impl TRANSACTION_BASIC_INFORMATION {}
impl ::std::default::Default for TRANSACTION_BASIC_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TRANSACTION_BASIC_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TRANSACTION_BASIC_INFORMATION")
            .field("TransactionId", &self.TransactionId)
            .field("State", &self.State)
            .field("Outcome", &self.Outcome)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TRANSACTION_BASIC_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.TransactionId == other.TransactionId
            && self.State == other.State
            && self.Outcome == other.Outcome
    }
}
impl ::std::cmp::Eq for TRANSACTION_BASIC_INFORMATION {}
unsafe impl ::windows::runtime::Abi for TRANSACTION_BASIC_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct TRANSACTION_BIND_INFORMATION {
    pub TmHandle: super::super::Foundation::HANDLE,
}
#[cfg(feature = "Win32_Foundation")]
impl TRANSACTION_BIND_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for TRANSACTION_BIND_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for TRANSACTION_BIND_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TRANSACTION_BIND_INFORMATION")
            .field("TmHandle", &self.TmHandle)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for TRANSACTION_BIND_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.TmHandle == other.TmHandle
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for TRANSACTION_BIND_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for TRANSACTION_BIND_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const TRANSACTION_COMMIT: u32 = 8u32;
pub const TRANSACTION_ENLIST: u32 = 4u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TRANSACTION_ENLISTMENTS_INFORMATION {
    pub NumberOfEnlistments: u32,
    pub EnlistmentPair: [TRANSACTION_ENLISTMENT_PAIR; 1],
}
impl TRANSACTION_ENLISTMENTS_INFORMATION {}
impl ::std::default::Default for TRANSACTION_ENLISTMENTS_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TRANSACTION_ENLISTMENTS_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TRANSACTION_ENLISTMENTS_INFORMATION")
            .field("NumberOfEnlistments", &self.NumberOfEnlistments)
            .field("EnlistmentPair", &self.EnlistmentPair)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TRANSACTION_ENLISTMENTS_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NumberOfEnlistments == other.NumberOfEnlistments
            && self.EnlistmentPair == other.EnlistmentPair
    }
}
impl ::std::cmp::Eq for TRANSACTION_ENLISTMENTS_INFORMATION {}
unsafe impl ::windows::runtime::Abi for TRANSACTION_ENLISTMENTS_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TRANSACTION_ENLISTMENT_PAIR {
    pub EnlistmentId: ::windows::runtime::GUID,
    pub ResourceManagerId: ::windows::runtime::GUID,
}
impl TRANSACTION_ENLISTMENT_PAIR {}
impl ::std::default::Default for TRANSACTION_ENLISTMENT_PAIR {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TRANSACTION_ENLISTMENT_PAIR {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TRANSACTION_ENLISTMENT_PAIR")
            .field("EnlistmentId", &self.EnlistmentId)
            .field("ResourceManagerId", &self.ResourceManagerId)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TRANSACTION_ENLISTMENT_PAIR {
    fn eq(&self, other: &Self) -> bool {
        self.EnlistmentId == other.EnlistmentId && self.ResourceManagerId == other.ResourceManagerId
    }
}
impl ::std::cmp::Eq for TRANSACTION_ENLISTMENT_PAIR {}
unsafe impl ::windows::runtime::Abi for TRANSACTION_ENLISTMENT_PAIR {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct TRANSACTION_INFORMATION_CLASS(pub i32);
pub const TransactionBasicInformation: TRANSACTION_INFORMATION_CLASS =
    TRANSACTION_INFORMATION_CLASS(0i32);
pub const TransactionPropertiesInformation: TRANSACTION_INFORMATION_CLASS =
    TRANSACTION_INFORMATION_CLASS(1i32);
pub const TransactionEnlistmentInformation: TRANSACTION_INFORMATION_CLASS =
    TRANSACTION_INFORMATION_CLASS(2i32);
pub const TransactionSuperiorEnlistmentInformation: TRANSACTION_INFORMATION_CLASS =
    TRANSACTION_INFORMATION_CLASS(3i32);
pub const TransactionBindInformation: TRANSACTION_INFORMATION_CLASS =
    TRANSACTION_INFORMATION_CLASS(4i32);
pub const TransactionDTCPrivateInformation: TRANSACTION_INFORMATION_CLASS =
    TRANSACTION_INFORMATION_CLASS(5i32);
impl ::std::convert::From<i32> for TRANSACTION_INFORMATION_CLASS {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for TRANSACTION_INFORMATION_CLASS {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TRANSACTION_LIST_ENTRY {
    pub UOW: ::windows::runtime::GUID,
}
impl TRANSACTION_LIST_ENTRY {}
impl ::std::default::Default for TRANSACTION_LIST_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TRANSACTION_LIST_ENTRY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TRANSACTION_LIST_ENTRY")
            .field("UOW", &self.UOW)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TRANSACTION_LIST_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.UOW == other.UOW
    }
}
impl ::std::cmp::Eq for TRANSACTION_LIST_ENTRY {}
unsafe impl ::windows::runtime::Abi for TRANSACTION_LIST_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TRANSACTION_LIST_INFORMATION {
    pub NumberOfTransactions: u32,
    pub TransactionInformation: [TRANSACTION_LIST_ENTRY; 1],
}
impl TRANSACTION_LIST_INFORMATION {}
impl ::std::default::Default for TRANSACTION_LIST_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TRANSACTION_LIST_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TRANSACTION_LIST_INFORMATION")
            .field("NumberOfTransactions", &self.NumberOfTransactions)
            .field("TransactionInformation", &self.TransactionInformation)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TRANSACTION_LIST_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NumberOfTransactions == other.NumberOfTransactions
            && self.TransactionInformation == other.TransactionInformation
    }
}
impl ::std::cmp::Eq for TRANSACTION_LIST_INFORMATION {}
unsafe impl ::windows::runtime::Abi for TRANSACTION_LIST_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const TRANSACTION_PROPAGATE: u32 = 32u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TRANSACTION_PROPERTIES_INFORMATION {
    pub IsolationLevel: u32,
    pub IsolationFlags: u32,
    pub Timeout: i64,
    pub Outcome: u32,
    pub DescriptionLength: u32,
    pub Description: [u16; 1],
}
impl TRANSACTION_PROPERTIES_INFORMATION {}
impl ::std::default::Default for TRANSACTION_PROPERTIES_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TRANSACTION_PROPERTIES_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TRANSACTION_PROPERTIES_INFORMATION")
            .field("IsolationLevel", &self.IsolationLevel)
            .field("IsolationFlags", &self.IsolationFlags)
            .field("Timeout", &self.Timeout)
            .field("Outcome", &self.Outcome)
            .field("DescriptionLength", &self.DescriptionLength)
            .field("Description", &self.Description)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TRANSACTION_PROPERTIES_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.IsolationLevel == other.IsolationLevel
            && self.IsolationFlags == other.IsolationFlags
            && self.Timeout == other.Timeout
            && self.Outcome == other.Outcome
            && self.DescriptionLength == other.DescriptionLength
            && self.Description == other.Description
    }
}
impl ::std::cmp::Eq for TRANSACTION_PROPERTIES_INFORMATION {}
unsafe impl ::windows::runtime::Abi for TRANSACTION_PROPERTIES_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const TRANSACTION_QUERY_INFORMATION: u32 = 1u32;
pub const TRANSACTION_RIGHT_RESERVED1: u32 = 64u32;
pub const TRANSACTION_ROLLBACK: u32 = 16u32;
pub const TRANSACTION_SET_INFORMATION: u32 = 2u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct TRANSACTION_STATE(pub i32);
pub const TransactionStateNormal: TRANSACTION_STATE = TRANSACTION_STATE(1i32);
pub const TransactionStateIndoubt: TRANSACTION_STATE = TRANSACTION_STATE(2i32);
pub const TransactionStateCommittedNotify: TRANSACTION_STATE = TRANSACTION_STATE(3i32);
impl ::std::convert::From<i32> for TRANSACTION_STATE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for TRANSACTION_STATE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    pub SuperiorEnlistmentPair: TRANSACTION_ENLISTMENT_PAIR,
}
impl TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {}
impl ::std::default::Default for TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION")
            .field("SuperiorEnlistmentPair", &self.SuperiorEnlistmentPair)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.SuperiorEnlistmentPair == other.SuperiorEnlistmentPair
    }
}
impl ::std::cmp::Eq for TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {}
unsafe impl ::windows::runtime::Abi for TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const TREE_CONNECT_ATTRIBUTE_GLOBAL: u32 = 4u32;
pub const TREE_CONNECT_ATTRIBUTE_INTEGRITY: u32 = 32768u32;
pub const TREE_CONNECT_ATTRIBUTE_PINNED: u32 = 2u32;
pub const TREE_CONNECT_ATTRIBUTE_PRIVACY: u32 = 16384u32;
pub const TRUST_PROTECTED_FILTER_ACE_FLAG: u32 = 64u32;
pub const TTO_METRICS_ONLY: u32 = 1u32;
pub const TTO_QUBICS: u32 = 2u32;
pub const TTO_UNHINTED: u32 = 4u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct TTTOOLINFO_FLAGS(pub u32);
pub const TTF_ABSOLUTE: TTTOOLINFO_FLAGS = TTTOOLINFO_FLAGS(128u32);
pub const TTF_CENTERTIP: TTTOOLINFO_FLAGS = TTTOOLINFO_FLAGS(2u32);
pub const TTF_IDISHWND: TTTOOLINFO_FLAGS = TTTOOLINFO_FLAGS(1u32);
pub const TTF_PARSELINKS: TTTOOLINFO_FLAGS = TTTOOLINFO_FLAGS(4096u32);
pub const TTF_RTLREADING: TTTOOLINFO_FLAGS = TTTOOLINFO_FLAGS(4u32);
pub const TTF_SUBCLASS: TTTOOLINFO_FLAGS = TTTOOLINFO_FLAGS(16u32);
pub const TTF_TRACK: TTTOOLINFO_FLAGS = TTTOOLINFO_FLAGS(32u32);
pub const TTF_TRANSPARENT: TTTOOLINFO_FLAGS = TTTOOLINFO_FLAGS(256u32);
impl ::std::convert::From<u32> for TTTOOLINFO_FLAGS {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for TTTOOLINFO_FLAGS {
    type Abi = Self;
    type DefaultType = Self;
}
impl ::std::ops::BitOr for TTTOOLINFO_FLAGS {
    type Output = Self;
    fn bitor(self, rhs: Self) -> Self {
        Self(self.0 | rhs.0)
    }
}
impl ::std::ops::BitAnd for TTTOOLINFO_FLAGS {
    type Output = Self;
    fn bitand(self, rhs: Self) -> Self {
        Self(self.0 & rhs.0)
    }
}
impl ::std::ops::BitOrAssign for TTTOOLINFO_FLAGS {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0)
    }
}
impl ::std::ops::BitAndAssign for TTTOOLINFO_FLAGS {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0)
    }
}
impl ::std::ops::Not for TTTOOLINFO_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
pub const TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_CREATED: u32 = 1u32;
pub const TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_DELETED: u32 = 2u32;
pub const TXFS_LOGGING_MODE_FULL: u32 = 2u32;
pub const TXFS_LOGGING_MODE_SIMPLE: u32 = 1u32;
pub const TXFS_RM_STATE_ACTIVE: u32 = 2u32;
pub const TXFS_RM_STATE_NOT_STARTED: u32 = 0u32;
pub const TXFS_RM_STATE_SHUTTING_DOWN: u32 = 3u32;
pub const TXFS_RM_STATE_STARTING: u32 = 1u32;
pub const TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN: u32 = 1u32;
pub const TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK: u32 = 2u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TXFS_ROLLFORWARD_REDO_INFORMATION {
    pub LastVirtualClock: i64,
    pub LastRedoLsn: u64,
    pub HighestRecoveryLsn: u64,
    pub Flags: u32,
}
impl TXFS_ROLLFORWARD_REDO_INFORMATION {}
impl ::std::default::Default for TXFS_ROLLFORWARD_REDO_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TXFS_ROLLFORWARD_REDO_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TXFS_ROLLFORWARD_REDO_INFORMATION")
            .field("LastVirtualClock", &self.LastVirtualClock)
            .field("LastRedoLsn", &self.LastRedoLsn)
            .field("HighestRecoveryLsn", &self.HighestRecoveryLsn)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TXFS_ROLLFORWARD_REDO_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.LastVirtualClock == other.LastVirtualClock
            && self.LastRedoLsn == other.LastRedoLsn
            && self.HighestRecoveryLsn == other.HighestRecoveryLsn
            && self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for TXFS_ROLLFORWARD_REDO_INFORMATION {}
unsafe impl ::windows::runtime::Abi for TXFS_ROLLFORWARD_REDO_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const TXFS_SAVEPOINT_CLEAR: u32 = 4u32;
pub const TXFS_SAVEPOINT_CLEAR_ALL: u32 = 16u32;
pub const TXFS_SAVEPOINT_ROLLBACK: u32 = 2u32;
pub const TXFS_SAVEPOINT_SET: u32 = 1u32;
pub const TXFS_START_RM_FLAG_LOGGING_MODE: u32 = 1024u32;
pub const TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE: u32 = 32u32;
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX: u32 = 1u32;
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN: u32 = 2u32;
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE: u32 = 4u32;
pub const TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS: u32 = 8u32;
pub const TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT: u32 = 16u32;
pub const TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX: u32 = 64u32;
pub const TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN: u32 = 128u32;
pub const TXFS_START_RM_FLAG_PREFER_AVAILABILITY: u32 = 8192u32;
pub const TXFS_START_RM_FLAG_PREFER_CONSISTENCY: u32 = 4096u32;
pub const TXFS_START_RM_FLAG_PRESERVE_CHANGES: u32 = 2048u32;
pub const TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT: u32 = 512u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct TXFS_START_RM_INFORMATION {
    pub Flags: u32,
    pub LogContainerSize: u64,
    pub LogContainerCountMin: u32,
    pub LogContainerCountMax: u32,
    pub LogGrowthIncrement: u32,
    pub LogAutoShrinkPercentage: u32,
    pub TmLogPathOffset: u32,
    pub TmLogPathLength: u16,
    pub LoggingMode: u16,
    pub LogPathLength: u16,
    pub Reserved: u16,
    pub LogPath: [u16; 1],
}
impl TXFS_START_RM_INFORMATION {}
impl ::std::default::Default for TXFS_START_RM_INFORMATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for TXFS_START_RM_INFORMATION {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("TXFS_START_RM_INFORMATION")
            .field("Flags", &self.Flags)
            .field("LogContainerSize", &self.LogContainerSize)
            .field("LogContainerCountMin", &self.LogContainerCountMin)
            .field("LogContainerCountMax", &self.LogContainerCountMax)
            .field("LogGrowthIncrement", &self.LogGrowthIncrement)
            .field("LogAutoShrinkPercentage", &self.LogAutoShrinkPercentage)
            .field("TmLogPathOffset", &self.TmLogPathOffset)
            .field("TmLogPathLength", &self.TmLogPathLength)
            .field("LoggingMode", &self.LoggingMode)
            .field("LogPathLength", &self.LogPathLength)
            .field("Reserved", &self.Reserved)
            .field("LogPath", &self.LogPath)
            .finish()
    }
}
impl ::std::cmp::PartialEq for TXFS_START_RM_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
            && self.LogContainerSize == other.LogContainerSize
            && self.LogContainerCountMin == other.LogContainerCountMin
            && self.LogContainerCountMax == other.LogContainerCountMax
            && self.LogGrowthIncrement == other.LogGrowthIncrement
            && self.LogAutoShrinkPercentage == other.LogAutoShrinkPercentage
            && self.TmLogPathOffset == other.TmLogPathOffset
            && self.TmLogPathLength == other.TmLogPathLength
            && self.LoggingMode == other.LoggingMode
            && self.LogPathLength == other.LogPathLength
            && self.Reserved == other.Reserved
            && self.LogPath == other.LogPath
    }
}
impl ::std::cmp::Eq for TXFS_START_RM_INFORMATION {}
unsafe impl ::windows::runtime::Abi for TXFS_START_RM_INFORMATION {
    type Abi = Self;
    type DefaultType = Self;
}
pub const TXFS_TRANSACTED_VERSION_NONTRANSACTED: u32 = 4294967294u32;
pub const TXFS_TRANSACTED_VERSION_UNCOMMITTED: u32 = 4294967295u32;
pub const TXFS_TRANSACTION_STATE_ACTIVE: u32 = 1u32;
pub const TXFS_TRANSACTION_STATE_NONE: u32 = 0u32;
pub const TXFS_TRANSACTION_STATE_NOTACTIVE: u32 = 3u32;
pub const TXFS_TRANSACTION_STATE_PREPARED: u32 = 2u32;
pub const UCSCHAR_INVALID_CHARACTER: u32 = 4294967295u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct UMS_CREATE_THREAD_ATTRIBUTES {
    pub UmsVersion: u32,
    pub UmsContext: *mut ::std::ffi::c_void,
    pub UmsCompletionList: *mut ::std::ffi::c_void,
}
impl UMS_CREATE_THREAD_ATTRIBUTES {}
impl ::std::default::Default for UMS_CREATE_THREAD_ATTRIBUTES {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for UMS_CREATE_THREAD_ATTRIBUTES {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("UMS_CREATE_THREAD_ATTRIBUTES")
            .field("UmsVersion", &self.UmsVersion)
            .field("UmsContext", &self.UmsContext)
            .field("UmsCompletionList", &self.UmsCompletionList)
            .finish()
    }
}
impl ::std::cmp::PartialEq for UMS_CREATE_THREAD_ATTRIBUTES {
    fn eq(&self, other: &Self) -> bool {
        self.UmsVersion == other.UmsVersion
            && self.UmsContext == other.UmsContext
            && self.UmsCompletionList == other.UmsCompletionList
    }
}
impl ::std::cmp::Eq for UMS_CREATE_THREAD_ATTRIBUTES {}
unsafe impl ::windows::runtime::Abi for UMS_CREATE_THREAD_ATTRIBUTES {
    type Abi = Self;
    type DefaultType = Self;
}
pub const UNDEFINE_ALTERNATE: u32 = 13u32;
pub const UNDEFINE_PRIMARY: u32 = 12u32;
pub const UNICODE_STRING_MAX_CHARS: u32 = 32767u32;
pub const UNIFIEDBUILDREVISION_MIN: u32 = 0u32;
pub const UNLOCK_ELEMENT: u32 = 1u32;
pub const UNRECOVERED_READS_VALID: u32 = 8u32;
pub const UNRECOVERED_WRITES_VALID: u32 = 2u32;
pub const UNWIND_CHAIN_LIMIT: u32 = 32u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct UNWIND_HISTORY_TABLE {
    pub Count: u32,
    pub LocalHint: u8,
    pub GlobalHint: u8,
    pub Search: u8,
    pub Once: u8,
    pub LowAddress: usize,
    pub HighAddress: usize,
    pub Entry: [UNWIND_HISTORY_TABLE_ENTRY; 12],
}
impl UNWIND_HISTORY_TABLE {}
impl ::std::default::Default for UNWIND_HISTORY_TABLE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for UNWIND_HISTORY_TABLE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("UNWIND_HISTORY_TABLE")
            .field("Count", &self.Count)
            .field("LocalHint", &self.LocalHint)
            .field("GlobalHint", &self.GlobalHint)
            .field("Search", &self.Search)
            .field("Once", &self.Once)
            .field("LowAddress", &self.LowAddress)
            .field("HighAddress", &self.HighAddress)
            .field("Entry", &self.Entry)
            .finish()
    }
}
impl ::std::cmp::PartialEq for UNWIND_HISTORY_TABLE {
    fn eq(&self, other: &Self) -> bool {
        self.Count == other.Count
            && self.LocalHint == other.LocalHint
            && self.GlobalHint == other.GlobalHint
            && self.Search == other.Search
            && self.Once == other.Once
            && self.LowAddress == other.LowAddress
            && self.HighAddress == other.HighAddress
            && self.Entry == other.Entry
    }
}
impl ::std::cmp::Eq for UNWIND_HISTORY_TABLE {}
unsafe impl ::windows::runtime::Abi for UNWIND_HISTORY_TABLE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct UNWIND_HISTORY_TABLE_ENTRY {
    pub ImageBase: usize,
    pub FunctionEntry: *mut IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
}
impl UNWIND_HISTORY_TABLE_ENTRY {}
impl ::std::default::Default for UNWIND_HISTORY_TABLE_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for UNWIND_HISTORY_TABLE_ENTRY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("UNWIND_HISTORY_TABLE_ENTRY")
            .field("ImageBase", &self.ImageBase)
            .field("FunctionEntry", &self.FunctionEntry)
            .finish()
    }
}
impl ::std::cmp::PartialEq for UNWIND_HISTORY_TABLE_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.ImageBase == other.ImageBase && self.FunctionEntry == other.FunctionEntry
    }
}
impl ::std::cmp::Eq for UNWIND_HISTORY_TABLE_ENTRY {}
unsafe impl ::windows::runtime::Abi for UNWIND_HISTORY_TABLE_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
pub const UNWIND_HISTORY_TABLE_SIZE: u32 = 12u32;
pub const UNW_FLAG_NO_EPILOGUE: u32 = 2147483648u32;
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct USER_ACTIVITY_PRESENCE(pub i32);
pub const PowerUserPresent: USER_ACTIVITY_PRESENCE = USER_ACTIVITY_PRESENCE(0i32);
pub const PowerUserNotPresent: USER_ACTIVITY_PRESENCE = USER_ACTIVITY_PRESENCE(1i32);
pub const PowerUserInactive: USER_ACTIVITY_PRESENCE = USER_ACTIVITY_PRESENCE(2i32);
pub const PowerUserMaximum: USER_ACTIVITY_PRESENCE = USER_ACTIVITY_PRESENCE(3i32);
pub const PowerUserInvalid: USER_ACTIVITY_PRESENCE = USER_ACTIVITY_PRESENCE(3i32);
impl ::std::convert::From<i32> for USER_ACTIVITY_PRESENCE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for USER_ACTIVITY_PRESENCE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const USN_DELETE_VALID_FLAGS: u32 = 3u32;
pub const USN_PAGE_SIZE: u32 = 4096u32;
pub const USN_REASON_BASIC_INFO_CHANGE: u32 = 32768u32;
pub const USN_REASON_CLOSE: u32 = 2147483648u32;
pub const USN_REASON_COMPRESSION_CHANGE: u32 = 131072u32;
pub const USN_REASON_DATA_EXTEND: u32 = 2u32;
pub const USN_REASON_DATA_OVERWRITE: u32 = 1u32;
pub const USN_REASON_DATA_TRUNCATION: u32 = 4u32;
pub const USN_REASON_DESIRED_STORAGE_CLASS_CHANGE: u32 = 16777216u32;
pub const USN_REASON_EA_CHANGE: u32 = 1024u32;
pub const USN_REASON_ENCRYPTION_CHANGE: u32 = 262144u32;
pub const USN_REASON_FILE_CREATE: u32 = 256u32;
pub const USN_REASON_FILE_DELETE: u32 = 512u32;
pub const USN_REASON_HARD_LINK_CHANGE: u32 = 65536u32;
pub const USN_REASON_INDEXABLE_CHANGE: u32 = 16384u32;
pub const USN_REASON_INTEGRITY_CHANGE: u32 = 8388608u32;
pub const USN_REASON_NAMED_DATA_EXTEND: u32 = 32u32;
pub const USN_REASON_NAMED_DATA_OVERWRITE: u32 = 16u32;
pub const USN_REASON_NAMED_DATA_TRUNCATION: u32 = 64u32;
pub const USN_REASON_OBJECT_ID_CHANGE: u32 = 524288u32;
pub const USN_REASON_RENAME_NEW_NAME: u32 = 8192u32;
pub const USN_REASON_RENAME_OLD_NAME: u32 = 4096u32;
pub const USN_REASON_REPARSE_POINT_CHANGE: u32 = 1048576u32;
pub const USN_REASON_SECURITY_CHANGE: u32 = 2048u32;
pub const USN_REASON_STREAM_CHANGE: u32 = 2097152u32;
pub const USN_REASON_TRANSACTED_CHANGE: u32 = 4194304u32;
#[cfg(feature = "Win32_Foundation")]
pub unsafe fn UnregisterDeviceNotification(
    handle: *const ::std::ffi::c_void,
) -> super::super::Foundation::BOOL {
    #[cfg(windows)]
    {
        #[link(name = "user32")]
        extern "system" {
            fn UnregisterDeviceNotification(
                handle: *const ::std::ffi::c_void,
            ) -> super::super::Foundation::BOOL;
        }
        ::std::mem::transmute(UnregisterDeviceNotification(::std::mem::transmute(handle)))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub const VALID_INHERIT_FLAGS: u32 = 31u32;
pub const VALID_NTFT: u32 = 192u32;
pub const VBS_BASIC_PAGE_MEASURED_DATA: u32 = 1u32;
pub const VBS_BASIC_PAGE_SYSTEM_CALL: u32 = 5u32;
pub const VBS_BASIC_PAGE_THREAD_DESCRIPTOR: u32 = 4u32;
pub const VBS_BASIC_PAGE_UNMEASURED_DATA: u32 = 2u32;
pub const VBS_BASIC_PAGE_ZERO_FILL: u32 = 3u32;
pub const VENDOR_ID_LENGTH: u32 = 8u32;
pub const VER_AND: u32 = 6u32;
pub const VER_CONDITION_MASK: u32 = 7u32;
pub const VER_EQUAL: u32 = 1u32;
pub const VER_GREATER: u32 = 2u32;
pub const VER_GREATER_EQUAL: u32 = 3u32;
pub const VER_LESS: u32 = 4u32;
pub const VER_LESS_EQUAL: u32 = 5u32;
pub const VER_NT_DOMAIN_CONTROLLER: u32 = 2u32;
pub const VER_NT_SERVER: u32 = 3u32;
pub const VER_NT_WORKSTATION: u32 = 1u32;
pub const VER_NUM_BITS_PER_CONDITION_MASK: u32 = 3u32;
pub const VER_OR: u32 = 7u32;
pub const VER_SERVER_NT: u32 = 2147483648u32;
pub const VER_SUITE_BACKOFFICE: u32 = 4u32;
pub const VER_SUITE_BLADE: u32 = 1024u32;
pub const VER_SUITE_COMMUNICATIONS: u32 = 8u32;
pub const VER_SUITE_COMPUTE_SERVER: u32 = 16384u32;
pub const VER_SUITE_DATACENTER: u32 = 128u32;
pub const VER_SUITE_EMBEDDEDNT: u32 = 64u32;
pub const VER_SUITE_EMBEDDED_RESTRICTED: u32 = 2048u32;
pub const VER_SUITE_ENTERPRISE: u32 = 2u32;
pub const VER_SUITE_MULTIUSERTS: u32 = 131072u32;
pub const VER_SUITE_PERSONAL: u32 = 512u32;
pub const VER_SUITE_SECURITY_APPLIANCE: u32 = 4096u32;
pub const VER_SUITE_SINGLEUSERTS: u32 = 256u32;
pub const VER_SUITE_SMALLBUSINESS: u32 = 1u32;
pub const VER_SUITE_SMALLBUSINESS_RESTRICTED: u32 = 32u32;
pub const VER_SUITE_STORAGE_SERVER: u32 = 8192u32;
pub const VER_SUITE_TERMINAL: u32 = 16u32;
pub const VER_SUITE_WH_SERVER: u32 = 32768u32;
pub const VER_WORKSTATION_NT: u32 = 1073741824u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct VIRTUALIZATION_INSTANCE_INFO_INPUT {
    pub NumberOfWorkerThreads: u32,
    pub Flags: u32,
}
impl VIRTUALIZATION_INSTANCE_INFO_INPUT {}
impl ::std::default::Default for VIRTUALIZATION_INSTANCE_INFO_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for VIRTUALIZATION_INSTANCE_INFO_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("VIRTUALIZATION_INSTANCE_INFO_INPUT")
            .field("NumberOfWorkerThreads", &self.NumberOfWorkerThreads)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for VIRTUALIZATION_INSTANCE_INFO_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.NumberOfWorkerThreads == other.NumberOfWorkerThreads && self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for VIRTUALIZATION_INSTANCE_INFO_INPUT {}
unsafe impl ::windows::runtime::Abi for VIRTUALIZATION_INSTANCE_INFO_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct VIRTUALIZATION_INSTANCE_INFO_INPUT_EX {
    pub HeaderSize: u16,
    pub Flags: u32,
    pub NotificationInfoSize: u32,
    pub NotificationInfoOffset: u16,
    pub ProviderMajorVersion: u16,
}
impl VIRTUALIZATION_INSTANCE_INFO_INPUT_EX {}
impl ::std::default::Default for VIRTUALIZATION_INSTANCE_INFO_INPUT_EX {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for VIRTUALIZATION_INSTANCE_INFO_INPUT_EX {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("VIRTUALIZATION_INSTANCE_INFO_INPUT_EX")
            .field("HeaderSize", &self.HeaderSize)
            .field("Flags", &self.Flags)
            .field("NotificationInfoSize", &self.NotificationInfoSize)
            .field("NotificationInfoOffset", &self.NotificationInfoOffset)
            .field("ProviderMajorVersion", &self.ProviderMajorVersion)
            .finish()
    }
}
impl ::std::cmp::PartialEq for VIRTUALIZATION_INSTANCE_INFO_INPUT_EX {
    fn eq(&self, other: &Self) -> bool {
        self.HeaderSize == other.HeaderSize
            && self.Flags == other.Flags
            && self.NotificationInfoSize == other.NotificationInfoSize
            && self.NotificationInfoOffset == other.NotificationInfoOffset
            && self.ProviderMajorVersion == other.ProviderMajorVersion
    }
}
impl ::std::cmp::Eq for VIRTUALIZATION_INSTANCE_INFO_INPUT_EX {}
unsafe impl ::windows::runtime::Abi for VIRTUALIZATION_INSTANCE_INFO_INPUT_EX {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct VIRTUALIZATION_INSTANCE_INFO_OUTPUT {
    pub VirtualizationInstanceID: ::windows::runtime::GUID,
}
impl VIRTUALIZATION_INSTANCE_INFO_OUTPUT {}
impl ::std::default::Default for VIRTUALIZATION_INSTANCE_INFO_OUTPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for VIRTUALIZATION_INSTANCE_INFO_OUTPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("VIRTUALIZATION_INSTANCE_INFO_OUTPUT")
            .field("VirtualizationInstanceID", &self.VirtualizationInstanceID)
            .finish()
    }
}
impl ::std::cmp::PartialEq for VIRTUALIZATION_INSTANCE_INFO_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.VirtualizationInstanceID == other.VirtualizationInstanceID
    }
}
impl ::std::cmp::Eq for VIRTUALIZATION_INSTANCE_INFO_OUTPUT {}
unsafe impl ::windows::runtime::Abi for VIRTUALIZATION_INSTANCE_INFO_OUTPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct VIRTUAL_STORAGE_BEHAVIOR_CODE(pub i32);
pub const VirtualStorageBehaviorUndefined: VIRTUAL_STORAGE_BEHAVIOR_CODE =
    VIRTUAL_STORAGE_BEHAVIOR_CODE(0i32);
pub const VirtualStorageBehaviorCacheWriteThrough: VIRTUAL_STORAGE_BEHAVIOR_CODE =
    VIRTUAL_STORAGE_BEHAVIOR_CODE(1i32);
pub const VirtualStorageBehaviorCacheWriteBack: VIRTUAL_STORAGE_BEHAVIOR_CODE =
    VIRTUAL_STORAGE_BEHAVIOR_CODE(2i32);
pub const VirtualStorageBehaviorStopIoProcessing: VIRTUAL_STORAGE_BEHAVIOR_CODE =
    VIRTUAL_STORAGE_BEHAVIOR_CODE(3i32);
pub const VirtualStorageBehaviorRestartIoProcessing: VIRTUAL_STORAGE_BEHAVIOR_CODE =
    VIRTUAL_STORAGE_BEHAVIOR_CODE(4i32);
impl ::std::convert::From<i32> for VIRTUAL_STORAGE_BEHAVIOR_CODE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for VIRTUAL_STORAGE_BEHAVIOR_CODE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT {
    pub Size: u32,
    pub BehaviorCode: VIRTUAL_STORAGE_BEHAVIOR_CODE,
}
impl VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT {}
impl ::std::default::Default for VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT")
            .field("Size", &self.Size)
            .field("BehaviorCode", &self.BehaviorCode)
            .finish()
    }
}
impl ::std::cmp::PartialEq for VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.BehaviorCode == other.BehaviorCode
    }
}
impl ::std::cmp::Eq for VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT {}
unsafe impl ::windows::runtime::Abi for VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[cfg(feature = "Win32_Foundation")]
pub const VOLMGR_KSR_BYPASS: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2143813629i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const VOLMGR_KSR_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2143813631i32 as _);
#[cfg(feature = "Win32_Foundation")]
pub const VOLMGR_KSR_READ_ERROR: super::super::Foundation::NTSTATUS =
    super::super::Foundation::NTSTATUS(-2143813630i32 as _);
pub const VOLUME_IS_DIRTY: u32 = 1u32;
pub const VOLUME_SESSION_OPEN: u32 = 4u32;
pub const VOLUME_UPGRADE_SCHEDULED: u32 = 2u32;
pub const VRL_CUSTOM_CLASS_BEGIN: u32 = 256u32;
pub const VRL_ENABLE_KERNEL_BREAKS: u32 = 2147483648u32;
pub const VRL_PREDEFINED_CLASS_BEGIN: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct VolLockBroadcast {
    pub vlb_dbh: DEV_BROADCAST_HDR,
    pub vlb_owner: u32,
    pub vlb_perms: u8,
    pub vlb_lockType: u8,
    pub vlb_drive: u8,
    pub vlb_flags: u8,
}
impl VolLockBroadcast {}
impl ::std::default::Default for VolLockBroadcast {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for VolLockBroadcast {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("VolLockBroadcast")
            .field("vlb_dbh", &self.vlb_dbh)
            .field("vlb_owner", &self.vlb_owner)
            .field("vlb_perms", &self.vlb_perms)
            .field("vlb_lockType", &self.vlb_lockType)
            .field("vlb_drive", &self.vlb_drive)
            .field("vlb_flags", &self.vlb_flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for VolLockBroadcast {
    fn eq(&self, other: &Self) -> bool {
        self.vlb_dbh == other.vlb_dbh
            && self.vlb_owner == other.vlb_owner
            && self.vlb_perms == other.vlb_perms
            && self.vlb_lockType == other.vlb_lockType
            && self.vlb_drive == other.vlb_drive
            && self.vlb_flags == other.vlb_flags
    }
}
impl ::std::cmp::Eq for VolLockBroadcast {}
unsafe impl ::windows::runtime::Abi for VolLockBroadcast {
    type Abi = Self;
    type DefaultType = Self;
}
#[cfg(feature = "Win32_Foundation")]
pub type WAITORTIMERCALLBACK = unsafe extern "system" fn(
    param0: *mut ::std::ffi::c_void,
    param1: super::super::Foundation::BOOLEAN,
);
pub const WDT_INPROC64_CALL: u32 = 1349805143u32;
pub const WDT_INPROC_CALL: u32 = 1215587415u32;
pub const WDT_REMOTE_CALL: u32 = 1383359575u32;
pub const WIM_BOOT_NOT_OS_WIM: u32 = 0u32;
pub const WIM_BOOT_OS_WIM: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct WIM_PROVIDER_ADD_OVERLAY_INPUT {
    pub WimType: u32,
    pub WimIndex: u32,
    pub WimFileNameOffset: u32,
    pub WimFileNameLength: u32,
}
impl WIM_PROVIDER_ADD_OVERLAY_INPUT {}
impl ::std::default::Default for WIM_PROVIDER_ADD_OVERLAY_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for WIM_PROVIDER_ADD_OVERLAY_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("WIM_PROVIDER_ADD_OVERLAY_INPUT")
            .field("WimType", &self.WimType)
            .field("WimIndex", &self.WimIndex)
            .field("WimFileNameOffset", &self.WimFileNameOffset)
            .field("WimFileNameLength", &self.WimFileNameLength)
            .finish()
    }
}
impl ::std::cmp::PartialEq for WIM_PROVIDER_ADD_OVERLAY_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.WimType == other.WimType
            && self.WimIndex == other.WimIndex
            && self.WimFileNameOffset == other.WimFileNameOffset
            && self.WimFileNameLength == other.WimFileNameLength
    }
}
impl ::std::cmp::Eq for WIM_PROVIDER_ADD_OVERLAY_INPUT {}
unsafe impl ::windows::runtime::Abi for WIM_PROVIDER_ADD_OVERLAY_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const WIM_PROVIDER_CURRENT_VERSION: u32 = 1u32;
pub const WIM_PROVIDER_EXTERNAL_FLAG_NOT_ACTIVE: u32 = 1u32;
pub const WIM_PROVIDER_EXTERNAL_FLAG_SUSPENDED: u32 = 2u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct WIM_PROVIDER_EXTERNAL_INFO {
    pub Version: u32,
    pub Flags: u32,
    pub DataSourceId: i64,
    pub ResourceHash: [u8; 20],
}
impl WIM_PROVIDER_EXTERNAL_INFO {}
impl ::std::default::Default for WIM_PROVIDER_EXTERNAL_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for WIM_PROVIDER_EXTERNAL_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("WIM_PROVIDER_EXTERNAL_INFO")
            .field("Version", &self.Version)
            .field("Flags", &self.Flags)
            .field("DataSourceId", &self.DataSourceId)
            .field("ResourceHash", &self.ResourceHash)
            .finish()
    }
}
impl ::std::cmp::PartialEq for WIM_PROVIDER_EXTERNAL_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Flags == other.Flags
            && self.DataSourceId == other.DataSourceId
            && self.ResourceHash == other.ResourceHash
    }
}
impl ::std::cmp::Eq for WIM_PROVIDER_EXTERNAL_INFO {}
unsafe impl ::windows::runtime::Abi for WIM_PROVIDER_EXTERNAL_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
pub const WIM_PROVIDER_HASH_SIZE: u32 = 20u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct WIM_PROVIDER_OVERLAY_ENTRY {
    pub NextEntryOffset: u32,
    pub DataSourceId: i64,
    pub WimGuid: ::windows::runtime::GUID,
    pub WimFileNameOffset: u32,
    pub WimType: u32,
    pub WimIndex: u32,
    pub Flags: u32,
}
impl WIM_PROVIDER_OVERLAY_ENTRY {}
impl ::std::default::Default for WIM_PROVIDER_OVERLAY_ENTRY {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for WIM_PROVIDER_OVERLAY_ENTRY {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("WIM_PROVIDER_OVERLAY_ENTRY")
            .field("NextEntryOffset", &self.NextEntryOffset)
            .field("DataSourceId", &self.DataSourceId)
            .field("WimGuid", &self.WimGuid)
            .field("WimFileNameOffset", &self.WimFileNameOffset)
            .field("WimType", &self.WimType)
            .field("WimIndex", &self.WimIndex)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::std::cmp::PartialEq for WIM_PROVIDER_OVERLAY_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset
            && self.DataSourceId == other.DataSourceId
            && self.WimGuid == other.WimGuid
            && self.WimFileNameOffset == other.WimFileNameOffset
            && self.WimType == other.WimType
            && self.WimIndex == other.WimIndex
            && self.Flags == other.Flags
    }
}
impl ::std::cmp::Eq for WIM_PROVIDER_OVERLAY_ENTRY {}
unsafe impl ::windows::runtime::Abi for WIM_PROVIDER_OVERLAY_ENTRY {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct WIM_PROVIDER_REMOVE_OVERLAY_INPUT {
    pub DataSourceId: i64,
}
impl WIM_PROVIDER_REMOVE_OVERLAY_INPUT {}
impl ::std::default::Default for WIM_PROVIDER_REMOVE_OVERLAY_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for WIM_PROVIDER_REMOVE_OVERLAY_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("WIM_PROVIDER_REMOVE_OVERLAY_INPUT")
            .field("DataSourceId", &self.DataSourceId)
            .finish()
    }
}
impl ::std::cmp::PartialEq for WIM_PROVIDER_REMOVE_OVERLAY_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.DataSourceId == other.DataSourceId
    }
}
impl ::std::cmp::Eq for WIM_PROVIDER_REMOVE_OVERLAY_INPUT {}
unsafe impl ::windows::runtime::Abi for WIM_PROVIDER_REMOVE_OVERLAY_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {
    pub DataSourceId: i64,
}
impl WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {}
impl ::std::default::Default for WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("WIM_PROVIDER_SUSPEND_OVERLAY_INPUT")
            .field("DataSourceId", &self.DataSourceId)
            .finish()
    }
}
impl ::std::cmp::PartialEq for WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.DataSourceId == other.DataSourceId
    }
}
impl ::std::cmp::Eq for WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {}
unsafe impl ::windows::runtime::Abi for WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct WIM_PROVIDER_UPDATE_OVERLAY_INPUT {
    pub DataSourceId: i64,
    pub WimFileNameOffset: u32,
    pub WimFileNameLength: u32,
}
impl WIM_PROVIDER_UPDATE_OVERLAY_INPUT {}
impl ::std::default::Default for WIM_PROVIDER_UPDATE_OVERLAY_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for WIM_PROVIDER_UPDATE_OVERLAY_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("WIM_PROVIDER_UPDATE_OVERLAY_INPUT")
            .field("DataSourceId", &self.DataSourceId)
            .field("WimFileNameOffset", &self.WimFileNameOffset)
            .field("WimFileNameLength", &self.WimFileNameLength)
            .finish()
    }
}
impl ::std::cmp::PartialEq for WIM_PROVIDER_UPDATE_OVERLAY_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.DataSourceId == other.DataSourceId
            && self.WimFileNameOffset == other.WimFileNameOffset
            && self.WimFileNameLength == other.WimFileNameLength
    }
}
impl ::std::cmp::Eq for WIM_PROVIDER_UPDATE_OVERLAY_INPUT {}
unsafe impl ::windows::runtime::Abi for WIM_PROVIDER_UPDATE_OVERLAY_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const WINDDI_MAXSETPALETTECOLORINDEX: u32 = 255u32;
pub const WINDDI_MAXSETPALETTECOLORS: u32 = 256u32;
pub const WINDDI_MAX_BROADCAST_CONTEXT: u32 = 64u32;
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_DisplayDevices"))]
pub type WNDOBJCHANGEPROC =
    unsafe extern "system" fn(pwo: *mut super::super::UI::DisplayDevices::WNDOBJ, fl: u32);
pub const WNDOBJ_SETUP: u32 = 4354u32;
pub const WOC_CHANGED: u32 = 16u32;
pub const WOC_DELETE: u32 = 32u32;
pub const WOC_DRAWN: u32 = 64u32;
pub const WOC_RGN_CLIENT: u32 = 2u32;
pub const WOC_RGN_CLIENT_DELTA: u32 = 1u32;
pub const WOC_RGN_SPRITE: u32 = 512u32;
pub const WOC_RGN_SURFACE: u32 = 8u32;
pub const WOC_RGN_SURFACE_DELTA: u32 = 4u32;
pub const WOC_SPRITE_NO_OVERLAP: u32 = 256u32;
pub const WOC_SPRITE_OVERLAP: u32 = 128u32;
pub const WOF_CURRENT_VERSION: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Storage_FileSystem")]
pub struct WOF_EXTERNAL_FILE_ID {
    pub FileId: super::super::Storage::FileSystem::FILE_ID_128,
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl WOF_EXTERNAL_FILE_ID {}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::default::Default for WOF_EXTERNAL_FILE_ID {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::fmt::Debug for WOF_EXTERNAL_FILE_ID {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("WOF_EXTERNAL_FILE_ID")
            .field("FileId", &self.FileId)
            .finish()
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::PartialEq for WOF_EXTERNAL_FILE_ID {
    fn eq(&self, other: &Self) -> bool {
        self.FileId == other.FileId
    }
}
#[cfg(feature = "Win32_Storage_FileSystem")]
impl ::std::cmp::Eq for WOF_EXTERNAL_FILE_ID {}
#[cfg(feature = "Win32_Storage_FileSystem")]
unsafe impl ::windows::runtime::Abi for WOF_EXTERNAL_FILE_ID {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct WOF_EXTERNAL_INFO {
    pub Version: u32,
    pub Provider: u32,
}
impl WOF_EXTERNAL_INFO {}
impl ::std::default::Default for WOF_EXTERNAL_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for WOF_EXTERNAL_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("WOF_EXTERNAL_INFO")
            .field("Version", &self.Version)
            .field("Provider", &self.Provider)
            .finish()
    }
}
impl ::std::cmp::PartialEq for WOF_EXTERNAL_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Provider == other.Provider
    }
}
impl ::std::cmp::Eq for WOF_EXTERNAL_INFO {}
unsafe impl ::windows::runtime::Abi for WOF_EXTERNAL_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
pub const WOF_PROVIDER_CLOUD: u32 = 3u32;
pub const WOF_PROVIDER_FILE: u32 = 2u32;
pub const WOF_PROVIDER_WIM: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct WOF_VERSION_INFO {
    pub WofVersion: u32,
}
impl WOF_VERSION_INFO {}
impl ::std::default::Default for WOF_VERSION_INFO {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for WOF_VERSION_INFO {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("WOF_VERSION_INFO")
            .field("WofVersion", &self.WofVersion)
            .finish()
    }
}
impl ::std::cmp::PartialEq for WOF_VERSION_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.WofVersion == other.WofVersion
    }
}
impl ::std::cmp::Eq for WOF_VERSION_INFO {}
unsafe impl ::windows::runtime::Abi for WOF_VERSION_INFO {
    type Abi = Self;
    type DefaultType = Self;
}
pub type WORKERCALLBACKFUNC = unsafe extern "system" fn(param0: *mut ::std::ffi::c_void);
pub const WO_DRAW_NOTIFY: u32 = 64u32;
pub const WO_RGN_CLIENT: u32 = 2u32;
pub const WO_RGN_CLIENT_DELTA: u32 = 1u32;
pub const WO_RGN_DESKTOP_COORD: u32 = 256u32;
pub const WO_RGN_SPRITE: u32 = 512u32;
pub const WO_RGN_SURFACE: u32 = 8u32;
pub const WO_RGN_SURFACE_DELTA: u32 = 4u32;
pub const WO_RGN_UPDATE_ALL: u32 = 16u32;
pub const WO_RGN_WINDOW: u32 = 32u32;
pub const WO_SPRITE_NOTIFY: u32 = 128u32;
pub const WRITE_COMPRESSION_INFO_VALID: u32 = 16u32;
pub const WRITE_DAC: u32 = 262144u32;
pub const WRITE_NV_MEMORY_FLAG_FLUSH: u32 = 1u32;
pub const WRITE_NV_MEMORY_FLAG_NON_TEMPORAL: u32 = 2u32;
pub const WRITE_NV_MEMORY_FLAG_NO_DRAIN: u32 = 256u32;
pub const WRITE_OWNER: u32 = 524288u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct WRITE_USN_REASON_INPUT {
    pub Flags: u32,
    pub UsnReasonToWrite: u32,
}
impl WRITE_USN_REASON_INPUT {}
impl ::std::default::Default for WRITE_USN_REASON_INPUT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for WRITE_USN_REASON_INPUT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("WRITE_USN_REASON_INPUT")
            .field("Flags", &self.Flags)
            .field("UsnReasonToWrite", &self.UsnReasonToWrite)
            .finish()
    }
}
impl ::std::cmp::PartialEq for WRITE_USN_REASON_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags && self.UsnReasonToWrite == other.UsnReasonToWrite
    }
}
impl ::std::cmp::Eq for WRITE_USN_REASON_INPUT {}
unsafe impl ::windows::runtime::Abi for WRITE_USN_REASON_INPUT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const WRITE_WATCH_FLAG_RESET: u32 = 1u32;
pub const WT_EXECUTEDELETEWAIT: u32 = 8u32;
pub const WT_EXECUTEINLONGTHREAD: u32 = 16u32;
pub const WT_EXECUTEINPERSISTENTIOTHREAD: u32 = 64u32;
pub const WT_EXECUTEINUITHREAD: u32 = 2u32;
pub const X3_BTYPE_QP_INST_VAL_POS_X: u32 = 0u32;
pub const X3_BTYPE_QP_INST_WORD_POS_X: u32 = 23u32;
pub const X3_BTYPE_QP_INST_WORD_X: u32 = 2u32;
pub const X3_BTYPE_QP_SIZE_X: u32 = 9u32;
pub const X3_D_WH_INST_WORD_POS_X: u32 = 24u32;
pub const X3_D_WH_INST_WORD_X: u32 = 3u32;
pub const X3_D_WH_SIGN_VAL_POS_X: u32 = 0u32;
pub const X3_D_WH_SIZE_X: u32 = 3u32;
pub const X3_EMPTY_INST_VAL_POS_X: u32 = 0u32;
pub const X3_EMPTY_INST_WORD_POS_X: u32 = 14u32;
pub const X3_EMPTY_INST_WORD_X: u32 = 1u32;
pub const X3_EMPTY_SIZE_X: u32 = 2u32;
pub const X3_IMM20_INST_WORD_POS_X: u32 = 4u32;
pub const X3_IMM20_INST_WORD_X: u32 = 3u32;
pub const X3_IMM20_SIGN_VAL_POS_X: u32 = 0u32;
pub const X3_IMM20_SIZE_X: u32 = 20u32;
pub const X3_IMM39_1_INST_WORD_POS_X: u32 = 0u32;
pub const X3_IMM39_1_INST_WORD_X: u32 = 2u32;
pub const X3_IMM39_1_SIGN_VAL_POS_X: u32 = 36u32;
pub const X3_IMM39_1_SIZE_X: u32 = 23u32;
pub const X3_IMM39_2_INST_WORD_POS_X: u32 = 16u32;
pub const X3_IMM39_2_INST_WORD_X: u32 = 1u32;
pub const X3_IMM39_2_SIGN_VAL_POS_X: u32 = 20u32;
pub const X3_IMM39_2_SIZE_X: u32 = 16u32;
pub const X3_I_INST_WORD_POS_X: u32 = 27u32;
pub const X3_I_INST_WORD_X: u32 = 3u32;
pub const X3_I_SIGN_VAL_POS_X: u32 = 59u32;
pub const X3_I_SIZE_X: u32 = 1u32;
pub const X3_OPCODE_INST_WORD_POS_X: u32 = 28u32;
pub const X3_OPCODE_INST_WORD_X: u32 = 3u32;
pub const X3_OPCODE_SIGN_VAL_POS_X: u32 = 0u32;
pub const X3_OPCODE_SIZE_X: u32 = 4u32;
pub const X3_P_INST_WORD_POS_X: u32 = 0u32;
pub const X3_P_INST_WORD_X: u32 = 3u32;
pub const X3_P_SIGN_VAL_POS_X: u32 = 0u32;
pub const X3_P_SIZE_X: u32 = 4u32;
pub const X3_TMPLT_INST_WORD_POS_X: u32 = 0u32;
pub const X3_TMPLT_INST_WORD_X: u32 = 0u32;
pub const X3_TMPLT_SIGN_VAL_POS_X: u32 = 0u32;
pub const X3_TMPLT_SIZE_X: u32 = 4u32;
pub const X86_CACHE_ALIGNMENT_SIZE: u32 = 64u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct XFORMOBJ {
    pub ulReserved: u32,
}
impl XFORMOBJ {}
impl ::std::default::Default for XFORMOBJ {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for XFORMOBJ {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("XFORMOBJ")
            .field("ulReserved", &self.ulReserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for XFORMOBJ {
    fn eq(&self, other: &Self) -> bool {
        self.ulReserved == other.ulReserved
    }
}
impl ::std::cmp::Eq for XFORMOBJ {}
unsafe impl ::windows::runtime::Abi for XFORMOBJ {
    type Abi = Self;
    type DefaultType = Self;
}
pub const XF_INV_FXTOL: i32 = 3i32;
pub const XF_INV_LTOL: i32 = 1i32;
pub const XF_LTOFX: i32 = 2i32;
pub const XF_LTOL: i32 = 0i32;
pub const XO_DESTBITFIELDS: u32 = 5u32;
pub const XO_DESTDCPALETTE: u32 = 3u32;
pub const XO_DESTPALETTE: u32 = 2u32;
pub const XO_DEVICE_ICM: u32 = 16u32;
pub const XO_FROM_CMYK: u32 = 8u32;
pub const XO_HOST_ICM: u32 = 32u32;
pub const XO_SRCBITFIELDS: u32 = 4u32;
pub const XO_SRCPALETTE: u32 = 1u32;
pub const XO_TABLE: u32 = 2u32;
pub const XO_TO_MONO: u32 = 4u32;
pub const XO_TRIVIAL: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct XSAVE_AREA {
    pub LegacyState: XSAVE_FORMAT,
    pub Header: XSAVE_AREA_HEADER,
}
impl XSAVE_AREA {}
impl ::std::default::Default for XSAVE_AREA {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for XSAVE_AREA {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("XSAVE_AREA")
            .field("LegacyState", &self.LegacyState)
            .field("Header", &self.Header)
            .finish()
    }
}
impl ::std::cmp::PartialEq for XSAVE_AREA {
    fn eq(&self, other: &Self) -> bool {
        self.LegacyState == other.LegacyState && self.Header == other.Header
    }
}
impl ::std::cmp::Eq for XSAVE_AREA {}
unsafe impl ::windows::runtime::Abi for XSAVE_AREA {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct XSAVE_AREA_HEADER {
    pub Mask: u64,
    pub CompactionMask: u64,
    pub Reserved2: [u64; 6],
}
impl XSAVE_AREA_HEADER {}
impl ::std::default::Default for XSAVE_AREA_HEADER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for XSAVE_AREA_HEADER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("XSAVE_AREA_HEADER")
            .field("Mask", &self.Mask)
            .field("CompactionMask", &self.CompactionMask)
            .field("Reserved2", &self.Reserved2)
            .finish()
    }
}
impl ::std::cmp::PartialEq for XSAVE_AREA_HEADER {
    fn eq(&self, other: &Self) -> bool {
        self.Mask == other.Mask
            && self.CompactionMask == other.CompactionMask
            && self.Reserved2 == other.Reserved2
    }
}
impl ::std::cmp::Eq for XSAVE_AREA_HEADER {}
unsafe impl ::windows::runtime::Abi for XSAVE_AREA_HEADER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct XSAVE_CET_U_FORMAT {
    pub Ia32CetUMsr: u64,
    pub Ia32Pl3SspMsr: u64,
}
impl XSAVE_CET_U_FORMAT {}
impl ::std::default::Default for XSAVE_CET_U_FORMAT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for XSAVE_CET_U_FORMAT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("XSAVE_CET_U_FORMAT")
            .field("Ia32CetUMsr", &self.Ia32CetUMsr)
            .field("Ia32Pl3SspMsr", &self.Ia32Pl3SspMsr)
            .finish()
    }
}
impl ::std::cmp::PartialEq for XSAVE_CET_U_FORMAT {
    fn eq(&self, other: &Self) -> bool {
        self.Ia32CetUMsr == other.Ia32CetUMsr && self.Ia32Pl3SspMsr == other.Ia32Pl3SspMsr
    }
}
impl ::std::cmp::Eq for XSAVE_CET_U_FORMAT {}
unsafe impl ::windows::runtime::Abi for XSAVE_CET_U_FORMAT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct XSAVE_FORMAT {
    pub ControlWord: u16,
    pub StatusWord: u16,
    pub TagWord: u8,
    pub Reserved1: u8,
    pub ErrorOpcode: u16,
    pub ErrorOffset: u32,
    pub ErrorSelector: u16,
    pub Reserved2: u16,
    pub DataOffset: u32,
    pub DataSelector: u16,
    pub Reserved3: u16,
    pub MxCsr: u32,
    pub MxCsr_Mask: u32,
    pub FloatRegisters: [M128A; 8],
    pub XmmRegisters: [M128A; 16],
    pub Reserved4: [u8; 96],
}
impl XSAVE_FORMAT {}
impl ::std::default::Default for XSAVE_FORMAT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for XSAVE_FORMAT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("XSAVE_FORMAT")
            .field("ControlWord", &self.ControlWord)
            .field("StatusWord", &self.StatusWord)
            .field("TagWord", &self.TagWord)
            .field("Reserved1", &self.Reserved1)
            .field("ErrorOpcode", &self.ErrorOpcode)
            .field("ErrorOffset", &self.ErrorOffset)
            .field("ErrorSelector", &self.ErrorSelector)
            .field("Reserved2", &self.Reserved2)
            .field("DataOffset", &self.DataOffset)
            .field("DataSelector", &self.DataSelector)
            .field("Reserved3", &self.Reserved3)
            .field("MxCsr", &self.MxCsr)
            .field("MxCsr_Mask", &self.MxCsr_Mask)
            .field("FloatRegisters", &self.FloatRegisters)
            .field("XmmRegisters", &self.XmmRegisters)
            .field("Reserved4", &self.Reserved4)
            .finish()
    }
}
impl ::std::cmp::PartialEq for XSAVE_FORMAT {
    fn eq(&self, other: &Self) -> bool {
        self.ControlWord == other.ControlWord
            && self.StatusWord == other.StatusWord
            && self.TagWord == other.TagWord
            && self.Reserved1 == other.Reserved1
            && self.ErrorOpcode == other.ErrorOpcode
            && self.ErrorOffset == other.ErrorOffset
            && self.ErrorSelector == other.ErrorSelector
            && self.Reserved2 == other.Reserved2
            && self.DataOffset == other.DataOffset
            && self.DataSelector == other.DataSelector
            && self.Reserved3 == other.Reserved3
            && self.MxCsr == other.MxCsr
            && self.MxCsr_Mask == other.MxCsr_Mask
            && self.FloatRegisters == other.FloatRegisters
            && self.XmmRegisters == other.XmmRegisters
            && self.Reserved4 == other.Reserved4
    }
}
impl ::std::cmp::Eq for XSAVE_FORMAT {}
unsafe impl ::windows::runtime::Abi for XSAVE_FORMAT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const XSTATE_ALIGN_BIT: u32 = 1u32;
pub const XSTATE_AMX_TILE_CONFIG: u32 = 17u32;
pub const XSTATE_AMX_TILE_DATA: u32 = 18u32;
pub const XSTATE_AVX: u32 = 2u32;
pub const XSTATE_AVX512_KMASK: u32 = 5u32;
pub const XSTATE_AVX512_ZMM: u32 = 7u32;
pub const XSTATE_AVX512_ZMM_H: u32 = 6u32;
pub const XSTATE_CET_S: u32 = 12u32;
pub const XSTATE_CET_U: u32 = 11u32;
pub const XSTATE_COMPACTION_ENABLE: u32 = 63u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct XSTATE_CONFIGURATION {
    pub EnabledFeatures: u64,
    pub EnabledVolatileFeatures: u64,
    pub Size: u32,
    pub Anonymous: XSTATE_CONFIGURATION_0,
    pub Features: [XSTATE_FEATURE; 64],
    pub EnabledSupervisorFeatures: u64,
    pub AlignedFeatures: u64,
    pub AllFeatureSize: u32,
    pub AllFeatures: [u32; 64],
    pub EnabledUserVisibleSupervisorFeatures: u64,
    pub ExtendedFeatureDisableFeatures: u64,
    pub AllNonLargeFeatureSize: u32,
    pub Spare: u32,
}
impl XSTATE_CONFIGURATION {}
impl ::std::default::Default for XSTATE_CONFIGURATION {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for XSTATE_CONFIGURATION {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for XSTATE_CONFIGURATION {}
unsafe impl ::windows::runtime::Abi for XSTATE_CONFIGURATION {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union XSTATE_CONFIGURATION_0 {
    pub ControlFlags: u32,
    pub Anonymous: XSTATE_CONFIGURATION_0_0,
}
impl XSTATE_CONFIGURATION_0 {}
impl ::std::default::Default for XSTATE_CONFIGURATION_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for XSTATE_CONFIGURATION_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for XSTATE_CONFIGURATION_0 {}
unsafe impl ::windows::runtime::Abi for XSTATE_CONFIGURATION_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct XSTATE_CONFIGURATION_0_0 {
    pub _bitfield: u32,
}
impl XSTATE_CONFIGURATION_0_0 {}
impl ::std::default::Default for XSTATE_CONFIGURATION_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for XSTATE_CONFIGURATION_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_Anonymous_e__Struct")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::std::cmp::PartialEq for XSTATE_CONFIGURATION_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::std::cmp::Eq for XSTATE_CONFIGURATION_0_0 {}
unsafe impl ::windows::runtime::Abi for XSTATE_CONFIGURATION_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct XSTATE_CONTEXT {
    pub Mask: u64,
    pub Length: u32,
    pub Reserved1: u32,
    pub Area: *mut XSAVE_AREA,
    pub Buffer: *mut ::std::ffi::c_void,
}
impl XSTATE_CONTEXT {}
impl ::std::default::Default for XSTATE_CONTEXT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for XSTATE_CONTEXT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("XSTATE_CONTEXT")
            .field("Mask", &self.Mask)
            .field("Length", &self.Length)
            .field("Reserved1", &self.Reserved1)
            .field("Area", &self.Area)
            .field("Buffer", &self.Buffer)
            .finish()
    }
}
impl ::std::cmp::PartialEq for XSTATE_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.Mask == other.Mask
            && self.Length == other.Length
            && self.Reserved1 == other.Reserved1
            && self.Area == other.Area
            && self.Buffer == other.Buffer
    }
}
impl ::std::cmp::Eq for XSTATE_CONTEXT {}
unsafe impl ::windows::runtime::Abi for XSTATE_CONTEXT {
    type Abi = Self;
    type DefaultType = Self;
}
pub const XSTATE_CONTROLFLAG_XFD_MASK: u32 = 4u32;
pub const XSTATE_CONTROLFLAG_XSAVEC_MASK: u32 = 2u32;
pub const XSTATE_CONTROLFLAG_XSAVEOPT_MASK: u32 = 1u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct XSTATE_FEATURE {
    pub Offset: u32,
    pub Size: u32,
}
impl XSTATE_FEATURE {}
impl ::std::default::Default for XSTATE_FEATURE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for XSTATE_FEATURE {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("XSTATE_FEATURE")
            .field("Offset", &self.Offset)
            .field("Size", &self.Size)
            .finish()
    }
}
impl ::std::cmp::PartialEq for XSTATE_FEATURE {
    fn eq(&self, other: &Self) -> bool {
        self.Offset == other.Offset && self.Size == other.Size
    }
}
impl ::std::cmp::Eq for XSTATE_FEATURE {}
unsafe impl ::windows::runtime::Abi for XSTATE_FEATURE {
    type Abi = Self;
    type DefaultType = Self;
}
pub const XSTATE_GSSE: u32 = 2u32;
pub const XSTATE_IPT: u32 = 8u32;
pub const XSTATE_LEGACY_FLOATING_POINT: u32 = 0u32;
pub const XSTATE_LEGACY_SSE: u32 = 1u32;
pub const XSTATE_LWP: u32 = 62u32;
pub const XSTATE_MPX_BNDCSR: u32 = 4u32;
pub const XSTATE_MPX_BNDREGS: u32 = 3u32;
pub const XSTATE_PASID: u32 = 10u32;
pub const XSTATE_XFD_BIT: u32 = 2u32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct _D3DDeviceDesc {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub dcmColorModel: u32,
    pub dwDevCaps: u32,
    pub dtcTransformCaps: D3DTRANSFORMCAPS,
    pub bClipping: super::super::Foundation::BOOL,
    pub dlcLightingCaps: D3DLIGHTINGCAPS,
    pub dpcLineCaps: _D3DPrimCaps,
    pub dpcTriCaps: _D3DPrimCaps,
    pub dwDeviceRenderBitDepth: u32,
    pub dwDeviceZBufferBitDepth: u32,
    pub dwMaxBufferSize: u32,
    pub dwMaxVertexCount: u32,
    pub dwMinTextureWidth: u32,
    pub dwMinTextureHeight: u32,
    pub dwMaxTextureWidth: u32,
    pub dwMaxTextureHeight: u32,
    pub dwMinStippleWidth: u32,
    pub dwMaxStippleWidth: u32,
    pub dwMinStippleHeight: u32,
    pub dwMaxStippleHeight: u32,
    pub dwMaxTextureRepeat: u32,
    pub dwMaxTextureAspectRatio: u32,
    pub dwMaxAnisotropy: u32,
    pub dvGuardBandLeft: f32,
    pub dvGuardBandTop: f32,
    pub dvGuardBandRight: f32,
    pub dvGuardBandBottom: f32,
    pub dvExtentsAdjust: f32,
    pub dwStencilCaps: u32,
    pub dwFVFCaps: u32,
    pub dwTextureOpCaps: u32,
    pub wMaxTextureBlendStages: u16,
    pub wMaxSimultaneousTextures: u16,
}
#[cfg(feature = "Win32_Foundation")]
impl _D3DDeviceDesc {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for _D3DDeviceDesc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for _D3DDeviceDesc {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_D3DDeviceDesc")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("dcmColorModel", &self.dcmColorModel)
            .field("dwDevCaps", &self.dwDevCaps)
            .field("dtcTransformCaps", &self.dtcTransformCaps)
            .field("bClipping", &self.bClipping)
            .field("dlcLightingCaps", &self.dlcLightingCaps)
            .field("dpcLineCaps", &self.dpcLineCaps)
            .field("dpcTriCaps", &self.dpcTriCaps)
            .field("dwDeviceRenderBitDepth", &self.dwDeviceRenderBitDepth)
            .field("dwDeviceZBufferBitDepth", &self.dwDeviceZBufferBitDepth)
            .field("dwMaxBufferSize", &self.dwMaxBufferSize)
            .field("dwMaxVertexCount", &self.dwMaxVertexCount)
            .field("dwMinTextureWidth", &self.dwMinTextureWidth)
            .field("dwMinTextureHeight", &self.dwMinTextureHeight)
            .field("dwMaxTextureWidth", &self.dwMaxTextureWidth)
            .field("dwMaxTextureHeight", &self.dwMaxTextureHeight)
            .field("dwMinStippleWidth", &self.dwMinStippleWidth)
            .field("dwMaxStippleWidth", &self.dwMaxStippleWidth)
            .field("dwMinStippleHeight", &self.dwMinStippleHeight)
            .field("dwMaxStippleHeight", &self.dwMaxStippleHeight)
            .field("dwMaxTextureRepeat", &self.dwMaxTextureRepeat)
            .field("dwMaxTextureAspectRatio", &self.dwMaxTextureAspectRatio)
            .field("dwMaxAnisotropy", &self.dwMaxAnisotropy)
            .field("dvGuardBandLeft", &self.dvGuardBandLeft)
            .field("dvGuardBandTop", &self.dvGuardBandTop)
            .field("dvGuardBandRight", &self.dvGuardBandRight)
            .field("dvGuardBandBottom", &self.dvGuardBandBottom)
            .field("dvExtentsAdjust", &self.dvExtentsAdjust)
            .field("dwStencilCaps", &self.dwStencilCaps)
            .field("dwFVFCaps", &self.dwFVFCaps)
            .field("dwTextureOpCaps", &self.dwTextureOpCaps)
            .field("wMaxTextureBlendStages", &self.wMaxTextureBlendStages)
            .field("wMaxSimultaneousTextures", &self.wMaxSimultaneousTextures)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for _D3DDeviceDesc {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.dcmColorModel == other.dcmColorModel
            && self.dwDevCaps == other.dwDevCaps
            && self.dtcTransformCaps == other.dtcTransformCaps
            && self.bClipping == other.bClipping
            && self.dlcLightingCaps == other.dlcLightingCaps
            && self.dpcLineCaps == other.dpcLineCaps
            && self.dpcTriCaps == other.dpcTriCaps
            && self.dwDeviceRenderBitDepth == other.dwDeviceRenderBitDepth
            && self.dwDeviceZBufferBitDepth == other.dwDeviceZBufferBitDepth
            && self.dwMaxBufferSize == other.dwMaxBufferSize
            && self.dwMaxVertexCount == other.dwMaxVertexCount
            && self.dwMinTextureWidth == other.dwMinTextureWidth
            && self.dwMinTextureHeight == other.dwMinTextureHeight
            && self.dwMaxTextureWidth == other.dwMaxTextureWidth
            && self.dwMaxTextureHeight == other.dwMaxTextureHeight
            && self.dwMinStippleWidth == other.dwMinStippleWidth
            && self.dwMaxStippleWidth == other.dwMaxStippleWidth
            && self.dwMinStippleHeight == other.dwMinStippleHeight
            && self.dwMaxStippleHeight == other.dwMaxStippleHeight
            && self.dwMaxTextureRepeat == other.dwMaxTextureRepeat
            && self.dwMaxTextureAspectRatio == other.dwMaxTextureAspectRatio
            && self.dwMaxAnisotropy == other.dwMaxAnisotropy
            && self.dvGuardBandLeft == other.dvGuardBandLeft
            && self.dvGuardBandTop == other.dvGuardBandTop
            && self.dvGuardBandRight == other.dvGuardBandRight
            && self.dvGuardBandBottom == other.dvGuardBandBottom
            && self.dvExtentsAdjust == other.dvExtentsAdjust
            && self.dwStencilCaps == other.dwStencilCaps
            && self.dwFVFCaps == other.dwFVFCaps
            && self.dwTextureOpCaps == other.dwTextureOpCaps
            && self.wMaxTextureBlendStages == other.wMaxTextureBlendStages
            && self.wMaxSimultaneousTextures == other.wMaxSimultaneousTextures
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for _D3DDeviceDesc {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for _D3DDeviceDesc {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct _D3DDeviceDesc7 {
    pub dwDevCaps: u32,
    pub dpcLineCaps: _D3DPrimCaps,
    pub dpcTriCaps: _D3DPrimCaps,
    pub dwDeviceRenderBitDepth: u32,
    pub dwDeviceZBufferBitDepth: u32,
    pub dwMinTextureWidth: u32,
    pub dwMinTextureHeight: u32,
    pub dwMaxTextureWidth: u32,
    pub dwMaxTextureHeight: u32,
    pub dwMaxTextureRepeat: u32,
    pub dwMaxTextureAspectRatio: u32,
    pub dwMaxAnisotropy: u32,
    pub dvGuardBandLeft: f32,
    pub dvGuardBandTop: f32,
    pub dvGuardBandRight: f32,
    pub dvGuardBandBottom: f32,
    pub dvExtentsAdjust: f32,
    pub dwStencilCaps: u32,
    pub dwFVFCaps: u32,
    pub dwTextureOpCaps: u32,
    pub wMaxTextureBlendStages: u16,
    pub wMaxSimultaneousTextures: u16,
    pub dwMaxActiveLights: u32,
    pub dvMaxVertexW: f32,
    pub deviceGUID: ::windows::runtime::GUID,
    pub wMaxUserClipPlanes: u16,
    pub wMaxVertexBlendMatrices: u16,
    pub dwVertexProcessingCaps: u32,
    pub dwReserved1: u32,
    pub dwReserved2: u32,
    pub dwReserved3: u32,
    pub dwReserved4: u32,
}
impl _D3DDeviceDesc7 {}
impl ::std::default::Default for _D3DDeviceDesc7 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for _D3DDeviceDesc7 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_D3DDeviceDesc7")
            .field("dwDevCaps", &self.dwDevCaps)
            .field("dpcLineCaps", &self.dpcLineCaps)
            .field("dpcTriCaps", &self.dpcTriCaps)
            .field("dwDeviceRenderBitDepth", &self.dwDeviceRenderBitDepth)
            .field("dwDeviceZBufferBitDepth", &self.dwDeviceZBufferBitDepth)
            .field("dwMinTextureWidth", &self.dwMinTextureWidth)
            .field("dwMinTextureHeight", &self.dwMinTextureHeight)
            .field("dwMaxTextureWidth", &self.dwMaxTextureWidth)
            .field("dwMaxTextureHeight", &self.dwMaxTextureHeight)
            .field("dwMaxTextureRepeat", &self.dwMaxTextureRepeat)
            .field("dwMaxTextureAspectRatio", &self.dwMaxTextureAspectRatio)
            .field("dwMaxAnisotropy", &self.dwMaxAnisotropy)
            .field("dvGuardBandLeft", &self.dvGuardBandLeft)
            .field("dvGuardBandTop", &self.dvGuardBandTop)
            .field("dvGuardBandRight", &self.dvGuardBandRight)
            .field("dvGuardBandBottom", &self.dvGuardBandBottom)
            .field("dvExtentsAdjust", &self.dvExtentsAdjust)
            .field("dwStencilCaps", &self.dwStencilCaps)
            .field("dwFVFCaps", &self.dwFVFCaps)
            .field("dwTextureOpCaps", &self.dwTextureOpCaps)
            .field("wMaxTextureBlendStages", &self.wMaxTextureBlendStages)
            .field("wMaxSimultaneousTextures", &self.wMaxSimultaneousTextures)
            .field("dwMaxActiveLights", &self.dwMaxActiveLights)
            .field("dvMaxVertexW", &self.dvMaxVertexW)
            .field("deviceGUID", &self.deviceGUID)
            .field("wMaxUserClipPlanes", &self.wMaxUserClipPlanes)
            .field("wMaxVertexBlendMatrices", &self.wMaxVertexBlendMatrices)
            .field("dwVertexProcessingCaps", &self.dwVertexProcessingCaps)
            .field("dwReserved1", &self.dwReserved1)
            .field("dwReserved2", &self.dwReserved2)
            .field("dwReserved3", &self.dwReserved3)
            .field("dwReserved4", &self.dwReserved4)
            .finish()
    }
}
impl ::std::cmp::PartialEq for _D3DDeviceDesc7 {
    fn eq(&self, other: &Self) -> bool {
        self.dwDevCaps == other.dwDevCaps
            && self.dpcLineCaps == other.dpcLineCaps
            && self.dpcTriCaps == other.dpcTriCaps
            && self.dwDeviceRenderBitDepth == other.dwDeviceRenderBitDepth
            && self.dwDeviceZBufferBitDepth == other.dwDeviceZBufferBitDepth
            && self.dwMinTextureWidth == other.dwMinTextureWidth
            && self.dwMinTextureHeight == other.dwMinTextureHeight
            && self.dwMaxTextureWidth == other.dwMaxTextureWidth
            && self.dwMaxTextureHeight == other.dwMaxTextureHeight
            && self.dwMaxTextureRepeat == other.dwMaxTextureRepeat
            && self.dwMaxTextureAspectRatio == other.dwMaxTextureAspectRatio
            && self.dwMaxAnisotropy == other.dwMaxAnisotropy
            && self.dvGuardBandLeft == other.dvGuardBandLeft
            && self.dvGuardBandTop == other.dvGuardBandTop
            && self.dvGuardBandRight == other.dvGuardBandRight
            && self.dvGuardBandBottom == other.dvGuardBandBottom
            && self.dvExtentsAdjust == other.dvExtentsAdjust
            && self.dwStencilCaps == other.dwStencilCaps
            && self.dwFVFCaps == other.dwFVFCaps
            && self.dwTextureOpCaps == other.dwTextureOpCaps
            && self.wMaxTextureBlendStages == other.wMaxTextureBlendStages
            && self.wMaxSimultaneousTextures == other.wMaxSimultaneousTextures
            && self.dwMaxActiveLights == other.dwMaxActiveLights
            && self.dvMaxVertexW == other.dvMaxVertexW
            && self.deviceGUID == other.deviceGUID
            && self.wMaxUserClipPlanes == other.wMaxUserClipPlanes
            && self.wMaxVertexBlendMatrices == other.wMaxVertexBlendMatrices
            && self.dwVertexProcessingCaps == other.dwVertexProcessingCaps
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
            && self.dwReserved3 == other.dwReserved3
            && self.dwReserved4 == other.dwReserved4
    }
}
impl ::std::cmp::Eq for _D3DDeviceDesc7 {}
unsafe impl ::windows::runtime::Abi for _D3DDeviceDesc7 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct _D3DExecuteBufferDesc {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub dwCaps: u32,
    pub dwBufferSize: u32,
    pub lpData: *mut ::std::ffi::c_void,
}
impl _D3DExecuteBufferDesc {}
impl ::std::default::Default for _D3DExecuteBufferDesc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for _D3DExecuteBufferDesc {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_D3DExecuteBufferDesc")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("dwCaps", &self.dwCaps)
            .field("dwBufferSize", &self.dwBufferSize)
            .field("lpData", &self.lpData)
            .finish()
    }
}
impl ::std::cmp::PartialEq for _D3DExecuteBufferDesc {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.dwCaps == other.dwCaps
            && self.dwBufferSize == other.dwBufferSize
            && self.lpData == other.lpData
    }
}
impl ::std::cmp::Eq for _D3DExecuteBufferDesc {}
unsafe impl ::windows::runtime::Abi for _D3DExecuteBufferDesc {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct _D3DNTDeviceDesc_V3 {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub dcmColorModel: u32,
    pub dwDevCaps: u32,
    pub dtcTransformCaps: D3DTRANSFORMCAPS,
    pub bClipping: super::super::Foundation::BOOL,
    pub dlcLightingCaps: D3DLIGHTINGCAPS,
    pub dpcLineCaps: _D3DPrimCaps,
    pub dpcTriCaps: _D3DPrimCaps,
    pub dwDeviceRenderBitDepth: u32,
    pub dwDeviceZBufferBitDepth: u32,
    pub dwMaxBufferSize: u32,
    pub dwMaxVertexCount: u32,
    pub dwMinTextureWidth: u32,
    pub dwMinTextureHeight: u32,
    pub dwMaxTextureWidth: u32,
    pub dwMaxTextureHeight: u32,
    pub dwMinStippleWidth: u32,
    pub dwMaxStippleWidth: u32,
    pub dwMinStippleHeight: u32,
    pub dwMaxStippleHeight: u32,
    pub dwMaxTextureRepeat: u32,
    pub dwMaxTextureAspectRatio: u32,
    pub dwMaxAnisotropy: u32,
    pub dvGuardBandLeft: f32,
    pub dvGuardBandTop: f32,
    pub dvGuardBandRight: f32,
    pub dvGuardBandBottom: f32,
    pub dvExtentsAdjust: f32,
    pub dwStencilCaps: u32,
    pub dwFVFCaps: u32,
    pub dwTextureOpCaps: u32,
    pub wMaxTextureBlendStages: u16,
    pub wMaxSimultaneousTextures: u16,
}
#[cfg(feature = "Win32_Foundation")]
impl _D3DNTDeviceDesc_V3 {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for _D3DNTDeviceDesc_V3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for _D3DNTDeviceDesc_V3 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_D3DNTDeviceDesc_V3")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("dcmColorModel", &self.dcmColorModel)
            .field("dwDevCaps", &self.dwDevCaps)
            .field("dtcTransformCaps", &self.dtcTransformCaps)
            .field("bClipping", &self.bClipping)
            .field("dlcLightingCaps", &self.dlcLightingCaps)
            .field("dpcLineCaps", &self.dpcLineCaps)
            .field("dpcTriCaps", &self.dpcTriCaps)
            .field("dwDeviceRenderBitDepth", &self.dwDeviceRenderBitDepth)
            .field("dwDeviceZBufferBitDepth", &self.dwDeviceZBufferBitDepth)
            .field("dwMaxBufferSize", &self.dwMaxBufferSize)
            .field("dwMaxVertexCount", &self.dwMaxVertexCount)
            .field("dwMinTextureWidth", &self.dwMinTextureWidth)
            .field("dwMinTextureHeight", &self.dwMinTextureHeight)
            .field("dwMaxTextureWidth", &self.dwMaxTextureWidth)
            .field("dwMaxTextureHeight", &self.dwMaxTextureHeight)
            .field("dwMinStippleWidth", &self.dwMinStippleWidth)
            .field("dwMaxStippleWidth", &self.dwMaxStippleWidth)
            .field("dwMinStippleHeight", &self.dwMinStippleHeight)
            .field("dwMaxStippleHeight", &self.dwMaxStippleHeight)
            .field("dwMaxTextureRepeat", &self.dwMaxTextureRepeat)
            .field("dwMaxTextureAspectRatio", &self.dwMaxTextureAspectRatio)
            .field("dwMaxAnisotropy", &self.dwMaxAnisotropy)
            .field("dvGuardBandLeft", &self.dvGuardBandLeft)
            .field("dvGuardBandTop", &self.dvGuardBandTop)
            .field("dvGuardBandRight", &self.dvGuardBandRight)
            .field("dvGuardBandBottom", &self.dvGuardBandBottom)
            .field("dvExtentsAdjust", &self.dvExtentsAdjust)
            .field("dwStencilCaps", &self.dwStencilCaps)
            .field("dwFVFCaps", &self.dwFVFCaps)
            .field("dwTextureOpCaps", &self.dwTextureOpCaps)
            .field("wMaxTextureBlendStages", &self.wMaxTextureBlendStages)
            .field("wMaxSimultaneousTextures", &self.wMaxSimultaneousTextures)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for _D3DNTDeviceDesc_V3 {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.dcmColorModel == other.dcmColorModel
            && self.dwDevCaps == other.dwDevCaps
            && self.dtcTransformCaps == other.dtcTransformCaps
            && self.bClipping == other.bClipping
            && self.dlcLightingCaps == other.dlcLightingCaps
            && self.dpcLineCaps == other.dpcLineCaps
            && self.dpcTriCaps == other.dpcTriCaps
            && self.dwDeviceRenderBitDepth == other.dwDeviceRenderBitDepth
            && self.dwDeviceZBufferBitDepth == other.dwDeviceZBufferBitDepth
            && self.dwMaxBufferSize == other.dwMaxBufferSize
            && self.dwMaxVertexCount == other.dwMaxVertexCount
            && self.dwMinTextureWidth == other.dwMinTextureWidth
            && self.dwMinTextureHeight == other.dwMinTextureHeight
            && self.dwMaxTextureWidth == other.dwMaxTextureWidth
            && self.dwMaxTextureHeight == other.dwMaxTextureHeight
            && self.dwMinStippleWidth == other.dwMinStippleWidth
            && self.dwMaxStippleWidth == other.dwMaxStippleWidth
            && self.dwMinStippleHeight == other.dwMinStippleHeight
            && self.dwMaxStippleHeight == other.dwMaxStippleHeight
            && self.dwMaxTextureRepeat == other.dwMaxTextureRepeat
            && self.dwMaxTextureAspectRatio == other.dwMaxTextureAspectRatio
            && self.dwMaxAnisotropy == other.dwMaxAnisotropy
            && self.dvGuardBandLeft == other.dvGuardBandLeft
            && self.dvGuardBandTop == other.dvGuardBandTop
            && self.dvGuardBandRight == other.dvGuardBandRight
            && self.dvGuardBandBottom == other.dvGuardBandBottom
            && self.dvExtentsAdjust == other.dvExtentsAdjust
            && self.dwStencilCaps == other.dwStencilCaps
            && self.dwFVFCaps == other.dwFVFCaps
            && self.dwTextureOpCaps == other.dwTextureOpCaps
            && self.wMaxTextureBlendStages == other.wMaxTextureBlendStages
            && self.wMaxSimultaneousTextures == other.wMaxSimultaneousTextures
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for _D3DNTDeviceDesc_V3 {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for _D3DNTDeviceDesc_V3 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct _D3DNTHALDeviceDesc_V1 {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub dcmColorModel: u32,
    pub dwDevCaps: u32,
    pub dtcTransformCaps: D3DTRANSFORMCAPS,
    pub bClipping: super::super::Foundation::BOOL,
    pub dlcLightingCaps: D3DLIGHTINGCAPS,
    pub dpcLineCaps: _D3DPrimCaps,
    pub dpcTriCaps: _D3DPrimCaps,
    pub dwDeviceRenderBitDepth: u32,
    pub dwDeviceZBufferBitDepth: u32,
    pub dwMaxBufferSize: u32,
    pub dwMaxVertexCount: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl _D3DNTHALDeviceDesc_V1 {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for _D3DNTHALDeviceDesc_V1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for _D3DNTHALDeviceDesc_V1 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_D3DNTHALDeviceDesc_V1")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("dcmColorModel", &self.dcmColorModel)
            .field("dwDevCaps", &self.dwDevCaps)
            .field("dtcTransformCaps", &self.dtcTransformCaps)
            .field("bClipping", &self.bClipping)
            .field("dlcLightingCaps", &self.dlcLightingCaps)
            .field("dpcLineCaps", &self.dpcLineCaps)
            .field("dpcTriCaps", &self.dpcTriCaps)
            .field("dwDeviceRenderBitDepth", &self.dwDeviceRenderBitDepth)
            .field("dwDeviceZBufferBitDepth", &self.dwDeviceZBufferBitDepth)
            .field("dwMaxBufferSize", &self.dwMaxBufferSize)
            .field("dwMaxVertexCount", &self.dwMaxVertexCount)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for _D3DNTHALDeviceDesc_V1 {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.dcmColorModel == other.dcmColorModel
            && self.dwDevCaps == other.dwDevCaps
            && self.dtcTransformCaps == other.dtcTransformCaps
            && self.bClipping == other.bClipping
            && self.dlcLightingCaps == other.dlcLightingCaps
            && self.dpcLineCaps == other.dpcLineCaps
            && self.dpcTriCaps == other.dpcTriCaps
            && self.dwDeviceRenderBitDepth == other.dwDeviceRenderBitDepth
            && self.dwDeviceZBufferBitDepth == other.dwDeviceZBufferBitDepth
            && self.dwMaxBufferSize == other.dwMaxBufferSize
            && self.dwMaxVertexCount == other.dwMaxVertexCount
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for _D3DNTHALDeviceDesc_V1 {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for _D3DNTHALDeviceDesc_V1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct _D3DNTHALDeviceDesc_V2 {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub dcmColorModel: u32,
    pub dwDevCaps: u32,
    pub dtcTransformCaps: D3DTRANSFORMCAPS,
    pub bClipping: super::super::Foundation::BOOL,
    pub dlcLightingCaps: D3DLIGHTINGCAPS,
    pub dpcLineCaps: _D3DPrimCaps,
    pub dpcTriCaps: _D3DPrimCaps,
    pub dwDeviceRenderBitDepth: u32,
    pub dwDeviceZBufferBitDepth: u32,
    pub dwMaxBufferSize: u32,
    pub dwMaxVertexCount: u32,
    pub dwMinTextureWidth: u32,
    pub dwMinTextureHeight: u32,
    pub dwMaxTextureWidth: u32,
    pub dwMaxTextureHeight: u32,
    pub dwMinStippleWidth: u32,
    pub dwMaxStippleWidth: u32,
    pub dwMinStippleHeight: u32,
    pub dwMaxStippleHeight: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl _D3DNTHALDeviceDesc_V2 {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for _D3DNTHALDeviceDesc_V2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for _D3DNTHALDeviceDesc_V2 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_D3DNTHALDeviceDesc_V2")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("dcmColorModel", &self.dcmColorModel)
            .field("dwDevCaps", &self.dwDevCaps)
            .field("dtcTransformCaps", &self.dtcTransformCaps)
            .field("bClipping", &self.bClipping)
            .field("dlcLightingCaps", &self.dlcLightingCaps)
            .field("dpcLineCaps", &self.dpcLineCaps)
            .field("dpcTriCaps", &self.dpcTriCaps)
            .field("dwDeviceRenderBitDepth", &self.dwDeviceRenderBitDepth)
            .field("dwDeviceZBufferBitDepth", &self.dwDeviceZBufferBitDepth)
            .field("dwMaxBufferSize", &self.dwMaxBufferSize)
            .field("dwMaxVertexCount", &self.dwMaxVertexCount)
            .field("dwMinTextureWidth", &self.dwMinTextureWidth)
            .field("dwMinTextureHeight", &self.dwMinTextureHeight)
            .field("dwMaxTextureWidth", &self.dwMaxTextureWidth)
            .field("dwMaxTextureHeight", &self.dwMaxTextureHeight)
            .field("dwMinStippleWidth", &self.dwMinStippleWidth)
            .field("dwMaxStippleWidth", &self.dwMaxStippleWidth)
            .field("dwMinStippleHeight", &self.dwMinStippleHeight)
            .field("dwMaxStippleHeight", &self.dwMaxStippleHeight)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for _D3DNTHALDeviceDesc_V2 {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.dcmColorModel == other.dcmColorModel
            && self.dwDevCaps == other.dwDevCaps
            && self.dtcTransformCaps == other.dtcTransformCaps
            && self.bClipping == other.bClipping
            && self.dlcLightingCaps == other.dlcLightingCaps
            && self.dpcLineCaps == other.dpcLineCaps
            && self.dpcTriCaps == other.dpcTriCaps
            && self.dwDeviceRenderBitDepth == other.dwDeviceRenderBitDepth
            && self.dwDeviceZBufferBitDepth == other.dwDeviceZBufferBitDepth
            && self.dwMaxBufferSize == other.dwMaxBufferSize
            && self.dwMaxVertexCount == other.dwMaxVertexCount
            && self.dwMinTextureWidth == other.dwMinTextureWidth
            && self.dwMinTextureHeight == other.dwMinTextureHeight
            && self.dwMaxTextureWidth == other.dwMaxTextureWidth
            && self.dwMaxTextureHeight == other.dwMaxTextureHeight
            && self.dwMinStippleWidth == other.dwMinStippleWidth
            && self.dwMaxStippleWidth == other.dwMaxStippleWidth
            && self.dwMinStippleHeight == other.dwMinStippleHeight
            && self.dwMaxStippleHeight == other.dwMaxStippleHeight
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for _D3DNTHALDeviceDesc_V2 {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for _D3DNTHALDeviceDesc_V2 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct _D3DPrimCaps {
    pub dwSize: u32,
    pub dwMiscCaps: u32,
    pub dwRasterCaps: u32,
    pub dwZCmpCaps: u32,
    pub dwSrcBlendCaps: u32,
    pub dwDestBlendCaps: u32,
    pub dwAlphaCmpCaps: u32,
    pub dwShadeCaps: u32,
    pub dwTextureCaps: u32,
    pub dwTextureFilterCaps: u32,
    pub dwTextureBlendCaps: u32,
    pub dwTextureAddressCaps: u32,
    pub dwStippleWidth: u32,
    pub dwStippleHeight: u32,
}
impl _D3DPrimCaps {}
impl ::std::default::Default for _D3DPrimCaps {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for _D3DPrimCaps {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_D3DPrimCaps")
            .field("dwSize", &self.dwSize)
            .field("dwMiscCaps", &self.dwMiscCaps)
            .field("dwRasterCaps", &self.dwRasterCaps)
            .field("dwZCmpCaps", &self.dwZCmpCaps)
            .field("dwSrcBlendCaps", &self.dwSrcBlendCaps)
            .field("dwDestBlendCaps", &self.dwDestBlendCaps)
            .field("dwAlphaCmpCaps", &self.dwAlphaCmpCaps)
            .field("dwShadeCaps", &self.dwShadeCaps)
            .field("dwTextureCaps", &self.dwTextureCaps)
            .field("dwTextureFilterCaps", &self.dwTextureFilterCaps)
            .field("dwTextureBlendCaps", &self.dwTextureBlendCaps)
            .field("dwTextureAddressCaps", &self.dwTextureAddressCaps)
            .field("dwStippleWidth", &self.dwStippleWidth)
            .field("dwStippleHeight", &self.dwStippleHeight)
            .finish()
    }
}
impl ::std::cmp::PartialEq for _D3DPrimCaps {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwMiscCaps == other.dwMiscCaps
            && self.dwRasterCaps == other.dwRasterCaps
            && self.dwZCmpCaps == other.dwZCmpCaps
            && self.dwSrcBlendCaps == other.dwSrcBlendCaps
            && self.dwDestBlendCaps == other.dwDestBlendCaps
            && self.dwAlphaCmpCaps == other.dwAlphaCmpCaps
            && self.dwShadeCaps == other.dwShadeCaps
            && self.dwTextureCaps == other.dwTextureCaps
            && self.dwTextureFilterCaps == other.dwTextureFilterCaps
            && self.dwTextureBlendCaps == other.dwTextureBlendCaps
            && self.dwTextureAddressCaps == other.dwTextureAddressCaps
            && self.dwStippleWidth == other.dwStippleWidth
            && self.dwStippleHeight == other.dwStippleHeight
    }
}
impl ::std::cmp::Eq for _D3DPrimCaps {}
unsafe impl ::windows::runtime::Abi for _D3DPrimCaps {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(
    :: std :: cmp :: PartialEq,
    :: std :: cmp :: Eq,
    :: std :: marker :: Copy,
    :: std :: clone :: Clone,
    :: std :: default :: Default,
    :: std :: fmt :: Debug,
)]
#[repr(transparent)]
pub struct _DEVICEDUMP_COLLECTION_TYPE(pub i32);
pub const TCCollectionBugCheck: _DEVICEDUMP_COLLECTION_TYPE = _DEVICEDUMP_COLLECTION_TYPE(1i32);
pub const TCCollectionApplicationRequested: _DEVICEDUMP_COLLECTION_TYPE =
    _DEVICEDUMP_COLLECTION_TYPE(2i32);
pub const TCCollectionDeviceRequested: _DEVICEDUMP_COLLECTION_TYPE =
    _DEVICEDUMP_COLLECTION_TYPE(3i32);
impl ::std::convert::From<i32> for _DEVICEDUMP_COLLECTION_TYPE {
    fn from(value: i32) -> Self {
        Self(value)
    }
}
unsafe impl ::windows::runtime::Abi for _DEVICEDUMP_COLLECTION_TYPE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct _DEV_BROADCAST_HEADER {
    pub dbcd_size: u32,
    pub dbcd_devicetype: u32,
    pub dbcd_reserved: u32,
}
impl _DEV_BROADCAST_HEADER {}
impl ::std::default::Default for _DEV_BROADCAST_HEADER {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for _DEV_BROADCAST_HEADER {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_DEV_BROADCAST_HEADER")
            .field("dbcd_size", &self.dbcd_size)
            .field("dbcd_devicetype", &self.dbcd_devicetype)
            .field("dbcd_reserved", &self.dbcd_reserved)
            .finish()
    }
}
impl ::std::cmp::PartialEq for _DEV_BROADCAST_HEADER {
    fn eq(&self, other: &Self) -> bool {
        self.dbcd_size == other.dbcd_size
            && self.dbcd_devicetype == other.dbcd_devicetype
            && self.dbcd_reserved == other.dbcd_reserved
    }
}
impl ::std::cmp::Eq for _DEV_BROADCAST_HEADER {}
unsafe impl ::windows::runtime::Abi for _DEV_BROADCAST_HEADER {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct _DEV_BROADCAST_USERDEFINED {
    pub dbud_dbh: DEV_BROADCAST_HDR,
    pub dbud_szName: [CHAR; 1],
}
impl _DEV_BROADCAST_USERDEFINED {}
impl ::std::default::Default for _DEV_BROADCAST_USERDEFINED {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for _DEV_BROADCAST_USERDEFINED {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_DEV_BROADCAST_USERDEFINED")
            .field("dbud_dbh", &self.dbud_dbh)
            .field("dbud_szName", &self.dbud_szName)
            .finish()
    }
}
impl ::std::cmp::PartialEq for _DEV_BROADCAST_USERDEFINED {
    fn eq(&self, other: &Self) -> bool {
        self.dbud_dbh == other.dbud_dbh && self.dbud_szName == other.dbud_szName
    }
}
impl ::std::cmp::Eq for _DEV_BROADCAST_USERDEFINED {}
unsafe impl ::windows::runtime::Abi for _DEV_BROADCAST_USERDEFINED {
    type Abi = Self;
    type DefaultType = Self;
}
pub const _MM_HINT_NTA: u32 = 0u32;
pub const _MM_HINT_T0: u32 = 1u32;
pub const _MM_HINT_T1: u32 = 2u32;
pub const _MM_HINT_T2: u32 = 3u32;
pub const _NT_D3DDEVCAPS_HWINDEXBUFFER: i32 = 67108864i32;
pub const _NT_D3DDEVCAPS_HWVERTEXBUFFER: i32 = 33554432i32;
pub const _NT_D3DDEVCAPS_SUBVOLUMELOCK: i32 = 134217728i32;
pub const _NT_D3DFVF_FOG: i32 = 8192i32;
pub const _NT_D3DGDI2_MAGIC: u32 = 4294967295u32;
pub const _NT_D3DGDI2_TYPE_DEFERRED_AGP_AWARE: u32 = 24u32;
pub const _NT_D3DGDI2_TYPE_DEFER_AGP_FREES: u32 = 32u32;
pub const _NT_D3DGDI2_TYPE_DXVERSION: u32 = 4u32;
pub const _NT_D3DGDI2_TYPE_FREE_DEFERRED_AGP: u32 = 25u32;
pub const _NT_D3DGDI2_TYPE_GETADAPTERGROUP: u32 = 19u32;
pub const _NT_D3DGDI2_TYPE_GETD3DCAPS8: u32 = 1u32;
pub const _NT_D3DGDI2_TYPE_GETD3DCAPS9: u32 = 16u32;
pub const _NT_D3DGDI2_TYPE_GETD3DQUERY: u32 = 34u32;
pub const _NT_D3DGDI2_TYPE_GETD3DQUERYCOUNT: u32 = 33u32;
pub const _NT_D3DGDI2_TYPE_GETDDIVERSION: u32 = 35u32;
pub const _NT_D3DGDI2_TYPE_GETEXTENDEDMODE: u32 = 18u32;
pub const _NT_D3DGDI2_TYPE_GETEXTENDEDMODECOUNT: u32 = 17u32;
pub const _NT_D3DGDI2_TYPE_GETFORMAT: u32 = 3u32;
pub const _NT_D3DGDI2_TYPE_GETFORMATCOUNT: u32 = 2u32;
pub const _NT_D3DGDI2_TYPE_GETMULTISAMPLEQUALITYLEVELS: u32 = 22u32;
pub const _NT_D3DPMISCCAPS_FOGINFVF: i32 = 8192i32;
pub const _NT_D3DPS_COLOROUT_MAX_V2_0: u32 = 4u32;
pub const _NT_D3DPS_COLOROUT_MAX_V2_1: u32 = 4u32;
pub const _NT_D3DPS_COLOROUT_MAX_V3_0: u32 = 4u32;
pub const _NT_D3DPS_CONSTBOOLREG_MAX_SW_DX9: u32 = 2048u32;
pub const _NT_D3DPS_CONSTBOOLREG_MAX_V2_1: u32 = 16u32;
pub const _NT_D3DPS_CONSTBOOLREG_MAX_V3_0: u32 = 16u32;
pub const _NT_D3DPS_CONSTINTREG_MAX_SW_DX9: u32 = 2048u32;
pub const _NT_D3DPS_CONSTINTREG_MAX_V2_1: u32 = 16u32;
pub const _NT_D3DPS_CONSTINTREG_MAX_V3_0: u32 = 16u32;
pub const _NT_D3DPS_CONSTREG_MAX_DX8: u32 = 8u32;
pub const _NT_D3DPS_CONSTREG_MAX_SW_DX9: u32 = 8192u32;
pub const _NT_D3DPS_CONSTREG_MAX_V1_1: u32 = 8u32;
pub const _NT_D3DPS_CONSTREG_MAX_V1_2: u32 = 8u32;
pub const _NT_D3DPS_CONSTREG_MAX_V1_3: u32 = 8u32;
pub const _NT_D3DPS_CONSTREG_MAX_V1_4: u32 = 8u32;
pub const _NT_D3DPS_CONSTREG_MAX_V2_0: u32 = 32u32;
pub const _NT_D3DPS_CONSTREG_MAX_V2_1: u32 = 32u32;
pub const _NT_D3DPS_CONSTREG_MAX_V3_0: u32 = 224u32;
pub const _NT_D3DPS_INPUTREG_MAX_DX8: u32 = 8u32;
pub const _NT_D3DPS_INPUTREG_MAX_V1_1: u32 = 2u32;
pub const _NT_D3DPS_INPUTREG_MAX_V1_2: u32 = 2u32;
pub const _NT_D3DPS_INPUTREG_MAX_V1_3: u32 = 2u32;
pub const _NT_D3DPS_INPUTREG_MAX_V1_4: u32 = 2u32;
pub const _NT_D3DPS_INPUTREG_MAX_V2_0: u32 = 2u32;
pub const _NT_D3DPS_INPUTREG_MAX_V2_1: u32 = 2u32;
pub const _NT_D3DPS_INPUTREG_MAX_V3_0: u32 = 12u32;
pub const _NT_D3DPS_MAXLOOPINITVALUE_V2_1: u32 = 255u32;
pub const _NT_D3DPS_MAXLOOPINITVALUE_V3_0: u32 = 255u32;
pub const _NT_D3DPS_MAXLOOPITERATIONCOUNT_V2_1: u32 = 255u32;
pub const _NT_D3DPS_MAXLOOPITERATIONCOUNT_V3_0: u32 = 255u32;
pub const _NT_D3DPS_MAXLOOPSTEP_V2_1: u32 = 128u32;
pub const _NT_D3DPS_MAXLOOPSTEP_V3_0: u32 = 128u32;
pub const _NT_D3DPS_PREDICATE_MAX_V2_1: u32 = 1u32;
pub const _NT_D3DPS_PREDICATE_MAX_V3_0: u32 = 1u32;
pub const _NT_D3DPS_TEMPREG_MAX_DX8: u32 = 8u32;
pub const _NT_D3DPS_TEMPREG_MAX_V1_1: u32 = 2u32;
pub const _NT_D3DPS_TEMPREG_MAX_V1_2: u32 = 2u32;
pub const _NT_D3DPS_TEMPREG_MAX_V1_3: u32 = 2u32;
pub const _NT_D3DPS_TEMPREG_MAX_V1_4: u32 = 6u32;
pub const _NT_D3DPS_TEMPREG_MAX_V2_0: u32 = 12u32;
pub const _NT_D3DPS_TEMPREG_MAX_V2_1: u32 = 32u32;
pub const _NT_D3DPS_TEMPREG_MAX_V3_0: u32 = 32u32;
pub const _NT_D3DPS_TEXTUREREG_MAX_DX8: u32 = 8u32;
pub const _NT_D3DPS_TEXTUREREG_MAX_V1_1: u32 = 4u32;
pub const _NT_D3DPS_TEXTUREREG_MAX_V1_2: u32 = 4u32;
pub const _NT_D3DPS_TEXTUREREG_MAX_V1_3: u32 = 4u32;
pub const _NT_D3DPS_TEXTUREREG_MAX_V1_4: u32 = 6u32;
pub const _NT_D3DPS_TEXTUREREG_MAX_V2_0: u32 = 8u32;
pub const _NT_D3DPS_TEXTUREREG_MAX_V2_1: u32 = 8u32;
pub const _NT_D3DPS_TEXTUREREG_MAX_V3_0: u32 = 0u32;
pub const _NT_D3DRS_DELETERTPATCH: u32 = 169u32;
pub const _NT_D3DVS_ADDRREG_MAX_V1_1: u32 = 1u32;
pub const _NT_D3DVS_ADDRREG_MAX_V2_0: u32 = 1u32;
pub const _NT_D3DVS_ADDRREG_MAX_V2_1: u32 = 1u32;
pub const _NT_D3DVS_ADDRREG_MAX_V3_0: u32 = 1u32;
pub const _NT_D3DVS_ATTROUTREG_MAX_V1_1: u32 = 2u32;
pub const _NT_D3DVS_ATTROUTREG_MAX_V2_0: u32 = 2u32;
pub const _NT_D3DVS_ATTROUTREG_MAX_V2_1: u32 = 2u32;
pub const _NT_D3DVS_CONSTBOOLREG_MAX_SW_DX9: u32 = 2048u32;
pub const _NT_D3DVS_CONSTBOOLREG_MAX_V2_0: u32 = 16u32;
pub const _NT_D3DVS_CONSTBOOLREG_MAX_V2_1: u32 = 16u32;
pub const _NT_D3DVS_CONSTBOOLREG_MAX_V3_0: u32 = 16u32;
pub const _NT_D3DVS_CONSTINTREG_MAX_SW_DX9: u32 = 2048u32;
pub const _NT_D3DVS_CONSTINTREG_MAX_V2_0: u32 = 16u32;
pub const _NT_D3DVS_CONSTINTREG_MAX_V2_1: u32 = 16u32;
pub const _NT_D3DVS_CONSTINTREG_MAX_V3_0: u32 = 16u32;
pub const _NT_D3DVS_CONSTREG_MAX_V1_1: u32 = 96u32;
pub const _NT_D3DVS_CONSTREG_MAX_V2_0: u32 = 8192u32;
pub const _NT_D3DVS_CONSTREG_MAX_V2_1: u32 = 8192u32;
pub const _NT_D3DVS_CONSTREG_MAX_V3_0: u32 = 8192u32;
pub const _NT_D3DVS_INPUTREG_MAX_V1_1: u32 = 16u32;
pub const _NT_D3DVS_INPUTREG_MAX_V2_0: u32 = 16u32;
pub const _NT_D3DVS_INPUTREG_MAX_V2_1: u32 = 16u32;
pub const _NT_D3DVS_INPUTREG_MAX_V3_0: u32 = 16u32;
pub const _NT_D3DVS_LABEL_MAX_V3_0: u32 = 2048u32;
pub const _NT_D3DVS_MAXINSTRUCTIONCOUNT_V1_1: u32 = 128u32;
pub const _NT_D3DVS_MAXLOOPINITVALUE_V2_0: u32 = 255u32;
pub const _NT_D3DVS_MAXLOOPINITVALUE_V2_1: u32 = 255u32;
pub const _NT_D3DVS_MAXLOOPINITVALUE_V3_0: u32 = 255u32;
pub const _NT_D3DVS_MAXLOOPITERATIONCOUNT_V2_0: u32 = 255u32;
pub const _NT_D3DVS_MAXLOOPITERATIONCOUNT_V2_1: u32 = 255u32;
pub const _NT_D3DVS_MAXLOOPITERATIONCOUNT_V3_0: u32 = 255u32;
pub const _NT_D3DVS_MAXLOOPSTEP_V2_0: u32 = 128u32;
pub const _NT_D3DVS_MAXLOOPSTEP_V2_1: u32 = 128u32;
pub const _NT_D3DVS_MAXLOOPSTEP_V3_0: u32 = 128u32;
pub const _NT_D3DVS_OUTPUTREG_MAX_SW_DX9: u32 = 16u32;
pub const _NT_D3DVS_OUTPUTREG_MAX_V3_0: u32 = 12u32;
pub const _NT_D3DVS_PREDICATE_MAX_V2_1: u32 = 1u32;
pub const _NT_D3DVS_PREDICATE_MAX_V3_0: u32 = 1u32;
pub const _NT_D3DVS_TCRDOUTREG_MAX_V1_1: u32 = 8u32;
pub const _NT_D3DVS_TCRDOUTREG_MAX_V2_0: u32 = 8u32;
pub const _NT_D3DVS_TCRDOUTREG_MAX_V2_1: u32 = 8u32;
pub const _NT_D3DVS_TEMPREG_MAX_V1_1: u32 = 12u32;
pub const _NT_D3DVS_TEMPREG_MAX_V2_0: u32 = 12u32;
pub const _NT_D3DVS_TEMPREG_MAX_V2_1: u32 = 32u32;
pub const _NT_D3DVS_TEMPREG_MAX_V3_0: u32 = 32u32;
pub const _NT_RTPATCHFLAG_HASINFO: i32 = 2i32;
pub const _NT_RTPATCHFLAG_HASSEGS: i32 = 1i32;
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Com")]
pub struct remoteMETAFILEPICT {
    pub mm: i32,
    pub xExt: i32,
    pub yExt: i32,
    pub hMF: *mut userHMETAFILE,
}
#[cfg(feature = "Win32_System_Com")]
impl remoteMETAFILEPICT {}
#[cfg(feature = "Win32_System_Com")]
impl ::std::default::Default for remoteMETAFILEPICT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::fmt::Debug for remoteMETAFILEPICT {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("remoteMETAFILEPICT")
            .field("mm", &self.mm)
            .field("xExt", &self.xExt)
            .field("yExt", &self.yExt)
            .field("hMF", &self.hMF)
            .finish()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::PartialEq for remoteMETAFILEPICT {
    fn eq(&self, other: &Self) -> bool {
        self.mm == other.mm
            && self.xExt == other.xExt
            && self.yExt == other.yExt
            && self.hMF == other.hMF
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::Eq for remoteMETAFILEPICT {}
#[cfg(feature = "Win32_System_Com")]
unsafe impl ::windows::runtime::Abi for remoteMETAFILEPICT {
    type Abi = Self;
    type DefaultType = Self;
}
pub unsafe fn timeKillEvent(utimerid: u32) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "winmm")]
        extern "system" {
            fn timeKillEvent(utimerid: u32) -> u32;
        }
        ::std::mem::transmute(timeKillEvent(::std::mem::transmute(utimerid)))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
pub unsafe fn timeSetEvent(
    udelay: u32,
    uresolution: u32,
    fptc: ::std::option::Option<LPTIMECALLBACK>,
    dwuser: usize,
    fuevent: u32,
) -> u32 {
    #[cfg(windows)]
    {
        #[link(name = "winmm")]
        extern "system" {
            fn timeSetEvent(
                udelay: u32,
                uresolution: u32,
                fptc: ::windows::runtime::RawPtr,
                dwuser: usize,
                fuevent: u32,
            ) -> u32;
        }
        ::std::mem::transmute(timeSetEvent(
            ::std::mem::transmute(udelay),
            ::std::mem::transmute(uresolution),
            ::std::mem::transmute(fptc),
            ::std::mem::transmute(dwuser),
            ::std::mem::transmute(fuevent),
        ))
    }
    #[cfg(not(windows))]
    unimplemented!("Unsupported target OS");
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct uCLSSPEC {
    pub tyspec: u32,
    pub tagged_union: uCLSSPEC_0,
}
#[cfg(feature = "Win32_Foundation")]
impl uCLSSPEC {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for uCLSSPEC {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for uCLSSPEC {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for uCLSSPEC {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for uCLSSPEC {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub union uCLSSPEC_0 {
    pub clsid: ::windows::runtime::GUID,
    pub pFileExt: super::super::Foundation::PWSTR,
    pub pMimeType: super::super::Foundation::PWSTR,
    pub pProgId: super::super::Foundation::PWSTR,
    pub pFileName: super::super::Foundation::PWSTR,
    pub ByName: uCLSSPEC_0_0,
    pub ByObjectId: uCLSSPEC_0_1,
}
#[cfg(feature = "Win32_Foundation")]
impl uCLSSPEC_0 {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for uCLSSPEC_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for uCLSSPEC_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for uCLSSPEC_0 {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for uCLSSPEC_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct uCLSSPEC_0_0 {
    pub pPackageName: super::super::Foundation::PWSTR,
    pub PolicyId: ::windows::runtime::GUID,
}
#[cfg(feature = "Win32_Foundation")]
impl uCLSSPEC_0_0 {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for uCLSSPEC_0_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::fmt::Debug for uCLSSPEC_0_0 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_ByName_e__Struct")
            .field("pPackageName", &self.pPackageName)
            .field("PolicyId", &self.PolicyId)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for uCLSSPEC_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.pPackageName == other.pPackageName && self.PolicyId == other.PolicyId
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for uCLSSPEC_0_0 {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for uCLSSPEC_0_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct uCLSSPEC_0_1 {
    pub ObjectId: ::windows::runtime::GUID,
    pub PolicyId: ::windows::runtime::GUID,
}
impl uCLSSPEC_0_1 {}
impl ::std::default::Default for uCLSSPEC_0_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for uCLSSPEC_0_1 {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("_ByObjectId_e__Struct")
            .field("ObjectId", &self.ObjectId)
            .field("PolicyId", &self.PolicyId)
            .finish()
    }
}
impl ::std::cmp::PartialEq for uCLSSPEC_0_1 {
    fn eq(&self, other: &Self) -> bool {
        self.ObjectId == other.ObjectId && self.PolicyId == other.PolicyId
    }
}
impl ::std::cmp::Eq for uCLSSPEC_0_1 {}
unsafe impl ::windows::runtime::Abi for uCLSSPEC_0_1 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct userBITMAP {
    pub bmType: i32,
    pub bmWidth: i32,
    pub bmHeight: i32,
    pub bmWidthBytes: i32,
    pub bmPlanes: u16,
    pub bmBitsPixel: u16,
    pub cbSize: u32,
    pub pBuffer: [u8; 1],
}
impl userBITMAP {}
impl ::std::default::Default for userBITMAP {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::fmt::Debug for userBITMAP {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.debug_struct("userBITMAP")
            .field("bmType", &self.bmType)
            .field("bmWidth", &self.bmWidth)
            .field("bmHeight", &self.bmHeight)
            .field("bmWidthBytes", &self.bmWidthBytes)
            .field("bmPlanes", &self.bmPlanes)
            .field("bmBitsPixel", &self.bmBitsPixel)
            .field("cbSize", &self.cbSize)
            .field("pBuffer", &self.pBuffer)
            .finish()
    }
}
impl ::std::cmp::PartialEq for userBITMAP {
    fn eq(&self, other: &Self) -> bool {
        self.bmType == other.bmType
            && self.bmWidth == other.bmWidth
            && self.bmHeight == other.bmHeight
            && self.bmWidthBytes == other.bmWidthBytes
            && self.bmPlanes == other.bmPlanes
            && self.bmBitsPixel == other.bmBitsPixel
            && self.cbSize == other.cbSize
            && self.pBuffer == other.pBuffer
    }
}
impl ::std::cmp::Eq for userBITMAP {}
unsafe impl ::windows::runtime::Abi for userBITMAP {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub struct userCLIPFORMAT {
    pub fContext: i32,
    pub u: userCLIPFORMAT_0,
}
#[cfg(feature = "Win32_Foundation")]
impl userCLIPFORMAT {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for userCLIPFORMAT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for userCLIPFORMAT {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for userCLIPFORMAT {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for userCLIPFORMAT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Foundation")]
pub union userCLIPFORMAT_0 {
    pub dwValue: u32,
    pub pwszName: super::super::Foundation::PWSTR,
}
#[cfg(feature = "Win32_Foundation")]
impl userCLIPFORMAT_0 {}
#[cfg(feature = "Win32_Foundation")]
impl ::std::default::Default for userCLIPFORMAT_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::PartialEq for userCLIPFORMAT_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::std::cmp::Eq for userCLIPFORMAT_0 {}
#[cfg(feature = "Win32_Foundation")]
unsafe impl ::windows::runtime::Abi for userCLIPFORMAT_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub struct userHBITMAP {
    pub fContext: i32,
    pub u: userHBITMAP_0,
}
impl userHBITMAP {}
impl ::std::default::Default for userHBITMAP {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for userHBITMAP {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for userHBITMAP {}
unsafe impl ::windows::runtime::Abi for userHBITMAP {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
pub union userHBITMAP_0 {
    pub hInproc: i32,
    pub hRemote: *mut userBITMAP,
    pub hInproc64: i64,
}
impl userHBITMAP_0 {}
impl ::std::default::Default for userHBITMAP_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ::std::cmp::PartialEq for userHBITMAP_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
impl ::std::cmp::Eq for userHBITMAP_0 {}
unsafe impl ::windows::runtime::Abi for userHBITMAP_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Com")]
pub struct userHENHMETAFILE {
    pub fContext: i32,
    pub u: userHENHMETAFILE_0,
}
#[cfg(feature = "Win32_System_Com")]
impl userHENHMETAFILE {}
#[cfg(feature = "Win32_System_Com")]
impl ::std::default::Default for userHENHMETAFILE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::PartialEq for userHENHMETAFILE {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::Eq for userHENHMETAFILE {}
#[cfg(feature = "Win32_System_Com")]
unsafe impl ::windows::runtime::Abi for userHENHMETAFILE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Com")]
pub union userHENHMETAFILE_0 {
    pub hInproc: i32,
    pub hRemote: *mut super::Com::BYTE_BLOB,
    pub hInproc64: i64,
}
#[cfg(feature = "Win32_System_Com")]
impl userHENHMETAFILE_0 {}
#[cfg(feature = "Win32_System_Com")]
impl ::std::default::Default for userHENHMETAFILE_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::PartialEq for userHENHMETAFILE_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::Eq for userHENHMETAFILE_0 {}
#[cfg(feature = "Win32_System_Com")]
unsafe impl ::windows::runtime::Abi for userHENHMETAFILE_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Com")]
pub struct userHGLOBAL {
    pub fContext: i32,
    pub u: userHGLOBAL_0,
}
#[cfg(feature = "Win32_System_Com")]
impl userHGLOBAL {}
#[cfg(feature = "Win32_System_Com")]
impl ::std::default::Default for userHGLOBAL {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::PartialEq for userHGLOBAL {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::Eq for userHGLOBAL {}
#[cfg(feature = "Win32_System_Com")]
unsafe impl ::windows::runtime::Abi for userHGLOBAL {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Com")]
pub union userHGLOBAL_0 {
    pub hInproc: i32,
    pub hRemote: *mut super::Com::FLAGGED_BYTE_BLOB,
    pub hInproc64: i64,
}
#[cfg(feature = "Win32_System_Com")]
impl userHGLOBAL_0 {}
#[cfg(feature = "Win32_System_Com")]
impl ::std::default::Default for userHGLOBAL_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::PartialEq for userHGLOBAL_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::Eq for userHGLOBAL_0 {}
#[cfg(feature = "Win32_System_Com")]
unsafe impl ::windows::runtime::Abi for userHGLOBAL_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Com")]
pub struct userHMETAFILE {
    pub fContext: i32,
    pub u: userHMETAFILE_0,
}
#[cfg(feature = "Win32_System_Com")]
impl userHMETAFILE {}
#[cfg(feature = "Win32_System_Com")]
impl ::std::default::Default for userHMETAFILE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::PartialEq for userHMETAFILE {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::Eq for userHMETAFILE {}
#[cfg(feature = "Win32_System_Com")]
unsafe impl ::windows::runtime::Abi for userHMETAFILE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Com")]
pub union userHMETAFILE_0 {
    pub hInproc: i32,
    pub hRemote: *mut super::Com::BYTE_BLOB,
    pub hInproc64: i64,
}
#[cfg(feature = "Win32_System_Com")]
impl userHMETAFILE_0 {}
#[cfg(feature = "Win32_System_Com")]
impl ::std::default::Default for userHMETAFILE_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::PartialEq for userHMETAFILE_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::Eq for userHMETAFILE_0 {}
#[cfg(feature = "Win32_System_Com")]
unsafe impl ::windows::runtime::Abi for userHMETAFILE_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Com")]
pub struct userHMETAFILEPICT {
    pub fContext: i32,
    pub u: userHMETAFILEPICT_0,
}
#[cfg(feature = "Win32_System_Com")]
impl userHMETAFILEPICT {}
#[cfg(feature = "Win32_System_Com")]
impl ::std::default::Default for userHMETAFILEPICT {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::PartialEq for userHMETAFILEPICT {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::Eq for userHMETAFILEPICT {}
#[cfg(feature = "Win32_System_Com")]
unsafe impl ::windows::runtime::Abi for userHMETAFILEPICT {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_System_Com")]
pub union userHMETAFILEPICT_0 {
    pub hInproc: i32,
    pub hRemote: *mut remoteMETAFILEPICT,
    pub hInproc64: i64,
}
#[cfg(feature = "Win32_System_Com")]
impl userHMETAFILEPICT_0 {}
#[cfg(feature = "Win32_System_Com")]
impl ::std::default::Default for userHMETAFILEPICT_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::PartialEq for userHMETAFILEPICT_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_System_Com")]
impl ::std::cmp::Eq for userHMETAFILEPICT_0 {}
#[cfg(feature = "Win32_System_Com")]
unsafe impl ::windows::runtime::Abi for userHMETAFILEPICT_0 {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Gdi")]
pub struct userHPALETTE {
    pub fContext: i32,
    pub u: userHPALETTE_0,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl userHPALETTE {}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::std::default::Default for userHPALETTE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::std::cmp::PartialEq for userHPALETTE {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::std::cmp::Eq for userHPALETTE {}
#[cfg(feature = "Win32_Graphics_Gdi")]
unsafe impl ::windows::runtime::Abi for userHPALETTE {
    type Abi = Self;
    type DefaultType = Self;
}
#[derive(:: std :: clone :: Clone, :: std :: marker :: Copy)]
#[repr(C)]
#[cfg(feature = "Win32_Graphics_Gdi")]
pub union userHPALETTE_0 {
    pub hInproc: i32,
    pub hRemote: *mut super::super::Graphics::Gdi::LOGPALETTE,
    pub hInproc64: i64,
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl userHPALETTE_0 {}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::std::default::Default for userHPALETTE_0 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::std::cmp::PartialEq for userHPALETTE_0 {
    fn eq(&self, _other: &Self) -> bool {
        unimplemented!()
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl ::std::cmp::Eq for userHPALETTE_0 {}
#[cfg(feature = "Win32_Graphics_Gdi")]
unsafe impl ::windows::runtime::Abi for userHPALETTE_0 {
    type Abi = Self;
    type DefaultType = Self;
}
