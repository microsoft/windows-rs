## Safety

We aim to be fully compliant with Rust's safety guarantees. Unfortunately, some Windows APIs are not entirely compatible with Rust's safety semantics and thus need to be marked with `unsafe`. This does not mean these APIs are necessarily unsafe to use. It is possible that some APIs that are safe are still marked with `unsafe` due to the absence of a mechanism in Windows metadata for marking APIs as being compatible with Rust's safety semantics. A best attempt is made to map common idioms to safe Rust, but that is not always possible with older pointer-based APIs.

The `windows` crate makes two blanket policies around the safety of bindings:
* Win32 and COM bindings are marked with `unsafe`. It is up to the developer to read the documentation on how to call these APIs in a safe way.
* WinRT bindings are *not* marked with `unsafe` as the WinRT contract maps nicely to Rust's safety properties.

It is important to note that WinRT APIs are often implemented in non-memory safe languages like C++. Users can be sure that (modulo bugs), the WinRT bindings generated by this crate are 100% safe to use. Users should, however, make sure that the code that implements the APIs being called through the bindings are either written in safe Rust or have been audited for memory safety and correctly adhere to the WinRT contract. WinRT APIs written in safe Rust and consumed from Rust using the `windows` crate should therefore be 100% memory safe.

We take these safety guarantees very seriously. Please let us know if you run into issues where you see Rust's memory safety guarantees being violated using this crate.
